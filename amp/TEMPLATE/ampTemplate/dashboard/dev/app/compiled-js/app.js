(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./app/js/app.js":[function(require,module,exports){
require('./ugly/lib-load-hacks');
var jquery = require('jquery');
var _ = require('underscore');
var UserModel = require('./app/models/amp-user.js');
var App = require('./app/app-class');
var app = new App({ el: '#amp-dashboard' });
window.app = app;  // for debugging convenience

//Force call to the EP that sends the saved filters if any.
app.state.saved.load();
//app.render();

},{"./app/app-class":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/app-class.js","./app/models/amp-user.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/amp-user.js","./ugly/lib-load-hacks":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-load-hacks.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/app-class.js":[function(require,module,exports){
var _ = require('underscore');
var Deferred = require('jquery').Deferred;
var BackboneDash = require('./backbone-dash');
var supportCheck = require('./check-support');
var URLService = require('amp-url/index');
var State = require('amp-state/index');
var StateLoadError = require('amp-state/index').StateLoadError;

var Translator = require('amp-translate');
var Filter = require('amp-filter/src/main');
var Settings = require('amp-settings/src/index');
var UserModel = require('./models/amp-user.js');
var SavedDashes = require('./models/saved-dashes-collection.js');
var MainView = require('./views/main');
var FailView = require('./views/fail');


function App() {
  if (!(this instanceof App)) {
    throw new Error('App needs to be instantiated with the `new` keyword.');
  }
  this.initialize.apply(this, arguments);
}


_.extend(App.prototype, BackboneDash.Events, {
	
  rendered: false,

  initialize: function(options) {
    var _initDefer = new Deferred(),
        missingFeatures;
    this.initialized = _initDefer.promise();

    try {
    	
    	this.user = new UserModel()

      // check our support level
      this.browserIssues = supportCheck();
      _(this.browserIssues).chain()
        .groupBy('severity')
        .each(function(severityGroup, severity) {
          missingFeatures = _(severityGroup).pluck('feature').join(', ');
          if (severity === 'critical') {
            throw {
              name: 'Incompatible Web Browser',
              message: 'Dashboards cannot work without these features, which are ' +
                       'not supported by your web browser: ' + missingFeatures + '. ' +
                       'Any <a href="http://browsehappy.com/">modern browser</a> will work.',
              toString: function() { return this.name + ': ' + this.message; }
            };
          } else if (severity === 'major') {
            this.report('Limited support for old web browsers', [
              'Your browser does not provide some features used by Dashboards: ' +
              missingFeatures + '.',
              'Some features may not work correctly, however any ' +
              '<a href="http://browsehappy.com/">modern browser</a> will provide ' +
              'a better experience.']);
          } else if (severity === 'minor') {
            console.warn('This browser is missing support for', missingFeatures);
          }
        }, this);

      // inject downloadify if we have no download but have flash (IE)
      if (this.hasIssue('download') && !this.hasIssue('flash')) {
        var swfObj = document.createElement('script'),
            downloadify = document.createElement('script');
        swfObj.src = '/TEMPLATE/ampTemplate/commonJs/swfobject-2.2.js';
        downloadify.src = '/TEMPLATE/ampTemplate/commonJs/downloadify-0.2.js';
        document.body.appendChild(swfObj);
        document.body.appendChild(downloadify);
      }

      // initialize app services
      this.url = new URLService();
      this.savedDashes = new SavedDashes([], { app: this });
      this.state = new State({
        url: this.url,
        saved: this.savedDashes
      });
      
      // try to load an initial state from the url
      try {
    	  this.state.urlMaybeLoad();
      } catch (e) {
          if (e instanceof StateLoadError) {
        	  this.report('Could not load saved dashboard', ['If you are trying to load a shared link, please make sure the entire URL was copied']);
        	  this.url.hash('');  // clear the bad saved-state hash
          } else {
        	  throw e;
          }
      }

      var dashboardTranslateKeys = JSON.parse("{\n\"amp.common:footer\": \"Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and DG\",\n\n\"amp.common:title\": \"AMP\",\n\"amp.common:title-desktop\": \"Desktop\",\n\"amp.common:subtitle-my-desktop\": \"My Desktop\",\n\"amp.common:subtitle-add-tab\": \"Add Tab\",\n\"amp.common:subtitle-tab-manager\": \"Tab Manager\",\n\"amp.common:title-reports\": \"Reports\",\n\"amp.common:subtitle-all-reports\": \"All Reports\",\n\"amp.common:subtitle-fav-reports\": \"Favourite Reports\",\n\"amp.common:subtitle-report-generator\": \"Report Generator\",\n\"amp.common:subtitle-saiku\": \"Saiku\",\n\"amp.common:title-documents\": \"Documents\",\n\"amp.common:title-dashboards\": \"Dashboards\",\n\"amp.common:subtitle-gis\": \"New GIS (BETA)\",\n\"amp.common:subtitle-dashboards\": \"New Dashboard (BETA)\",\n\"amp.common:subtitle-dashboard-generator\": \"Dashboard Generator\",\n\"amp.common:subtitle-donor-profile\": \"Donor Profile\",\n\"amp.common:subtitle-region-profile\": \"Region Profile\",\n\"amp.common:subtitle-sector-profile\": \"Sector Profile\",\n\"amp.common:subtitle-executing-profile\": \"Executing Agency Profile\",\n\"amp.common:subtitle-beneficiary-profile\": \"Beneficiary Ministry Profile\",\n\"amp.common:title-tools\": \"Tools\",\n\"amp.common:subtitle-workspace-setup\": \"Workspace Setup\",\n\"amp.common:subtitle-advanced-mode\": \"Advanced Mode\",\n\"amp.common:subtitle-search\": \"Search\",\n\"amp.common:subtitle-addressbook\": \"Address Book\",\n\"amp.common:title-help\": \"Help\",\n\"amp.common:subtitle-amp-help\": \"AMP Help\",\n\"amp.common:subtitle-glossary\": \"Glossary\",\n\"amp.common:subtitle-email-support-team\": \"Email Support Team\",\n\"amp.common:title-logout\": \"Logout\",\n\"amp.common:filters-loading\": \"Loading...\",\n\"amp.dashboard:page-title\":\"AMP Dashboards\",\n\"amp.dashboard:loading\": \"Loading...\",\n\"amp.dashboard:title-projectdata\": \"Project Data\",\n\"amp.dashboard:sub-title-projectdata\": \"View where projects are being implemented throughout the country.\",\n\"amp.dashboard:title-Country\": \"Country\",\n\"amp.dashboard:title-Region\": \"Region\",\n\"amp.dashboard:title-Zone\": \"Zone\",\n\"amp.dashboard:title-District\": \"District\",\n\"amp.dashboard:chart-reset\": \"reset others\",\n\"amp.dashboard:chart-radioui-commitments\": \"Commitments\",\n\"amp.dashboard:chart-radioui-disbursements\": \"Disbursements\",\n\"amp.dashboard:filters-none-applied\": \"No filters applied\",\n\"amp.dashboard:close\": \"Close\",\n\"amp.dashboard:modal-sorry\": \"Sorry for any inconvenience\",\n\"amp.dashboard:share-dashboard-top\": \"Share dashboard\",\n\"amp.dashboard:share-dashboard\": \"Share this dashboard view\",\n\"amp.dashboard:share-link\": \"Link\",\n\"amp.dashboard:of\": \"of\",\n\"amp.dashboard:tooltip-predict-otherseries\": \"TRANSLATEME\",\n\"amp.dashboard:total\": \"total\",\n\"amp.common:title\": \"AMP Toolbar\",\n\"amp.common:title-filters\": \"Filters\",\n\"amp.dashboard:chart-TopDonorAgencies\": \"Top Donor Agencies\",\n\"amp.dashboard:chart-TopDonorGroups\": \"Top Donor Groups\",\n\"amp.dashboard:chart-TopRegions\": \"Top Regions\",\n\"amp.dashboard:chart-TopSectors\": \"Top Sectors\",\n\"amp.dashboard:chart-AidPredictability\": \"Aid Predictability\",\n\"amp.dashboard:chart-FundingType\": \"Funding Type\",\n\"amp.dashboard:chart-ResponsibleOrganizations\": \"Responsible Organizations\",\n\"amp.dashboard:chart-BeneficiaryAgencies\": \"Beneficiary Agencies\",\n\"amp.dashboard:chart-ExecutingAgencies\": \"Executing Agencies\",\n\"amp.dashboard:chart-ImplementingAgencies\": \"Implementing Agencies\",\n\"amp.dashboard:chart-Peace-buildingandState-buildingGoals\": \"Peace-building and State-building Goals\",\n\"amp.dashboard:predictability-planned\": \"Planned\",\n\"amp.dashboard:predictability-actual\": \"Actual\",\n\"amp.dashboard:chart-FundingType-Grant\": \"Grant\",\n\"amp.dashboard:chart-FundingType-Loan\": \"Loan\",\n\"amp.dashboard:chart-FundingType-others\": \"Others\",\n\"amp.dashboard:chart-TopRegions-DistrictUndefined\": \"District: U\",\n\"amp.dashboard:chart-TopRegions-others\": \"Others\",\n\"amp.dashboard:chart-TopSectors-others\": \"Others\",\n\"amp.dashboard:chart-TopDonorAgencies-others\": \"Others\",\n\"amp.dashboard:chart-TopDonorGroups-others\": \"Others\",\n\"amp.dashboard:chart-ResponsibleOrganizations-others\": \"Others\",\n\"amp.dashboard:chart-BeneficiaryAgencies-others\": \"Others\",\n\"amp.dashboard:chart-ExecutingAgencies-others\": \"Others\",\n\"amp.dashboard:chart-ImplementingAgencies-others\": \"Others\",\n\"amp.dashboard:chart-Peace-buildingandState-buildingGoals-others\":\"Others\",\n\"amp.dashboard:filters-edit\":\"edit filters\",\n\"amp.dashboard:dashboard-settings\":\"Settings\",\n\"amp.dashboard:settings-edit\":\"edit settings\",\n\"amp.dashboard:download-amount\":\"Amount\",\n\"amp.dashboard:download-preview\":\"Preview:\",\n\"amp.dashboard:download-rendering\":\"Rendering...\",\n\"amp.dashboard:download-download-chart\":\"Download chart\",\n\"amp.dashboard:download-download-data\":\"Download data\",\n\"amp.dashboard:chart-no-data-available\":\"No Data Available\",\n\"amp.dashboard:chart-loading-saved-settings\":\"Loading saved settings...\",\n\"amp.dashboard:filters-show-settings\":\"Show filter settings\",\n\"amp.dashboard:filters-chart-legends-Grouped\":\"Grouped\",\n\"amp.dashboard:filters-chart-legends-Stacked\":\"Stacked\",\n\"amp.dashboard:of-total\": \"of total\",\n\"amp.dashboard:aid-predictability-actual-disbursements\": \"Actual Disbursements\",\n\"amp.dashboard:aid-predictability-planned-disbursements\": \"Planned Disbursements\",\n\"amp.dashboard:filters-hide-details\": \"Hide filter details\",\n\"amp.dashboard:saving-state\": \"Saving dashboard state, please wait...\",\n\"amp.dashboard:date-range\": \"Date Range\",\n\"amp.dashboard:currency\" : \"Currency\",\n\"amp.dashboard:type\" : \"Type\",\n\"amp.dashboard:year\" : \"Year\",\n\"amp.dashboard:ftype-actual-commitment\": \"Actual Commitments\",\n\"amp.dashboard:ftype-actual-disbursement\": \"Actual Disbursements\",\n\"amp.dashboard:ftype-actual-expenditure\": \"Actual Expenditures\",\n\"amp.dashboard:ftype-planned-commitment\": \"Planned Commitments\" ,\n\"amp.dashboard:ftype-planned-disbursement\":\t\"Planned Disbursements\" ,\n\"amp.dashboard:ftype-planned-expenditures\":\t\"Planned Expenditures\",  \t\t\t\n\"amp.dashboard:dashboard-chart-tops-info-modal\": \"Category Detail\",\n\"amp.dashboard:chart-tops-table-projecttitle\": \"Project Title\",\n\"amp.dashboard:chart-tops-inunits\": \"In units\",\n\"amp.dashboard:chart-tops-inthousands\": \"In thousands\",\n\"amp.dashboard:chart-tops-inmillions\": \"In millions\",\n\"amp.dashboard:chart-thousand\": \"k\",\n\"amp.dashboard:chart-million\": \"M\",\n\"amp.dashboard:chart-billion\": \"B\",\n\"amp.dashboard:chart-trillion\": \"T\",\n\"amp.dashboard:chart-peta\": \"P\",\n\"amp.dashboard:chart-exa\": \"E\",\n\"amp.dashboard:chart-swap-axes\": \"Swap Axes\",\n\"amp.dashboard:chart-HeatMapbySectorandDonorGroup\":\"Sector Fragmentation\",\n\"amp.dashboard:chart-HeatMapbyLocationandDonorGroup\":\"Location Fragmentation\",\n\"amp.dashboard:chart-HeatMapbyProgramandDonorGroup\":\"Program Fragmentation\",\n\"amp.dashboard:chart-heatmap-reset-others\":\"Reset Others\",\n\"amp.dashboard:negatives-values\":\"Negative values are not represented in this chart.\",\n\"amp.dashboard:negatives-values-parag\":\"Please switch to bar chart or table view to view all values.\",\n\"amp.dashboard:chart-heatmap-legends\":\"LEGENDS\",\n\"amp.dashboard:chart-heatmap-totals\":\"TOTALS\",\n\"amp.dashboard:chart-heatmap-legend-less-than\":\"Less than\",\n\"amp.dashboard:chart-heatmap-legend-between\":\"Between\",\n\"amp.dashboard:chart-heatmap-legend-and\":\"and\",\n\"amp.dashboard:chart-heatmap-legend-more-than\":\"More than\",\n\"amp.dashboard:chart-heatmap-others\":\"Others\",\n\"amp.dashboard:percentage\": \"Percentage\",\n\"amp.dashboard:chart-heatmap-legend-n-a\": \"N/A\",\n\"amp.dashboard:chart-heatmap-help-text-location\":\"Each cell represents an intersection between a donor group and a location and represents how much that funder contributes to the total funding received by that location.\",\n\"amp.dashboard:chart-heatmap-help-text-sector\":\"Each cell represents an intersection between a donor group and a sector and represents how much that funder contributes to the total funding received by that sector.\",\n\"amp.dashboard:chart-heatmap-help-text-program\":\"Each cell represents an intersection between a donor group and a program and represents how much that funder contributes to the total funding received by that program.\",\n\"amp.dashboard:chart-tooltip-pie-chart[title]\":\"View data in pie chart\",\n\"amp.dashboard:chart-tooltip-bar-chart[title]\":\"View data in bar chart\",\n\"amp.dashboard:chart-tooltip-table-chart[title]\":\"View data in table format\",\n\"amp.dashboard:chart-tooltip-multibar-chart[title]\":\"View data in multibar chart\",\n\"amp.dashboard:chart-tooltip-download-chart[title]\":\"Download image or table\",\n\"amp.dashboard:chart-tooltip-expand-chart[title]\":\"Expand chart\",\n\"amp.dashboard:chart-tooltip-collapse-chart[title]\":\"Collapse chart\",\n\"amp.dashboard:chart-tooltip-heatmap-chart[title]\":\"View heat map\"\n}");
      this.translator = new Translator({
        defaultKeys: dashboardTranslateKeys,
        ajax: BackboneDash.wrappedAjax
      });
      
      this.initSettings();
      
      // TODO: handle translations load failure      ​
      this.filter = new Filter({
          draggable: true,
          sync: options.sync || BackboneDash.sync,
          caller: 'DASHBOARD'
        });
       
      

   	  // initialize app components
      this.view = new MainView({ app: this, el: options.el });      

      _initDefer.resolve(this);
    } catch (e) {
      _.defer(function() { throw e; });
      this.view = new FailView({ app: this, el: options.el, err: e});
      this.err = e;
      _initDefer.reject(this);
    }
  },

  render: function() {
    // TODO: fix some parts of the app so we can load translations async
    this.tryAfter(this.translator.promise, this.view.render, this.view);
    // this.tryTo(this.view.render, this.view);

    /* ensure entire page--header and footer, not just this view is translated */
    // TODO: if possible, move this out of app-class
    // or at least make it more targeted than document
    this.translator.translateDOM(document);
  },

  hasIssue: function(featureName) {
    return !!_(this.browserIssues).findWhere({feature: featureName});
  },

  viewFail: function(view, err) {
    view.$el.html(new FailView({ app: this, err: err }).render().el);
  },

  tryTo: function(fn, view) {
    try {
      return fn.call(view);
    } catch (e) {
      _.defer(function() { throw e; });
      this.viewFail(view, e);
    }
  },

  tryAfter: function(promise, fn, view) {
    promise
      .done(_(function() {
        this.tryTo(fn, view);
      }).bind(this))
      .fail(_(function() {
        this.viewFail(view, 'failed to load');
      }).bind(this));
  },

  report: function(title, messages) {
    this.initialized
      .done(function(app) {
        app.modal(title, {messages: messages, tone: 'warning'});
      })
      .fail(function() {
        console.warn('REPORT:', title, messages);
      });
  },

  modal: function(title, options) {
    options = _({}).extend(options, {tone: 'primary'});
    var modalReady = new Deferred();
    this.initialized
      .done(function(app) {
        var modalEl = app.view.modal(title, options);
        modalReady.resolve(modalEl);
      })
      .fail(function() {
        console.warn('failed to show modal because the app views did not initialize', title);
        modalReady.reject('app views did not init');
      });
    return modalReady.promise();
  },
  initSettings: function(){
	this.settingsWidget = new Settings.SettingsWidget({
	  		draggable : true,
	  		caller : 'DASHBOARDS',
	  		isPopup: true,
	  		definitionUrl: '/rest/settings-definitions/dashboards'
	});	
	this.generalSettings = new Settings.GeneralSettings();
	this.generalSettings.load();	
  }
});

module.exports = App;

},{"./backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./check-support":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/check-support.js","./models/amp-user.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/amp-user.js","./models/saved-dashes-collection.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dashes-collection.js","./views/fail":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/fail.js","./views/main":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/main.js","amp-filter/src/main":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/main.js","amp-settings/src/index":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/index.js","amp-state/index":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-state/index.js","amp-translate":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js","amp-url/index":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-url/index.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


// TODO: ... ... ...
var IS_PHILS_CORS = window && (window.location.host === 'localhost:3000');


var CACHE = ['/rest/dashboard'];


function InitError(instance) {
  this.instance = instance;
  this.toString = function() { return 'Module initialization error'; };
}


var ajaxOptionWrap = function(options) {
  options = _({}).extend(options, {
    // maybe use phil's DRC CORS dev server
    url: (IS_PHILS_CORS ? 'http://localhost:8080' : '') + options.url,
    headers: {
      // jscs:disable disallowQuotedKeysInObjects
      'Accept': 'application/json',
      'Content-Type': 'application/json'
      // jscs:enable disallowQuotedKeysInObjects
    }
  });
  return options;
};


var syncOverride = (function(bs) {
  var cache = {};

  function _doSync(url, method, model, options) {
    options = _({}).extend(options, { url: url });
    options = ajaxOptionWrap(options);
    return bs.call(this, method, model, options);
  }

  function _cacheSync(url, method, model, options) {
    var key = url + '+POST:' + options.data;
    if (cache[key]) { return cache[key](); }

    var xhr = _doSync(url, method, model, options);

    cache[key] = function() {
      // calling this function will make the xhr re-call its callbacks
      return xhr
        .done(options.success)
        .always(options.complete);
    };

    // do not cache failed requests
    xhr.fail(function() { delete cache[key]; });

    return xhr;
  }

  return function(method, model, options) {
    var url = options.url || _(model).result('url') || Backbone.Model.prototype.url.call(model),
        cacheable = false;
    if (options.type === 'POST' &&
      _.some(CACHE, function(i) { return url.indexOf(i) === 0; })) {
      cacheable = true;
    }
    return (cacheable ? _cacheSync : _doSync)(url, method, model, options);
  };
})(Backbone.sync);


// mixed into all models, collections and views to ensure we have a convenient
// reference to the app instance everywhere.
function mixDash(Class) {
  return Class.extend({

    constructor: function() {
      var constructed = Class.apply(this, arguments);
      if (!this.app) {
        throw new InitError(this);
      }
      return constructed;
    },

    sync: syncOverride

  });
}


module.exports = _({}).extend(Backbone, {
  // errors
  InitError: InitError,

  Model: mixDash(Backbone.Model),
  Collection: mixDash(Backbone.Collection),
  View: mixDash(Backbone.View),

  sync: syncOverride,
  wrappedAjax: function(o) { return Backbone.ajax(ajaxOptionWrap(o)); }
});

},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_bar.js":[function(require,module,exports){
/*
 * Drawing a bar chart in AMP? Please use ./chart.js instead.
 */

var barDebug = require('../../../../../../../reamp/tools/log')("amp:dashboards:charts:bar");

var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3');
var util = require('../../ugly/util');


function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data[0].values.length - 1;  // 1 for others...?
}


function chart(options, data) {
  //this check is needed because I need strictly either 300 or 400 px, and sometimes, when the chart overflows, it
  //will give me >400 px height
  var height = options.height < 400 ? 300 : 400;
  var calculatedHeight = util.calculateChartHeight(data[0].values.length, false, options.model);
  if (calculatedHeight !== null) {
	  height = calculatedHeight; 
  }
   
  barDebug.log("Setting height to", height);
  var _chart = nv.models.discreteBarChart()
    .valueFormat(options.shortFormatter)
    .showValues(true)
    .showYAxis(false)
    .showXAxis(false)
    .height(height)
    .margin({ top: 5, right: 10, bottom: 10, left: 10 });
  return _chart;
}


function addLegend(svg, chart, nvData, trimLabels, width) {
  var legendHeight;

  var legend = nv.models.legend()
    .width(width || svg.clientWidth)
    .margin({left: 20, right: 20})
    .rightAlign(false)
    .color(util.categoryColours(nvData[0].values.length))
    .key(function(d) { return trimLabels ? util.formatShortText(12)(d.x) : util.formatShortText(85)(d.x); });

  d3.select(svg)
    .datum(nvData)
    .append('g')
      .attr('class', 'legend')
      .datum(nvData[0].values)
      .call(legend);

  legendHeight = svg.querySelector('.legend').getBBox().height;
  chart.margin({top: legendHeight + 15});
}


module.exports = {
  dispatchName: 'discretebar',
  countCategories: countCategories,
  addLegend: addLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../../../../../../reamp/tools/log":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/reamp/tools/log/index.js","../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","d3":"d3"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_heatmap.js":[function(require,module,exports){
/*
 * Drawing a bar chart in AMP? Please use ./chart.js instead.
 */

var barDebug = require('../../../../../../../reamp/tools/log')("amp:dashboards:charts:bar");

var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3');
var util = require('../../ugly/util');
var heatMapChart = require('./customized/heatMapChart');
var _ = require('underscore');

function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data[0].values.length - 1;  // 1 for others...?
}


function chart(options, data) {
  //this check is needed because I need strictly either 300 or 400 px, and sometimes, when the chart overflows, it
  //will give me >400 px height
  var height = options.height < 400 ? 300 : 400;
  var calculatedHeight = util.calculateChartHeight(data[0].values.length, false, options.model);
  if (calculatedHeight !== null) {
	  height = calculatedHeight; 
  }
   
  var _chart = nv.models.heatMapChart().height(900);
  return _chart;
}


function addLegend(svg, chart, nvData, trimLabels, width) {
}


module.exports = {
  dispatchName: 'heatmap',
  countCategories: countCategories,
  addLegend: addLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../../../../../../reamp/tools/log":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/reamp/tools/log/index.js","../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","./customized/heatMapChart":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/heatMapChart.js","d3":"d3","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_multibar.js":[function(require,module,exports){
/*
 * Drawing a multibar chart in AMP? Please use ./chart.js instead.
 */

var multibarDebug = require('../../../../../../../reamp/tools/log')("amp:dashboards:charts:multibar");

var nv = window.nv;  // nvd3 is a pain
var customizedMultiBarChart = require('./customized/multiBarChart.js');
// var d3 = require('d3-browserify');


function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data.length;
}


function chart(options) {
  var maxValue = 10;
  //this check is needed because I need strictly either 300 or 400 px, and sometimes, when the chart overflows, it
  //will give me >400 px height
  var height = options.height < 400 ? 300 : 400;
  multibarDebug.log("Setting multibar height", height);
  var _chart = nv.models.customizedMultiBarChart()  
    .forceY([0, maxValue])  // ensures yAxis is showing at least 0 and 10, but won't restrict the domain
                            // (meaning if the are values falling outside the range it will show then).
    .reduceXTicks(false)
    .height(height)
    .margin({ top: 5, right: 10, bottom: 20, left: 50 });

  if (!options.nvControls) {
    _chart.showControls(false);
  }
  
  if(options.stacked){
	  _chart.multibar.stacked(true); 
  }else{
	  _chart.multibar.stacked(false);
  }

  _chart.yAxis
    .tickFormat(options.shortFormatter)
    .showMaxMin(false);

  return _chart;
}


module.exports = {
  dispatchName: 'multibar',
  countCategories: countCategories,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../../../../../../reamp/tools/log":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/reamp/tools/log/index.js","./customized/multiBarChart.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/multiBarChart.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_pie.js":[function(require,module,exports){
/*
 * Drawing a pie chart in AMP? Please use ./chart.js instead.
 */

var nv = window.nv;  // nvd3 is a pain
// var d3 = require('d3-browserify');

var _ = require('underscore');
var common = require('./common');
var util = require('../../ugly/util');
var customizedPieChart = require('./customized/pieChart.js');


function dataToNv(data) {
  if (data.length !== 1) {
    common.fail('Pie charts can only show one series of data. got', data.length);
  }
  if (!_.isArray(data[0].values)) {
    common.fail('Data series did not have a "values" array. Instead', data[0].values);
  }
  return getPositiveValues(data[0].values);
}

function getPositiveValues(values) {
  return _.filter(values, function(e) {
    return e.y>0;
  });
}

function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return getPositiveValues(data[0].values).length;
}


function chart(options, data) {
	var height = options.height < 400 ? 300 : 400;
	  var calculatedHeight = util.calculateChartHeight(data[0].values.length, false, options.model);
	  if (calculatedHeight !== null) {
		  height = calculatedHeight; 
	  }

  var _chart = nv.models.customizedPieChart()
    .valueFormat(options.shortFormatter)
    .labelType('percent')
    .showLegend(false)
    .donut(true)
    .height(height)
    .margin({ top: 5, right: 5, bottom: 5, left: 5 })
    .donutRatio(0.35);
  return _chart;
}

function addLegend(svg, chart, nvData, trimLabels, width) {
	  var legendHeight;

	  var legend = nv.models.legend()
	    .width(width || svg.clientWidth)
	    .margin({left: 20, right: 20})
	    .rightAlign(false)
	    .color(util.categoryColours(nvData.length))
	    .key(function(d) { return trimLabels ? util.formatShortText(12)(d.x) : util.formatShortText(85)(d.x); });

	  d3.select(svg)
	    .datum(nvData)
	    .append('g')
	      .attr('class', 'legend')
	      .datum(nvData)
	      .call(legend);

	  legendHeight = svg.querySelector('.legend').getBBox().height;
	  chart.margin({top: legendHeight + 15});
}


function removeLegend(chart) {
  chart.showLegend(false);
}


function normalizeNvTTArgs(fmtX, fmtY, raw) {
  // nv pie charts drop the seriesName as first arg
  return [void 0, fmtX, fmtY, raw];
}


module.exports = {
  dispatchName: 'pie',
  normalizeNvTTArgs: normalizeNvTTArgs,
  countCategories: countCategories,
  addLegend: addLegend,
  removeLegend: removeLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","./common":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","./customized/pieChart.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/pieChart.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_table.js":[function(require,module,exports){

var _ = require('underscore');
var util = require('../../ugly/util');
var common = require('./common');
var tableTemplate = _.template("<div class=\"table-responsive\">\n  <table class=\"table table-striped table-condensed\">\n\n    <% if (_(keys).some()) { %>\n      <thead>\n        <tr>\n          <td></td>\n          <% _(keys).each(function(key, colIndex) { %>\n            <th data-series-index=\"<%= colIndex %>\">\n              <%= key %>\n            </th>\n          <% }); %>\n        </tr>\n      </thead>\n    <% } %>\n\n    <tbody>\n      <% _(values).each(function(row, rowIndex) { %>\n        <tr>\n          <th data-x-index=\"<%= rowIndex %>\">\n            <%= row[0].x %>\n          </th>\n          <% _(row).each(function(datum, colIndex) { %>\n            <td data-x-index=\"<%= rowIndex %>\" data-series-index=\"<%= colIndex %>\">\n              <%= moneyFormat(datum.y) %>\n            </td>\n          <% }) %>\n        </tr>\n      <% }) %>\n    </tbody>\n\n  </table>\n</div>\n");
var heatmapTableTemplate = _.template("<div class=\"heatmap-table-responsive\">\n\t<table class=\"table table-striped table-condensed\">\n\t\t<% if (_(keys).some()) { %>\n\t    \t<thead>\n\t        \t<tr>\n\t          \t\t<% _(keys).each(function(key, colIndex) { %>\n\t            \t\t<th data-series-index=\"0\">\n\t              \t\t\t<%= key %>\n\t            \t\t</th>\n\t          \t\t<% }); %>\n\t        \t</tr>\n\t      \t</thead>\n\t    <% } %>\n\t\t<tbody>\n\t\t\t<% _(matrix).each(function(row, i) { %>\n\t\t\t\t<% _(row).each(function(col, j) { %>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].y %>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].x %>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].value.dv %>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].value.p %>\n\t\t\t\t\t\t</td>\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t</tr>\n\t\t\t\t<% }) %>\n\t\t\t<% }) %>\n\t\t</tbody>\n\t</table>\n</div>");


function fakeRawContext(e, data) {
  // transform a table-click event into something that looks like it came from
  // an nvd3 handler
  var t = e.target,
      seriesIndex = parseInt(util.data(t, 'seriesIndex'), 10) || 0,
      xIndex = parseInt(util.data(t, 'xIndex'), 10);
  // This check is for heatmaps because they dont use the same data structure.
  if (!isNaN(xIndex)) {
	  return {
	    label: data[seriesIndex].values[xIndex].x || xIndex,
	    seriesIndex: seriesIndex,
	    pointIndex: xIndex,
	    point: data[seriesIndex].values[xIndex] || xIndex
	  };
  } else {
	  return {
		  label: '',
		  point: ''
	  };
  }
}


function bindClickHandler(el, data, options) {
  el.addEventListener('click', function(e) {
    var fakeRaw = fakeRawContext(e, data),  // so we can use the shared context transformer
        context = common.getNiceContext(fakeRaw, data, e.target.innerText);
    options.clickHandler(context);
  });
}


function charter(data, options) {
	if (options.model.get('chartType') === 'fragmentation') {
		return heatmapCharter(data, options);
	} else {
		return commonCharter(data, options);
	}	
}

function commonCharter(data, options) {
	var keys = _(data).pluck('key');

	var values = _(data).chain().map(function(datum) {
		return datum.values;
	}).transpose().value();

	var html = tableTemplate({
		keys : keys,
		values : values,
		moneyFormat : options.shortFormatter
	});

	var chartEl = document.createElement('div');
	chartEl.innerHTML = html;

	bindClickHandler(chartEl, data, options);

	return chartEl;
}

function heatmapCharter(data, options) {
	// For AMP-23582: we dont want the name from "summary" because thats the origName and not always the same name than the X axis combo selector. 
	var firstColumnName = _.find(options.model.get('heatmap_config').models[0].get('columns'), function(item) {
		return item.origName === options.model.get('summary')[0];
	}).name; 
	var secondColumnName = _.find(options.model.get('heatmap_config').models[0].get('columns'), function(item) {
		return item.origName === options.model.get('summary')[1];
	}).name;
	var keys = [firstColumnName, 
	            secondColumnName, 
	            this.app.translator.translateSync('amp.dashboard:download-amount', 'Amount'), 
	            this.app.translator.translateSync('amp.dashboard:percentage', 'Percentage')];

	var matrix = _.map(options.model.get("matrix"), function(itemY, i) {
		return _.map(itemY, function(itemX, j) {
			return {
				y : options.model.get("yDataSet")[i],
				x : options.model.get("xDataSet")[j],
				value : (options.model.get("matrix")[i][j] ? options.model.get("matrix")[i][j] : {
					'dv' : '',
					'p' : ''
				})
			}
		})
	});

	var html = heatmapTableTemplate({
		keys : keys,
		matrix : matrix,
		moneyFormat : options.shortFormatter
	});

	var chartEl = document.createElement('div');
	chartEl.innerHTML = html;
	
	bindClickHandler(chartEl, data, options);

	return chartEl;
}


module.exports = {
  charter: charter
};
},{"../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","./common":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/chart.js":[function(require,module,exports){

var _ = require('underscore');
var d3 = require('d3');
var util = require('../../ugly/util');
var common = require('./common');
var barSpecific = require('./_bar');
var multibarSpecific = require('./_multibar');
var pieSpecific = require('./_pie');
var table = require('./_table');
var heatmap = require('./_heatmap');
var defaultTTTemplate = _.template("<div class=\"panel panel-primary panel-popover\">\n  <% if (tt.heading) { %>\n    <div class=\"panel-heading\"><%= tt.heading %></div>\n  <% } %>\n  <div class=\"panel-body\">\n    <span class=\"dollaz\">\n      <% if (tt.bodyText) { %>\n        <%= tt.bodyText %>\n      <% } %>\n      <% if (tt.bodyList) { %>\n        <ul class=\"list-unstyled\">\n          <% _(tt.bodyList).each(function(item) { %>\n            <li><b><%= item.k %></b> <%= item.v %></li>\n          <% }) %>\n        </ul>\n      <% } %>\n    </span>\n  </div>\n  <% if (tt.footerText) { %>\n    <div class=\"panel-footer\">\n      <%= tt.footerText %>\n    </div>\n  <% } %>\n</div>\n");


var charters = {
  bar: common.nvCharter(barSpecific),
  pie: common.nvCharter(pieSpecific),
  multibar: common.nvCharter(multibarSpecific),
  heatmap: common.nvCharter(heatmap),
  table: table.charter
};


function chart(type, data, options) {
  /*
   * @param type: 'bar' (default), 'pie', or 'multibar'
   * @param data: [{key: 'serisName', values: [{x:NN, y:NN}]}]
   * @param options: optional extra stuff
   */

  options = options || {};

  // settings defaults
  options = _(_(options).clone()).defaults({
    height: void 0,  // should fill container in most cases by default
    width: void 0,
    numberFormatter: d3.format(','),
    shortFormatter: options.numberFormatter || util.formatKMB(3, app.generalSettings.numberFormatSettings.decimalSeparator),
    addLegend: true,
    trimLabels: true,
    getTTContent: common.defaultGetTTContent,
    ttTemplate: defaultTTTemplate,
    clickHandler: common.defaultClickHandler,
    nvControls: true
  });

  var charter = charters[type] || common.fail('unrecognized chart type', type);

  return {
    el: charter(data, options)
  };
}


module.exports = chart;

},{"../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","./_bar":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_bar.js","./_heatmap":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_heatmap.js","./_multibar":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_multibar.js","./_pie":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_pie.js","./_table":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_table.js","./common":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","d3":"d3","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js":[function(require,module,exports){
var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3');
var util = require('../../ugly/util');
var Numeral = require('numeral');
var _ = require('underscore');


// hack nvd3's calcApproxTextWidth because it is terrrrrrrrrrible
// this solution is just as bad :(
// nvd3 makes me so sad :(
(function(unfortunateLib) {
  var sadWayOfCalculatingTextWidth = unfortunateLib.utils.calcApproxTextWidth;
  unfortunateLib.utils.calcApproxTextWidth = function(svgTextEl) {
    var originalText = svgTextEl.text(),
        spacePaddedText = originalText,
        numberOfDots = (originalText.match(/\./g) || []).length,
        poorlyCalculatedWidth;

    if (originalText.toUpperCase() === originalText) {
      for (var i = 0; i < originalText.length / 5; i++) { spacePaddedText += ' '; }
      svgTextEl.text(spacePaddedText);
      poorlyCalculatedWidth = sadWayOfCalculatingTextWidth(svgTextEl);
      svgTextEl.text(originalText);
    } else {
      poorlyCalculatedWidth = sadWayOfCalculatingTextWidth(svgTextEl);
    }

    // ♪ do you believe in maaaagic ♫
    poorlyCalculatedWidth -=
      (poorlyCalculatedWidth / spacePaddedText.length) * (numberOfDots / 3);
    // ♪ magic magic magic ♫
    poorlyCalculatedWidth += 6;

    return poorlyCalculatedWidth;
  };
})(nv);


function fail(/* arguments */) {
  throw {
    name: 'Chart Error',
    message: Array.prototype.join.call(arguments, ', '),
    toString: function() { return this.name + ': ' + this.message; }
  };
}


function nvChartCommon(nvChart, maxCategories) {
  return nvChart
    .x(function(d) { return util.formatShortText(19)(d.x); })  // fix overflows in legends
    .color(util.categoryColours(maxCategories));
}


function getSecretRenderArea(height, width) {
  var secretArea = document.getElementById('super-secret-render-area-shh');
  if (!secretArea) {
    secretArea = document.createElement('div');
    secretArea.id = 'super-secret-render-area-shh';
    secretArea.style.position = 'absolute';
    secretArea.style.left = '-9999em';
    secretArea.style.top = '-9999em';  // for IE :(
    document.body.appendChild(secretArea);
  }
  if (height) { secretArea.style.height = height + 'px'; }
  if (width) { secretArea.style.width = width + 'px'; }
  return secretArea;
}


function mkChartSVG(height, width) {
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('class', 'dash-chart');
  // put it in the dom but out of the way, so we can compute styles n stuff
  getSecretRenderArea(height, width).appendChild(svg);
  return svg;
}


function nvBoiler(nvData, chart, svg, specific, trimLabels, addLegend, width) {
  if (trimLabels) {
    chart.x(function(d) { return util.formatShortText(50)(d.x); });
  }
  if (addLegend && specific.addLegend) {
    specific.addLegend(svg, chart, nvData, trimLabels, width);
  } else if (!addLegend && specific.removeLegend) {
    specific.removeLegend(chart);
  }
  d3.select(svg)
    .datum(nvData)
    .call(chart);
  nv.utils.windowResize(chart.update);  // uuuuuguggggh
  nv.addGraph(function() { return chart; });  // uuuuugly is nvd3
  return svg;
}


function nvColorifyCategories(chart, data, specific) {
  var numberOfCategories = specific.countCategories(data);
  chart.color(util.categoryColours(numberOfCategories));
  return chart;
}


function defaultGetTTContent(context) {
  return {tt: {
    heading: context.x.raw,
    bodyText: context.y.raw,
    formattedAmount: context.z.raw
  }};
}


function getNiceContext(raw, data, fmtY) {
  var seriesIndex = raw.seriesIndex || 0;
  return {
    data: data,
    series: {
      key: data[seriesIndex].key,
      index: seriesIndex,
      values: data[seriesIndex].values
    },
    x: {
      raw: raw.point.x,
      fmt: raw.label,
      index: raw.pointIndex || raw.index || 0
    },
    y: {
      raw: raw.point.y,
      fmt: raw.point.z || fmtY
    }
  };
}


function nvBindTooltip(chart, data, specific, template, getTTContent) {
  var nvTTHandler = function(seriesName, fmtX, fmtY, raw) {
    return template(getTTContent(getNiceContext(raw, data, fmtY)));
  };

  if (specific.normalizeNvTTArgs) { // we might have to fix nv's inconsistent TT args
    nvTTHandler = util.transformArgs(specific.normalizeNvTTArgs, nvTTHandler);
  }
  chart.tooltipContent(nvTTHandler);
}


function defaultClickHandler(/* context */) {
  // does nothing
}


function nvBindOthersCb(chart, data, specific, clickHandler) {
  if (chart[specific.dispatchName] !== undefined) {
	  chart[specific.dispatchName].dispatch.on('elementClick', function(raw) {
		  clickHandler(getNiceContext(raw, data));
	  });
  }	else {
	  console.warn("Cant find " + specific.dispatchName);
  }
}


function nvCharter(specific) {
  return function(data, options) {
    var svg = mkChartSVG(options.height, options.width),
        nvChart = specific.chart(options, data),
        nvData = specific.dataToNv(data);
    nvColorifyCategories(nvChart, data, specific);
    nvBindTooltip(nvChart, data, specific, options.ttTemplate, options.getTTContent);
    nvBoiler(nvData, nvChart, svg, specific, options.trimLabels, options.addLegend, options.width);
    nvBindOthersCb(nvChart, data, specific, options.clickHandler);
    return svg;
  };
}

function formatNumber(number) {
	var format = "";
	if (app.generalSettings.numberFormatSettings.groupSeparator.length > 0) {
		format = "0,0";
	} else {
		format = "0";
	}
	if (app.generalSettings.numberFormatSettings.numberFormat.indexOf('.') > 0) {
		var decimalDigits = app.generalSettings.numberFormatSettings.numberFormat.length
			- app.generalSettings.numberFormatSettings.numberFormat.indexOf('.');
		format = format + "." + new Array(decimalDigits).join("0");
	}

	// Define a new "language" for Numeral where we can change the default
	// delimiters.
	var ampLang = {
		delimiters : {
			thousands : app.generalSettings.numberFormatSettings.groupSeparator,
			decimal : app.generalSettings.numberFormatSettings.decimalSeparator
		},
		abbreviations : {
			thousand : app.translator.translateSync('amp.dashboard:chart-thousand'),
			million : app.translator.translateSync('amp.dashboard:chart-million'),
			billion : app.translator.translateSync('amp.dashboard:chart-billion'),
			trillion : app.translator.translateSync('amp.dashboard:chart-trillion')
		},
		ordinal : function(number) {
			return number === 1 ? 'st' : 'rds';
		},
		currency : {
			symbol : '$'
		}
	};
	Numeral.language('amp', ampLang);
	// Apply new language.
	Numeral.language('amp');
	// Apply the format.
	var stringNumber = new Numeral(number).format(format);
	return stringNumber;
}

var ampLang =


module.exports = {
  fail: fail,
  nvChartCommon: nvChartCommon,
  getNiceContext: getNiceContext,
  defaultGetTTContent: defaultGetTTContent,
  defaultClickHandler: defaultClickHandler,
  mkChartSVG: mkChartSVG,
  nvBoiler: nvBoiler,
  nvCharter: nvCharter,
  formatNumber: formatNumber
};

},{"../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","d3":"d3","numeral":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/node_modules/numeral/numeral.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/heatMapChart.js":[function(require,module,exports){
nv.models.heatmap = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 500
        , height = 500
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , duration = 250
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;


    //============================================================
    // chart function
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.renderEnd('heatmap immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        x:          {get: function(){return getX;}, set: function(_){getX=_;}},
        id:         {get: function(){return id;}, set: function(_){id=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
            margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
            margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
            margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY=d3.functor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

nv.models.heatMapChart = function() {
	"use strict";

	//============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------	

    var heatmap = nv.models.heatmap();

    var margin = {top: 30, right: 20, bottom: 20, left: 20}
    var width = null;
	var height = null;
    var showLegend = false;
    var color = nv.utils.defaultColor();
    var	state = nv.utils.state();
    var defaultState = null;
    var noData = "No Data Available.";
    var duration = 250;
    var dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd');
    var shortTextLength = 17;
    var innerMargin = {
    		top : 120,
			right : 0,
			bottom : 100,
			left : 150
    };
    
    const initialWidth = 960;
    const initialHeight = 400;
    const containerWidth = 1024;

    //============================================================
    // Private Variables
    //------------------------------------------------------------
    var renderWatch = nv.utils.renderWatch(dispatch);

    var stateGetter = function(data) {
    	return function(){
    		return {
    			active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined) {
                data.forEach(function (series, i) {
                    series.disabled = !state.active[i];
                });
            }
        }
    };
  
    var shortenText = function(text, length) {
    	if (text.length > length) {
    		text = text.substring(0, length) + '...';
    	}
    	return text;
    };

    //============================================================
    // Chart function
    //------------------------------------------------------------

    function chart(selection) {
    	var _self = this;
    	this.rendered = false;
    	var _ = require('underscore'); // This doesnt works on top of the file :(((

        renderWatch.reset();
        renderWatch.models(heatmap);

        selection.each(function(data) {
        	// Get currency for later.        	       	
        	var currencyId = app.settingsWidget.definitions.getSelectedOrDefaultCurrencyId();
        	var selectedCurrency = app.settingsWidget.definitions.findCurrencyById(currencyId).value;        	
        	var newShortTextLength = !data[0].values.model.get('showFullLegends') ? shortTextLength : 100;
        	
        	var container = d3.select(this);
            nv.utils.initSVG(container);

            var availableWidth = (width || parseInt(container.style('width'), 10) || initialWidth)
                    - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height'), 10) || initialHeight)
                    - margin.top - margin.bottom;

            chart.container = this;

            state.setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

        	var cubeSize = 30;
        	var width = containerWidth - innerMargin.left - innerMargin.right;
        	var topSectionHeight = 180;
        	var legendSectionHeight = 20;
        	var height = topSectionHeight + (cubeSize * data[0].values.y.length) + legendSectionHeight;
        	var legendElementHeight = 22;
        	const undefinedColor = '#666';
        	const noColor = '#FFFFFF';
        	var categories = getCategoriesByThreshold(undefinedColor, noColor, data[0].values.model);
        	
        	$(container[0]).css('height', height + 'px').attr('class', 'dash-chart nvd3-svg heatmap-chart');
        	
        	var svg = container
        		.append("g")
        		.attr("transform", "translate(" + innerMargin.left + "," + innerMargin.top + ")")
        		.attr("class", "heatmap-main-container");
        	
        	// Add SVG filter for cell highlight.
        	// For more info about these filters see: http://www.svgbasics.com/filters4.html // http://apike.ca/prog_svg_filter_feColorMatrix.html // http://alistapart.com/article/finessing-fecolormatrix
        	svg.append("defs").append("filter").attr("id", "filterSaturate").append("feColorMatrix").attr("in", "SourceGraphic").attr("type", "saturate").attr("values", "5");
        	svg.append("defs").append("filter").attr("id", "filterLuminanceToAlpha").append("feColorMatrix").attr("in", "SourceGraphic").attr("type", "luminanceToAlpha");
        	svg.append("defs").append("filter").attr("id", "filterBlur").append("feGaussianBlur").attr("in", "SourceGraphic").attr("stdDeviation", "2");
        	svg.append("defs").append("filter").attr("id", "filterDarken").append("feColorMatrix").attr("type", "matrix").attr("values", "0.5 0 0 0 0 0 0.5 0 0 0 0 0 0.5 0 0 0 0 0 1 0");

        	// Rows container.
        	var yAxisLabelsContainer = svg        	
				.append("g")
				.attr("class", "heatmap-yAxis-container");
        	
        	// Rows.
        	var yAxisLabels = yAxisLabelsContainer
        		.selectAll(".yLabel")
        		.data(data[0].values.y)
        		.enter()
        		.append("text")
        		.text(function(d) {
        			return shortenText(d, newShortTextLength);
        		})
        		.attr("x", 0)
        		.attr("y", function(d, i) {
        			return i * cubeSize;
        		})
        		.style("text-anchor", "end")
        		.attr("transform", "translate(-6," + cubeSize / 1.5 + ")")
        		.attr("class", function(d, i) {
        							return "yLabel mono axis nv-series";
        		})
        		.attr('data-title', function(d) {
        			return d;
        		});
        	
        		// Format "Others" special row if needed.
        		if (data[0].values.yCount < data[0].values.yTotalCount) {
        			var self = this;
        			var data2 = data;
        			var textElement = $(container[0]).find('.yLabel').last();
        			$(textElement).attr("class", function(d, i) {
        				return $(textElement).attr('class') + ' legend-others';
        			});
        		}
        	
        		// Add Totals special row.
        		yAxisLabelsContainer.append("text")
        			.text("TOTALS")
        			.attr("x", 0)
        			.attr("y", (data[0].values.y.length * cubeSize))
        			.attr("class", "yLabel mono axis nv-series heatmap-totals")
        			.style("text-anchor", "end")
        			.style("font-weight", "bold")
            		.attr("transform", "translate(-6," + cubeSize / 1.5 + ")")
            		.attr('data-i18n', 'amp.dashboard:chart-heatmap-totals');

        		// Columns container.
        		var xAxisLabelsContainer = svg
        			.append("g")
        			.attr("transform", "translate(18.5, -5)")
        			.attr("class", "heatmap-xAxis-container");

        		// Columns
        		// Notice in transform functions the order is very important if you have to apply more than one, like translate and rotate.
        		// cubeSize is where we define how big are the cubes so if we change it in the future the chart will resize correctly.
        		var xAxisLabels = xAxisLabelsContainer
        			.selectAll(".xLabel")
        			.data(data[0].values.x)
        			.enter()
        			.append("text")
        			.text(function(d) {
        				return shortenText(d, newShortTextLength);
        			})
        			.attr("x", function(d, i) {
        				return i * cubeSize;
        			})
        			.attr("y", 0)
        			.attr("transform", function(d, i) {
        				return "rotate(270, " + (cubeSize * i) + ", 0)";
        			})
        			.attr("class", function(d, i) {
        							return "xLabel mono axis nv-series";
        			})
        			.attr('data-title', function(d) {
        				return d;
        			});
        		
        		// Add Totals special column.
        		xAxisLabelsContainer.append("text")
        			.text("TOTALS")
        			.attr("x", cubeSize * data[0].values.x.length)
        			.attr("y", 0)
        			.attr("class", "xLabel mono axis nv-series heatmap-totals")
        			.style("font-weight", "bold")
            		.attr("transform", function(d, i) {
        				return "rotate(270, " + (cubeSize * data[0].values.x.length) + ", 0)";
        			})
        			.attr('data-i18n', 'amp.dashboard:chart-heatmap-totals');

        		// Cubes
        		var cubesContainer = svg
    				.append("g")
    				.attr("class", "heatmap-cubes-container");
        		for (var i = 0; i < data[0].values.length; i++) {
        			createCube(cubesContainer, $.extend(data[0].values[i], {tooltip: selectedCurrency + ' ' + data[0].values[i].amount}), cubeSize, noColor, categories);        			    				
        		}        
        		// Add total's row in the end.        		
        		for (var i = 0; i < data[0].values.x.length; i++) {
        			createCube(cubesContainer, {x: i + 1, y: data[0].values.y.length + 1, value: data[0].values.xPTotals[i], tooltip: selectedCurrency + ' ' + data[0].values.xTotals[i]}, cubeSize, noColor, categories);
        		}
        		// Add total's column on the right side.
        		for (var j = 0; j < data[0].values.y.length; j++) {
        			createCube(cubesContainer, {x: data[0].values.x.length + 1 , y: j + 1, value: data[0].values.yPTotals[j], tooltip: selectedCurrency + ' ' + data[0].values.yTotals[j]}, cubeSize, noColor, categories);
        		}
        		
        		// Add percentage legends.
        		createLegends(svg, data, cubeSize, categories, legendElementHeight);
        		
        		app.translator.translateDOM(svg[0]);
        		
        		// Recalculate margins if we are showing the full legends.
            	if (data[0].values.model.get('showFullLegends')) {        		
            		var top = svg.select('.heatmap-xAxis-container').node().getBBox().height;
            		var left = svg.select('.heatmap-yAxis-container').node().getBBox().width + 25;
            		svg.attr("transform", "translate(" + left + "," + top + ")");
            	}
        });
        
        renderWatch.renderEnd('heatmap immediate');
        return chart;
    }
    
    function getCategoriesByThreshold(undefinedColor, noColor, model) {
    	var categories = new Array();
    	categories.push({min: -99, max: -1, color: undefinedColor});
    	categories.push({min: -1, max: 0, color: noColor});
    	var colors = model.get('heatmap_config').models[0].get('amountColors');
    	var i = 2;
    	for (var property in colors) {
    	    if (colors.hasOwnProperty(property)) {
    	    	categories.push({min: parseInt(property), color: colors[property], max: null});
    	    	if (i > 2) {
    	    		categories[i - 1].max = parseInt(property);
    	    	}
    	    	i++;
    	    }
    	}
    	categories[i - 1].max = 101;
    	return categories;
    }
    
    function createLegends(svg, data, cubeSize, categories, legendElementHeight) {
    	var legendsContainer = svg
			.append("g")
			.attr("transform", "translate(0, " + (((data[0].values.y.length + 1) * cubeSize) + 10) + ")")
			.attr("class", "heatmap-legends-container");
    	var legendsPool = [app.translator.translateSync("amp.dashboard:chart-heatmap-legend-less-than") + " " + categories[2].max + "%",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[3].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[3].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[4].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[4].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[5].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[5].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[6].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[6].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-more-than") + " " + categories[7].min + "%"];
    	var maxLegendTextWidth = 0;
    	for (var i = 0; i < legendsPool.length; i++) {
    		var auxWidth = calculateTextWidth(legendsPool[i]);
    		if (auxWidth > maxLegendTextWidth) {
    			maxLegendTextWidth = auxWidth;
    		}
    		$("#tempSpan").remove();
    	}
    	maxLegendTextWidth += 20;
    	
    	for (var i = 0; i < legendsPool.length; i++) {
    		var legends = legendsContainer
				.append("rect")
				.attr("x", (i * maxLegendTextWidth))
				.attr("width", maxLegendTextWidth)
				.attr("height", legendElementHeight)
				.attr("class", "bordered")
				.style("fill", categories[i + 2].color);
		
			var text = legendsContainer.append("text"); 
			text.attr('font-family', 'Arial')
				.attr('font-size', '11px')
				.attr("y", 15)
				.attr("x", ((i * maxLegendTextWidth) + ((maxLegendTextWidth - calculateTextWidth(legendsPool[i])) / 2)))
				.text(legendsPool[i]); // Why "text" instead of "html", because it doesnt work on IE.
    	}
    	
    	legendsContainer.append("text")
			.text("LEGENDS")
			.attr("x", -6)
			.attr("y", 15)
			.attr("class", "yLabel mono axis nv-series heatmap-totals")
			.style("text-anchor", "end")
			.style("font-weight", "bold")
			.attr('data-i18n', 'amp.dashboard:chart-heatmap-legends');
    }
    
    function createCube(cubesContainer, data, cubeSize, noColor, categories) {
    	var selfData = data;
    	var cube = cubesContainer
			.append("rect")
			.attr("x", ((data.x - 1) * cubeSize))
			.attr("y", ((data.y - 1) * cubeSize))
			.attr("rx", 4)
			.attr("ry", 4)
			.attr("class", "bordered")
			.attr("width", cubeSize)
			.attr("height", cubeSize)
			.style("fill", noColor)
			.attr("data-x", data.x - 1)
			.attr("data-y", data.y - 1);
		
		cube.transition()
			.duration(1000)
			.style("fill", calculateColorFromCategories(data.value, categories, noColor));
		
		var text = cubesContainer.append("text"); 
		text.attr('font-family', 'Arial')
			.attr('font-size', '11px')
			.attr("x", ((data.y - 1) * cubeSize))
			.attr("y", ((data.y - 1) * cubeSize) + 19)
			.attr("class", "heatmap-cell")
			.attr("x", function() {
				// The "offsets" we add on each return call are tied to the current font family and size, so if we change them we might need to change the offsets too.
				var d = data;
				var auxVal = d.value;
				if (auxVal > 0 && auxVal < 1) {
					return ((d.x - 1) * cubeSize) + 4;
				} else if (auxVal < 10) {
					return ((d.x - 1) * cubeSize) + 8;
				} else if (auxVal == 100) {
					return ((d.x - 1) * cubeSize) + 1;	
				} else {
					return ((d.x - 1) * cubeSize) + 5;
				}					
			}).text(function() {
				// Cant use "html" function on IE.
				var d = data;
				var auxVal = d.value;
				if (auxVal > -1) {
					if (auxVal > 0 && auxVal < 1) {
						return '<1%';
					} else {
						return auxVal + '%';
					}
				} else {
                    if (auxVal == -1) {
                        return '';
                    } else {
                        return app.translator.translateSync("amp.dashboard:chart-heatmap-legend-n-a");
					}
				}
			})
			.on("click", function(obj) {				
				// Remove all filters applied.
				$($(cubesContainer[0]).find("rect")).removeAttr("filter");
				// Apply "darken" to the row and column.		
				$($(cubesContainer[0]).find("[data-x='"+ (selfData.x - 1) + "']")).attr("filter", "url(#filterDarken)");
				$($(cubesContainer[0]).find("[data-y='"+ (selfData.y - 1) + "']")).attr("filter", "url(#filterDarken)");
				// Highlight this cell.
				$($(cubesContainer[0]).find("[data-y='"+ (selfData.y - 1) + "']" + "[data-x='"+ (selfData.x - 1) + "']")).removeAttr("filter");
			});
		
		if (data.tooltip) {
			text.attr('data-title', data.tooltip)
				.attr("class", "nv-series heatmap-cell");
		}
    }
       
    function calculateColorFromCategories(value, categories, noColor) {
    	var color = noColor;
    	for (var i = 0; i < categories.length; i++) {
    		if ((value >= categories[i].min) && (value < categories[i].max)) {
    			color = categories[i].color;
    			break;
    		}
    	}
    	return color;
    }
    
    function calculateTextWidth(text) {
    	$("body").append("<span id='tempSpan' class='invisible'>" + text + "</span>");
    	var auxWidth = $("#tempSpan").width();
    	$("#tempSpan").remove();
    	return auxWidth;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.legend = {};
    chart.dispatch = dispatch;
    chart.heatmap = heatmap;
    chart.options = nv.utils.optionsFunc.bind(chart);
    chart.shortTextLength = function(_) {
        return shortTextLength;
    };

    // use Object get/set functionality to map between vars and chart functions
    chart._options = Object.create({}, {    	
        // simple options, just get/set the necessary values
        noData:         {get: function(){return noData;},         set: function(_){noData=_;}},
        defaultState:   {get: function(){return defaultState;},   set: function(_){defaultState=_;}},
        // options that require extra logic in the setter
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color: {},
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        tooltipContent: {}
    });
    
    chart.height = function(_) {
        if (!arguments.length) return height;
        height = _;
        return chart;
    };
    
    nv.utils.inheritOptions(chart, heatmap);
    nv.utils.initOptions(chart);
    return chart;
};
},{"underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/multiBarChart.js":[function(require,module,exports){

nv.models.customizedMultiBarChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var multibar = nv.models.multiBar()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    , controls = nv.models.legend() //this isn't exposed by default :(
    ;

  var margin = {top: 30, right: 20, bottom: 50, left: 60}
    , width = null
    , height = null
    , color = nv.utils.defaultColor()
    , showControls = true
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , reduceXTicks = true // if false a tick will show for every data point
    , staggerLabels = false
    , rotateLabels = 0
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
      return '<h3>' + key + '</h3>' +
        '<p>' +  y + ' on ' + x + '</p>'
    }
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , state = { stacked: false }
    , defaultState = null
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , controlWidth = function() { return showControls ? 300 : 0 } /*Increased from 180 in original file.*/
    , transitionDuration = 250
    ;

  multibar
    .stacked(false)
  ;
  xAxis
    .orient('bottom')
    .tickPadding(7)
    .highlightZero(true)
    .showMaxMin(false)
    .tickFormat(function(d) { return d })
  ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    .tickFormat(d3.format(',.1f'))
  ;

  controls.updateState(false);
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
      top = e.pos[1] + ( offsetElement.offsetTop || 0),
      x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
      y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
      content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
        that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
          - margin.left - margin.right,
        availableHeight = (height || parseInt(container.style('height')) || 400)
          - margin.top - margin.bottom;

      try{
        if(data[0].values[0].x.length > 4){
        	//margin.bottom += 130;
        	margin.bottom = 130;
        }
      }catch(e){}

      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }
      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = multibar.xScale();
      y = multibar.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-barsWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth - controlWidth());

        if (multibar.barColor())
          data.forEach(function(series,i) {
            series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
          })

        g.select('.nv-legendWrap')
          .datum(data)
          .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
            - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
          .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      var groupedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Grouped","Grouped");
      var stackedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Stacked","Stacked");
      if (showControls) {
        var controlsData = [
          { key: groupedLegendTrn, disabled: multibar.stacked() },
          { key: stackedLegendTrn, disabled: !multibar.stacked() }
        ];

        controls.width(controlWidth()).color(['#444', '#444', '#444']);
        g.select('.nv-controlsWrap')
          .datum(controlsData)
          .attr('transform', 'translate(0,' + (-margin.top) +')')
          .call(controls);
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
        g.select(".nv-y.nv-axis")
          .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------
      // Main Chart Component(s)

      multibar
        .disabled(data.map(function(series) { return series.disabled }))
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled }))


      var barsWrap = g.select('.nv-barsWrap')
        .datum(data.filter(function(d) { return !d.disabled }))

      barsWrap.transition().call(multibar);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
        xAxis
          .scale(x)
          .ticks( availableWidth / 100 )
          .tickSize(-availableHeight, 0);

        g.select('.nv-x.nv-axis')
          .attr('transform', 'translate(0,' + y.range()[0] + ')');
        g.select('.nv-x.nv-axis').transition()
          .call(xAxis);

        var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');

        xTicks
          .selectAll('line, text')
          .style('opacity', 1);

        try{
          if(data[0].values[0].x.length > 4){
            g.selectAll(".nv-x.nv-axis .nv-wrap g g text")
              .style("text-anchor", "end")
              .attr("dx", "-.8em")
              .attr("dy", ".15em")
              .attr("transform", "rotate(-65)" );
          }
        }catch(e){}

        if (staggerLabels) {
          var getTranslate = function(x,y) {
            return "translate(" + x + "," + y + ")";
          };

          var staggerUp = 5, staggerDown = 17;  //pixels to stagger by
          // Issue #140
          xTicks
            .selectAll("text")
            .attr('transform', function(d,i,j) {
              return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));
            });

          var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
          g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text")
            .attr("transform", function(d,i) {
              return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);
            });
        }

        if (reduceXTicks)
          xTicks
            .filter(function(d,i) {
              return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
            })
            .selectAll('text, line')
            .style('opacity', 0);

        if(rotateLabels)
          xTicks
            .selectAll('.tick text')
            .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
            .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');

        g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')
          .style('opacity', 1);
      }


      if (showYAxis) {
        yAxis
          .scale(y)
          .ticks( availableHeight / 36 )
          .tickSize( -availableWidth, 0);

        g.select('.nv-y.nv-axis').transition()
          .call(yAxis);
      }


      //------------------------------------------------------------



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) {
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });

      controls.dispatch.on('legendClick', function(d,i) {
        if (!d.disabled) return;
        controlsData = controlsData.map(function(s) {
          s.disabled = true;
          return s;
        });
        d.disabled = false;

        switch (d.key) {
          case groupedLegendTrn:
            multibar.stacked(false);
            break;
          case stackedLegendTrn:
            multibar.stacked(true);
            break;
        }

        state.stacked = multibar.stacked();
        dispatch.stateChange(state);

        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode)
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        if (typeof e.stacked !== 'undefined') {
          multibar.stacked(e.stacked);
          state.stacked = e.stacked;
        }

        chart.update();
      });

      //============================================================


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  multibar.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  multibar.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });
  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.multibar = multibar;
  chart.legend = legend;
  chart.controls = controls;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;

  d3.rebind(chart, multibar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'clipEdge',
    'id', 'stacked', 'stackOffset', 'delay', 'barColor','groupSpacing');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.reduceXTicks= function(_) {
    if (!arguments.length) return reduceXTicks;
    reduceXTicks = _;
    return chart;
  };

  chart.rotateLabels = function(_) {
    if (!arguments.length) return rotateLabels;
    rotateLabels = _;
    return chart;
  }

  chart.staggerLabels = function(_) {
    if (!arguments.length) return staggerLabels;
    staggerLabels = _;
    return chart;
  };

  chart.tooltip = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}
},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/pieChart.js":[function(require,module,exports){

nv.models.customizedPieChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var pie = nv.models.pie();
    var legend = nv.models.legend().margin({top: 0, right: 0, bottom: 0, left: 0});

    var margin = {top: 30, right: 20, bottom: 20, left: 20}
    //var legendMargin = {top: 30, right: 20, bottom: 20, left: 20}
        , width = null
        , height = null
        , showLegend = true
        , color = nv.utils.defaultColor()
        , tooltips = true
        , tooltip = function(key, y, e, graph) {
            return '<h3 style="background-color: '
                + e.color + '">' + key + '</h3>'
                + '<p>' +  y + '</p>';
        }
        , state = nv.utils.state()
        , defaultState = null
        , noData = "No Data Available."
        , duration = 250
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var tooltipLabel = pie.x()(e.point);
        var left = e.pos[0] + ( (offsetElement && offsetElement.offsetLeft) || 0 ),
            top = e.pos[1] + ( (offsetElement && offsetElement.offsetTop) || 0),
            y = pie.valueFormat()(pie.y()(e.point)),
            content = tooltip(tooltipLabel, y, e, chart)
            ;
        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch);

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined) {
                data.forEach(function (series, i) {
                    series.disabled = !state.active[i];
                });
            }
        }
    };

    //============================================================
    // Chart function
    //------------------------------------------------------------

    function chart(selection) {
    	
        renderWatch.reset();
        renderWatch.models(pie);

        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var that = this;
            var availableWidth = (width || parseInt(container.style('width'), 10) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height'), 10) || 400)
                    - margin.top - margin.bottom
                ;

            chart.update = function() { container.transition().call(chart); };
            chart.container = this;

            state.setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');
            var g = wrap.select('g');

            var heightOffset = $($(container[0])[0]).find(".legend.nvd3-svg")[0].getBoundingClientRect().height;
            gEnter.append('g').attr('class', 'nv-pieWrap').attr('transform', 'translate(0,' + heightOffset + ')');
            gEnter.append('g').attr('class', 'nv-legendWrap');

            // Legend
            if (showLegend) {
                legend.width( availableWidth ).key(pie.x());

                wrap.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);
            }
            //wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            pie.width(availableWidth).height(availableHeight);
            var pieWrap = g.select('.nv-pieWrap').datum([data]);
            d3.transition(pieWrap).call(pie);

            // Event Handling/Dispatching (in chart's scope)
            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState) {
                    state[key] = newState[key];
                }
                dispatch.stateChange(state);
                chart.update();
            });

            pie.dispatch.on('elementMouseout.tooltip', function(e) {
                dispatch.tooltipHide(e);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                    state.disabled = e.disabled;
                }
                chart.update();
            });

        });

        renderWatch.renderEnd('pieChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    pie.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.legend = legend;
    chart.dispatch = dispatch;
    chart.pie = pie;
    chart.options = nv.utils.optionsFunc.bind(chart);

    // use Object get/set functionality to map between vars and chart functions
    chart._options = Object.create({}, {    	
        // simple options, just get/set the necessary values
        noData:         {get: function(){return noData;},         set: function(_){noData=_;}},
        tooltipContent: {get: function(){return tooltip;},        set: function(_){tooltip=_;}},
        tooltips:       {get: function(){return tooltips;},       set: function(_){tooltips=_;}},
        showLegend:     {get: function(){return showLegend;},     set: function(_){showLegend=_;}},
        defaultState:   {get: function(){return defaultState;},   set: function(_){defaultState=_;}},
        // options that require extra logic in the setter
        color: {get: function(){return color;}, set: function(_){
            color = _;
            legend.color(color);
            pie.color(color);
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        /*legendMargin: {get: function(){return legendMargin;}, set: function(_){
        	legendMargin.top    = _.top    !== undefined ? _.top    : legendMargin.top;
        	legendMargin.right  = _.right  !== undefined ? _.right  : legendMargin.right;
        	legendMargin.bottom = _.bottom !== undefined ? _.bottom : legendMargin.bottom;
        	legendMargin.left   = _.left   !== undefined ? _.left   : legendMargin.left;
        }},*/
    });
    
    nv.utils.inheritOptions(chart, pie);
    nv.utils.initOptions(chart);
    return chart;
};
},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/check-support.js":[function(require,module,exports){
function queryselector() {
  return !!document.querySelector;  // fails on oooooooooold IE
}


function svg() {
  try {
    document.createElementNS('http://w3.org/2000/svg', 'svg');
    return true;
  } catch (err) { return false; }
}


function canvas() {
  return !!document.createElement('canvas').getContext;
}


function canvasText() {
  if (!canvas()) { return false; }
  var textFn = document.createElement('canvas').getContext('2d').fillText;
  return (typeof textFn === 'function');
}


var isIE = (function() {
  // http://stackoverflow.com/a/2401861/1299695
  // Magic. Do not touch.
  var yesItIs = !!(function() {
    var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(M[1])) {
      tem =  /\brv[ :]+(\d+)/g.exec(ua) || [];
      return 'MSIE ' + (tem[1] || '');
    }
    if (M[1] === 'Chrome') {
      tem = ua.match(/\bOPR\/(\d+)/);
      if (!!tem) { return 'Opera ' + tem[1]; }
    }
    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
    if ((tem = !!ua.match(/version\/(\d+)/i))) { M.splice(1, 1, tem[1]); }
    return M.join(' ');
  })().match(/^MSIE/);

  return function() { return yesItIs; };
})();


function dataURLHref() {
  // I don't know how to feature-detect this :(
  // we will be optimisitic an only say "no" if we see IE.
  return !isIE();
}


function flash() {
  // http://stackoverflow.com/a/20095467/1299695
  // gross...
  try {
    return !!(new ActiveXObject('ShockwaveFlash.ShockwaveFlash')); // jshint ignore:line
  } catch (e) {
    return navigator.mimeTypes &&
      navigator.mimeTypes['application/x-shockwave-flash'] !== void 0 &&
      navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin;
  }
}


module.exports = function() {
  var missingFeatures = [];  // an empty array will cast to bool false. handy!

  if (!queryselector()) {
    missingFeatures.push({
      feature: 'querySelector',
      severity: 'critical'
    });
  }

  if (!svg()) {
    missingFeatures.push({
      feature: 'SVG',
      severity: 'critical'
    });
  }

  if (!canvasText()) {
    missingFeatures.push({
      feature: 'canvas',
      severity: 'major'
    });
  }

  if (!dataURLHref()) {
    missingFeatures.push({
      feature: 'download',
      severity: flash() ? 'minor' : 'major'
    });
  }

  if (!flash()) {
    missingFeatures.push({
      feature: 'flash',
      severity: isIE() ? 'major' : 'minor'
    });
  }

  return missingFeatures;
};

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/amp-user.js":[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  url: '/rest/security/layout',

  /************
   * email is null from server when not logged in or when workspace not set yet.
   * Before it is fetched, default to undefined.
   */
  defaults: {
    email: undefined
  },
  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }


});

},{"backbone":"backbone"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-aid-predictability.js":[function(require,module,exports){
var _ = require('underscore');
var ChartModel = require('./chart-model-base');


module.exports = ChartModel.extend({
	

	defaults : {
		title : '',
		showPlannedDisbursements: true,
		showActualDisbursements: true,
		chartType: 'aidPredictability'
	},

  _prepareTranslations: function() {
    var self = this;
    var predictabilityBaseLanguage = {};

    /* Prepare the translations for the chart */
    predictabilityBaseLanguage['amp.dashboard:aid-predictability-planned-disbursements'] = 'Planned Disbursements';
    predictabilityBaseLanguage['amp.dashboard:aid-predictability-actual-disbursements'] = 'Actual Disbursements';

    this.localizedPredictability = this.app.translator.translateList(predictabilityBaseLanguage).then(
      function(localizedPredictabilityList) {
        self.localizedPredictabilityList = localizedPredictabilityList;
      });
  },

  parse: function(data) {
	this.set('title', data.title);	
	if(!_.isUndefined(data.showPlannedDisbursements)){
		this.set('showPlannedDisbursements', data.showPlannedDisbursements);
	}
	if(!_.isUndefined(data.showActualDisbursements)){
		this.set('showActualDisbursements', data.showActualDisbursements);
	}	
	
    function pick(which) {
      return function(d) {
        return {
          x: d.year,
          y: d[which]['amount'],
          z: d[which]['formattedAmount']
        };
      };
    }
    /* returns from map() like [{amp.gis:title-Region: 'Region'}, ... ]*/

    data.processed = [
      {
        key: this.localizedPredictabilityList['amp.dashboard:aid-predictability-planned-disbursements'],
        originalKey: 'planned',
        values: _(data.years).map(pick('planned disbursements')),
        disabled: !this.get('showPlannedDisbursements')
      },
      {
        key: this.localizedPredictabilityList['amp.dashboard:aid-predictability-actual-disbursements'],
        originalKey: 'actual',
        values: _(data.years).map(pick('actual disbursements')),
        disabled: !this.get('showActualDisbursements')
      }
    ];
    return data;
  }

});

},{"./chart-model-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-funding-type.js":[function(require,module,exports){
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');

module.exports = ChartModel.extend({

  defaults: {
    typed: true,
    limit: 3,
    title: '',
    stacked: false,
    seriesToExclude: [],
    yearTotals:{},
    chartType: 'fundingType'
  },

  _prepareTranslations: function() {
    var self = this;
    var ftypeBaseLanguage = {};

    /* Prepare the translations for the chart */
    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');

    /*
     * TODO: load all the localizations in this chart's namespace to this array
     * from initial-translation-request.json -- For now just hardcode the two sorts.
     */
    if (this.get('name') === 'Funding Type') {
      ftypeBaseLanguage[chartName + 'Grant'] = 'Grant';
      ftypeBaseLanguage[chartName + 'Loan'] = 'Loan';
      ftypeBaseLanguage[chartName + 'others'] = 'Others';
    }

    this.localizedFType = this.app.translator.translateList(ftypeBaseLanguage).then(
      function(localizedKeyVal) {
        self.localizedLookup = localizedKeyVal;
      });
  },

  parse: function(data) {
	this.set('title', data.title);
	
    var self = this;
    var years;
    if (data.values.length > 0 && !isNaN(parseInt((data.values)[0].Year, 10))) {
      years = _.sortBy(data.values, function(obj) { return parseInt(obj.Year, 10); });
    } else {
      years = _(data.values).sortBy('Year');
    }

    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');
    var localizedOthers = self.localizedLookup[chartName + 'others'];

    // reformat the data for nvd3
    data.processed = _(years)
      .chain()
      .reduce(function(series, year) {
        series.push.apply(series, _(year.values).pluck('type'));
        return series;
      }, [])
      .uniq()
      .map(function(s) {
        var cleanName = s.replace(/[ :.]/g, '');
        var localizedName = s;
        if (self.localizedLookup[chartName + cleanName]) {
          localizedName = self.localizedLookup[chartName + cleanName];
        }
        return {
          key: localizedName,
          values: _(years).map(function(y) {
            var yearValue = _(y.values).findWhere({type: s});
            return {
              x: y.Year,
              y: yearValue && yearValue.amount || 0,
              z: yearValue && yearValue.formattedAmount || 0,
            };
          }),
          disabled: (_.indexOf(self.get('seriesToExclude'),localizedName) != -1)
        };
      })
      .value();
    
 
	
    // group smallest contributors as "other"s
    if (this.get('limit') < data.processed.length) {
    	// Summarize each funding type and sort by total descending, create a new array only with funding types names.
    	var othersNames = _(data.processed)
	        .chain()
	        .map(function(series) {
	        	return {
	        		key: series.key,
		        	total: _(series.values).reduce(function(t, v) { return t + v.y; }, 0)
		        };
	        })
	        .sortBy('total')
	        .reverse()
	        .rest(this.get('limit'))
	        .pluck('key')
	        .value();

    	// Create a new array from the original data but only with the funding types from 'Others' category.
    	var othersSeriesValues = _(data.processed).filter(function(series) { return _(othersNames).contains(series.key); })
    	var sortedOthersSeriesValues = [];
    	
    	// Sort 'othersSeriesValues' by the values from 'othersNames' 
    	// (if we dont do this step then we will 'extract' the wrong funding type when clicking 'Others').
    	othersNames.forEach(function(key) {
    		var found = false;
    		othersSeriesValues = othersSeriesValues.filter(function(item) {
    	        if(!found && item.key === key) {
    	        	sortedOthersSeriesValues.push(item);
    	            found = true;
    	            return false;
    	        } else 
    	            return true;
    	    })
    	});
    	
    	// Summarize all funding types (from 'Others') by year.
    	othersSeriesValues = _(sortedOthersSeriesValues)
	    	.chain()
	    	.map(function(series) { return series.values; })
	        .transpose()
	        .map(function(othersYear) {
	            return {
	            	x: othersYear[0].x,
	            	y: _(othersYear).reduce(function(t, s) { return t + s.y; }, 0),
	            	z: ''
	            };
	        })
	        .map(function(item) {
	        	return {
	        		x: item.x,
	        		y: item.y,
	        		z: common.formatNumber(item.y /** parseFloat(app.generalSettings.numberDivider)*/)
	        	};
	        })
	        .value()
	    
	    var othersSeries = { 
	        key: localizedOthers,
	        color: '#777',
	        special: 'others',
	        disabled: (_.indexOf(self.get('seriesToExclude'), localizedOthers) != -1),
	        values: othersSeriesValues
	    };
    	    	// Remove from the original data the funding types we grouped in 'Others' (cant use slice because the sorting in 'data.processed' is different).
    	data.processed = _(data.processed).filter(function(item) {return !_(othersNames).contains(item.key)});
    	data.processed.push(othersSeries);
    }
    
    var yearTotals = {};
	_.each(data.processed, function(d){
		_.each(d.values, function(value){
			yearTotals[value.x] = (yearTotals[value.x] || 0) + value.y;
		});    		
	});
	
	this.set('yearTotals', yearTotals);

    return data;
  }

});

},{"../charts/common":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","./chart-model-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-heatmaps.js":[function(require,module,exports){
var param = require('jquery').param;
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');

module.exports = ChartModel.extend({

	defaults: {
	    xLimit: 30, //This is the max number of elements we will see in the x axis.
	    yLimit: 10, //This is the max number of elements we will see in the y axis.  
	    originalYLimit: 10, //This is the original max number of elements for the y axis (used to revert "others").
	    title: '',
	    name: '',
	    bigN: 0,
	    alternativeContainerClass: 'heatmap-chart-wrap',
	    values: [],
	    chartType: 'fragmentation',
	    swapAxes: false,
	    heatmap_type: null,
	    showResetButton: false,
	    showFullLegends: false
	},

	_prepareTranslations: function() {
		var topBaseLanguage = {};

	    /* Prepare the translations for the chart */
	    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');
	
	    this.localizedTopChart = this.app.translator.translateList(topBaseLanguage)
	    	.done(_(function(localizedTopChartKeyVal) {
	    		this.localizedLookup = localizedTopChartKeyVal;
	    	}).bind(this));
	},

	parse: function (data) {
		var self = this;
		self.values = new Array();
		if (_.isUndefined(data.xDataSet) || _.isUndefined(data.yDataSet)) {
			// The EP for heatmaps is different than the other charts because it returns an empty object, so we set explicitly some fields to empty value. 
			data.yDataSet = [];
			data.xDataSet = [];
			data.matrix = [];
			data.xTotals = 0;
			data.yTotals = 0;
			data.xCount = 0;
			data.yCount = 0;
			data.xTotalCount = 0;
			data.yTotalCount = 0;
		}		
		self.values.x = data.xDataSet;
		self.values.y = data.yDataSet;
		for (var i = 0; i < data.yDataSet.length; i++) {
			for (var j = 0; j < data.xDataSet.length; j++) {
				if (data.matrix[i] !== null) {
					var value = data.matrix[i][j] !== null ? data.matrix[i][j] : {p: -1, amount: '0'};
					var row = {y: i + 1, x: j + 1, value: value.p, amount: value.dv/*, yname: data.yDataSet[i], xname: data.xDataSet[i]*/}; //name is for tooltip
					self.values.push(row);
				} else {
					self.values.push({y: i + 1, x: j + 1, value: -1, amount: "0"});
				}
			}
		}
				
		// Normalize values.
		self.values = this.normalizeValues(self.values);
		
		// Add totals data.
		self.values.xPTotals = this.normalizeValues(data.xPTotals);
		self.values.yPTotals = this.normalizeValues(data.yPTotals);
		self.values.xTotals = data.xTotals;
		self.values.yTotals = data.yTotals;
		self.values.xCount = data.xCount;
		self.values.yCount = data.yCount;
		self.values.xTotalCount = data.xTotalCount;
		self.values.yTotalCount = data.yTotalCount;	
		self.values.model = this;

		if (!this.localizedLookup) {
			// we can't procede if we don't have translations yet :(
			// this code should now be unreachable, but y'never know...
			this.app.report('Loading error', ['Translations for the application were not loaded before rendering']);
		}
		var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');

		data.processed = [{values: this.values}];
		data.values = this.values;
		
		if (data.yCount > this.get('originalYLimit') + 1) {
			this.set('showResetButton', true);
		} else {
			this.set('showResetButton', false);
		}
		
		return data;
	},
	
	normalizeValues: function(values) {
		if (_.isUndefined(values) === false) {
			for (var i = 0; i < values.length; i++) {
				var auxValue = values[i].value !== undefined ? values[i].value : values[i];
				if (auxValue > 0 && auxValue < 1) {
					//Do nothing;
				} else {
                    if (auxValue == null) {
                        auxValue = -99;
                    }
                    if (values[i].value !== undefined) {
                        values[i].value = Math.floor(auxValue);
                    } else {
                        values[i] = Math.floor(auxValue);
                    }
				}
			}
		}
		return values;
	},

	fetch: function(options) {
		var self = this;
		options = _.defaults(options || {}, { url: this.url });
		
		// Process params from heat-map/configs, in that EP we have defined each heatmap.
		var configs = this.get('heatmap_config').models[0];
		var thisChart = _.find(configs.get('charts'), function(item) {return item.name === self.get('name')});
		var xColumn = self.get('xAxisColumn') !== '' ? self.get('xAxisColumn') : configs.get('columns')[thisChart.xColumns[0]].origName; // First column is default.
		var yColumn = configs.get('columns')[thisChart.yColumns[0]].origName; // First column is default.
		
		// Check if we need to switch axis.
		if (self.get('swapAxes') === true) {
			var auxAxis = yColumn;
			yColumn = xColumn;
			xColumn = auxAxis;
		}		
		var paramsForHeatMap = {xCount: self.get('xLimit'), xColumn: xColumn, yColumn: yColumn, yCount: self.get('yLimit')};		
		var filterObject = JSON.parse(options.data);		
		paramsForHeatMap.filters = (filterObject && filterObject.filters) ? filterObject.filters : {}; 
		options.data = JSON.stringify(paramsForHeatMap);

		return ChartModel.prototype.fetch.call(this, options);
	}
});
},{"../charts/common":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","./chart-model-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Model.extend({

  defaults: {},

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;
    this._prepareTranslations();  // TODO: refactor this implementation into here
  },

  hasData: function() {
    return _(this.get('processed'))
      .chain()
      .pluck('values')
      .reduce(function(result, values) {
        return values.length && true || result;
      }, false)
      .value();
  },

  fetch: function(options) {
    var data = JSON.parse(options.data);
    data.settings = this.app.settingsWidget.toAPIFormat();

    if (this.get('adjtype')) {
      // TODO adjtype hard-coding key for now, should get from settings...
      data.settings = _({}).extend(data.settings, {'funding-type': this.get('adjtype')});
    }
    _.defaults(data.settings,{ 'currency-code': this.app.settingsWidget.definitions.getDefaultCurrencyId()});
    options.data = JSON.stringify(data);
    return BackboneDash.Model.prototype.fetch.call(this, options);
  }

});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-tops.js":[function(require,module,exports){
var param = require('jquery').param;
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');


module.exports = ChartModel.extend({

  defaults: {
    limit: 5,
    title: '',
    bigN: 0,
    chartType: 'top'
  },

  _prepareTranslations: function() {
    var topBaseLanguage = {};

    /* Prepare the translations for the chart */
    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');

    /*
     * TODO: load all the localizations in this chart's namespace to this array
     * from initial-translation-request.json -- For now just hardcode the two sorts.
     */
    if (this.get('name') === 'Top Regions') {
      topBaseLanguage[chartName + 'DistrictUndefined'] = 'Districts: Undefined';
    }
    topBaseLanguage[chartName + 'others'] = 'Others';

    this.localizedTopChart = this.app.translator.translateList(topBaseLanguage)
      .done(_(function(localizedTopChartKeyVal) {
        this.localizedLookup = localizedTopChartKeyVal;
      }).bind(this));
  },

  parse: function(data) {
	this.set('title', data.title);
	  
    if (!this.localizedLookup) {
      // we can't procede if we don't have translations yet :(
      // this code should now be unreachable, but y'never know...
      this.app.report('Loading error', [
      'Translations for the application were not loaded before rendering']);
    }

    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');
    this.localizedOthers = this.localizedLookup[chartName + 'others'];
    if (this.localizedOthers === undefined) {
    	console.error('missing translation in .json file: ' + chartName + 'others');
    }

    var values = _(data.values.slice()).map(function(v) {
      var cleanName = v.name.replace(/[ :.]/g, '');
      var localizedName = v.name;
      if (this.localizedLookup[chartName + cleanName]) {
        localizedName = this.localizedLookup[chartName + cleanName];
      }

      return {
        x: localizedName,
        y: v.amount,
        z: v.formattedAmount,
        id: v.id
      };
    }, this);

    // make sure we don't have any duplicate keys... nvd3 pukes on those
    if (_(_(values).pluck('x')).uniq().length < values.length) {
      this.app.report('Data Error',
        ['The data for ' + this.get('name') + ' was inconsistent due to duplicate keys',
        'The chart will be shown, but it may have errors or other issues as a result.']);
    }

    if (data.maxLimit > values.length) {
    	var other = {
    			x: this.localizedOthers,
    			y: data.total -  // total minus the sum of what we have
                _.chain(values).pluck('y').reduce(function(l, r) { return l + r; }, 0).value(),
                color: '#777',
                special: 'others'
        };
        //AMP-18740: We changed the EP to send raw numbers expressed in units so we need to apply the GS here.
    	other.z = common.formatNumber(other.y / app.generalSettings.numberDivider);
        values.push(other);
    }

    data.processed = [{values: values}];
    return data;
  },

  fetch: function(options) {
    options = _.defaults(
      options || {},
      { url: this.url + '?' + param(this.pick('limit')) });
    return ChartModel.prototype.fetch.call(this, options);
  }

});

},{"../charts/common":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","./chart-model-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/charts-collection.js":[function(require,module,exports){
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Collection.extend({
  initialize: function(models, options) {
    this.app = options.app;
  }
});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/enabled-charts-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');

var EnabledChartModel = Backbone.Model.extend({

});

var EnabledChartsCollection = Backbone.Collection.extend({
	model : EnabledChartModel,
	url : '/rest/common/fm',
	fetchData : function() {
		var params = {
			"detail-modules" : [ "DASHBOARDS" ]
		};
		this.fetch({
			type : 'POST',
			async : false,
			processData : false,
			mimeType : 'application/json',
			traditional : true,
			headers : {
				'Content-Type' : 'application/json',
				'Cache-Control' : 'no-cache'
			},
			data : JSON.stringify(params), // This is necessary due to
											// incompatibilities with Jersey
											// when receiving the params.
			error : function(collection, response) {
				console.error('error loading charts.');
			},
			success : function(collection, response) {
				// console.log(response);
			}
		});
	}
});

module.exports = EnabledChartsCollection;
},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/heatmaps-config-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');

var HeatmapsConfigModel = Backbone.Model.extend({

});

var HeatmapsConfigCollection = Backbone.Collection.extend({
	model : HeatmapsConfigModel,
	url : '/rest/dashboard/heat-map/configs',
	fetchData : function() {
		this.fetch({
			type : 'GET',
			async : false,
			processData : false,
			mimeType : 'application/json',
			traditional : true,
			headers : {
				'Content-Type' : 'application/json',
				'Cache-Control' : 'no-cache'
			},
			data : JSON.stringify(), // This is necessary due to
											// incompatibilities with Jersey
											// when receiving the params.
			error : function(collection, response) {
				console.error('error loading heatmap configs.');
			},
			success : function(collection, response) {
				//console.log(response);
			}
		});
	}
});

module.exports = HeatmapsConfigCollection;
},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dash.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


var API_ID_KEY = 'mapId';


module.exports = BackboneDash.Model.extend({

  defaults: {
    name: undefined,
    description: undefined,
    stateBlob: undefined
  },

  // parse and toJSON map the id field to mapId for the API.
  parse: function(obj) {
    if (_(obj).has(API_ID_KEY)) {
      obj.id = obj[API_ID_KEY];
      delete obj[API_ID_KEY];
    }
    return obj;
  },

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;
  },

  toJSON: function() {
    var copy = BackboneDash.Model.prototype.toJSON.apply(this, arguments);
    if (_(copy).has('id')) {
      copy[API_ID_KEY] = copy.id;
      delete copy.id;
    }
    return copy;
  }

}, {
  fromId: function(id, options) {
    return new this({ id: id }, options);
  }
});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dashes-collection.js":[function(require,module,exports){
var _ = require('underscore');
var Deferred = require('jquery').Deferred;
var BackboneDash = require('../backbone-dash');
var SavedChart = require('./saved-dash');


module.exports = BackboneDash.Collection.extend({

  url: '/rest/dashboard/saved-charts',

  model: SavedChart,
  timer: undefined,
  initializedOnce: false,

  initialize: function(models, options) {
    this.app = options.app;
  },

  load: function(stateId) {
	var self = this;
	if (self.initializedOnce !== false) { return; }
	self.initializedOnce = true;
	 
    var deferred = new Deferred();
    var loaded = this.get(stateId);
    if (loaded) {
      deferred.resolve(loaded);
    } else {
      var model = this.model.fromId(stateId, { app: this.app });
      this.add(model);  // sets up collection so the model can find a URL
      model.fetch().done(function() {
          deferred.resolve(model);
          
          // AMP-19803 and AMP-20206: Here we wait until the filter widget has been loaded to trigger the 'apply' event and force each chart to redraw with the saved filters.
	      // Tried to do something similar before we reach this stage (ie: in app-class.js, chart-view-base.js, charts.js, etc) but without luck because the render is triggered automatically.
	      // TODO: We need more time to evaluate a solution using this.app.filter.loaded promise but that didnt work consistently on IE.          
          if (self.timer === undefined) {
        	  self.timer = setInterval(function() {
		    	  if (this.app !== undefined && this.app.filter !== undefined && this.app.filter.finishedFirstLoad === true) {
		    		  clearInterval(self.timer);
		    		  this.app.filter.trigger('apply');			    		  
		    		  // Only make 1 render call to the main app view, this will prevent other bugs (ie: the double and triple chart rendering).
		    		  if (this.app.rendered === false) {
		    			  this.app.rendered = true;
		    			  app.render();
		    		  }
		    	  }
		      }, 100);
          }
        }).fail(_(function() {
          this.app.report('Failed to load saved dashboard', ['Could not retrieve the saved state.']);
          deferred.reject();
        }).bind(this));
    }

    return deferred.promise();
   }
});
},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./saved-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dash.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-aid-predictability.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var _ = require('underscore');


module.exports = ChartViewBase.extend({

  uiDefaults: {
    big: false,
    view: 'multibar',
    showTotal: true,
    showMeasuresSelector: true,
    showTopLegends: true,
    showCommonChartArea: true
  },
  events: function(){
      return _.extend({},ChartViewBase.prototype.events,{
          'click .nv-series' : 'changeChartColumns'
      });
  },  
  changeChartColumns: function(e){
	  var key = $(e.currentTarget).find('.nv-legend-text').text();
	  var plannedDisbursementTrn = app.translator.translateSync("amp.dashboard:aid-predictability-planned-disbursements","Planned Disbursements");
	  var actualDisbursementTrn = app.translator.translateSync("amp.dashboard:aid-predictability-actual-disbursements","Actual Disbursements");
	  if(key == plannedDisbursementTrn){
		  this.model.set('showPlannedDisbursements', !this.model.get('showPlannedDisbursements'));	
	  }else if(key == actualDisbursementTrn){
		  this.model.set('showActualDisbursements', !this.model.get('showActualDisbursements'));	
	  }	
  },
  chartViews: [
    'multibar',
    'table'
  ],

  chartOptions: {
    nvControls: false
  },

  downloadChartOptions: {
    nvControls: false,
    trimLabels: false
  },

  getTTContent: function(context) {
    var app = this.app;
    var of = app.translator.translateSync('amp.dashboard:of','of');
    var total = app.translator.translateSync('amp.dashboard:total','total');
    var units = app.translator.translateSync(app.generalSettings.numberDividerDescription);

    // IMPORTANT: We assume this chart will ALWAYS show 2 data series.
    /* modify to be like chart-funding-type if adding more series */
    var index = -1;
    if (context.data[0].disabled === true) {
      index = 1;
    } else {
      index = context.series.index;
    }

    var header = context.x.raw + ' ' +
          app.translator.translateSync('amp.dashboard:aid-predictability-' +
          context.data[index].originalKey + '-' + this.model.get('measure'), '');

    var otherSeries = context.data[1 - index];  // WARNING: assumes only 2 series
    var otherHere = otherSeries.values[context.x.index];
    var line2Amount = 0;
    if (otherHere.y > 0) {
      line2Amount = context.y.raw / otherHere.y;
    }
    var line2 = '<b>' + d3.format('%')(line2Amount) +
        '</b>&nbsp<span>' + of + '</span>&nbsp' + context.x.raw +
        '&nbsp<span>' + total + '</span>';
    var self = this;
    var currencyName = app.settingsWidget.definitions.findCurrencyById(self.model.get('currency')).value; 
    return {tt: {
      heading: header,
      bodyText: '<b>' + context.y.fmt + '</b> ' + currencyName + ' (' + units + ')',
      footerText: line2
    }};
  }

});

},{"./chart-view-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js","d3":"d3","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-funding-type.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var _ = require('underscore');


module.exports = ChartViewBase.extend({

  uiDefaults: {
    big: true,
    adjtype: 'FAKE',
    view: 'multibar',
    showTotal: true,
    showMeasuresSelector: true,
    showTopLegends: true,
    showCommonChartArea: true
  },
  events: function(){
      return _.extend({},ChartViewBase.prototype.events,{
          'click .nv-series' : 'changeChartColumns'
      });
  },   
  changeChartColumns: function(e){	  
	  var key = $(e.currentTarget).find('.nv-legend-text').text();	 
	  var stackedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Stacked","Stacked");
	  var groupedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Grouped","Grouped");
	  if(key == stackedLegendTrn || key == groupedLegendTrn){
		  this.model.set('stacked', (key == stackedLegendTrn ));	
	  }else{
		  var seriesToExclude = this.model.get('seriesToExclude') ? this.model.get('seriesToExclude') : [];
		  var indexOfKeyInExclusionList = _.indexOf(seriesToExclude, key);
		  if($(e.currentTarget).attr('class').indexOf('disabled') != -1){
			  if(indexOfKeyInExclusionList == -1){
				  seriesToExclude.push(key);
			  }			  
		  }else{
			  if(indexOfKeyInExclusionList != -1){
				  seriesToExclude.splice(indexOfKeyInExclusionList, 1);
			  }
		  }
		  this.model.set('seriesToExclude',seriesToExclude);
	  }	 
  },
  chartViews: [
    'multibar',
    'table'
  ],

  downloadChartOptions: {
    trimLabels: false
  },

  getTTContent: function(context) {
    var app = this.app;
    var of = app.translator.translateSync('amp.dashboard:of','of');
    var total = app.translator.translateSync('amp.dashboard:total','total');
    var units = app.translator.translateSync(app.generalSettings.numberDividerDescription);

    var activeTooltipTitles = _.filter(context.data, function(series) {
      return series.disabled !== true;
    });
    
    var totalForYear = this.model.get('yearTotals') ? this.model.get('yearTotals')[context.x.raw ] : null;
    var d3FormatTotal = '', totalSpan = '';
    if(totalForYear && totalForYear != 0){
    	d3FormatTotal = d3.format('%')(context.y.raw / totalForYear);
        totalSpan = '&nbsp<span>' + total + '</span>';
    }
    var self = this;
    var currencyName =  app.settingsWidget.definitions.findCurrencyById(self.model.get('currency')).value;  
    return {tt: {
      heading: context.x.raw + ' ' + activeTooltipTitles[context.series.index].key,
      bodyText: '<b>' + context.y.fmt + '</b> ' + currencyName + ' (' + units + ')',
      footerText: '<b>' + d3FormatTotal + '</b>&nbsp<span>' + of + '</span>&nbsp' + context.x.raw + totalSpan
    }};
  },

  chartClickHandler: function(context) {
    // clicking on the "others" bar loads five more.
    if (context.data[context.series.index].special === 'others') {
      this.model.set('limit', this.model.get('limit') + 1);
    }
  }

});

},{"./chart-view-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js","d3":"d3","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-heatmaps.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var ModalView = require('./chart-tops-info-modal');
var _ = require('underscore');

module.exports = ChartViewBase.extend({

  uiDefaults: {
	adjtype: 'FAKE',
	xAxisColumn: '',
    showTotal: false,
    showMeasuresSelector: true,
    showTopLegends: false,
    showCommonChartArea: false,
    disableResize: true
  },
  
  chartViews: [
    'heatmap',
    'table'    
  ],
  
  modalView: undefined,
  
  chartClickHandler : function(context) {
	  if (context.y.fmt === app.translator.translateSync('amp.dashboard:chart-heatmap-others')) {
		  this.model.set('yLimit', this.model.get('yLimit') + 10);
		  this.updateData();
	  }
  },
  
  downloadChartOptions: {
    trimLabels: false
  }

});
},{"./chart-tops-info-modal":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops-info-modal.js","./chart-view-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js","d3":"d3","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops-info-modal.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<script type=\"text/javascript\">\r\n\tfunction openPreviewActivity(id) {\r\n\t\twindow.open('/aim/viewActivityPreview.do~public=true~pageId=2~activityId=' + id, '_blank');\r\n\t}\r\n</script>\r\n\r\n<div class='chart-tops-info-category'>\r\n\t<span>\r\n\t\t<b><%= (context.x.fmt || context.x.raw) %></b> - <%= model.get('adjtype')%> -  \t\t\r\n\t\t<span data-i18n=\"<%= app.generalSettings.numberDividerDescription %>\"></span>\r\n\t\t<%= model.get('currency') %>\r\n\t</span>\r\n</div>\r\n<div class=\"chart-tops-info-container\">\r\n\t<div class=\"chart-tops-info-content\">\r\n\t\t<% if(error) { %>\r\n\t\t\t<div class=\"alert alert-danger\" role=\"alert\">\r\n\t\t\t\t<strong><span data-i18n=\"amp.dashboard:error\">Error</span></strong>\r\n\t\t\t\t<span data-i18n=\"amp.dashboard:error-detail\">The Aid Management Platform has temporarily encountered an issue. We apologize for any inconvenience.</span>\r\n\t\t\t</div>\r\n\t\t<% } else if(values === undefined) { %>\r\n\t\t\t<img alt=\"\" src=\"/TEMPLATE/ampTemplate/dashboard/build/img/loading-icon.gif\">\r\n\t\t\t<span data-i18n=\"amp.dashboard:download-rendering\">Rendering...</span>\r\n\t\t<% } else { %>\r\n\t\t\t<% var rowClass = ''; %>\r\n\t\t\t<table>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<th><span data-i18n=\"amp.dashboard:chart-tops-table-projecttitle\">Project Title</span></th>\r\n\t\t\t\t\t<th><span data-i18n=\"amp.dashboard:chart-tops-table-amount\">Amount</span></th>\r\n\t\t\t\t</tr>\t\t\t\r\n\t\t\t<% _(values).each(function(row, i) { %>\r\n          \t\t<% \tif (i % 2 === 0) rowClass = 'odd_row';\r\n    \t\t\t\telse rowClass = ''; %>\r\n    \t\t\t<tr class=\"<%=rowClass%>\">\r\n    \t\t\t\t<td>\r\n    \t\t\t\t\t<span class='pointer' onclick='openPreviewActivity(<%=row.id%>)'><%=row.name%></span>\r\n    \t\t\t\t</td>\r\n    \t\t\t\t<td><%=row.formattedAmount%></td>\r\n    \t\t\t</tr>\r\n        \t<% }) %>\r\n        \t</table>\r\n\t\t<% } %>\r\n\t</div>\r\n</div>");

module.exports = BackboneDash.View.extend({

	initialize: function(options) {
		this.app = options.app;
		this.context = options.context;
		this.model = options.model;
		this.numberDivider = app.generalSettings.numberDivider;			
	},

	render: function() {
		var self = this;
		this.$el.html(template({
			error: undefined,
			model: this.model,
			context: this.context,
			values: undefined,
			numberDivider: this.numberDivider
		}));
		app.translator.translateDOM($(".dash-settings-modal"));
		
		//TODO: move this code to a new model so the API call is made automatically.
    	var config = this.app.filter.serialize();
    	config.settings = this.app.settingsWidget.toAPIFormat();
    	config.settings['funding-type'] = this.model.get('adjtype');
    	$.ajax({
    		method: 'POST',
    		url: self.model.url + '/' + this.context.data[0].values[this.context.x.index].id,
    		dataType: 'json',
    		contentType: 'application/json',
    		processData: false,
    		data: JSON.stringify(config)
    	}).done(function(data) {
    		//TODO: Can we avoid re-calling the template by binding the changes in the 'values' field? 
    		self.$el.html(template({
				error: undefined,
    			model: self.model,
    			context: self.context,
    			values: data.values,
    			numberDivider: self.numberDivider
    		}));
    		app.translator.translateDOM($(".dash-settings-modal"));
    	}).fail(function(xhr, err) {
			var msg = JSON.parse(xhr.responseText).error;
			console.error("Error Getting chart-tops-info-modal from EP", msg);
			self.$el.html(template({
				model: self.model,
				context: self.context,
				error: err,
				numberDivider: self.numberDivider
			}));
		});
    	
		return this;
	},

});
},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var ModalView = require('./chart-tops-info-modal');
var _ = require('underscore');

module.exports = ChartViewBase.extend({

  uiDefaults: {
    adjtype: 'FAKE',
    showTotal: true,
    showMeasuresSelector: true,
    showTopLegends: true,
    showCommonChartArea: true    
  },
  
  chartViews: [
	'bar',
    'pie',
    'table'    
  ],
  
  modalView: undefined,
  
  //Dont try to call initialize here because it throws a 'Module initialization error' :((
  /*initialize: function(options) {
	  this.modalView = new ModalView({ app: options.app, collection: this.model.collection });
  },*/

  downloadChartOptions: {
    trimLabels: false
  },

  getTTContent: function(context) {
	var ofTotal = app.translator.translateSync("amp.dashboard:of-total","of total");
	var units = app.translator.translateSync(app.generalSettings.numberDividerDescription);
    var self = this;
    var currencyName =  app.settingsWidget.definitions.findCurrencyById(self.model.get('currency')).value;
    var percentage = context.y.raw > 0 ?
        d3.format('%')(context.y.raw / this.model.get('totalPositive')) + '</b>&nbsp<span>' + ofTotal:
        "";
    return {tt: {
      heading: context.x.raw,
      bodyText: '<b>' + context.y.fmt + '</b> ' + currencyName + ' (' + units + ')',
      footerText: '<b>' + percentage + '</span>'
    }};
  },

  chartClickHandler: function(context) {	  
    // clicking on the "others" bar loads five more.
    if (context.data[context.series.index]
               .values[context.x.index].special === 'others') {
      this.model.set('limit', this.model.get('limit') + 5);      
        this.model.set('big', true);      
    } else if (this.model.get('showCategoriesInfo') === true) {    	
    	this.modalView = new ModalView({ app: app, context: context, model: this.model });
    	this.openInfoWindow();    	    	
    }
  },
  
  openInfoWindow: function() {
	  var specialClass = 'dash-settings-modal';
	  this.app.modal('Category Detail', {
		  specialClass: specialClass,
	      bodyEl: this.modalView.render().el,
	      i18nTitle: 'amp.dashboard:dashboard-chart-tops-info-modal'
	  });	    
	  // Translate modal popup.
	  app.translator.translateDOM($("." + specialClass));
  }

});

},{"./chart-tops-info-modal":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops-info-modal.js","./chart-view-base":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js","d3":"d3","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js":[function(require,module,exports){

var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var getChart = require('../charts/chart');
var util = require('../../ugly/util');
var DownloadView = require('./download');
var template = _.template("<div class=\"col-xs-12 <% if (!model.get('big')) { %>col-md-6<% } else { %> big-chart-<%= model.get('bigN')%> <% } %>\">\n\n  <div class=\"panel panel-chart\">\n    <div class=\"panel-heading fix-title-height\">\n      <% if (model.get('showTotal') === true) { %>\n\t      <div class=\"pull-right big-number\">\n\t        <b class=\"chart-total\"></b>\n\t        <span class=\"chart-currency\"></span>\n\t      </div>\n      <% } %>\n      <div class=\"chart-title\">\n\t      <h2 data-i18n=\"amp.dashboard:chart-<%= model.get('name').replace(/ /g,'') %>\"><%= model.get('title') %></h2>\n\t      <% if (model.get('chartType') === 'fragmentation') { %>\n\t      \t<% var help_icon_text = app.translator.translateSync('amp.dashboard:chart-heatmap-help-text-' + model.get('heatmap_type'));%>\n\t      \t<img src=\"/TEMPLATE/ampTemplate/dashboard/build/img/questionmark1.png\" class=\"question_mark nv-series\" data-title=\"<%= help_icon_text %>\">\n\t      <% } %>\n      </div>\n    </div>\n\t\n    <div class=\"panel-body\">\n      <div class=\"chart-container\">\n        <h3 class=\"dash-chart-diagnostic text-center\"></h3>\n        <div class=\"dash-chart-wrap <%= (model.get('alternativeContainerClass') !== undefined ? model.get('alternativeContainerClass') : '')%>\">\n        </div>\n        <button type=\"button\" class=\"btn btn-link btn-xs pull-right reset\" style=\"display:none\" data-i18n=\"amp.dashboard:chart-reset\">reset others</button>\n      </div>\n      <div class=\"alert alert-warning negative-values-message\" role=\"alert\">\n          <strong data-i18n=\"amp.dashboard:negatives-values\">Negative values are not represented in this chart.</strong><br>\n          <span data-i18n=\"amp.dashboard:negatives-values-parag\">Please switch to bar chart or table view to view all values.</span>\n      </div>\n    </div>\n\n    <div class=\"panel-footer clearfix\">\n\n      <div class=\"pull-right\">\n\n        <div class=\"btn-group\">\n          <% _(views).each(function(view) { %>\n            <button data-i18n=\"amp.dashboard:chart-tooltip-<%= view %>-chart[title]\" data-toggle=\"tooltip\" title=\"View data in <%= view %> chart\" type=\"button\" data-view=\"<%= view %>\"\n                class=\"chart-view btn btn-sm btn-<%= (view === model.get('view')) ? 'primary' : 'default' %>\">\n              <span class=\"glyphicon glyphicon-<%= {\n                bar: 'signal',\n                multibar: 'signal',\n                heatmap: 'stats',\n                pie: 'adjust',\n                table: 'th-list'\n              }[view] %>\"></span>\n            </button>\n          <% }) %>\n        </div>\n\n        <div class=\"btn-group\">\n          <a data-i18n=\"amp.dashboard:chart-tooltip-download-chart[title]\" data-toggle=\"tooltip\" title=\"Download image or table\"\n            class=\"btn btn-sm btn-default download\"\n            download=\"AMP <%= model.get('title') %> - <%= (new Date()).toISOString().split('T')[0] %>.png\"\n            target=\"_blank\">\n            <span class=\"glyphicon glyphicon-cloud-download\"></span>\n          </a>\n          <button data-i18n=\"<%= model.get('big') ? 'amp.dashboard:chart-tooltip-collapse-chart[title]' : 'amp.dashboard:chart-tooltip-expand-chart[title]' %>\" data-toggle=\"tooltip\" title=\"<%= model.get('big') ? 'Collapse chart' : 'Expand chart' %>\" type=\"button\" class=\"btn btn-sm btn-<%= model.get('big') ? 'primary' : 'default' %> expand hidden-xs hidden-sm\" <%= model.get('disableResize') ? 'disabled' : ''%>>\n            <span class=\"glyphicon glyphicon-fullscreen\"></span>\n          </button>\n        </div>\n\n      </div><!-- buttons in .pull-right -->\n\n      <% if (model.get('adjtype') && model.get('showMeasuresSelector') === true) { %>\n        <form class=\"form-inline dash-form dash-adj-type\" role=\"form\">\n          <select class=\"form-control like-btn-sm ftype-options\">\n            <option>...</option>\n            <!-- gets populated after settings load -->\n          </select>\n          <span class=\"cheat-lineheight\"></span>\n        </form>\n      <% } %>\n      \n      <% if (model.get('chartType') === 'fragmentation') { %>\n\t\t<form class=\"form-inline dash-form dash-xaxis-options\" role=\"form\">\n        \t<select class=\"form-control like-btn-sm xaxis-options\">\n            \t<option>...</option>\n            \t<!-- gets populated after settings load -->\n          \t</select>\n          \t<span class=\"cheat-lineheight\"></span>\n        </form>\n        <button type=\"button\" class=\"btn btn-sm btn-default heatmap-switch\">\n            <span data-i18n=\"amp.dashboard:chart-swap-axes\">Swap Axes</span>\n        </button>\n\t <% } %>\n\n    </div>\n  </div>\n\n  <div class=\"export-modal\"></div>\n</div>");


var adjOptTemplate = _.template('<option value="<%=opt.id%>" ' +
  '<%= current ? selected="selected" : \'\' %>><%=opt.name%></option>');


module.exports = BackboneDash.View.extend({

  uiDefaults: {
    big: false,
    view: 'bar'
  },

  events: {
    'change .dash-adj-type select': 'changeAdjType',
    'change .dash-xaxis-options select': 'changeXAxis',
    'click .reset': 'resetLimit',
    'click .chart-view': 'changeChartView',
    'click .download': 'download',
    'click .expand': 'big',
    'click .retry': 'render',
    'click .heatmap-switch': 'heatmapSwitchAxis'
  },

  chartViews: [
    'bar',
    'pie',
    'heatmap',
    'table'    
  ],  
  
  initialize: function(options) {
    this.app = options.app;
    this.model.set(this.uiDefaults);
    this.rendered = false;
    this._stateWait = new Deferred();
    this.message = null;
    this.showChartPromise = new Deferred();
    this.renderedPromise = new Deferred();

    if (this.app.savedDashes.length) {
      // a bit sketch....
    	  this.app.state.loadPromise.always(this._stateWait.resolve);
      } else {
      this._stateWait.resolve();
    }

    this.listenTo(this.app.filter, 'apply', this.updateData);
    this.listenTo(this.app.settingsWidget, 'applySettings', this.updateData);
    this.listenTo(this.model, 'change:adjtype', this.render);
    this.listenTo(this.model, 'change:xAxisColumn', this.render);
    this.listenTo(this.model, 'change:limit', this.updateData);
    this.listenTo(this.model, 'change:view', this.render);

    this.app.state.register(this, 'chart:' + this.model.url, {
      get: _.partial(_(this.model.pick).bind(this.model), 'limit', 'adjtype', 'xAxisColumn', 'view', 'big','stacked','showPlannedDisbursements','showActualDisbursements','seriesToExclude', 'xLimit', 'yLimit', 'swapAxes'),
      set: _(this.model.set).bind(this.model),
      empty: null
    });

    _.bindAll(this, 'showChart', 'failLoading','hideExportInPublicView','extractNumberFormatSettings');
    if (this.getTTContent) { _.bindAll(this, 'getTTContent'); }
    if (this.chartClickHandler) { _.bindAll(this, 'chartClickHandler'); }
  },

  render: function() {
	var self = this;
	this.renderedPromise = new Deferred();
    var renderOptions = {
      views: this.chartViews,
      model: this.model,
      chart: this.chartEl,
      util: util
    };
    // We need to be sure all dependencies have been loaded before processing each chart (specially the templates).
    $.when(this._stateWait, this.app.filter.loaded, this.app.translator.promise, this.app.settingsWidget.definitions.loaded, this.app.generalSettings.loaded).done(function() {
    	
    	self.extractNumberFormatSettings();
    	self.$el.html(template(renderOptions));
    	self.hideExportInPublicView();
    	self.message = self.$('.dash-chart-diagnostic');
    	self.chartContainer = self.$('.dash-chart-wrap');
	
	    if (self.model.get('adjtype') !== void 0) {  // this chart has adj settings
	    	self.rendered = true;
	        var adjSettings = self.app.settingsWidget.definitions.getFundingTypeSetting(); 	        	
	        if (!adjSettings) { 
	        	self.app.report('Could not find Funding Type settings'); 
	        } else {
	        	if (self.model.get('adjtype') === 'FAKE') {
	        		self.model.set('adjtype', adjSettings.get('value').defaultId);
	        	}
	        }
	        self.$('.ftype-options').html(
	          _(adjSettings.get('value').options).map(function(opt) {
	            return adjOptTemplate({
	              opt: opt,
	              current: (opt.id === self.model.get('adjtype'))
	            });
	          }, self)
	        );
	      
	    } else {
	    	self.rendered = true;
	    }
	    
	    // For heatmaps add some extra combos.
	    if (self.model.get('chartType') === 'fragmentation') {
	    	var heatMapConfigs = self.model.get('heatmap_config').models[0];
	    	var thisHeatMapChart = _.find(heatMapConfigs.get('charts'), function(item) {return item.name === self.model.get('name')});
	    	self.$('.xaxis-options').html(
	    		_(thisHeatMapChart.xColumns).map(function(colId) {
	    			var item = _.find(heatMapConfigs.get('columns'), function(item, i) { return i === colId});
	    			var opt = {id: item.origName, name: item.name, selected: false, value: item.origName};
	    			return adjOptTemplate({
	    				opt: opt,
	    	            current: (opt.id === self.model.get('xAxisColumn'))
	    	        });
	    	    }, self)
	    	);
	    }
	
	    if (self._stateWait.state() !== 'pending') {
	    	self.updateData();
	    }

	    self.app.translator.translateDOM(self.$el);
        self.$el.find('[data-toggle="tooltip"]').tooltip();
	    self.renderedPromise.resolve();
    });
    return this;
  },

  updateData: function() {
	if(this.app.rendered !== true) { return; }  
    if (!this.rendered) { return; }  // short-circuit on early filters apply event
    if (this._stateWait.state() === 'pending') {  // short-circuit until we have state
      this.message.html('Loading...').attr('data-i18n', 'amp.dashboard:chart-loading-saved-settings');
      app.translator.translateDOM($('.chart-container'));
      //this.message.fadeIn(100);
      return;
    }

    this.showChartPromise = new Deferred(); // We need to reinitialize this promise.
    this.chartContainer.empty();
    this.message.html('<span data-i18n="amp.dashboard:loading">Loading...</span>').fadeIn(100);

    this.app.translator.getTranslations()
      .done(_(function() {  // defer here to prevent a race with translations loading

    	if (this.model.get('chartType') === 'fragmentation') {
    		// We need this for AMP-25599.
    		this.app.translator.translateDOM(this.el);
    	}

        this.model.fetch({
          type: 'POST',  // TODO: move fetch options to model?
          data: JSON.stringify(this.app.filter.serialize())
        })
        .always(_(function() {  }).bind(this))
        .done(this.showChart)
        .fail(this.failLoading);
      }).bind(this))
      .fail(_(function() {
        this.app.report('Could not load translations', [
          'Refreshing the page may fix the issue.']);
      }).bind(this));

  },

  showChart: function() {
	  this.showNegativeAlert();
	  
    // TODO: why are we triggering twice on load???
    if (!this.model.hasData()) {
      this.message.html('No Data Available').attr('data-i18n','amp.dashboard:chart-no-data-available');
      app.translator.translateDOM($('.chart-container'));
      this.resetNumbers();
      return;
    }    
    var chart = getChart(this.model.get('view'), this.model.get('processed'), this.getChartOptions(), this.model);
    this.chartContainer.html(chart.el);

    if (this.model.get('chartType') !== 'fragmentation') {
    	this.renderNumbers();
    	this.fixTitleWidth();
    }
    
    if (this.model.get('chartType') !== 'fragmentation') {
	    var limit = this.model.get('limit');
	    if (limit) {
	      this.$('.reset')[limit === this.model.defaults.limit ? 'hide' : 'show']();
	    }
    } else {
        if (this.model.get('showResetButton')) {
        	this.$('.reset').show();
        } else {
        	this.$('.reset').hide();
        }
    }
    this.message.stop().fadeOut(200);
    
    this.beautifyLegends(this);
    
    if (this.model.get('view') === 'heatmap') {
    	this.handleHeatmapClicks();
    }
        
    this.showChartPromise.resolve();
  },
  
  handleHeatmapClicks: function() {
	  var self = this;
	  var others = this.$(".legend-others");
	  if (others) {
		  $(others).on('click', function(evt) {
			  self.model.set('yLimit', self.model.get('yLimit') + self.model.get('originalYLimit'));
			  self.updateData();
		  });
	  }
  },
  
  showNegativeAlert: function() {
    if(this.model.get('view') === 'pie' && _.find(this.model.get('processed')[0].values, function(item) { return item.y < 0;})) {
      this.$('.negative-values-message').show();
    } else {
      this.$('.negative-values-message').hide();
    }
  },

  getChartOptions: function() {	  
    var co = _(_(this.chartOptions).clone() || {}).defaults({
      trimLabels: !this.model.get('big'),
      getTTContent: this.getTTContent,
      clickHandler: this.chartClickHandler,
      width: this.$('.panel-body').width(),
      height: this.$('.panel-body').height()
      
    });
    if(this.model.get('view') == 'multibar'){
  	  co.stacked = this.model.get('stacked');
  	}
    co.model = this.model;
    return co;
  },

  failLoading: function() {
    this.message.html('Failed to load data <small>' + arguments[2] +
      ' <button type="button" class="retry btn btn-warning btn-sm">' +
      '<span class="glyphicon glyphicon-refresh"></span> Retry</button></small>').show();
    console.error('failed loading chart :(', arguments);
  },

  renderNumbers: function() {
    if (this.model.get('total')) {
    	this.$('.chart-total').html(util.translateLanguage(this.model.get('sumarizedTotal'))); // this shall use the format from the server and translate it in the front end
    }
    var self = this;
   var currencyName = app.settingsWidget.definitions.findCurrencyById(self.model.get('currency')).value;    	
    this.$('.chart-currency').html(currencyName);
  },

  resetNumbers: function() {
    this.$('.chart-total').html('');
    this.$('.chart-currency').html('');
  },
  
  fixTitleWidth: function() {
	  var elementsSpace = 10;
	  var max_lines_on_title = 2;
	  var charsToRemove = 5;
	  var title = this.$(".chart-title h2");
	  var titleWidth = $(title).width();
	  var containerWidth = this.$(".panel-heading").width();
	  var amountWidth = this.$(".big-number").width();
	  if (containerWidth < titleWidth + amountWidth) {
		  $(title).css('width', (containerWidth - amountWidth - elementsSpace) + 'px');
		  while (this.calculateTextLines(title) > max_lines_on_title) {
			  $(title).html($(title).html().substring(0, $(title).html().length - charsToRemove) + '...');
			  $(title).attr('data-title', this.model.get('title'));
			  this.addSimpleTooltip(title);
		  }
	  }
  },
  
  calculateTextLines: function(object) {
	  var lineHeight = 24;
	  var lines = Math.floor($(object).height() / lineHeight);
	  return lines;
  },

  resetLimit: function() {
	  if (this.model.get('chartType') === 'fragmentation') {
		  this.model.set('yLimit', this.model.get('originalYLimit'));
		  this.updateData();
	  } else {
		  this.model.set('limit', this.model.defaults.limit);
	  }
  },

  changeAdjType: function(e) {
    var newType = e.currentTarget.value;
    this.model.set('adjtype', newType);
  },
  
  changeXAxis: function(e) {
	  var newType = e.currentTarget.value;
	  this.model.set('xAxisColumn', newType);
  },  

  changeChartView: function(e) {
    var view = util.data(e.currentTarget, 'view');
    this.model.set('view', view);
    this.hideExportInPublicView();
  },
  hideExportInPublicView: function(){
	  var editableDataExportSetting = this.app.generalSettings.get('hide-editable-export-formats-public-view');
	  if(this.model.get('view') === 'table' && editableDataExportSetting == true && this.app.user.get('logged') == false ){
		  this.$el.find('.download').hide();
	  }else{
		  this.$el.find('.download').show();
	  }  
  },  
  big: function() {
    // toggle big/small charts on large screens
    this.model.set('big', !this.model.get('big'));
  },
  setClear: function(shouldBreak) {
    // layout hints, should only be called by ./charts.js
    this.$el[shouldBreak ? 'addClass' : 'removeClass']('clearfix');
  },

  download: function() {     
	var chartOptions = _(this.getChartOptions()).omit('height', 'width');	
    var downloadView = new DownloadView({
      app: this.app,
      model: this.model,
      chartOptions: chartOptions
    });
    var specialClass = 'dash-download-modal';
    this.app.modal('Download chart', {
      bodyEl: downloadView.render().el,
      specialClass: specialClass,
      i18nTitle: 'amp.dashboard:download-download-chart'
    });
    
    // Translate modal popup.	
   	app.translator.translateDOM($("." + specialClass));
  },
  
  heatmapSwitchAxis: function () {
	  if (this.model.get('swapAxes') === true) {
		  this.model.set('swapAxes', false);
	  } else {
		  this.model.set('swapAxes', true);
	  }  
	  this.updateData();
  },

  //AMP-18630: Here we setup a simple tooltip for each legend element.
  beautifyLegends : function(self) {	  
	  var hasValues = false;
	  var hasProcessed = false;
	  if(self.model !== undefined && self.model.get('values') !== undefined && self.model.get('values').length > 0) {
		  hasValues = true;
	  }
	  if(self.model !== undefined && self.model.get('processed') !== undefined && self.model.get('processed').length > 1) {
		  hasProcessed = true;
	  }
	  
	  // Iterate the list of legend elements in DOM (only for this chart) and set a data element called 'data-title' that
	  // will be then used when a hover event is fired.
	  $(this.$el).find(".nv-series").each(function(i, elem) {
		  // Heatmaps dont need a special reprocessing.
		  if (self.model.get('view') !== 'heatmap') {
			  if(hasValues && !hasProcessed) {
				  // Top charts.
				  if(self.model.get('values')[i] !== undefined) {
					  $(elem).data('data-title', self.model.get('values')[i].name);
				  } else {
					// This the last legend "Others" (doesnt come in the data).
			    	$(elem).data('data-title', app.translator.translateSync("amp.dashboard:chart-FundingType-others", "Others"));
				  }
			  } else if(hasProcessed) {
				  // Aid Predictability charts and Funding Type charts.
				  if(self.model.get('processed')[i] !== undefined) {
					  // The extra check is for FT charts that have more legends (grouped, stacked, etc).
					  $(elem).data('data-title', self.model.get('processed')[i].key);
				  }
			  }
		  }
	    
		  // Now bind NV tooltip mechanism to hover event for each legend.
		  self.addSimpleTooltip(elem);
	  });
  },
  
  addSimpleTooltip: function(object) {
	  if ($(object).data('data-title') || $(object).data('title')) {
		  $(object).hover(function() {
			  var title = $(object).data('data-title') ? $(object).data('data-title') : $(object).data('title');
			  var offset = $(object).offset();
	    	  nv.tooltip.show([offset.left, offset.top], "<div class='panel panel-primary panel-popover'><div class='panel-heading'>" + title + "</div></div>");
		  }, function() {
			  nv.tooltip.cleanup();
		  });
	  }
  },
  extractNumberFormatSettings: function(settings) {
		  var numberFormat = {}; 
	      numberFormat.numberFormat = this.app.generalSettings.get('number-format') || '#,#.#';

		  // If the format pattern doesnt have thousands grouping then ignore 'number-group-separator' param or it will 
		  // be used by JS to group by thousands (ie: in the 'Others' columns).
		  if(numberFormat.numberFormat.indexOf(',') !== -1) {			  		  
			  numberFormat.groupSeparator = this.app.generalSettings.get('number-group-separator') || ',';
		  } else {
			  numberFormat.groupSeparator = '';
		  }
		  			  
		  numberFormat.decimalSeparator = this.app.generalSettings.get('number-decimal-separator') || '.';
		  this.app.generalSettings.numberFormatSettings = numberFormat;		
		  
		  this.app.generalSettings.numberDivider = this.app.generalSettings.get('number-divider');		  
		  if (this.app.generalSettings.numberDivider === 1) {
			  this.app.generalSettings.numberDividerDescription = 'amp.dashboard:chart-tops-inunits';
		  } else if(this.app.generalSettings.numberDivider === 1000) {
			  this.app.generalSettings.numberDividerDescription = 'amp.dashboard:chart-tops-inthousands';
		  } else if(this.app.generalSettings.numberDivider === 1000000) {
			  this.app.generalSettings.numberDividerDescription = 'amp.dashboard:chart-tops-inmillions';
		  }else if(this.app.generalSettings.numberDivider === 1000000000) {
			  this.app.generalSettings.numberDividerDescription = 'amp.dashboard:chart-tops-inbillions';
		  }
	  }

});

},{"../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../charts/chart":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/chart.js","./download":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/download.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/charts.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');

var Tops = require('../models/chart-tops');
var Predictability = require('../models/chart-aid-predictability');
var FundingType = require('../models/chart-funding-type');
var HeatMapChart = require('../models/chart-heatmaps');

var TopsChartView = require('./chart-tops');
var HeatMapChartView = require('./chart-heatmaps');
var PredictabilityChartView = require('./chart-aid-predictability');
var FundingTypeChartView = require('./chart-funding-type');


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;
    this.chartViews = this.collection.map(function(chart) {
      var ChartView = chart instanceof Tops ? TopsChartView
                    : chart instanceof Predictability ? PredictabilityChartView
                    : chart instanceof FundingType ? FundingTypeChartView
                    : chart instanceof HeatMapChart ? HeatMapChartView
                    : null;
      return new ChartView({ model: chart, app: this.app });
    }, this);
    this.listenToOnce(this.app.filter, 'apply', this.applyFilter);
    this.listenTo(this.collection, 'change:big', this.injectBreaks);
    this.listenTo(this.collection, 'change:bigN', this.redrawContainer);
  },

  render: function() {
    this.$el.html(_(this.chartViews).map(function(view) {
      return view.render().el;
    }));
    this.injectBreaks();
    return this;
  },

  injectBreaks: function(chartModel) {
    _(this.chartViews).reduce(function(breakAfter, thisView) {
      thisView.setClear(breakAfter);
      if (!breakAfter) {
        return thisView.model.get('big') ? false : true;
      } else {
        return false;
      }
    }, false);

    if (chartModel) {
      var chartView = _(this.chartViews).find(function(v) {
        return v.model === chartModel;
      });
      if (chartView) { chartView.render(); }
    }
  },
  
  redrawContainer: function(chartModel) {
	  if (chartModel) {
		  var chartView = _(this.chartViews).find(function(v) {
			  return v.model === chartModel;
	      });
	      if (chartView) { 
	    	  chartView.render(); 
	      }
	  } 
  }

});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../models/chart-aid-predictability":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-aid-predictability.js","../models/chart-funding-type":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-funding-type.js","../models/chart-heatmaps":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-heatmaps.js","../models/chart-tops":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-tops.js","./chart-aid-predictability":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-aid-predictability.js","./chart-funding-type":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-funding-type.js","./chart-heatmaps":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-heatmaps.js","./chart-tops":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/controls.js":[function(require,module,exports){
var BackboneDash = require('../backbone-dash');
var Filters = require('./filters');
var Settings = require('./settings');
var Share = require('./share');


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;    
    this.settings = new Settings({ app: this.app });
    this.filters = new Filters({ app: this.app });
    this.share = new Share({ app: this.app });
  },

  render: function() {
    this.$el.html([
      this.filters.render().el,
      this.settings.render().el,
      this.share.render().el
    ]);
    return this;
  }

});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./filters":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/filters.js","./settings":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/settings.js","./share":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/share.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/download.js":[function(require,module,exports){
var _ = require('underscore');
var baby = require('babyparse');
var canvg = require('../../ugly/lib-load-hacks').canvg;
var util = require('../../ugly/util');


var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var getChart = require('../charts/chart');
var util = require('../../ugly/util');
var template = _.template("<h4 data-i18n=\"amp.dashboard:download-preview\">Preview:</h4>\n\n<!-- This 'modal' div fixes AMP-19525: In FF when the chart is drawn (for less than a second) in 'svg-wrap', sometimes the mouse cursor is over one of the bars and triggers the tooltip,\nthat process is not fully performed thus resulting in incomplete html which is rejected by the browser :(  -->\n<div class=\"modal-preview-area\">\n</div>\n<div class=\"preview-area\">\n\t<div class=\"svg-wrap hidden\">\n  \t</div>\n  \t<div class=\"canvas-wrap hidden\">\n  \t</div>\n  \t<div class=\"table-wrap hidden\">\n  \t</div>\n</div>\n\n<div class=\"text-center\">\n  <a class=\"btn btn-success download-chart disabled\">\n    <span class=\"glyphicon glyphicon-download\"></span>\n    <span data-i18n=\"amp.dashboard:download-rendering\" class=\"word\">Rendering...</span>\n  </a>\n</div>\n");

var previousXLimit = null;
var previousYLimit = null;

module.exports = BackboneDash.View.extend({

  initialize: function(options) {
	var self = this;
    this.app = options.app;
    var valuesLength = this.model.get('values') ? this.model.get('values').length : 0;
    var height = util.calculateChartHeight(valuesLength, true);
    this.dashChartOptions = _({}).extend(options.chartOptions, {
      height: height, //450,  // sync with css!!!
      width: $('.container').width(),	// sync with css!!!
      trimLabels: false,
      nvControls: false      
    });
    
    // Heatmaps export need to show all data at once so we force the x/y limits and re-render the chart.
    if (this.model.get('chartType') === 'fragmentation') {
	    previousXLimit = this.model.get('xLimit');
	    previousYLimit = this.model.get('yLimit');
	    this.model.set('yLimit', -1);
	    this.model.set('xLimit', -1);
	    this.model.set('showFullLegends', true);
	    var chart = _.find(this.app.view.charts.chartViews, function(item) {return item.model.get('name') === self.model.get('name')});
	    chart.render();
    }
  },

  render: function() {
	var self = this;
    this.$el.html(template());   
    this.chart = _.find(self.app.view.charts.chartViews, function(item) {return item.model.get('name') === self.model.get('name')});
    
	// Here we will define an interval that will check periodically if the bootstrap modal is fully rendered.
	// In that moment the interval is finished and the chart is rendered.
	var rendered = false; // This flag is used to avoid triggering the render process twice in case the browser mess up the interval.	    	
	var interval = window.setInterval(function() {
		if ($('.dash-download-modal').closest('.in').length > 0) {
			window.clearInterval(interval);
			// Wait for the chart in the dashboard page to be fully rendered, this has impact only on heatmap charts, on the rest is transparent.
			$.when(self.chart.renderedPromise, self.chart.showChartPromise).done(function() {
	    		if (self.model.get('chartType') === 'fragmentation') {
	    			// We add an event for heatmaps to re-draw the original chart.
	    		    $('.dash-download-modal').closest('.in').on('hide.bs.modal', function() {
	    		    	self.model.set('yLimit', previousYLimit);
	    		    	self.model.set('xLimit', previousXLimit);
	    		    	self.model.set('showFullLegends', false);
						self.chart.render();
	    		    });
	    		}
			    if (self.model.get('view') === 'table') {
			    	self.renderCSV(self.$('.preview-area .table-wrap').removeClass('hidden'));
			    } else {
			        nv.tooltip.cleanup();
			        if (rendered === false) {
			        	rendered = true;
			        	self.renderChart(self.$('.preview-area .svg-wrap').removeClass('hidden'),
			        		self.$('.preview-area .canvas-wrap'), self.chart);
			        }
			    }
			});
		}
    }, 100);
    
    return this;
  },

  renderChart: function(svgContainer, canvasContainer, chart) {
	var self = this;
    if (_(this.app.browserIssues).findWhere({feature: 'canvas'})) {
      this.app.viewFail(this, 'Chart export requires a modern web browser');
    }
    
    if (self.model.get('chartType') === 'fragmentation') {
    	var svg = $($($(chart)[0].el).find("svg"))[0].getBBox();
	    this.dashChartOptions.height = svg.height + 100;
	    this.dashChartOptions.width = svg.width + 80;
    }
        
    var view = this.model.get('view'),
        data = this.model.get('processed'),
        canvas = document.createElement('canvas'),
        chartEl = getChart(view, data,
          _({}).extend(this.dashChartOptions, { height: this.dashChartOptions.height - 42 })).el;

    svgContainer.html(chartEl);

    this.prepareCanvas(canvas, this.dashChartOptions.height, this.dashChartOptions.width);

    this.chartToCanvas(chartEl, canvas, function() {
      svgContainer.hide();
      var img = new Image();
      img.src = canvas.toDataURL('image/png');
      canvasContainer.html(img);
      $(canvasContainer).removeClass('hidden');
      $('.modal-preview-area').remove();
      this.makeDownloadable(img.src, 'chart', '.png');
    });
    
    // Scale the modal correctly for heatmaps.
    if (self.model.get('chartType') === 'fragmentation') {
    	var modal = $('.dash-download-modal').closest('.in').find('.dash-download-modal');
    	if ($(svgContainer).width() > $(modal).width()) {
    		$(modal).find('.preview-area').css('max-width','90%');
        	$(modal).closest('.in').find('.preview-area').css('overflow','auto');
    	}
    	if ($(svgContainer).height() > $(window).height()) {
    		$(modal).find('.preview-area').css('max-height', ($(window).height() - 270) + 'px');
        	$(modal).closest('.in').find('.preview-area').css('overflow','auto');
    	}
    }
  },

  prepareCanvas: function(canvas, h, w) {
	var self = this;
	var currency = app.settingsWidget.definitions.findCurrencyById(self.model.get('currency'));
    var currencyName = currency !== undefined ? currency.value : '';
    var ctx = canvas.getContext('2d'),
    	moneyContext = (this.model.get('sumarizedTotal') !== undefined ? ': ' + util.translateLanguage(this.model.get('sumarizedTotal')) + ' ': ' ') + currencyName,
        adjType = this.model.get('adjtype');    
    if (adjType) {
        var trnAdjType = this.chart.$el.find('.ftype-options option:selected').text();
        moneyContext = trnAdjType + moneyContext;
    }

    // size the canvas
    canvas.setAttribute('width', w);
    canvas.setAttribute('height', h);

    // make the background opaque white
    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = '#fff';
    ctx.fill();

    // Add the chart title
    ctx.fillStyle = '#163f66';
    ctx.font = 'bold 22px "Open Sans"';
    ctx.fillText(this.model.get('title').toUpperCase(), 10, 10 + 22);
    // what money are we talking about?
    ctx.fillStyle = '#333';
    if (self.model.get('chartType') === 'fragmentation') {
    	ctx.font = 'normal 14px "Open Sans"';
    	ctx.textAlign = 'left';
    	ctx.fillText(trnAdjType, 10, 50);	    
    } else {    
    	ctx.textAlign = 'right';
	    ctx.fillText(moneyContext, w - 10, 10 + 22);
	    ctx.textAlign = 'left';  // reset it
    }    
    // reset font to something normal (nvd3 uses css ugh...)
    ctx.font = 'normal 12px "sans-serif"';
    
    $('.modal.in .modal-dialog').width(w + 60);
  },

  chartToCanvas: function(svg, canvas, cb) {
	var self = this;
	
	if (this.model.get('chartType') === 'fragmentation') {
		// This is what applies the necessary styles to the chart´s SVG.
		var css = "rect.bordered {stroke: #E6E6E6;stroke-width: 2px;} text.mono {font-size: 9pt;font-family: Arial;fill: #000;}";
	    var s = document.createElement('style');
	    s.setAttribute('type', 'text/css');
	    s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
	    svg.getElementsByTagName("defs")[0].appendChild(s);
	}
	
    var boundCB = _(cb).bind(this);
    window.setTimeout(function() {
      this.app.tryTo(function() {
        canvg(canvas, svg.parentNode.innerHTML, { // note: svg.outerHTML breaks IE
          offsetY: ((self.model.get('chartType') !== 'fragmentation') ? 42 : 65),
          ignoreDimensions: true,
          ignoreClear: true,
          ignoreMouse: true,
          renderCallback: boundCB
        });
      }, this);
    }.bind(this), 1500);  // we have to wait for stupid nvd3...
  },

  renderCSV: function(csvContainer) {
	var self = this;
	var currencyName = app.settingsWidget.definitions.findCurrencyById(self.model.get('currency')).value;
    var data = this.model.get('processed'),
        currency = currencyName,
        adjtype = this.model.get('adjtype') || false,
        csvTransformed,
        headerRow,
        textContent,
        preview;

    var self = this;
    var keys = _(data).pluck('key');
    
    if (self.model.get('chartType') !== 'fragmentation') {
	    // table of all the data
	    csvTransformed = _(data)
	      .chain()
	      .pluck('values')
	      .transpose()
	      .map(function(row) {
	        return _(row).reduce(function(csvRow, cell) {
	          csvRow.push(cell.y);
	          return csvRow;
	        }, [row[0].x]);
	      })
	      .map(function(row) {
	        row.push(currency || '');
	        if (adjtype) {
				var trnAdjType = self.chart.$el.find('.ftype-options option:selected').text();
	            row.push(trnAdjType);
	        }
	        return row;
	      })
	      .value();
    } else {
        csvTransformed = _.map(self.model.get("matrix"), function(itemY, i) {
			return _.map(itemY, function(itemX, j) {
				return [self.model.get("yDataSet")[i],
					self.model.get("xDataSet")[j],
					self.model.get("matrix")[i][j] ? self.model.get("matrix")[i][j].dv : '',
					self.model.get("matrix")[i][j] ? self.model.get("matrix")[i][j].p : ''
				]
			})
		});
	    csvTransformed = [].concat.apply([], csvTransformed);
	    csvTransformed = _.each(csvTransformed, function(item) { 
	        item.push(currency);
	        if (adjtype) {
				var trnAdjType = self.chart.$el.find('.ftype-options option:selected').text();
	            item.push(trnAdjType);
	        }	        
	    });
    }

    // prepend a header row
    headerRow = [];
    var amountTrn = this.app.translator.translateSync('amp.dashboard:download-amount', 'Amount');
    var currencyTrn = this.app.translator.translateSync('amp.dashboard:currency', 'Currency');
    var percentageTrn = this.app.translator.translateSync('amp.dashboard:percentage', 'Percentage');
    var typeTrn = this.app.translator.translateSync('amp.dashboard:type', 'Type');
    var yearTrn = this.app.translator.translateSync('amp.dashboard:year', 'Year');

	if (this.model.url.indexOf('/tops') > -1) {
	    headerRow.push(this.model.get('title'));
	    headerRow.push(amountTrn);
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	} else if (this.model.url.indexOf('/aid-predictability') > -1) {
	    headerRow.push(yearTrn);
	    _.each(keys, function(item) {
	    	headerRow.push(item);
	    });
	    headerRow.push(currencyTrn);
	} else if (this.model.url.indexOf('/ftype') > -1) {
		headerRow.push(yearTrn);
	    _.each(keys, function(item) {
	    	headerRow.push(item);
	    });
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	} else if (this.model.get('chartType') === 'fragmentation') {
		// For AMP-23582: we dont want the name from "summary" because thats the origName and not always the same name than the X axis combo selector. 
		var firstColumnName = _.find(self.model.get('heatmap_config').models[0].get('columns'), function(item) {
			return item.origName === self.model.get('summary')[0];
		}).name; 
		var secondColumnName = _.find(self.model.get('heatmap_config').models[0].get('columns'), function(item) {
			return item.origName === self.model.get('summary')[1];
		}).name;
		headerRow.push(firstColumnName);
		headerRow.push(secondColumnName);
	    headerRow.push(amountTrn);
	    headerRow.push(percentageTrn);
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	}

    csvTransformed.unshift(headerRow);
    /* Add sep=, for automatic Excel support at the very top of the file works but breaks BOM unicode.
     * Let us use tab-delimited instead.
     *  This website shows a csv with Tab-delimited, utf16le with a BOM has best Excel support (via StackOverflow):
     *  http://wiki.scn.sap.com/wiki/display/ABAP/CSV+tests+of+encoding+and+column+separator
     */

    textContent = baby.unparse(csvTransformed, {
      delimiter: ';',
      encoding: 'utf-16',
    	quotes: true
    });

    preview = document.createElement('textarea');
    preview.setAttribute('class', 'csv-preview');
    preview.value = textContent;
    csvContainer.html(preview);

    if (!this.app.hasIssue('download')) {
      textContent = util.textAsDataURL(textContent);
    }

    window.setTimeout(_(function() {  // stupid bootstrap modals...
      // this setTimeout is needed for the flash fallback :(
      this.makeDownloadable(textContent, 'data', '.csv');
    }).bind(this), 100);
  },

  makeDownloadable: function(stuff, what, ext) {
	var messageKey = ['amp.dashboard:chart-', this.model.get('name').replace(/ /g, '')].join('')
	var translatedName = app.translator.translateSync(messageKey, this.model.get('name'));
    var fileName = translatedName + ext,
        dlButton = this.$('.download-chart').removeClass('disabled');
    dlButton.find('.word').text('Download ' + what).attr('data-i18n', 'amp.dashboard:download-download-' + what);
    app.translator.translateDOM(dlButton);

    if (this.app.hasIssue('download')) {
      if (this.app.hasIssue('flash')) {
        this.app.report('Your browser is missing features to initiate the download', [
          'You might be able to save this chart manually by right-clicking the ' +
          'preview and selecting "Save Picture As...']);
      } else {
        // bad browser, but has flash! fallback to downloadify
        this.app.tryTo(function() {
          window.Downloadify.create(dlButton[0], {
            swf: '/TEMPLATE/ampTemplate/commonMedia/downloadify.swf',
            downloadImage: '/TEMPLATE/ampTemplate/commonMedia/download-button-states.png?rev=4',
            transparent: true,
            width: 176,
            height: 34,
            filename: fileName,
            data: stuff
              .replace('data:text/plain;base64,//', '')
              .replace('data:image/png;base64,', ''),
            dataType: ext === '.csv' ? 'string' : 'base64',
            append: true,
            onError: function() {
              this.app.report('Could not download the file.');
            }
          });
        }, this);
      }
    } else {
      this.$('.download-chart')
        .attr('href', stuff)
        .attr('download', fileName);
    }

    // AMP-19813
    if (ext.indexOf('csv') !== -1) {
    	$('.modal-preview-area').remove();
    }
  }

});

},{"../../ugly/lib-load-hacks":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-load-hacks.js","../../ugly/util":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../charts/chart":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/chart.js","babyparse":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/node_modules/babyparse/babyparse.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/fail.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"container\">\n  <header class=\"spaced text-center\">\n    <h2>\n      The application encountered an\n      <span class=\"text-danger\">error</span>\n      <small>:(</small>\n    </h2>\n    <p><%= err %></p>\n  </header>\n</div>\n");


module.exports = BackboneDash.View.extend({

  initialize: function(options) {
    this.app = options.app;
    this.err = options.err;
  },

  render: function() {
    this.$el.html(template({ err: this.err }));
    return this;
  }

});


},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/filters.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"col-xs-12 col-md-5\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right show-filters\">\n        <span class=\"glyphicon glyphicon-edit\"></span>\n        <span data-i18n=\"amp.dashboard:filters-edit\">Edit filters</span>\n      </button>\n      <h3 class=\"inline-heading\" data-i18n=\"amp.common:title-filters\">Filters</h3>\n      <div class=\"applied-filters\">\n        <em data-i18n=\"amp.common:filters-loading\">Loading...</em>\n      </div>\n    </div>\n  </div>\n</div>\n<div id=\"filter-popup\"></div>\n");
var summaryTemplate = _.template("<% if (!countApplied) { %>\n  <em data-i18n=\"amp.dashboard:filters-none-applied\">No filters applied</em>\n<% } else { %>\n  <span>\n    <button class=\"btn btn-default btn-sm show-filter-details\">\n      <span class=\"glyphicon glyphicon-eye-open\"></span>\n      <span data-i18n=\"amp.dashboard:filters-show-settings\">Show filter settings</span>\n      (<b><%= countApplied %></b>)\n    </button>\n  </span>\n<% } %>\n");
var detailsTemplate = _.template("<div>\n  <h4 class=\"inline-heading\" data-i18n=\"amp.dashboard:filters-active\">Active Filters</h4>\n  <button type=\"button\" class=\"btn btn-sm btn-default hide-filter-details\">\n    <span class=\"glyphicon glyphicon-eye-close\"></span>\n    <span data-i18n=\"amp.dashboard:filters-hide-details\">Hide filter details</span>\n  </button>\n</div>\n<% _(applied).each(function(filter) { %>\n  <h5>\n    <a href=\"#filter-detail-<%= filter.id %>\" data-toggle=\"collapse\" aria-expanded=\"false\"><%= filter.name %></a>\n    (<%= filter.detail.length %>)\n  </h5>\n  <ul id=\"filter-detail-<%= filter.id %>\" class=\"collapse\">\n    <% _(filter.detail).each(function(detail) { %>\n      <li><%= detail %></li>\n    <% }) %>\n  </ul>\n<% }) %>");
var filtersViewLog = require('../../../../../../../reamp/tools/log')('amp:dashboards:filters:view');


module.exports = BackboneDash.View.extend({

  events: {
    'click .show-filters': 'showFilter',
    'click .show-filter-details': 'showFilterDetails',
    'click .hide-filter-details': 'hideFilterDetails'
  },

  initialize: function(options) {
	var self = this;
    this.finishedFirstLoad = false;
    this.app = options.app;
    this.listenTo(this.app.filter, 'cancel', this.hideFilter);
    this.listenTo(this.app.filter, 'apply', this.applyFilter);
    this.app.generalSettings.load().done(_(function() {     
      this.app.filter.loaded.done(_(function() {        
        this.app.state.register(this, 'filters', {
            get: _(function() {
             return this.app.filter.serialize();            
          }).bind(this),
          set: _(function(state) {        	
            if (_.isEmpty(state)){            
            	self.app.filter.extractDates(self.app.generalSettings, state, 'dashboard-default-min-date', 'dashboard-default-max-date');
            }
            this.app.filter.deserialize(state);
            this.app.filter.finishedFirstLoad = true;
          }).bind(this),
          empty: {}
        });
      }).bind(this));
    }).bind(this));
  },
  render: function() {
    this.$el.html(template());
    this.app.filter.setElement(this.el.querySelector('#filter-popup'));
    this.hideFilter();
    this.app.filter.loaded
      .done(_(this.renderApplied).bind(this))
      .fail(_(function() {
        this.$('.applied-filters').html('<strong class="text-danger filters-err">' +
          'Failed to load filters</strong> <a href="" class="btn btn-warning btn-sm">' +
          '<span class="glyphicon glyphicon-refresh"></span> Refresh page</a>');
        this.$('button').addClass('disabled');
      }).bind(this));
    return this;
  },

  renderApplied: function() {	  
    var filterObject = this.app.filter.serializeToModels();
    var countApplied = _(filterObject.filters).keys().length;
    this.$('.applied-filters').html(summaryTemplate({ countApplied: countApplied }));
    this.app.translator.translateDOM(this.el);
  },

  showFilter: function() {
    this.app.filter.showFilters();
    this.$('#filter-popup').show();
  },

  hideFilter: function() {
    this.$('#filter-popup').hide();
  },

  applyFilter: function() {
    // todo: actually do an effect for changed filters...
    this.hideFilter();
    this.renderApplied();
  },

  showFilterDetails: function() {
	var self = this;
    var filterObject = this.app.filter.serializeToModels(); 
    var applied = _(filterObject.filters).map(function(filter, key) {
      var filterField = filterObject.filters[key];
      if(filterField.modelType === 'YEAR-SINGLE-VALUE' || filterField.modelType === 'DATE-RANGE-VALUES'){
    	  return self.getAppliedDateObject(filterObject,key);
      } else {
    	  return {
    	        name: filter.filterName || key,
    	        id: key.replace(/[^\w]/g, ''), // remove anything non-alphanum
    	        detail: _(filter).map(function(value) {
    	          if (value.attributes !== undefined) {
    	            return value.get('name');
    	          } else {
    	            // To fix problem with dates.
    	            if (value !== key && value !== filter.filterName) {
    	              return value;
    	            }
    	          }
    	        })
    	      };  
      }
      
    });
    
    this.$('.applied-filters').html(detailsTemplate({ applied: applied }));
    this.app.translator.translateDOM(this.el);
  },
  getAppliedDateObject: function(filterObject, filterKey){
	  var filterField = filterObject.filters[filterKey];
	  var dateRangeText = '';
	  if(filterKey === 'date') {
		  dateRangeText = app.translator.translateSync("amp.dashboard:date-range", "Date Range");
	  } else if(filterKey === 'computed-year') {
		  dateRangeText = app.translator.translateSync("amp.dashboard:computedYear", "Computed Year");
	  } else {
		  dateRangeText = app.translator.translateSync("amp.dashboard:" + filterKey.replace(/[^\w]/g, '-'), filterKey);
	  }
	  var detail = filterField.modelType === 'YEAR-SINGLE-VALUE'? filterField.year: this.app.filter.formatDate(filterField.start) + '&mdash;' + this.app.filter.formatDate(filterField.end)
	  return {
		  id: filterKey.replace(/[^\w]/g, '-'),
		  name: dateRangeText,
		  detail: [detail]
		};	  
  },
  hideFilterDetails: function() {
    this.renderApplied();
  }
});

},{"../../../../../../../reamp/tools/log":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/reamp/tools/log/index.js","../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/main.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');

var StateLoadError = require('amp-state/index').StateLoadError;

var Controls = require('./controls');
var ChartsView = require('./charts');
var Charts = require('../models/charts-collection');
var boilerplate = require('amp-boilerplate');
var HeatMapChart = require('../models/chart-heatmaps');
var TopsChart = require('../models/chart-tops');
var PredictabilityChart = require('../models/chart-aid-predictability');
var FundingTypeChart = require('../models/chart-funding-type');

var template = _.template("<div class=\"container\">\n</div>\n");
var modalTemplate = _.template("<div class=\"modal fade\" id=\"<%= m.id %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog <%= m.specialClass %>\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\n        <h4 class=\"modal-title text-<%= m.tone %>\" data-i18n=\"<%= m.i18nTitle %>\"><%= m.title %></h4>\n      </div>\n      <div class=\"modal-body\">\n        <% if (m.content) { %>\n          <%= m.content %>\n        <% } %>\n        <% if (m.messages) { %>\n          <% _(m.messages).each(function(message) { %>\n            <p><%= message %></p>\n          <% }) %>\n        <% } %>\n      </div>      \n    </div>\n  </div>\n</div>\n");

var EnabledChartsCollection = require('../models/enabled-charts-collection');
var HeatmapsConfigCollection = require('../models/heatmaps-config-collection');

module.exports = BackboneDash.View.extend({

  initialize: function(options) {
    this.app = options.app;
        
                                   // but we already do other fetches on init so...
    this.app.user.fetch();
    this.controls = new Controls({ app: this.app });

    // AMP-19545: We instantiate the collection of enabled charts (from FM) and use it to enable or not each chart.
    var enabledChartsFM = new EnabledChartsCollection();
    enabledChartsFM.fetchData();
    
    // Get config of all heatmaps from backend.
    var heatmapsConfigs = new HeatmapsConfigCollection();
    heatmapsConfigs.fetchData();
    
    if(enabledChartsFM.models[0].get('error') !== undefined) {
        // The same endpoint will send an error if 'DASHBOARDS' is not active in the Feature Manager.
        window.location = '/';
    }
    
    var col = [];
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Donors'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Donor Agencies', big: false, view: 'bar' },
  	          { app: this.app, url: '/rest/dashboard/tops/do' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Donor Group'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Donor Groups', big: false, view: 'bar' },
  	          { app: this.app, url: '/rest/dashboard/tops/dg' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Regions'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Regions', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/re' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Sectors'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Sectors', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ps' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Aid Predictability'})) {
    	col.push(new PredictabilityChart(
  	          { name: 'Aid Predictability' },
	          { app: this.app, url: '/rest/dashboard/aid-predictability' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Funding Type'})) {
    	col.push(new FundingTypeChart(
  	          { name: 'Funding Type' },
	          { app: this.app, url: '/rest/dashboard/ftype' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Responsible Organizations'})) {
    	col.push(new TopsChart(
  	          { name: 'Responsible Organizations', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ro' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Beneficiary Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Beneficiary Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ba' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Executing Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Executing Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ea' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Implementing Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Implementing Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ia' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Peace-building and State-building Goals'})) {
    	col.push(new TopsChart(
    			{ name: 'Peace-building and State-building Goals', big: true, showCategoriesInfo: true, view: 'pie' },
    			{ app: this.app, url: '/rest/dashboard/tops/ndd' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Sector Fragmentation'})) {
    	col.push(new HeatMapChart(
  	          { name: 'HeatMap by Sector and Donor Group', title: 'Sector Fragmentation', big: true, view: 'heatmap', heatmap_config: heatmapsConfigs, heatmap_type: 'sector' },
  	          { app: this.app, url: '/rest/dashboard/heat-map/sec' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Location Fragmentation'})) {
    	col.push(new HeatMapChart(
  	          { name: 'HeatMap by Location and Donor Group', title: 'Location Fragmentation', big: true, view: 'heatmap', heatmap_config: heatmapsConfigs, heatmap_type: 'location' },
  	          { app: this.app, url: '/rest/dashboard/heat-map/loc' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Program Fragmentation'})) {
    	col.push(new HeatMapChart(
  	          { name: 'HeatMap by Program and Donor Group', title: 'Program Fragmentation', big: true, view: 'heatmap', heatmap_config: heatmapsConfigs, heatmap_type: 'program' },
  	          { app: this.app, url: '/rest/dashboard/heat-map/prg' }));
    }
       
    var chartsCollection = new Charts(col, { app: this.app });
    this.charts = new ChartsView({
      app: this.app,
      collection: chartsCollection
    });
    
    //auto-renders the layout
    this.headerWidget = new boilerplate.layout(
      {
        caller: 'DASHBOARD'
	  });
  },

  render: function() {
    this.$el.html(template());
    this.$('.container').html([
      this.controls.render().el,
      this.charts.render().el,
    ]);
    return this;
  },

  modal: function(title, options) {
    options = _({
      title: title,
      id: _.uniqueId('modal')
    }).extend(options);
    this.$el.parent().append(modalTemplate({m: options}));
    var thisModal = this.$el.parent().find('#' + options.id);
    if (options.bodyEl) { thisModal.find('.modal-body').html(options.bodyEl); }
    thisModal.modal();
    return thisModal[0];  // the actual DOM element
  }

});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../models/chart-aid-predictability":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-aid-predictability.js","../models/chart-funding-type":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-funding-type.js","../models/chart-heatmaps":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-heatmaps.js","../models/chart-tops":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-tops.js","../models/charts-collection":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/charts-collection.js","../models/enabled-charts-collection":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/enabled-charts-collection.js","../models/heatmaps-config-collection":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/heatmaps-config-collection.js","./charts":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/charts.js","./controls":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/controls.js","amp-boilerplate":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/index.js","amp-state/index":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-state/index.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/settings.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"col-xs-12 col-sm-6 col-md-3\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <h3 data-i18n=\"amp.dashboard:dashboard-settings\" class=\"inline-heading\" style=\"max-width: 50px;overflow-x: visible\">Settings</h3>\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right dash-settings-button\">\n        <span class=\"glyphicon glyphicon-edit\"></span>\n        <span data-i18n=\"amp.dashboard:settings-edit\">edit settings</span>\n      </button>\n    </div>\n  </div>\n</div>\n<div id=\"amp-settings\" style=\"display:none;\"></div>\n");
module.exports = BackboneDash.View.extend({
  events: {
    'click .dash-settings-button': 'editSettings'
  },
  initialize: function(options) {
    this.app = options.app;    
    this.app.settingsWidget.definitions.loaded.done(_(function() {
     this.app.state.register(this, 'settings', {
        get: this.app.settingsWidget.toAPIFormat,
        set: this.app.settingsWidget.restoreFromSaved
      });
    }).bind(this));
  },
  render: function() {
    this.$el.html(template()); 
    this.app.settingsWidget.setElement(this.el.querySelector('#amp-settings'));
    return this;
  },
  editSettings: function() {
	var self = this;
	this.app.settingsWidget.show();
	this.$('#amp-settings').show();
	this.app.settingsWidget.on('close', function() {
		self.$('#amp-settings').hide();
	});
	
	this.app.settingsWidget.on('applySettings', function() {
		self.$('#amp-settings').hide();
	});	
 }

});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/share.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"col-xs-12 col-sm-6 col-md-4\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <h3 data-i18n=\"amp.dashboard:share-dashboard-top\" class=\"inline-heading\">Share</h3>\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right dash-share-button\">\n        <span class=\"glyphicon glyphicon-link\"></span>\n        <span data-i18n=\"amp.dashboard:share-link\">link</span>\n      </button>\n    </div>\n  </div>\n</div>\n\n<div class=\"dash-share-modal modal fade\" id=\"<%= details.id %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog\">\n    <div class=\"panel panel-primary\">\n      <div class=\"panel-heading fix-title-height\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\n        <span data-i18n=\"amp.dashboard:share-dashboard\">Share this dashboard view</span>\n      </div>\n      <div class=\"panel-body\">\n        <form role=\"form\">\n          <label data-i18n=\"amp.dashboard:share-link\" for=\"dash-share-url\">Link</label>\n          <input type=\"url\" class=\"form-control\" id=\"dash-share-url\" />\n        </form>\n      </div>\n      <div class=\"panel-footer\">\n        <button type=\"button\" class=\"btn btn-primary\" data-i18n=\"amp.dashboard:close\" data-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .dash-share-button': 'share'
  },

  initialize: function(options) {
    this.app = options.app;
  },

  render: function() {
    this.$el.html(template({ details: {} }));
    return this;
  },

  share: function() {
    var saving = app.translator.translateSync("amp.dashboard:saving-state","Saving dashboard state, please wait...");
	  
    this.$('#dash-share-url')
      .attr('disabled', 'disabled')
      .val(saving);

    var stateBlob = this.app.state.freeze();

    this.listenToOnce(this.app.savedDashes, 'request', function(model, xhr) {
      // this has to be set up before .create, so we don't miss it
      xhr
        .done(_(function() {
          var id = model.get('id');
          this.app.url.hash(this.app.state.toHash(id), { silent: true });
          this.$('#dash-share-url')
            .removeAttr('disabled')
            .val(this.app.url.full());
        }).bind(this))
        .fail(_(function() {
          this.$('#dash-share-url').val('Error: could not save dashboard for sharing.');
        }).bind(this));
    });

    this.app.savedDashes.create({  // create does POST
      title: 'Dashboard',
      description: 'Saved dashboard',
      stateBlob: stateBlob
    }, { app: this.app });

    this.$('.dash-share-modal').modal();
  }

});

},{"../backbone-dash":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-load-hacks.js":[function(require,module,exports){
// nvd3 goes global sigh... make sure d3 is already global
/* TODO: in this version of nvd3 v1.7.1, main is not specified in package.json,
 if we ever upgrade to 1.8+, change this back to just require(nvd3) */
require('../../../node_modules/nvd3/build/nv.d3');

// load underscore mixins
require('./underscore-transpose');

// load canvg stuff
window.RGBColor = require('./lib-src/rgbcolor');
require('./lib-src/canvg');


module.exports = {
  canvg: window.canvg
};

},{"../../../node_modules/nvd3/build/nv.d3":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/node_modules/nvd3/build/nv.d3.js","./lib-src/canvg":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/canvg.js","./lib-src/rgbcolor":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/rgbcolor.js","./underscore-transpose":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/underscore-transpose.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/canvg.js":[function(require,module,exports){
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed 
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function(){
    // canvg(target, s)
    // empty parameters: replace all 'svg' elements on page with 'canvas' elements
    // target: canvas element or the id of a canvas element
    // s: svg string, url to svg file, or xml document
    // opts: optional hash of options
    //       ignoreMouse: true => ignore mouse events
    //       ignoreAnimation: true => ignore animations
    //       ignoreDimensions: true => does not try to resize canvas
    //       ignoreClear: true => does not clear canvas
    //       offsetX: int => draws at a x offset
    //       offsetY: int => draws at a y offset
    //       scaleWidth: int => scales horizontally to width
    //       scaleHeight: int => scales vertically to height
    //       renderCallback: function => will call the function after the first render is completed
    //       forceRedraw: function => will call the function on every frame, if it returns true, will redraw
    this.canvg = function (target, s, opts) {
        // no parameters
        if (target == null && s == null && opts == null) {
            var svgTags = document.querySelectorAll('svg');
            for (var i=0; i<svgTags.length; i++) {
                var svgTag = svgTags[i];
                var c = document.createElement('canvas');
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement('div');
                div.appendChild(svgTag);
                canvg(c, div.innerHTML);
            }
            return;
        }
    
        if (typeof target == 'string') {
            target = document.getElementById(target);
        }
        
        // store class on canvas
        if (target.svg != null) target.svg.stop();
        var svg = build(opts || {});
        // on i.e. 8 for flash canvas, we can't assign the property so check for it
        if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;
        
        var ctx = target.getContext('2d');
        if (typeof(s.documentElement) != 'undefined') {
            // load from xml doc
            svg.loadXmlDoc(ctx, s);
        }
        else if (s.substr(0,1) == '<') {
            // load from xml string
            svg.loadXml(ctx, s);
        }
        else {
            // load from url
            svg.load(ctx, s);
        }
    }

    function build(opts) {
        var svg = { opts: opts };
        
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;
        
        svg.log = function(msg) {};
        if (svg.opts['log'] == true && typeof(console) != 'undefined') {
            svg.log = function(msg) { console.log(msg); };
        };
        
        // globals
        svg.init = function(ctx) {
            var uniqueId = 0;
            svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId; };
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new (function () {
                this.viewPorts = [];
                this.Clear = function() { this.viewPorts = []; }
                this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
                this.RemoveCurrent = function() { this.viewPorts.pop(); }
                this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
                this.width = function() { return this.Current().width; }
                this.height = function() { return this.Current().height; }
                this.ComputeSize = function(d) {
                    if (d != null && typeof(d) == 'number') return d;
                    if (d == 'x') return this.width();
                    if (d == 'y') return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);            
                }
            });
        }
        svg.init();
        
        // images loaded
        svg.ImagesLoaded = function() { 
            for (var i=0; i<svg.Images.length; i++) {
                if (!svg.Images[i].loaded) return false;
            }
            return true;
        }

        // trim
        svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }
        
        // compress spaces
        svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }
        
        // ajax
        svg.ajax = function(url) {
            var AJAX;
            if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
            else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
            if(AJAX){
               AJAX.open('GET',url,false);
               AJAX.send(null);
               return AJAX.responseText;
            }
            return null;
        } 
        
        // parse xml
        svg.parseXml = function(xml) {
            if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
                var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
                var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
                settings.prohibitDtd = false;
                xmlDoc.loadXml(xml, settings);
                return xmlDoc;
            }
            else if (window.DOMParser)
            {
                var parser = new DOMParser();
                return parser.parseFromString(xml, 'text/xml');
            }
            else 
            {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                xmlDoc.async = 'false';
                xmlDoc.loadXML(xml); 
                return xmlDoc;
            }       
        }
        
        svg.Property = function(name, value) {
            this.name = name;
            this.value = value;
        }   
            svg.Property.prototype.getValue = function() {
                return this.value;
            }
        
            svg.Property.prototype.hasValue = function() {
                return (this.value != null && this.value !== '');
            }
                            
            // return the numerical value of the property
            svg.Property.prototype.numValue = function() {
                if (!this.hasValue()) return 0;
                
                var n = parseFloat(this.value);
                if ((this.value + '').match(/%$/)) {
                    n = n / 100.0;
                }
                return n;
            }
            
            svg.Property.prototype.valueOrDefault = function(def) {
                if (this.hasValue()) return this.value;
                return def;
            }
            
            svg.Property.prototype.numValueOrDefault = function(def) {
                if (this.hasValue()) return this.numValue();
                return def;
            }
            
            // color extensions
                // augment the current color value with the opacity
                svg.Property.prototype.addOpacity = function(opacityProp) {
                    var newValue = this.value;
                    if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
                        var color = new RGBColor(this.value);
                        if (color.ok) {
                            newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
                        }
                    }
                    return new svg.Property(this.name, newValue);
                }
            
            // definition extensions
                // get the definition from the definitions table
                svg.Property.prototype.getDefinition = function() {
                    var name = this.value.match(/#([^\)'"]+)/);
                    if (name) { name = name[1]; }
                    if (!name) { name = this.value; }
                    return svg.Definitions[name];
                }
                
                svg.Property.prototype.isUrlDefinition = function() {
                    return this.value.indexOf('url(') == 0
                }
                
                svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
                    var def = this.getDefinition();
                    
                    // gradient
                    if (def != null && def.createGradient) {
                        return def.createGradient(svg.ctx, e, opacityProp);
                    }
                    
                    // pattern
                    if (def != null && def.createPattern) {
                        if (def.getHrefAttribute().hasValue()) {
                            var pt = def.attribute('patternTransform');
                            def = def.getHrefAttribute().getDefinition();
                            if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
                        }
                        return def.createPattern(svg.ctx, e);
                    }
                    
                    return null;
                }
            
            // length extensions
                svg.Property.prototype.getDPI = function(viewPort) {
                    return 96.0; // TODO: compute?
                }
                
                svg.Property.prototype.getEM = function(viewPort) {
                    var em = 12;
                    
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);
                    
                    return em;
                }
                
                svg.Property.prototype.getUnits = function() {
                    var s = this.value+'';
                    return s.replace(/[0-9\.\-]/g,'');
                }
            
                // get the length as pixels
                svg.Property.prototype.toPixels = function(viewPort, processPercent) {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
                    if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
                    if (s.match(/px$/)) return this.numValue();
                    if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
                    if (s.match(/pc$/)) return this.numValue() * 15;
                    if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
                    if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
                    if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
                    if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
                    var n = this.numValue();
                    if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
                    return n;
                }

            // time extensions
                // get the time as milliseconds
                svg.Property.prototype.toMilliseconds = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/s$/)) return this.numValue() * 1000;
                    if (s.match(/ms$/)) return this.numValue();
                    return this.numValue();
                }
            
            // angle extensions
                // get the angle as radians
                svg.Property.prototype.toRadians = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
                    if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
                    if (s.match(/rad$/)) return this.numValue();
                    return this.numValue() * (Math.PI / 180.0);
                }
        
            // text extensions
                // get the text baseline
                var textBaselineMapping = {
                    'baseline': 'alphabetic',
                    'before-edge': 'top',
                    'text-before-edge': 'top',
                    'middle': 'middle',
                    'central': 'middle',
                    'after-edge': 'bottom',
                    'text-after-edge': 'bottom',
                    'ideographic': 'ideographic',
                    'alphabetic': 'alphabetic',
                    'hanging': 'hanging',
                    'mathematical': 'alphabetic'
                };
                svg.Property.prototype.toTextBaseline = function () {
                    if (!this.hasValue()) return null;
                    return textBaselineMapping[this.value];
                }
                
        // fonts
        svg.Font = new (function() {
            this.Styles = 'normal|italic|oblique|inherit';
            this.Variants = 'normal|small-caps|inherit';
            this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';
            
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return { 
                    fontFamily: fontFamily || f.fontFamily, 
                    fontSize: fontSize || f.fontSize, 
                    fontStyle: fontStyle || f.fontStyle, 
                    fontWeight: fontWeight || f.fontWeight, 
                    fontVariant: fontVariant || f.fontVariant,
                    toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') } 
                } 
            }
            
            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
                var ff = '';
                for (var i=0; i<d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
                    else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;  }
                    else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
                    else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
                    else { if (d[i] != 'inherit') ff += d[i]; }
                } if (ff != '') f.fontFamily = ff;
                return f;
            }
        });
        
        // points and paths
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i=0; i<a.length; i++) {
                a[i] = parseFloat(a[i]);
            }
            return a;
        }       
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y;
        }   
            svg.Point.prototype.angleTo = function(p) {
                return Math.atan2(p.y - this.y, p.x - this.x);
            }
            
            svg.Point.prototype.applyTransform = function(v) {
                var xp = this.x * v[0] + this.y * v[2] + v[4];
                var yp = this.x * v[1] + this.y * v[3] + v[5];
                this.x = xp;
                this.y = yp;
            }

        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1]);
        }
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i=0; i<a.length; i+=2) {
                path.push(new svg.Point(a[i], a[i+1]));
            }
            return path;
        }
        
        // bounding box
        svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            
            this.x = function() { return this.x1; }
            this.y = function() { return this.y1; }
            this.width = function() { return this.x2 - this.x1; }
            this.height = function() { return this.y2 - this.y1; }
            
            this.addPoint = function(x, y) {    
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x;
                    }
                    if (x < this.x1) this.x1 = x;
                    if (x > this.x2) this.x2 = x;
                }
            
                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y;
                    }
                    if (y < this.y1) this.y1 = y;
                    if (y > this.y2) this.y2 = y;
                }
            }           
            this.addX = function(x) { this.addPoint(x, null); }
            this.addY = function(y) { this.addPoint(null, y); }
            
            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2);
            }
            
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
                var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
            }
            
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                
                for (i=0; i<=1; i++) {
                    var f = function(t) { 
                        return Math.pow(1-t, 3) * p0[i]
                        + 3 * Math.pow(1-t, 2) * t * p1[i]
                        + 3 * (1-t) * Math.pow(t, 2) * p2[i]
                        + Math.pow(t, 3) * p3[i];
                    }
                    
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    
                    if (a == 0) {
                        if (b == 0) continue;
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0) this.addX(f(t));
                            if (i == 1) this.addY(f(t));
                        }
                        continue;
                    }
                    
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0) continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0) this.addX(f(t1));
                        if (i == 1) this.addY(f(t1));
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0) this.addX(f(t2));
                        if (i == 1) this.addY(f(t2));
                    }
                }
            }
            
            this.isPointInBox = function(x, y) {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
            }
            
            this.addPoint(x1, y1);
            this.addPoint(x2, y2);
        }
        
        // transforms
        svg.Transform = function(v) {   
            var that = this;
            this.Type = {}
        
            // translate
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);            
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                }
                this.unapply = function(ctx) {
                    ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                }
            }
            
            // rotate
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.unapply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(-1.0 * this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.applyToPoint = function(p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                }           
            }
            
            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                }
                this.unapply = function(ctx) {
                    ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                }               
            }
            
            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                }
                this.unapply = function(ctx) {
                    var a = this.m[0];
                    var b = this.m[2];
                    var c = this.m[4];
                    var d = this.m[1];
                    var e = this.m[3];
                    var f = this.m[5];
                    var g = 0.0;
                    var h = 0.0;
                    var i = 1.0;
                    var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
                    ctx.transform(
                        det*(e*i-f*h),
                        det*(f*g-d*i),
                        det*(c*h-b*i),
                        det*(a*i-c*g),
                        det*(b*f-c*e),
                        det*(c*d-a*f)
                    );
                }
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m);
                }                   
            }
            
            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s);
            }
            this.Type.SkewBase.prototype = new this.Type.matrix;
            
            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
            }
            this.Type.skewX.prototype = new this.Type.SkewBase;
            
            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
            }
            this.Type.skewY.prototype = new this.Type.SkewBase;
        
            this.transforms = [];
            
            this.apply = function(ctx) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].apply(ctx);
                }
            }
            
            this.unapply = function(ctx) {
                for (var i=this.transforms.length-1; i>=0; i--) {
                    this.transforms[i].unapply(ctx);
                }
            }
            
            this.applyToPoint = function(p) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p);
                }
            }
            
            var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
            for (var i=0; i<data.length; i++) {
                var type = svg.trim(data[i].split('(')[0]);
                var s = data[i].split('(')[1].replace(')','');
                var transform = new this.Type[type](s);
                transform.type = type;
                this.transforms.push(transform);
            }
        }
        
        // aspect ratio
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';                  
    
            // calculate scale
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
            if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }    
            
            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue()) {               
                ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
            } 
            else {                  
                // align
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0); 
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0); 
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0); 
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight); 
            }
            
            // scale
            if (align == 'none') ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin); 
            else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);     
            
            // translate
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);          
        }
        
        // elements
        svg.Element = {}
        
        svg.EmptyProperty = new svg.Property('EMPTY', '');
        
        svg.Element.ElementBase = function(node) {  
            this.attributes = {};
            this.styles = {};
            this.children = [];
            
            // get or create attribute
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null) return a;
                            
                if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
                return a || svg.EmptyProperty;
            }
            
            this.getHrefAttribute = function() {
                for (var a in this.attributes) { 
                    if (a.match(/:href$/)) { 
                        return this.attributes[a]; 
                    } 
                }
                return svg.EmptyProperty;
            }
            
            // get or create style, crawls up node tree
            this.style = function(name, createIfNotExists, skipAncestors) {
                var s = this.styles[name];
                if (s != null) return s;
                
                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    this.styles[name] = a; // move up to me to cache
                    return a;
                }
                
                if (skipAncestors != true) {
                    var p = this.parent;
                    if (p != null) {
                        var ps = p.style(name);
                        if (ps != null && ps.hasValue()) {
                            return ps;
                        }
                    }
                }
                    
                if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
                return s || svg.EmptyProperty;
            }
            
            // base render
            this.render = function(ctx) {
                // don't render display=none
                if (this.style('display').value == 'none') return;
                
                // don't render visibility=hidden
                if (this.style('visibility').value == 'hidden') return;
            
                ctx.save();
                if (this.attribute('mask').hasValue()) { // mask
                    var mask = this.attribute('mask').getDefinition();
                    if (mask != null) mask.apply(ctx, this);
                }
                else if (this.style('filter').hasValue()) { // filter
                    var filter = this.style('filter').getDefinition();
                    if (filter != null) filter.apply(ctx, this);
                }
                else {  
                    this.setContext(ctx);
                    this.renderChildren(ctx);   
                    this.clearContext(ctx);                         
                }
                ctx.restore();
            }
            
            // base set context
            this.setContext = function(ctx) {
                // OVERRIDE ME!
            }
            
            // base clear context
            this.clearContext = function(ctx) {
                // OVERRIDE ME!
            }           
            
            // base render children
            this.renderChildren = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].render(ctx);
                }
            }
            
            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create) child = svg.CreateElement(childNode);
                child.parent = this;
                if (child.type != 'title') { this.children.push(child); }
            }
                
            if (node != null && node.nodeType == 1) { //ELEMENT_NODE
                // add attributes
                for (var i=0; i<node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);
                }
                                        
                // add tag styles
                var styles = svg.Styles[node.nodeName];
                if (styles != null) {
                    for (var name in styles) {
                        this.styles[name] = styles[name];
                    }
                }                   
                
                // add class styles
                if (this.attribute('class').hasValue()) {
                    var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
                    for (var j=0; j<classes.length; j++) {
                        styles = svg.Styles['.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                        styles = svg.Styles[node.nodeName+'.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                    }
                }
                
                // add id styles
                if (this.attribute('id').hasValue()) {
                    var styles = svg.Styles['#' + this.attribute('id').value];
                    if (styles != null) {
                        for (var name in styles) {
                            this.styles[name] = styles[name];
                        }
                    }
                }
                
                // add inline styles
                if (this.attribute('style').hasValue()) {
                    var styles = this.attribute('style').value.split(';');
                    for (var i=0; i<styles.length; i++) {
                        if (svg.trim(styles[i]) != '') {
                            var style = styles[i].split(':');
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value);
                        }
                    }
                }   

                // add id
                if (this.attribute('id').hasValue()) {
                    if (svg.Definitions[this.attribute('id').value] == null) {
                        svg.Definitions[this.attribute('id').value] = this;
                    }
                }
                
                // add children
                for (var i=0; i<node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
                    if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
                        var text = childNode.nodeValue || childNode.text || '';
                        if (svg.trim(svg.compressSpaces(text)) != '') {
                            this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
                        }
                    }
                }
            }
        }
        
        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.setContext = function(ctx) {
                // fill
                if (this.style('fill').isUrlDefinition()) {
                    var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
                    if (fs != null) ctx.fillStyle = fs;
                }
                else if (this.style('fill').hasValue()) {
                    var fillStyle = this.style('fill');
                    if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
                    ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                }
                if (this.style('fill-opacity').hasValue()) {
                    var fillStyle = new svg.Property('fill', ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
                    ctx.fillStyle = fillStyle.value;
                }
                                    
                // stroke
                if (this.style('stroke').isUrlDefinition()) {
                    var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
                    if (fs != null) ctx.strokeStyle = fs;
                }
                else if (this.style('stroke').hasValue()) {
                    var strokeStyle = this.style('stroke');
                    if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
                    ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                }
                if (this.style('stroke-opacity').hasValue()) {
                    var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
                    ctx.strokeStyle = strokeStyle.value;
                }
                if (this.style('stroke-width').hasValue()) {
                    var newLineWidth = this.style('stroke-width').toPixels();
                    ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
                }
                if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
                if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
                if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
                if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
                    var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
                    if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
                    else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
                    else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }
                    
                    var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
                    if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
                    else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
                    else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
                }

                // font
                if (typeof(ctx.font) != 'undefined') {
                    ctx.font = svg.Font.CreateFont( 
                        this.style('font-style').value, 
                        this.style('font-variant').value, 
                        this.style('font-weight').value, 
                        this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', 
                        this.style('font-family').value).toString();
                }
                
                // transform
                if (this.attribute('transform').hasValue()) { 
                    var transform = new svg.Transform(this.attribute('transform').value);
                    transform.apply(ctx);
                }
                
                // clip
                if (this.style('clip-path', false, true).hasValue()) {
                    var clip = this.style('clip-path', false, true).getDefinition();
                    if (clip != null) clip.apply(ctx);
                }
                
                // opacity
                if (this.style('opacity').hasValue()) {
                    ctx.globalAlpha = this.style('opacity').numValue();
                }
            }       
        }
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        
        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                if (ctx != null) ctx.beginPath();
                return new svg.BoundingBox();
            }
            
            this.renderChildren = function(ctx) {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != '') {
                    if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
                    else { ctx.fill(); }
                }
                if (ctx.strokeStyle != '') ctx.stroke();
                
                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style('marker-start').isUrlDefinition()) {
                        var marker = this.style('marker-start').getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1]);
                    }
                    if (this.style('marker-mid').isUrlDefinition()) {
                        var marker = this.style('marker-mid').getDefinition();
                        for (var i=1;i<markers.length-1;i++) {
                            marker.render(ctx, markers[i][0], markers[i][1]);
                        }
                    }
                    if (this.style('marker-end').isUrlDefinition()) {
                        var marker = this.style('marker-end').getDefinition();
                        marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
                    }
                }                   
            }
            
            this.getBoundingBox = function() {
                return this.path();
            }
            
            this.getMarkers = function() {
                return null;
            }
        }
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // svg element
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent();
            }
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                // initial values and defaults
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4; 
                if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
                    ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
                }
            
                this.baseSetContext(ctx);
                
                // create new view port
                if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
                if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
                ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));
                
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                
                if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
                if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
                if (typeof(this.root) == 'undefined') {
                    width = this.attribute('width').toPixels('x');
                    height = this.attribute('height').toPixels('y');
                    
                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                        x = -this.attribute('refX').toPixels('x');
                        y = -this.attribute('refY').toPixels('y');
                    }
                    
                    if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(width, y);
                        ctx.lineTo(width, height);
                        ctx.lineTo(x, height);
                        ctx.closePath();
                        ctx.clip();
                    }
                }
                svg.ViewPort.SetCurrent(width, height); 
                        
                // viewbox
                if (this.attribute('viewBox').hasValue()) {             
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value, 
                                    svg.ViewPort.width(), 
                                    width,
                                    svg.ViewPort.height(),
                                    height,
                                    minX,
                                    minY,
                                    this.attribute('refX').value,
                                    this.attribute('refY').value);
                    
                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                }               
            }
        }
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

        // rect element
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
                rx = Math.min(rx, width / 2.0);
                ry = Math.min(ry, height / 2.0);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y)
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        
        // circle element
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                var r = this.attribute('r').toPixels();
            
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true); 
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
            }
        }
        svg.Element.circle.prototype = new svg.Element.PathElementBase; 

        // ellipse element
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        }
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;            
        
        // line element
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.getPoints = function() {
                return [
                    new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
                    new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
            }
                                
            this.path = function(ctx) {
                var points = this.getPoints();
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                }
                
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
            }
            
            this.getMarkers = function() {
                var points = this.getPoints();  
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]];
            }
        }
        svg.Element.line.prototype = new svg.Element.PathElementBase;       
                
        // polyline element
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                }
                for (var i=1; i<this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                return bb;
            }
            
            this.getMarkers = function() {
                var markers = [];
                for (var i=0; i<this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
                }
                markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
                return markers;
            }           
        }
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;               
                
        // polygon element
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);
            
            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath();
                }
                return bb;
            }
        }
        svg.Element.polygon.prototype = new svg.Element.polyline;

        // path element
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
                    
            var d = this.attribute('d').value;
            // TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
            d = d.replace(/,/gm,' '); // get rid of all commas
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
            d = svg.compressSpaces(d); // compress multiple spaces
            d = svg.trim(d);
            this.PathParser = new (function(d) {
                this.tokens = d.split(' ');
                
                this.reset = function() {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = [];
                }
                                
                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1;
                }
                
                this.isCommandOrEnd = function() {
                    if (this.isEnd()) return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                }
                
                this.isRelativeCommand = function() {
                    switch(this.command)
                    {
                        case 'm':
                        case 'l':
                        case 'h':
                        case 'v':
                        case 'c':
                        case 's':
                        case 'q':
                        case 't':
                        case 'a':
                        case 'z':
                            return true;
                            break;
                    }
                    return false;
                }
                            
                this.getToken = function() {
                    this.i++;
                    return this.tokens[this.i];
                }
                
                this.getScalar = function() {
                    return parseFloat(this.getToken());
                }
                
                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken();
                }               
                
                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p);
                }
                
                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p;
                }
                
                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p;   
                }
                
                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != 'c' && 
                        this.previousCommand.toLowerCase() != 's' &&
                        this.previousCommand.toLowerCase() != 'q' && 
                        this.previousCommand.toLowerCase() != 't' ){
                        return this.current;
                    }
                    
                    // reflect point
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);                    
                    return p;
                }
                
                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x += this.current.x;
                        p.y += this.current.y;
                    }
                    return p;
                }
                
                this.addMarker = function(p, from, priorTo) {
                    // if the last angle isn't filled in because we didn't have this point yet ...
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
                        this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                }
                
                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a);
                }               
                
                this.getMarkerPoints = function() { return this.points; }
                this.getMarkerAngles = function() {
                    for (var i=0; i<this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j=i+1; j<this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break;
                                }
                            }
                        }
                    }
                    return this.angles;
                }
            })(d);

            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();

                var bb = new svg.BoundingBox();
                if (ctx != null) ctx.beginPath();
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command) {
                    case 'M':
                    case 'm':
                        var p = pp.getAsCurrentPoint();
                        pp.addMarker(p);
                        bb.addPoint(p.x, p.y);
                        if (ctx != null) ctx.moveTo(p.x, p.y);
                        pp.start = pp.current;
                        while (!pp.isCommandOrEnd()) {
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, pp.start);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'L':
                    case 'l':
                        while (!pp.isCommandOrEnd()) {
                            var c = pp.current;
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, c);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'H':
                    case 'h':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'V':
                    case 'v':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'C':
                    case 'c':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'S':
                    case 's':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getReflectedControlPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'Q':
                    case 'q':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'T':
                    case 't':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getReflectedControlPoint();
                            pp.control = cntrl;
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'A':
                    case 'a':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var rx = pp.getScalar();
                            var ry = pp.getScalar();
                            var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                            var largeArcFlag = pp.getScalar();
                            var sweepFlag = pp.getScalar();
                            var cp = pp.getAsCurrentPoint();

                            // Conversion from endpoint to center parameterization
                            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                            // x1', y1'
                            var currp = new svg.Point(
                                Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                                -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                            );
                            // adjust radii
                            var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
                            if (l > 1) {
                                rx *= Math.sqrt(l);
                                ry *= Math.sqrt(l);
                            }
                            // cx', cy'
                            var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                                ((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
                                (Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
                            );
                            if (isNaN(s)) s = 0;
                            var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                            // cx, cy
                            var centp = new svg.Point(
                                (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                                (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                            );
                            // vector magnitude
                            var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
                            // ratio between two vectors
                            var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
                            // angle between two vectors
                            var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
                            // initial angle
                            var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
                            // angle delta
                            var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
                            var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
                            var ad = a(u, v);
                            if (r(u,v) <= -1) ad = Math.PI;
                            if (r(u,v) >= 1) ad = 0;

                            // for markers
                            var dir = 1 - sweepFlag ? 1.0 : -1.0;
                            var ah = a1 + dir * (ad / 2.0);
                            var halfWay = new svg.Point(
                                centp.x + rx * Math.cos(ah),
                                centp.y + ry * Math.sin(ah)
                            );
                            pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                            pp.addMarkerAngle(cp, ah - dir * Math.PI);

                            bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                            if (ctx != null) {
                                var r = rx > ry ? rx : ry;
                                var sx = rx > ry ? 1 : rx / ry;
                                var sy = rx > ry ? ry / rx : 1;

                                ctx.translate(centp.x, centp.y);
                                ctx.rotate(xAxisRotation);
                                ctx.scale(sx, sy);
                                ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                ctx.scale(1/sx, 1/sy);
                                ctx.rotate(-xAxisRotation);
                                ctx.translate(-centp.x, -centp.y);
                            }
                        }
                        break;
                    case 'Z':
                    case 'z':
                        if (ctx != null) ctx.closePath();
                        pp.current = pp.start;
                    }
                }

                return bb;
            }

            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                
                var markers = [];
                for (var i=0; i<points.length; i++) {
                    markers.push([points[i], angles[i]]);
                }
                return markers;
            }
        }
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        
        // pattern element
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.createPattern = function(ctx, element) {
                var width = this.attribute('width').toPixels('x', true);
                var height = this.attribute('height').toPixels('y', true);
            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
                tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
                tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
                tempSvg.children = this.children;
                
                var c = document.createElement('canvas');
                c.width = width;
                c.height = height;
                var cctx = c.getContext('2d');
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                    cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
                }
                // render 3x3 grid so when we transform there's no white space on edges
                for (var x=-1; x<=1; x++) {
                    for (var y=-1; y<=1; y++) {
                        cctx.save();
                        cctx.translate(x * c.width, y * c.height);
                        tempSvg.render(cctx);
                        cctx.restore();
                    }
                }
                var pattern = ctx.createPattern(c, 'repeat');
                return pattern;
            }
        }
        svg.Element.pattern.prototype = new svg.Element.ElementBase;
        
        // marker element
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();
                            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                
                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y);
            }
        }
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        
        // definitions element
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.render = function(ctx) {
                // NOOP
            }
        }
        svg.Element.defs.prototype = new svg.Element.ElementBase;
        
        // base for gradients
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            
            this.stops = [];            
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'stop') this.stops.push(child);
            }   
            
            this.getGradient = function() {
                // OVERRIDE ME!
            }           

            this.createGradient = function(ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                if (this.getHrefAttribute().hasValue()) {
                    stopsContainer = this.getHrefAttribute().getDefinition();
                }
                
                var addParentOpacity = function (color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property('color', color);
                        return p.addOpacity(parentOpacityProp).value;
                    }
                    return color;
                };
            
                var g = this.getGradient(ctx, element);
                if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                for (var i=0; i<stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                }
                
                if (this.attribute('gradientTransform').hasValue()) {
                    // render as transformed pattern on temporary canvas
                    var rootView = svg.ViewPort.viewPorts[0];
                    
                    var rect = new svg.Element.rect();
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
                    
                    var group = new svg.Element.g();
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [ rect ];
                    
                    var tempSvg = new svg.Element.svg();
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [ group ];
                    
                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);        
                    return tempCtx.createPattern(c, 'no-repeat');
                }
                
                return g;               
            }
        }
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        
        // linear gradient element
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = this.gradientUnits == 'objectBoundingBox' ? element.getBoundingBox() : null;
                
                if (!this.attribute('x1').hasValue()
                 && !this.attribute('y1').hasValue()
                 && !this.attribute('x2').hasValue()
                 && !this.attribute('y2').hasValue()) {
                    this.attribute('x1', true).value = 0;
                    this.attribute('y1', true).value = 0;
                    this.attribute('x2', true).value = 1;
                    this.attribute('y2', true).value = 0;
                 }
                
                var x1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x1').numValue() 
                    : this.attribute('x1').toPixels('x'));
                var y1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y1').numValue()
                    : this.attribute('y1').toPixels('y'));
                var x2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x2').numValue()
                    : this.attribute('x2').toPixels('x'));
                var y2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y2').numValue()
                    : this.attribute('y2').toPixels('y'));

                if (x1 == x2 && y1 == y2) return null;
                return ctx.createLinearGradient(x1, y1, x2, y2);
            }
        }
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        
        // radial gradient element
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                
                if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
                if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
                if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';
                
                var cx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('cx').numValue() 
                    : this.attribute('cx').toPixels('x'));
                var cy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('cy').numValue() 
                    : this.attribute('cy').toPixels('y'));
                
                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue()) {
                    fx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('fx').numValue() 
                    : this.attribute('fx').toPixels('x'));
                }
                if (this.attribute('fy').hasValue()) {
                    fy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('fy').numValue() 
                    : this.attribute('fy').toPixels('y'));
                }
                
                var r = (this.gradientUnits == 'objectBoundingBox' 
                    ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
                    : this.attribute('r').toPixels());
                
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
            }
        }
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        
        // gradient stop element
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.offset = this.attribute('offset').numValue();
            if (this.offset < 0) this.offset = 0;
            if (this.offset > 1) this.offset = 1;
            
            var stopColor = this.style('stop-color');
            if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
            this.color = stopColor.value;
        }
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        
        // animation base element
        svg.Element.AnimateBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            svg.Animations.push(this);
            
            this.duration = 0.0;
            this.begin = this.attribute('begin').toMilliseconds();
            this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();
            
            this.getProperty = function() {
                var attributeType = this.attribute('attributeType').value;
                var attributeName = this.attribute('attributeName').value;
                
                if (attributeType == 'CSS') {
                    return this.parent.style(attributeName, true);
                }
                return this.parent.attribute(attributeName, true);          
            };
            
            this.initialValue = null;
            this.initialUnits = '';
            this.removed = false;       

            this.calcValue = function() {
                // OVERRIDE ME!
                return '';
            }
                    
            this.update = function(delta) { 
                // set initial value
                if (this.initialValue == null) {
                    this.initialValue = this.getProperty().value;
                    this.initialUnits = this.getProperty().getUnits();
                }
            
                // if we're past the end time
                if (this.duration > this.maxDuration) {
                    // loop for indefinitely repeating animations
                    if (this.attribute('repeatCount').value == 'indefinite'
                     || this.attribute('repeatDur').value == 'indefinite') {
                        this.duration = 0.0
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
                        this.frozen = true;
                        this.parent.animationFrozen = true;
                        this.parent.animationFrozenValue = this.getProperty().value;
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
                        this.removed = true;
                        this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
                        return true;
                    }
                    return false;
                }           
                this.duration = this.duration + delta;
            
                // if we're past the begin time
                var updated = false;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue(); // tween
                    
                    if (this.attribute('type').hasValue()) {
                        // for transform, etc.
                        var type = this.attribute('type').value;
                        newValue = type + '(' + newValue + ')';
                    }
                    
                    this.getProperty().value = newValue;
                    updated = true;
                }
                
                return updated;
            }
            
            this.from = this.attribute('from');
            this.to = this.attribute('to');
            this.values = this.attribute('values');
            if (this.values.hasValue()) this.values.value = this.values.value.split(';');
            
            // fraction of duration we've covered
            this.progress = function() {
                var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1);
                    var lb = Math.floor(p), ub = Math.ceil(p);
                    ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
                    ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
                    ret.progress = (p - lb) / (ub - lb);
                }
                else {
                    ret.from = this.from;
                    ret.to = this.to;
                }
                return ret;
            }           
        }
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
        
        // animate element
        svg.Element.animate = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress; 
                return newValue + this.initialUnits;
            };
        }
        svg.Element.animate.prototype = new svg.Element.AnimateBase;
            
        // animate color element
        svg.Element.animateColor = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);

            this.calcValue = function() {
                var p = this.progress();
                var from = new RGBColor(p.from.value);
                var to = new RGBColor(p.to.value);
                
                if (from.ok && to.ok) {
                    // tween color linearly
                    var r = from.r + (to.r - from.r) * p.progress;
                    var g = from.g + (to.g - from.g) * p.progress;
                    var b = from.b + (to.b - from.b) * p.progress;
                    return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
                }
                return this.attribute('from').value;
            };
        }
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
        
        // animate transform element
        svg.Element.animateTransform = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var from = svg.ToNumberArray(p.from.value);
                var to = svg.ToNumberArray(p.to.value);
                var newValue = '';
                for (var i=0; i<from.length; i++) {
                    newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
                }
                return newValue;
            };
        }
        svg.Element.animateTransform.prototype = new svg.Element.animate;
        
        // font element
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();          
            
            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];           
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'font-face') {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue()) {
                        svg.Definitions[child.style('font-family').value] = this;
                    }
                }
                else if (child.type == 'missing-glyph') this.missingGlyph = child;
                else if (child.type == 'glyph') {
                    if (child.arabicForm != '') {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child;
                    }
                    else {
                        this.glyphs[child.unicode] = child;
                    }
                }
            }   
        }
        svg.Element.font.prototype = new svg.Element.ElementBase;
        
        // font-face element
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue();                
        }
        svg.Element.fontface.prototype = new svg.Element.ElementBase;
        
        // missing-glyph element
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = 0;
        }
        svg.Element.missingglyph.prototype = new svg.Element.path;
        
        // glyph element
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value;
        }
        svg.Element.glyph.prototype = new svg.Element.path;
        
        // text element
        svg.Element.text = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                
                var textBaseline = this.style('dominant-baseline').toTextBaseline();
                if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
                if (textBaseline != null) ctx.textBaseline = textBaseline;
            }
            
            this.getBoundingBox = function () {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
            }
            
            this.renderChildren = function(ctx) {
                this.x = this.attribute('x').toPixels('x');
                this.y = this.attribute('y').toPixels('y');
                this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i=0; i<this.children.length; i++) {
                    this.renderChild(ctx, this, i);
                }
            }
            
            this.getAnchorDelta = function (ctx, parent, startI) {
                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                if (textAnchor != 'start') {
                    var width = 0;
                    for (var i=startI; i<parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute('x').hasValue()) break; // new group
                        width += child.measureTextRecursive(ctx);
                    }
                    return -1 * (textAnchor == 'end' ? width : width / 2.0);
                }
                return 0;
            }
            
            this.renderChild = function(ctx, parent, i) {
                var child = parent.children[i];
                if (child.attribute('x').hasValue()) {
                    child.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);
                    if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
                }
                else {
                    if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
                    if (child.attribute('dx').hasValue()) this.x += child.attribute('dx').toPixels('x');
                    child.x = this.x;
                }
                this.x = child.x + child.measureText(ctx);
                
                if (child.attribute('y').hasValue()) {
                    child.y = child.attribute('y').toPixels('y');
                    if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
                }
                else {
                    if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
                    if (child.attribute('dy').hasValue()) this.y += child.attribute('dy').toPixels('y');
                    child.y = this.y;
                }
                this.y = child.y;
                
                child.render(ctx);
                
                for (var i=0; i<child.children.length; i++) {
                    this.renderChild(ctx, child, i);
                }
            }
        }
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;
        
        // text base
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = 'isolated';
                    if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal'; 
                    if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
                    if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
                    if (typeof(font.glyphs[c]) != 'undefined') {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
                    }
                }
                else {
                    glyph = font.glyphs[c];
                }
                if (glyph == null) glyph = font.missingGlyph;
                return glyph;
            }
            
            this.renderChildren = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1/scale, -1/scale);
                        ctx.translate(-this.x, -this.y);    
                        
                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            this.x += dx[i];
                        }
                    }
                    return;
                }
            
                if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
            }
            
            this.getText = function() {
                // OVERRIDE ME
            }
            
            this.measureTextRecursive = function(ctx) {
                var width = this.measureText(ctx);
                for (var i=0; i<this.children.length; i++) {
                    width += this.children[i].measureTextRecursive(ctx);
                }
                return width;
            }
            
            this.measureText = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            measure += dx[i];
                        }
                    }
                    return measure;
                }
            
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText) return textToMeasure.length * 10;
                
                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width;
            }
        }
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // tspan 
        svg.Element.tspan = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.text = node.nodeValue || node.text || '';
            this.getText = function() {
                return this.text;
            }
        }
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
        
        // tref
        svg.Element.tref = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.getText = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (element != null) return element.children[0].getText();
            }
        }
        svg.Element.tref.prototype = new svg.Element.TextElementBase;       
        
        // a element
        svg.Element.a = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.hasText = true;
            for (var i=0; i<node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType != 3) this.hasText = false;
            }
            
            // this might contain text
            this.text = this.hasText ? node.childNodes[0].nodeValue : '';
            this.getText = function() {
                return this.text;
            }       

            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx) {
                if (this.hasText) {
                    // render as text element
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));                 
                }
                else {
                    // render as temporary group
                    var g = new svg.Element.g();
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx);
                }
            }
            
            this.onclick = function() {
                window.open(this.getHrefAttribute().value);
            }
            
            this.onmousemove = function() {
                svg.ctx.canvas.style.cursor = 'pointer';
            }
        }
        svg.Element.a.prototype = new svg.Element.TextElementBase;      
        
        // image element
        svg.Element.image = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            var href = this.getHrefAttribute().value;
            if (href == '') { return; }
            var isSvg = href.match(/\.svg$/)
            
            svg.Images.push(this);
            this.loaded = false;
            if (!isSvg) {
                this.img = document.createElement('img');
                if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
                var self = this;
                this.img.onload = function() { self.loaded = true; }
                this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
                this.img.src = href;
            }
            else {
                this.img = svg.ajax(href);
                this.loaded = true;
            }
            
            this.renderChildren = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');            
                if (width == 0 || height == 0) return;
            
                ctx.save();
                if (isSvg) {
                    ctx.drawSvg(this.img, x, y, width, height);
                }
                else {
                    ctx.translate(x, y);
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value,
                                    width,
                                    this.img.width,
                                    height,
                                    this.img.height,
                                    0,
                                    0); 
                    ctx.drawImage(this.img, 0, 0);      
                }
                ctx.restore();
            }
            
            this.getBoundingBox = function() {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;
        
        // group element
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i=0; i<this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };
        }
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;

        // symbol element
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.render = function(ctx) {
                // NO RENDER
            };
        }
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;     
            
        // style element
        svg.Element.style = function(node) { 
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            // text, or spaces then CDATA
            var css = ''
            for (var i=0; i<node.childNodes.length; i++) {
              css += node.childNodes[i].nodeValue;
            }
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
            css = svg.compressSpaces(css); // replace whitespace
            var cssDefs = css.split('}');
            for (var i=0; i<cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != '') {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j=0; j<cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '') {
                            var props = {};
                            for (var k=0; k<cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == '@font-face') {
                                var fontFamily = props['font-family'].value.replace(/"/g,'');
                                var srcs = props['src'].value.split(',');
                                for (var s=0; s<srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")') > 0) {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f=0; f<fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        svg.Element.style.prototype = new svg.Element.ElementBase;
        
        // use element 
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
                if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
            }
            
            var element = this.getHrefAttribute().getDefinition();
            
            this.path = function(ctx) {
                if (element != null) element.path(ctx);
            }
            
            this.getBoundingBox = function() {
                if (element != null) return element.getBoundingBox();
            }
            
            this.renderChildren = function(ctx) {
                if (element != null) {
                    var tempSvg = element;
                    if (element.type == 'symbol') {
                        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
                        tempSvg = new svg.Element.svg();
                        tempSvg.type = 'svg';
                        tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
                        tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
                        tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
                        tempSvg.children = element.children;
                    }
                    if (tempSvg.type == 'svg') {
                        // if symbol or svg, inherit width/height from me
                        if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                        if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                    }
                    var oldParent = tempSvg.parent;
                    tempSvg.parent = null;
                    tempSvg.render(ctx);
                    tempSvg.parent = oldParent;
                }
            }
        }
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        
        // mask element
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                
                if (width == 0 && height == 0) {
                    var bb = new svg.BoundingBox();
                    for (var i=0; i<this.children.length; i++) {
                        bb.addBoundingBox(this.children[i].getBoundingBox());
                    }
                    var x = Math.floor(bb.x1);
                    var y = Math.floor(bb.y1);
                    var width = Math.floor(bb.width());
                    var height = Math.floor(bb.height());
                }
                
                // temporarily remove mask to avoid recursion
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';
                
                    var cMask = document.createElement('canvas');
                    cMask.width = x + width;
                    cMask.height = y + height;
                    var maskCtx = cMask.getContext('2d');
                    this.renderChildren(maskCtx);
                
                    var c = document.createElement('canvas');
                    c.width = x + width;
                    c.height = y + height;
                    var tempCtx = c.getContext('2d');
                    element.render(tempCtx);
                    tempCtx.globalCompositeOperation = 'destination-in';
                    tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                    tempCtx.fillRect(0, 0, x + width, y + height);
                    
                    ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                    ctx.fillRect(0, 0, x + width, y + height);
                    
                // reassign mask
                element.attribute('mask').value = mask; 
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.mask.prototype = new svg.Element.ElementBase;
        
        // clip element
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx) {
                var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
                CanvasRenderingContext2D.prototype.beginPath = function () { };
                
                var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
                CanvasRenderingContext2D.prototype.closePath = function () { };
            
                oldBeginPath.call(ctx);
                for (var i=0; i<this.children.length; i++) {
                    var child = this.children[i];
                    if (typeof(child.path) != 'undefined') {
                        var transform = null;
                        if (child.attribute('transform').hasValue()) { 
                            transform = new svg.Transform(child.attribute('transform').value);
                            transform.apply(ctx);
                        }
                        child.path(ctx);
                        CanvasRenderingContext2D.prototype.closePath = oldClosePath;
                        if (transform) { transform.unapply(ctx); }
                    }
                }
                oldClosePath.call(ctx);
                ctx.clip();
                
                CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
                CanvasRenderingContext2D.prototype.closePath = oldClosePath;
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;

        // filters
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var bb = element.getBoundingBox();
                var x = Math.floor(bb.x1);
                var y = Math.floor(bb.y1);
                var width = Math.floor(bb.width());
                var height = Math.floor(bb.height());

                // temporarily remove filter to avoid recursion
                var filter = element.style('filter').value;
                element.style('filter').value = '';
                
                var px = 0, py = 0;
                for (var i=0; i<this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd);
                    py = Math.max(py, efd);
                }
                
                var c = document.createElement('canvas');
                c.width = width + 2*px;
                c.height = height + 2*py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
            
                // apply filters
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
                }
                
                // render on me
                ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);
                
                // reassign filter
                element.style('filter', true).value = filter;   
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }       
        }
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        
        svg.Element.feMorphology = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
        
        svg.Element.feComposite = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feComposite.prototype = new svg.Element.ElementBase;
        
        svg.Element.feColorMatrix = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            var matrix = svg.ToNumberArray(this.attribute('values').value);
            switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
                case 'saturate':
                    var s = matrix[0];
                    matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'hueRotate':
                    var a = matrix[0] * Math.PI / 180.0;
                    var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
                    matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
                              c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
                              c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'luminanceToAlpha':
                    matrix = [0,0,0,0,0,
                              0,0,0,0,0,
                              0,0,0,0,0,
                              0.2125,0.7154,0.0721,0,0,
                              0,0,0,0,1];
                    break;
            }
            
            function imGet(img, x, y, width, height, rgba) {
                return img[y*width*4 + x*4 + rgba];
            }
            
            function imSet(img, x, y, width, height, rgba, val) {
                img[y*width*4 + x*4 + rgba] = val;
            }
            
            function m(i, v) {
                var mi = matrix[i];
                return mi * (mi < 0 ? v - 255 : v);
            }
                        
            this.apply = function(ctx, x, y, width, height) {
                // assuming x==0 && y==0 for now
                var srcData = ctx.getImageData(0, 0, width, height);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0);
                        var g = imGet(srcData.data, x, y, width, height, 1);
                        var b = imGet(srcData.data, x, y, width, height, 2);
                        var a = imGet(srcData.data, x, y, width, height, 3);
                        imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
                        imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
                        imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
                        imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
                    }
                }
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0);
            }
        }
        svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
        
        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
            this.extraFilterDistance = this.blurRadius;
            
            this.apply = function(ctx, x, y, width, height) {
                if (typeof(stackBlurCanvasRGBA) == 'undefined') {
                    svg.log('ERROR: StackBlur.js must be included for blur to work');
                    return;
                }
                
                // StackBlur requires canvas be on document
                ctx.canvas.id = svg.UniqueId();
                ctx.canvas.style.display = 'none';
                document.body.appendChild(ctx.canvas);
                stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                document.body.removeChild(ctx.canvas);
            }
        }
        svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
        
        // title element, do nothing
        svg.Element.title = function(node) {
        }
        svg.Element.title.prototype = new svg.Element.ElementBase;

        // desc element, do nothing
        svg.Element.desc = function(node) {
        }
        svg.Element.desc.prototype = new svg.Element.ElementBase;       
        
        svg.Element.MISSING = function(node) {
            svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
        }
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        
        // element factory
        svg.CreateElement = function(node) {    
            var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
            className = className.replace(/\-/g,''); // remove dashes
            var e = null;
            if (typeof(svg.Element[className]) != 'undefined') {
                e = new svg.Element[className](node);
            }
            else {
                e = new svg.Element.MISSING(node);
            }

            e.type = node.nodeName;
            return e;
        }
                
        // load from url
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url));
        }
        
        // load from xml
        svg.loadXml = function(ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml));
        }
        
        svg.loadXmlDoc = function(ctx, dom) {
            svg.init(ctx);
            
            var mapXY = function(p) {
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent;
                }
                if (window.scrollX) p.x += window.scrollX;
                if (window.scrollY) p.y += window.scrollY;
                return p;
            }
            
            // bind mouse
            if (svg.opts['ignoreMouse'] != true) {
                ctx.canvas.onclick = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y);
                };
                ctx.canvas.onmousemove = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y);
                };
            }
        
            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
                    
            // render loop
            var isFirstRender = true;
            var draw = function() {
                svg.ViewPort.Clear();
                if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
            
                if (svg.opts['ignoreDimensions'] != true) {
                    // set canvas size
                    if (e.style('width').hasValue()) {
                        ctx.canvas.width = e.style('width').toPixels('x');
                        ctx.canvas.style.width = ctx.canvas.width + 'px';
                    }
                    if (e.style('height').hasValue()) {
                        ctx.canvas.height = e.style('height').toPixels('y');
                        ctx.canvas.style.height = ctx.canvas.height + 'px';
                    }
                }
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
                    cWidth = e.style('width').toPixels('x');
                    cHeight = e.style('height').toPixels('y');
                }
                svg.ViewPort.SetCurrent(cWidth, cHeight);       
                
                if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
                if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
                if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
                    var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);
                    
                    if (svg.opts['scaleWidth'] != null) {
                        if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
                        else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
                    }
                    
                    if (svg.opts['scaleHeight'] != null) {
                        if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
                        else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
                    }

                    if (xRatio == null) { xRatio = yRatio; }
                    if (yRatio == null) { yRatio = xRatio; }
                    
                    e.attribute('width', true).value = svg.opts['scaleWidth'];
                    e.attribute('height', true).value = svg.opts['scaleHeight'];
                    e.attribute('transform', true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
                }
            
                // clear and render
                if (svg.opts['ignoreClear'] != true) {
                    ctx.clearRect(0, 0, cWidth, cHeight);
                }
                e.render(ctx);
                if (isFirstRender) {
                    isFirstRender = false;
                    if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
                }           
            }
            
            var waitingForImages = true;
            if (svg.ImagesLoaded()) {
                waitingForImages = false;
                draw();
            }
            svg.intervalID = setInterval(function() { 
                var needUpdate = false;
                
                if (waitingForImages && svg.ImagesLoaded()) {
                    waitingForImages = false;
                    needUpdate = true;
                }
            
                // need update from mouse events?
                if (svg.opts['ignoreMouse'] != true) {
                    needUpdate = needUpdate | svg.Mouse.hasEvents();
                }
            
                // need update from animations?
                if (svg.opts['ignoreAnimation'] != true) {
                    for (var i=0; i<svg.Animations.length; i++) {
                        needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
                    }
                }
                
                // need update from redraw?
                if (typeof(svg.opts['forceRedraw']) == 'function') {
                    if (svg.opts['forceRedraw']() == true) needUpdate = true;
                }
                
                // render if needed
                if (needUpdate) {
                    draw();             
                    svg.Mouse.runEvents(); // run and clear our events
                }
            }, 1000 / svg.FRAMERATE);
        }
        
        svg.stop = function() {
            if (svg.intervalID) {
                clearInterval(svg.intervalID);
            }
        }
        
        svg.Mouse = new (function() {
            this.events = [];
            this.hasEvents = function() { return this.events.length != 0; }
        
            this.onclick = function(x, y) {
                this.events.push({ type: 'onclick', x: x, y: y, 
                    run: function(e) { if (e.onclick) e.onclick(); }
                });
            }
            
            this.onmousemove = function(x, y) {
                this.events.push({ type: 'onmousemove', x: x, y: y,
                    run: function(e) { if (e.onmousemove) e.onmousemove(); }
                });
            }           
            
            this.eventElements = [];
            
            this.checkPath = function(element, ctx) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
                }
            }
            
            this.checkBoundingBox = function(element, bb) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
                }           
            }
            
            this.runEvents = function() {
                svg.ctx.canvas.style.cursor = '';
                
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element) {
                        e.run(element);
                        element = element.parent;
                    }
                }       
            
                // done running, clear
                this.events = []; 
                this.eventElements = [];
            }
        });
        
        return svg;
    }
})();

if (typeof(CanvasRenderingContext2D) != 'undefined') {
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
        canvg(this.canvas, s, { 
            ignoreMouse: true, 
            ignoreAnimation: true, 
            ignoreDimensions: true, 
            ignoreClear: true, 
            offsetX: dx, 
            offsetY: dy, 
            scaleWidth: dw, 
            scaleHeight: dh
        });
    }
}

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/rgbcolor.js":[function(require,module,exports){
// dependency for canvg
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}


module.exports = RGBColor;

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/underscore-transpose.js":[function(require,module,exports){
var _ = require('underscore');

_.mixin({
  transpose: function(arrs) {
    return _.zip.apply(_, arrs);
  }
});

},{"underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js":[function(require,module,exports){
// hopefully not that ugly, but seemed as good a place as any for this stuff...

var d3 = require('d3');


var formatKMB = function(precision, decimalSeparator) {
  var app = window.app;
  var formatSI = d3.format('.' + (precision || 3) + 's');
  decimalSeparator = decimalSeparator || '.';
  return function(value) {
    return formatSI(value)
      .replace('k', app.translator.translateSync('amp.dashboard:chart-thousand'))
      .replace('M', app.translator.translateSync('amp.dashboard:chart-million'))
      .replace('G', app.translator.translateSync('amp.dashboard:chart-billion'))  // now just need to convert G Gigia -> B Billion
      .replace('T', app.translator.translateSync('amp.dashboard:chart-trillion'))
      .replace('P', app.translator.translateSync('amp.dashboard:chart-peta'))
      .replace('E', app.translator.translateSync('amp.dashboard:chart-exa'))
      .replace('.', decimalSeparator);
  };
};

var translateLanguage = function(value) {
  var app = window.app;
  return value
    .replace('k', app.translator.translateSync('amp.dashboard:chart-thousand'))
    .replace('M', app.translator.translateSync('amp.dashboard:chart-million'))
    .replace('B', app.translator.translateSync('amp.dashboard:chart-billion'))
    .replace('T', app.translator.translateSync('amp.dashboard:chart-trillion'))
    .replace('P', app.translator.translateSync('amp.dashboard:chart-peta'))
    .replace('E', app.translator.translateSync('amp.dashboard:chart-exa'));
};

var formatShortText = function(maxWidth) {
  var ellipseWidth = 1;
  return function(text) {
    if (text.length - ellipseWidth > maxWidth) {
      text = text.slice(0, maxWidth - ellipseWidth) + '...';
    }
    return text;
  };
};


var categoryColours = function(cats) {
  // get an appropriate colour scale for the number of categories we are
  // dealing with
  var colours = d3.scale['category20']().range();
  return function(d, i) {
    return d.color || (d.data && d.data.color) || colours[i % colours.length];
  };
};


var u16le64 = function(str) {
  // base64-encode a string as UTF-16-LE (for MS Excel, probably). It will only
  // work for 2-byte-wide utf-16 characters, and will break at the first hint
  // of any 4-byte char. Two bytes covers the Basic Multiningual Plane, so we
  // should be good.
  var u16num,
      asciiBytePairString = String.fromCharCode(0xFF) + String.fromCharCode(0xFE);
  asciiBytePairString += Array.prototype.reduce.call(str, function(acc, chr) {
    u16num = chr.charCodeAt(0);
    /* jshint bitwise:false */
    return acc + String.fromCharCode(u16num & 0xFF) + String.fromCharCode(u16num >> 8);
    /* jshint bitwise:true */
  }, '');
  return btoa(asciiBytePairString);
};


var textAsDataURL = function(str) {
  return 'data:text/plain;base64,' + u16le64(str);
};


function transformArgs(transformer, wrapped) {
  return function(/* arguments */) {
    var transformedArgs = transformer.apply(null, arguments);
    return wrapped.apply(null, transformedArgs);
  };
}


function toDashed(name) {
  // transform namesLikeThis to names-like-this
  return name.replace(/([A-Z])/g, function(u) {
    return '-' + u.toLowerCase();
  });
}


function data(el, name, newValue) {
  if (newValue === void 0) {
    return el.getAttribute('data-' + toDashed(name));
  }
  el.setAttribute('data-' + toDashed(name), newValue);
}

/**
 * This function calculates how much height we need to show a readable chart with different number of legends. 
 */
function calculateChartHeight(length, isDownload, model) {
	var height = null;
	var bigN = null;
	if (length < 30) {
		bigN = '0';
		if (isDownload === true) {
			height = 450;
		}
	} else if(length >= 30 && length < 40) {
		if (isDownload === true) {
			height = 550;
		}  else {
			height = 475;
		}
		bigN = '1';
	} else if(length >= 40 && length < 50) {
		if (isDownload === true) {
			height = 700;
		} else {
			height = 625;
		}
		bigN = '2';
	} else if(length >= 50 && length < 60) {
		if (isDownload === true) {
			height = 850;
		} else {
			height = 775;
		}
		bigN = '3';
	} else if(length >= 60 && length < 70) {
		if (isDownload === true) {
			height = 1000;
		} else {
			height = 925;
		}
		bigN = '4';
	} else if(length >= 70 && length < 80) {
		if (isDownload === true) {
			height = 1150;
		} else {
			height = 1075;
		}
		bigN = '5';
	} else if(length >= 80 && length < 90) {
		if (isDownload === true) {
			height = 1150;
		} else {
			height = 1225;
		}
		bigN = '6';	
	} else if(length >= 90) {
		// Seriously????
		if (isDownload === true) {
			height = 1300;
		} else {
			height = 1375;
		}
		bigN = '7';
	}
	if (model !== undefined) {
		model.set('bigN', bigN);
	}
	return height
}


module.exports = {
  formatKMB: formatKMB,
  translateLanguage: translateLanguage,
  formatShortText: formatShortText,
  categoryColours: categoryColours,
  u16le64: u16le64,
  textAsDataURL: textAsDataURL,
  transformArgs: transformArgs,
  data: data,
  calculateChartHeight: calculateChartHeight
};

},{"d3":"d3"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/node_modules/babyparse/babyparse.js":[function(require,module,exports){
/*
	Baby Parse
	v0.2.1
	https://github.com/Rich-Harris/BabyParse

	based on Papa Parse v3.0.1
	https://github.com/mholt/PapaParse
*/


(function ( global ) {

	// A configuration object from which to draw default settings
	var DEFAULTS = {
		delimiter: "",	// empty: auto-detect
		header: false,
		dynamicTyping: false,
		preview: 0,
		step: undefined,
		comments: false,
		complete: undefined,
		keepEmptyRows: false
	};

	var Baby = {};
	Baby.parse = CsvToJson;
	Baby.unparse = JsonToCsv;
	Baby.RECORD_SEP = String.fromCharCode(30);
	Baby.UNIT_SEP = String.fromCharCode(31);
	Baby.BYTE_ORDER_MARK = "\ufeff";
	Baby.BAD_DELIMITERS = ["\r", "\n", "\"", Baby.BYTE_ORDER_MARK];


	function CsvToJson(_input, _config)
	{
		var config = copyAndValidateConfig(_config);
		var ph = new ParserHandle(config);
		var results = ph.parse(_input);
		if (isFunction(config.complete))
			config.complete(results);
		return results;
	}




	function JsonToCsv(_input, _config)
	{
		var _output = "";
		var _fields = [];

		// Default configuration
		var _quotes = false;	// whether to surround every datum with quotes
		var _delimiter = ",";	// delimiting character
		var _newline = "\r\n";	// newline character(s)

		unpackConfig();

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields = _input.data[0] instanceof Array
									? _input.fields
									: objectKeys(_input.data[0]);

				if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ["asdf"]
			}

			return serialize(_input.fields || [], _input.data || []);
		}

		// Default (any valid paths should return before this)
		throw "exception: Unable to serialize unrecognized input";


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
				&& _config.delimiter.length == 1
				&& Baby.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;
		}


		// Turns an object's keys into an array
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		// The double for loop that iterates the data and writes out a CSV string including header row
		function serialize(fields, data)
		{
			var csv = "";

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = fields instanceof Array && fields.length > 0;
			var dataKeyedByField = !(data[0] instanceof Array);

			// If there a header row, write it first
			if (hasHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				for (var col = 0; col < maxCol; col++)
				{
					if (col > 0)
						csv += _delimiter;
					var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}

				if (row < data.length - 1)
					csv += _newline;
			}

			return csv;
		}

		// Encloses a value around quotes if needed (makes a value safe for CSV insertion)
		function safe(str, col)
		{
			if (typeof str === "undefined")
				return "";

			str = str.toString().replace(/"/g, '""');

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (_quotes instanceof Array && _quotes[col])
							|| hasAny(str, Baby.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) == ' '
							|| str.charAt(str.length - 1) == ' ';

			return needsQuotes ? '"' + str + '"' : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}






	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};
		_config = copy(_config);

		this.parse = function(input)
		{
			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = ",";
				}
				_results.meta.delimiter = _config.delimiter;
			}

			if (isFunction(_config.step))
			{
				var userStep = _config.step;
				_config.step = function(results, parser)
				{
					_results = results;
					if (needsHeaderRow())
						processResults();
					else
						userStep(processResults(), parser);
				};
			}

			_results = new Parser(_config).parse(input);
			return processResults();
		};

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to comma");
				_delimiterError = false;
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTyping();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length == 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
				for (var j = 0; j < _results.data[i].length; j++)
					_fields.push(_results.data[i][j]);
			_results.data.splice(0, 1);
		}

		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping))
				return _results;

			for (var i = 0; i < _results.data.length; i++)
			{
				var row = {};
				for (var j = 0; j < _results.data[i].length; j++)
				{
					if (_config.dynamicTyping)
					{
						var value = _results.data[i][j];
						if (value == "true")
							_results.data[i][j] = true;
						else if (value == "false")
							_results.data[i][j] = false;
						else
							_results.data[i][j] = tryParseFloat(value);
					}

					if (_config.header)
					{
						if (j >= _fields.length)
						{
							if (!row["__parsed_extra"])
								row["__parsed_extra"] = [];
							row["__parsed_extra"].push(_results.data[i][j]);
						}
						row[_fields[j]] = _results.data[i][j];
					}
				}

				if (_config.header)
				{
					_results.data[i] = row;
					if (j > _fields.length)
						addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
					else if (j < _fields.length)
						addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
				}
			}

			if (_config.header && _results.meta);
				_results.meta.fields = _fields;

			return _results;
		}

		function guessDelimiter(input)
		{
			var delimChoices = [",", "\t", "|", ";", Baby.RECORD_SEP, Baby.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;

			for (var i = 0; i < delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					delimiter: delim,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++)
				{
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				avgFieldCount /= preview.data.length;

				if ((typeof bestDelta === 'undefined' || delta < bestDelta)
					&& avgFieldCount > 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			}
		}

		function tryParseFloat(val)
		{
			var isNumber = FLOAT.test(val);
			return isNumber ? parseFloat(val) : val;
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}







	function Parser(config)
	{
		var self = this;
		var EMPTY = /^\s*$/;

		var _input;		// The input text being parsed
		var _delimiter;	// The delimiting character
		var _comments;	// Comment character (default '#') or boolean
		var _step;		// The step (streaming) function
		var _callback;	// The callback to invoke when finished
		var _preview;	// Maximum number of lines (not rows) to parse
		var _ch;		// Current character
		var _i;			// Current character's positional index
		var _inQuotes;	// Whether in quotes or not
		var _lineNum;	// Current line number (1-based indexing)
		var _data;		// Parsed data (results)
		var _errors;	// Parse errors
		var _rowIdx;	// Current row index within results (0-based)
		var _colIdx;	// Current col index within result row (0-based)
		var _runningRowIdx;		// Cumulative row index, used by the preview feature
		var _aborted = false;	// Abort flag
		var _paused = false;	// Pause flag

		// Unpack the config object
		config = config || {};
		_delimiter = config.delimiter;
		_comments = config.comments;
		_step = config.step;
		_preview = config.preview;

		// Delimiter integrity check
		if (typeof _delimiter !== 'string'
			|| _delimiter.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(_delimiter) > -1)
			_delimiter = ",";

		// Comment character integrity check
		if (_comments === true)
			_comments = "#";
		else if (typeof _comments !== 'string'
			|| _comments.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(_comments) > -1
			|| _comments == _delimiter)
			_comments = false;


		this.parse = function(input)
		{
			if (typeof input !== 'string')
				throw "Input must be a string";
			reset(input);
			return parserLoop();
		};

		this.abort = function()
		{
			_aborted = true;
		};

		function parserLoop()
		{
			while (_i < _input.length)
			{
				if (_aborted) break;
				if (_preview > 0 && _runningRowIdx >= _preview) break;
				if (_paused) return finishParsing();

				if (_ch == '"')
					parseQuotes();
				else if (_inQuotes)
					parseInQuotes();
				else
					parseNotInQuotes();

				nextChar();
			}

			return finishParsing();
		}

		function nextChar()
		{
			_i++;
			_ch = _input[_i];
		}

		function finishParsing()
		{
			if (_aborted)
				addError("Abort", "ParseAbort", "Parsing was aborted by the user's step function");
			if (_inQuotes)
				addError("Quotes", "MissingQuotes", "Unescaped or mismatched quotes");
			endRow();	// End of input is also end of the last row
			if (!isFunction(_step))
				return returnable();
		}

		function parseQuotes()
		{
			if (quotesOnBoundary() && !quotesEscaped())
				_inQuotes = !_inQuotes;
			else
			{
				saveChar();
				if (_inQuotes && quotesEscaped())
					_i++
				else
					addError("Quotes", "UnexpectedQuotes", "Unexpected quotes");
			}
		}

		function parseInQuotes()
		{
			if (twoCharLineBreak(_i) || oneCharLineBreak(_i))
				_lineNum++;
			saveChar();
		}

		function parseNotInQuotes()
		{
			if (_ch == _delimiter)
				newField();
			else if (twoCharLineBreak(_i))
			{
				newRow();
				nextChar();
			}
			else if (oneCharLineBreak(_i))
				newRow();
			else if (isCommentStart())
				skipLine();
			else
				saveChar();
		}

		function isCommentStart()
		{
			if (!_comments)
				return false;

			var firstCharOfLine = _i == 0
									|| oneCharLineBreak(_i-1)
									|| twoCharLineBreak(_i-2);
			return firstCharOfLine && _input[_i] === _comments;
		}

		function skipLine()
		{
			while (!twoCharLineBreak(_i)
				&& !oneCharLineBreak(_i)
				&& _i < _input.length)
			{
				nextChar();
			}
		}

		function saveChar()
		{
			_data[_rowIdx][_colIdx] += _ch;
		}

		function newField()
		{
			_data[_rowIdx].push("");
			_colIdx = _data[_rowIdx].length - 1;
		}

		function newRow()
		{
			endRow();

			_lineNum++;
			_runningRowIdx++;
			_data.push([]);
			_rowIdx = _data.length - 1;
			newField();
		}

		function endRow()
		{
			trimEmptyLastRow();
			if (isFunction(_step))
			{
				if (_data[_rowIdx])
					_step(returnable(), self);
				clearErrorsAndData();
			}
		}

		function trimEmptyLastRow()
		{
			if (_data[_rowIdx].length == 1 && EMPTY.test(_data[_rowIdx][0]))
			{
				if (config.keepEmptyRows)
					_data[_rowIdx].splice(0, 1);	// leave row, but no fields
				else
					_data.splice(_rowIdx, 1);		// cut out row entirely
				_rowIdx = _data.length - 1;
			}
		}

		function twoCharLineBreak(i)
		{
			return i < _input.length - 1 &&
				((_input[i] == "\r" && _input[i+1] == "\n")
				|| (_input[i] == "\n" && _input[i+1] == "\r"))
		}

		function oneCharLineBreak(i)
		{
			return _input[i] == "\r" || _input[i] == "\n";
		}

		function quotesEscaped()
		{
			// Quotes as data cannot be on boundary, for example: ,"", are not escaped quotes
			return !quotesOnBoundary() && _i < _input.length - 1 && _input[_i+1] == '"';
		}

		function quotesOnBoundary()
		{
			return (!_inQuotes && isBoundary(_i-1)) || isBoundary(_i+1);
		}

		function isBoundary(i)
		{
			if (typeof i != 'number')
				i = _i;

			var ch = _input[i];

			return (i <= -1 || i >= _input.length)
				|| (ch == _delimiter
					|| ch == "\r"
					|| ch == "\n");
		}

		function addError(type, code, msg)
		{
			_errors.push({
				type: type,
				code: code,
				message: msg,
				line: _lineNum,
				row: _rowIdx,
				index: _i
			});
		}

		function reset(input)
		{
			_input = input;
			_inQuotes = false;
			_i = 0, _runningRowIdx = 0, _lineNum = 1;
			clearErrorsAndData();
			_data = [ [""] ];	// starting parsing requires an empty field
			_ch = _input[_i];
		}

		function clearErrorsAndData()
		{
			_data = [];
			_errors = [];
			_rowIdx = 0;
			_colIdx = 0;
		}

		function returnable()
		{
			return {
				data: _data,
				errors: _errors,
				meta: {
					lines: _lineNum,
					delimiter: _delimiter,
					aborted: _aborted
				}
			};
		}
	}

	// Replaces bad config values with good, default ones
	function copyAndValidateConfig(origConfig)
	{
		if (typeof origConfig !== 'object')
			origConfig = {};

		var config = copy(origConfig);

		if (typeof config.delimiter !== 'string'
			|| config.delimiter.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(config.delimiter) > -1)
			config.delimiter = DEFAULTS.delimiter;

		if (typeof config.header !== 'boolean')
			config.header = DEFAULTS.header;

		if (typeof config.dynamicTyping !== 'boolean')
			config.dynamicTyping = DEFAULTS.dynamicTyping;

		if (typeof config.preview !== 'number')
			config.preview = DEFAULTS.preview;

		if (typeof config.step !== 'function')
			config.step = DEFAULTS.step;

		if (typeof config.complete !== 'function')
			config.complete = DEFAULTS.complete;

		if (typeof config.keepEmptyRows !== 'boolean')
			config.keepEmptyRows = DEFAULTS.keepEmptyRows;

		return config;
	}

	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}






	// export to Node...
	if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = Baby;
	}

	// ...or as AMD module...
	else if ( typeof define === 'function' && define.amd ) {
		define( function () { return Baby; });
	}

	// ...or as browser global
	else {
		global.Baby = Baby;
	}



}( typeof window !== 'undefined' ? window : this ));

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/node_modules/numeral/numeral.js":[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/dashboard/dev/node_modules/nvd3/build/nv.d3.js":[function(require,module,exports){
/* nvd3 version 1.7.1(https://github.com/novus/nvd3) 2015-02-05 */
(function(){

// set up main nv object on window
var nv = window.nv || {};
window.nv = nv;

// the major global objects under the nv namespace
nv.dev = false; //set false when in production
nv.tooltip = nv.tooltip || {}; // For the tooltip system
nv.utils = nv.utils || {}; // Utility subsystem
nv.models = nv.models || {}; //stores all the possible models/components
nv.charts = {}; //stores all the ready to use charts
nv.graphs = []; //stores all the graphs currently on the page
nv.logs = {}; //stores some statistics and potential error messages

nv.dispatch = d3.dispatch('render_start', 'render_end');

// Function bind polyfill
// Needed ONLY for phantomJS as it's missing until version 2.0 which is unreleased as of this comment
// https://github.com/ariya/phantomjs/issues/10522
// http://kangax.github.io/compat-table/es5/#Function.prototype.bind
// phantomJS is used for running the test suite
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function () {},
            fBound = function () {
                return fToBind.apply(this instanceof fNOP && oThis
                        ? this
                        : oThis,
                    aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}

//  Development render timers - disabled if dev = false
if (nv.dev) {
    nv.dispatch.on('render_start', function(e) {
        nv.logs.startTime = +new Date();
    });

    nv.dispatch.on('render_end', function(e) {
        nv.logs.endTime = +new Date();
        nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;
        nv.log('total', nv.logs.totalTime); // used for development, to keep track of graph generation times
    });
}

// Logs all arguments, and returns the last so you can test things in place
// Note: in IE8 console.log is an object not a function, and if modernizr is used
// then calling Function.prototype.bind with with anything other than a function
// causes a TypeError to be thrown.
nv.log = function() {
    if (nv.dev && window.console && console.log && console.log.apply)
        console.log.apply(console, arguments);
    else if (nv.dev && window.console && typeof console.log == "function" && Function.prototype.bind) {
        var log = Function.prototype.bind.call(console.log, console);
        log.apply(console, arguments);
    }
    return arguments[arguments.length - 1];
};

// print console warning, should be used by deprecated functions
nv.deprecated = function(name) {
    if (nv.dev && console && console.warn) {
        console.warn('`' + name + '` has been deprecated.');
    }
};

// render function is used to queue up chart rendering
// in non-blocking timeout functions
nv.render = function render(step) {
    // number of graphs to generate in each timeout loop
    step = step || 1;

    nv.render.active = true;
    nv.dispatch.render_start();

    setTimeout(function() {
        var chart, graph;

        for (var i = 0; i < step && (graph = nv.render.queue[i]); i++) {
            chart = graph.generate();
            if (typeof graph.callback == typeof(Function)) graph.callback(chart);
            nv.graphs.push(chart);
        }

        nv.render.queue.splice(0, i);

        if (nv.render.queue.length) setTimeout(arguments.callee, 0);
        else {
            nv.dispatch.render_end();
            nv.render.active = false;
        }
    }, 0);
};

nv.render.active = false;
nv.render.queue = [];

// main function to use when adding a new graph, see examples
nv.addGraph = function(obj) {
    if (typeof arguments[0] === typeof(Function)) {
        obj = {generate: arguments[0], callback: arguments[1]};
    }

    nv.render.queue.push(obj);

    if (!nv.render.active) {
        nv.render();
    }
};/* Utility class to handle creation of an interactive layer.
 This places a rectangle on top of the chart. When you mouse move over it, it sends a dispatch
 containing the X-coordinate. It can also render a vertical line where the mouse is located.

 dispatch.elementMousemove is the important event to latch onto.  It is fired whenever the mouse moves over
 the rectangle. The dispatch is given one object which contains the mouseX/Y location.
 It also has 'pointXValue', which is the conversion of mouseX to the x-axis scale.
 */
nv.interactiveGuideline = function() {
    "use strict";

    var tooltip = nv.models.tooltip();

    //Public settings
    var width = null;
    var height = null;

    //Please pass in the bounding chart's top and left margins
    //This is important for calculating the correct mouseX/Y positions.
    var margin = {left: 0, top: 0}
        , xScale = d3.scale.linear()
        , yScale = d3.scale.linear()
        , dispatch = d3.dispatch('elementMousemove', 'elementMouseout', 'elementClick', 'elementDblclick')
        , showGuideLine = true;
    //Must pass in the bounding chart's <svg> container.
    //The mousemove event is attached to this container.
    var svgContainer = null;

    // check if IE by looking for activeX
    var isMSIE = "ActiveXObject" in window;


    function layer(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width || 960), availableHeight = (height || 400);
            var wrap = container.selectAll("g.nv-wrap.nv-interactiveLineLayer")
                .data([data]);
            var wrapEnter = wrap.enter()
                .append("g").attr("class", " nv-wrap nv-interactiveLineLayer");
            wrapEnter.append("g").attr("class","nv-interactiveGuideLine");

            if (!svgContainer) {
                return;
            }

            function mouseHandler() {
                var d3mouse = d3.mouse(this);
                var mouseX = d3mouse[0];
                var mouseY = d3mouse[1];
                var subtractMargin = true;
                var mouseOutAnyReason = false;
                if (isMSIE) {
                    /*
                     D3.js (or maybe SVG.getScreenCTM) has a nasty bug in Internet Explorer 10.
                     d3.mouse() returns incorrect X,Y mouse coordinates when mouse moving
                     over a rect in IE 10.
                     However, d3.event.offsetX/Y also returns the mouse coordinates
                     relative to the triggering <rect>. So we use offsetX/Y on IE.
                     */
                    mouseX = d3.event.offsetX;
                    mouseY = d3.event.offsetY;

                    /*
                     On IE, if you attach a mouse event listener to the <svg> container,
                     it will actually trigger it for all the child elements (like <path>, <circle>, etc).
                     When this happens on IE, the offsetX/Y is set to where ever the child element
                     is located.
                     As a result, we do NOT need to subtract margins to figure out the mouse X/Y
                     position under this scenario. Removing the line below *will* cause
                     the interactive layer to not work right on IE.
                     */
                    if(d3.event.target.tagName !== "svg") {
                        subtractMargin = false;
                    }

                    if (d3.event.target.className.baseVal.match("nv-legend")) {
                        mouseOutAnyReason = true;
                    }

                }

                if(subtractMargin) {
                    mouseX -= margin.left;
                    mouseY -= margin.top;
                }

                /* If mouseX/Y is outside of the chart's bounds,
                 trigger a mouseOut event.
                 */
                if (mouseX < 0 || mouseY < 0
                    || mouseX > availableWidth || mouseY > availableHeight
                    || (d3.event.relatedTarget && d3.event.relatedTarget.ownerSVGElement === undefined)
                    || mouseOutAnyReason
                    ) {

                    if (isMSIE) {
                        if (d3.event.relatedTarget
                            && d3.event.relatedTarget.ownerSVGElement === undefined
                            && d3.event.relatedTarget.className.match(tooltip.nvPointerEventsClass)) {

                            return;
                        }
                    }
                    dispatch.elementMouseout({
                        mouseX: mouseX,
                        mouseY: mouseY
                    });
                    layer.renderGuideLine(null); //hide the guideline
                    return;
                }

                var pointXValue = xScale.invert(mouseX);
                dispatch.elementMousemove({
                    mouseX: mouseX,
                    mouseY: mouseY,
                    pointXValue: pointXValue
                });

                //If user double clicks the layer, fire a elementDblclick
                if (d3.event.type === "dblclick") {
                    dispatch.elementDblclick({
                        mouseX: mouseX,
                        mouseY: mouseY,
                        pointXValue: pointXValue
                    });
                }

                // if user single clicks the layer, fire elementClick
                if (d3.event.type === 'click') {
                    dispatch.elementClick({
                        mouseX: mouseX,
                        mouseY: mouseY,
                        pointXValue: pointXValue
                    });
                }
            }

            svgContainer
                .on("mousemove",mouseHandler, true)
                .on("mouseout" ,mouseHandler,true)
                .on("dblclick" ,mouseHandler)
                .on("click", mouseHandler)
            ;

            //Draws a vertical guideline at the given X postion.
            layer.renderGuideLine = function(x) {
                if (!showGuideLine) return;
                var line = wrap.select(".nv-interactiveGuideLine")
                    .selectAll("line")
                    .data((x != null) ? [nv.utils.NaNtoZero(x)] : [], String);

                line.enter()
                    .append("line")
                    .attr("class", "nv-guideline")
                    .attr("x1", function(d) { return d;})
                    .attr("x2", function(d) { return d;})
                    .attr("y1", availableHeight)
                    .attr("y2",0)
                ;
                line.exit().remove();

            }
        });
    }

    layer.dispatch = dispatch;
    layer.tooltip = tooltip;

    layer.margin = function(_) {
        if (!arguments.length) return margin;
        margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
        margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        return layer;
    };

    layer.width = function(_) {
        if (!arguments.length) return width;
        width = _;
        return layer;
    };

    layer.height = function(_) {
        if (!arguments.length) return height;
        height = _;
        return layer;
    };

    layer.xScale = function(_) {
        if (!arguments.length) return xScale;
        xScale = _;
        return layer;
    };

    layer.showGuideLine = function(_) {
        if (!arguments.length) return showGuideLine;
        showGuideLine = _;
        return layer;
    };

    layer.svgContainer = function(_) {
        if (!arguments.length) return svgContainer;
        svgContainer = _;
        return layer;
    };

    return layer;
};

/* Utility class that uses d3.bisect to find the index in a given array, where a search value can be inserted.
 This is different from normal bisectLeft; this function finds the nearest index to insert the search value.

 For instance, lets say your array is [1,2,3,5,10,30], and you search for 28.
 Normal d3.bisectLeft will return 4, because 28 is inserted after the number 10.  But interactiveBisect will return 5
 because 28 is closer to 30 than 10.

 Unit tests can be found in: interactiveBisectTest.html

 Has the following known issues:
 * Will not work if the data points move backwards (ie, 10,9,8,7, etc) or if the data points are in random order.
 * Won't work if there are duplicate x coordinate values.
 */
nv.interactiveBisect = function (values, searchVal, xAccessor) {
    "use strict";
    if (! (values instanceof Array)) {
        return null;
    }
    if (typeof xAccessor !== 'function') {
        xAccessor = function(d,i) {
            return d.x;
        }
    }

    var bisect = d3.bisector(xAccessor).left;
    var index = d3.max([0, bisect(values,searchVal) - 1]);
    var currentValue = xAccessor(values[index], index);

    if (typeof currentValue === 'undefined') {
        currentValue = index;
    }

    if (currentValue === searchVal) {
        return index; //found exact match
    }

    var nextIndex = d3.min([index+1, values.length - 1]);
    var nextValue = xAccessor(values[nextIndex], nextIndex);

    if (typeof nextValue === 'undefined') {
        nextValue = nextIndex;
    }

    if (Math.abs(nextValue - searchVal) >= Math.abs(currentValue - searchVal)) {
        return index;
    } else {
        return nextIndex
    }
};

/*
 Returns the index in the array "values" that is closest to searchVal.
 Only returns an index if searchVal is within some "threshold".
 Otherwise, returns null.
 */
nv.nearestValueIndex = function (values, searchVal, threshold) {
    "use strict";
    var yDistMax = Infinity, indexToHighlight = null;
    values.forEach(function(d,i) {
        var delta = Math.abs(searchVal - d);
        if ( delta <= yDistMax && delta < threshold) {
            yDistMax = delta;
            indexToHighlight = i;
        }
    });
    return indexToHighlight;
};
/* Tooltip rendering model for nvd3 charts.
 window.nv.models.tooltip is the updated,new way to render tooltips.

 window.nv.tooltip.show is the old tooltip code.
 window.nv.tooltip.* also has various helper methods.
 */
(function() {
    "use strict";
    window.nv.tooltip = {};

    /* Model which can be instantiated to handle tooltip rendering.
     Example usage:
     var tip = nv.models.tooltip().gravity('w').distance(23)
     .data(myDataObject);

     tip();    //just invoke the returned function to render tooltip.
     */
    window.nv.models.tooltip = function() {
        //HTML contents of the tooltip.  If null, the content is generated via the data variable.
        var content = null;

        /*
        Tooltip data. If data is given in the proper format, a consistent tooltip is generated.
        Example Format of data:
        {
            key: "Date",
            value: "August 2009",
            series: [
                {key: "Series 1", value: "Value 1", color: "#000"},
                {key: "Series 2", value: "Value 2", color: "#00f"}
            ]
        }
        */
        var data = null;

        var gravity = 'w'   //Can be 'n','s','e','w'. Determines how tooltip is positioned.
            ,distance = 50   //Distance to offset tooltip from the mouse location.
            ,snapDistance = 25   //Tolerance allowed before tooltip is moved from its current position (creates 'snapping' effect)
            ,   fixedTop = null //If not null, this fixes the top position of the tooltip.
            ,   classes = null  //Attaches additional CSS classes to the tooltip DIV that is created.
            ,   chartContainer = null   //Parent DIV, of the SVG Container that holds the chart.
            ,   tooltipElem = null  //actual DOM element representing the tooltip.
            ,   position = {left: null, top: null}      //Relative position of the tooltip inside chartContainer.
            ,   enabled = true;  //True -> tooltips are rendered. False -> don't render tooltips.

        //Generates a unique id when you create a new tooltip() object
        var id = "nvtooltip-" + Math.floor(Math.random() * 100000);

        //CSS class to specify whether element should not have mouse events.
        var  nvPointerEventsClass = "nv-pointer-events-none";

        //Format function for the tooltip values column
        var valueFormatter = function(d,i) {
            return d;
        };

        //Format function for the tooltip header value.
        var headerFormatter = function(d) {
            return d;
        };

        //By default, the tooltip model renders a beautiful table inside a DIV.
        //You can override this function if a custom tooltip is desired.
        var contentGenerator = function(d) {
            if (content != null) {
                return content;
            }

            if (d == null) {
                return '';
            }

            var table = d3.select(document.createElement("table"));
            var theadEnter = table.selectAll("thead")
                .data([d])
                .enter().append("thead");

            theadEnter.append("tr")
                .append("td")
                .attr("colspan",3)
                .append("strong")
                .classed("x-value",true)
                .html(headerFormatter(d.value));

            var tbodyEnter = table.selectAll("tbody")
                .data([d])
                .enter().append("tbody");

            var trowEnter = tbodyEnter.selectAll("tr")
                    .data(function(p) { return p.series})
                    .enter()
                    .append("tr")
                    .classed("highlight", function(p) { return p.highlight});

            trowEnter.append("td")
                .classed("legend-color-guide",true)
                .append("div")
                .style("background-color", function(p) { return p.color});

            trowEnter.append("td")
                .classed("key",true)
                .html(function(p) {return p.key});

            trowEnter.append("td")
                .classed("value",true)
                .html(function(p,i) { return valueFormatter(p.value,i) });


            trowEnter.selectAll("td").each(function(p) {
                if (p.highlight) {
                    var opacityScale = d3.scale.linear().domain([0,1]).range(["#fff",p.color]);
                    var opacity = 0.6;
                    d3.select(this)
                        .style("border-bottom-color", opacityScale(opacity))
                        .style("border-top-color", opacityScale(opacity))
                    ;
                }
            });

            var html = table.node().outerHTML;
            if (d.footer !== undefined)
                html += "<div class='footer'>" + d.footer + "</div>";
            return html;

        };

        var dataSeriesExists = function(d) {
            if (d && d.series && d.series.length > 0) {
                return true;
            }
            return false;
        };

        //In situations where the chart is in a 'viewBox', re-position the tooltip based on how far chart is zoomed.
        function convertViewBoxRatio() {
            if (chartContainer) {
                var svg = d3.select(chartContainer);
                if (svg.node().tagName !== "svg") {
                    svg = svg.select("svg");
                }
                var viewBox = (svg.node()) ? svg.attr('viewBox') : null;
                if (viewBox) {
                    viewBox = viewBox.split(' ');
                    var ratio = parseInt(svg.style('width')) / viewBox[2];

                    position.left = position.left * ratio;
                    position.top  = position.top * ratio;
                }
            }
        }

        //Creates new tooltip container, or uses existing one on DOM.
        function getTooltipContainer(newContent) {
            var body;
            if (chartContainer) {
                body = d3.select(chartContainer);
            } else {
                body = d3.select("body");
            }

            var container = body.select(".nvtooltip");
            if (container.node() === null) {
                //Create new tooltip div if it doesn't exist on DOM.
                container = body.append("div")
                    .attr("class", "nvtooltip " + (classes? classes: "xy-tooltip"))
                    .attr("id",id)
                ;
            }

            container.node().innerHTML = newContent;
            container.style("top",0).style("left",0).style("opacity",0);
            container.selectAll("div, table, td, tr").classed(nvPointerEventsClass,true)
            container.classed(nvPointerEventsClass,true);
            return container.node();
        }

        //Draw the tooltip onto the DOM.
        function nvtooltip() {
            if (!enabled) return;
            if (!dataSeriesExists(data)) return;

            convertViewBoxRatio();

            var left = position.left;
            var top = (fixedTop != null) ? fixedTop : position.top;
            var container = getTooltipContainer(contentGenerator(data));
            tooltipElem = container;
            if (chartContainer) {
                var svgComp = chartContainer.getElementsByTagName("svg")[0];
                var boundRect = (svgComp) ? svgComp.getBoundingClientRect() : chartContainer.getBoundingClientRect();
                var svgOffset = {left:0,top:0};
                if (svgComp) {
                    var svgBound = svgComp.getBoundingClientRect();
                    var chartBound = chartContainer.getBoundingClientRect();
                    var svgBoundTop = svgBound.top;

                    //Defensive code. Sometimes, svgBoundTop can be a really negative
                    //  number, like -134254. That's a bug.
                    //  If such a number is found, use zero instead. FireFox bug only
                    if (svgBoundTop < 0) {
                        var containerBound = chartContainer.getBoundingClientRect();
                        svgBoundTop = (Math.abs(svgBoundTop) > containerBound.height) ? 0 : svgBoundTop;
                    }
                    svgOffset.top = Math.abs(svgBoundTop - chartBound.top);
                    svgOffset.left = Math.abs(svgBound.left - chartBound.left);
                }
                //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.
                //You need to also add any offset between the <svg> element and its containing <div>
                //Finally, add any offset of the containing <div> on the whole page.
                left += chartContainer.offsetLeft + svgOffset.left - 2*chartContainer.scrollLeft;
                top += chartContainer.offsetTop + svgOffset.top - 2*chartContainer.scrollTop;
            }

            if (snapDistance && snapDistance > 0) {
                top = Math.floor(top/snapDistance) * snapDistance;
            }

            nv.tooltip.calcTooltipPosition([left,top], gravity, distance, container);
            return nvtooltip;
        }

        nvtooltip.nvPointerEventsClass = nvPointerEventsClass;

        nvtooltip.content = function(_) {
            if (!arguments.length) return content;
            content = _;
            return nvtooltip;
        };

        //Returns tooltipElem...not able to set it.
        nvtooltip.tooltipElem = function() {
            return tooltipElem;
        };

        nvtooltip.contentGenerator = function(_) {
            if (!arguments.length) return contentGenerator;
            if (typeof _ === 'function') {
                contentGenerator = _;
            }
            return nvtooltip;
        };

        nvtooltip.data = function(_) {
            if (!arguments.length) return data;
            data = _;
            return nvtooltip;
        };

        nvtooltip.gravity = function(_) {
            if (!arguments.length) return gravity;
            gravity = _;
            return nvtooltip;
        };

        nvtooltip.distance = function(_) {
            if (!arguments.length) return distance;
            distance = _;
            return nvtooltip;
        };

        nvtooltip.snapDistance = function(_) {
            if (!arguments.length) return snapDistance;
            snapDistance = _;
            return nvtooltip;
        };

        nvtooltip.classes = function(_) {
            if (!arguments.length) return classes;
            classes = _;
            return nvtooltip;
        };

        nvtooltip.chartContainer = function(_) {
            if (!arguments.length) return chartContainer;
            chartContainer = _;
            return nvtooltip;
        };

        nvtooltip.position = function(_) {
            if (!arguments.length) return position;
            position.left = (typeof _.left !== 'undefined') ? _.left : position.left;
            position.top = (typeof _.top !== 'undefined') ? _.top : position.top;
            return nvtooltip;
        };

        nvtooltip.fixedTop = function(_) {
            if (!arguments.length) return fixedTop;
            fixedTop = _;
            return nvtooltip;
        };

        nvtooltip.enabled = function(_) {
            if (!arguments.length) return enabled;
            enabled = _;
            return nvtooltip;
        };

        nvtooltip.valueFormatter = function(_) {
            if (!arguments.length) return valueFormatter;
            if (typeof _ === 'function') {
                valueFormatter = _;
            }
            return nvtooltip;
        };

        nvtooltip.headerFormatter = function(_) {
            if (!arguments.length) return headerFormatter;
            if (typeof _ === 'function') {
                headerFormatter = _;
            }
            return nvtooltip;
        };

        //id() is a read-only function. You can't use it to set the id.
        nvtooltip.id = function() {
            return id;
        };

        return nvtooltip;
    };

    //Original tooltip.show function. Kept for backward compatibility.
    // pos = [left,top]
    nv.tooltip.show = function(pos, content, gravity, dist, parentContainer, classes) {

        //Create new tooltip div if it doesn't exist on DOM.
        var   container = document.createElement('div');
        container.className = 'nvtooltip ' + (classes ? classes : 'xy-tooltip');

        var body = parentContainer;
        if ( !parentContainer || parentContainer.tagName.match(/g|svg/i)) {
            //If the parent element is an SVG element, place tooltip in the <body> element.
            body = document.getElementsByTagName('body')[0];
        }

        container.style.left = 0;
        container.style.top = 0;
        container.style.opacity = 0;
        // Content can also be dom element
        if (typeof content !== 'string')
            container.appendChild(content);
        else
            container.innerHTML = content;
        body.appendChild(container);

        //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.
        if (parentContainer) {
            pos[0] = pos[0] - parentContainer.scrollLeft;
            pos[1] = pos[1] - parentContainer.scrollTop;
        }
        nv.tooltip.calcTooltipPosition(pos, gravity, dist, container);
    };

    //Looks up the ancestry of a DOM element, and returns the first NON-svg node.
    nv.tooltip.findFirstNonSVGParent = function(Elem) {
        while(Elem.tagName.match(/^g|svg$/i) !== null) {
            Elem = Elem.parentNode;
        }
        return Elem;
    };

    //Finds the total offsetTop of a given DOM element.
    //Looks up the entire ancestry of an element, up to the first relatively positioned element.
    nv.tooltip.findTotalOffsetTop = function ( Elem, initialTop ) {
        var offsetTop = initialTop;

        do {
            if( !isNaN( Elem.offsetTop ) ) {
                offsetTop += (Elem.offsetTop);
            }
        } while( Elem = Elem.offsetParent );
        return offsetTop;
    };

    //Finds the total offsetLeft of a given DOM element.
    //Looks up the entire ancestry of an element, up to the first relatively positioned element.
    nv.tooltip.findTotalOffsetLeft = function ( Elem, initialLeft) {
        var offsetLeft = initialLeft;

        do {
            if( !isNaN( Elem.offsetLeft ) ) {
                offsetLeft += (Elem.offsetLeft);
            }
        } while( Elem = Elem.offsetParent );
        return offsetLeft;
    };

    //Global utility function to render a tooltip on the DOM.
    //pos = [left,top] coordinates of where to place the tooltip, relative to the SVG chart container.
    //gravity = how to orient the tooltip
    //dist = how far away from the mouse to place tooltip
    //container = tooltip DIV
    nv.tooltip.calcTooltipPosition = function(pos, gravity, dist, container) {

        var height = parseInt(container.offsetHeight),
            width = parseInt(container.offsetWidth),
            windowWidth = nv.utils.windowSize().width,
            windowHeight = nv.utils.windowSize().height,
            scrollTop = window.pageYOffset,
            scrollLeft = window.pageXOffset,
            left, top;

        windowHeight = window.innerWidth >= document.body.scrollWidth ? windowHeight : windowHeight - 16;
        windowWidth = window.innerHeight >= document.body.scrollHeight ? windowWidth : windowWidth - 16;

        gravity = gravity || 's';
        dist = dist || 20;

        var tooltipTop = function ( Elem ) {
            return nv.tooltip.findTotalOffsetTop(Elem, top);
        };

        var tooltipLeft = function ( Elem ) {
            return nv.tooltip.findTotalOffsetLeft(Elem,left);
        };

        switch (gravity) {
            case 'e':
                left = pos[0] - width - dist;
                top = pos[1] - (height / 2);
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = pos[0] + dist > scrollLeft ? pos[0] + dist : scrollLeft - tLeft + left;
                if (tTop < scrollTop) top = scrollTop - tTop + top;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
            case 'w':
                left = pos[0] + dist;
                top = pos[1] - (height / 2);
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft + width > windowWidth) left = pos[0] - width - dist;
                if (tTop < scrollTop) top = scrollTop + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
            case 'n':
                left = pos[0] - (width / 2) - 5;
                top = pos[1] + dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width/2 + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
            case 's':
                left = pos[0] - (width / 2);
                top = pos[1] - height - dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width/2 + 5;
                if (scrollTop > tTop) top = scrollTop;
                break;
            case 'none':
                left = pos[0];
                top = pos[1] - dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                break;
        }

        container.style.left = left+'px';
        container.style.top = top+'px';
        container.style.opacity = 1;
        container.style.position = 'absolute';

        return container;
    };

    //Global utility function to remove tooltips from the DOM.
    nv.tooltip.cleanup = function() {

        // Find the tooltips, mark them for removal by this class (so others cleanups won't find it)
        var tooltips = document.getElementsByClassName('nvtooltip');
        var purging = [];
        while(tooltips.length) {
            purging.push(tooltips[0]);
            tooltips[0].style.transitionDelay = '0 !important';
            tooltips[0].style.opacity = 0;
            tooltips[0].className = 'nvtooltip-pending-removal';
        }

        setTimeout(function() {

            while (purging.length) {
                var removeMe = purging.pop();
                removeMe.parentNode.removeChild(removeMe);
            }
        }, 500);
    };

})();


/*
Gets the browser window size

Returns object with height and width properties
 */
nv.utils.windowSize = function() {
    // Sane defaults
    var size = {width: 640, height: 480};

    // Earlier IE uses Doc.body
    if (document.body && document.body.offsetWidth) {
        size.width = document.body.offsetWidth;
        size.height = document.body.offsetHeight;
    }

    // IE can use depending on mode it is in
    if (document.compatMode=='CSS1Compat' &&
        document.documentElement &&
        document.documentElement.offsetWidth ) {

        size.width = document.documentElement.offsetWidth;
        size.height = document.documentElement.offsetHeight;
    }

    // Most recent browsers use
    if (window.innerWidth && window.innerHeight) {
        size.width = window.innerWidth;
        size.height = window.innerHeight;
    }
    return (size);
};


/*
Binds callback function to run when window is resized
 */
nv.utils.windowResize = function(handler) {
    if (window.addEventListener) {
        window.addEventListener('resize', handler);
    } else {
        nv.log("ERROR: Failed to bind to window.resize with: ", handler);
    }
    // return object with clear function to remove the single added callback.
    return {
        callback: handler,
        clear: function() {
            window.removeEventListener('resize', handler);
        }
    }
};


/*
Backwards compatible way to implement more d3-like coloring of graphs.
If passed an array, wrap it in a function which implements the old behavior
Else return what was passed in
*/
nv.utils.getColor = function(color) {
    //if you pass in nothing, get default colors back
    if (!arguments.length) {
        return nv.utils.defaultColor();

    //if passed an array, wrap it in a function
    } else if(color instanceof Array) {
        return function(d, i) { return d.color || color[i % color.length]; };

    //if passed a function, return the function, or whatever it may be
    //external libs, such as angularjs-nvd3-directives use this
    } else {
        //can't really help it if someone passes rubbish as color
        return color;
    }
};


/*
Default color chooser uses the index of an object as before.
 */
nv.utils.defaultColor = function() {
    var colors = d3.scale.category20().range();
    return function(d, i) {
        return d.color || colors[i % colors.length]
    };
};


/*
Returns a color function that takes the result of 'getKey' for each series and
looks for a corresponding color from the dictionary
*/
nv.utils.customTheme = function(dictionary, getKey, defaultColors) {
    // use default series.key if getKey is undefined
    getKey = getKey || function(series) { return series.key };
    defaultColors = defaultColors || d3.scale.category20().range();

    // start at end of default color list and walk back to index 0
    var defIndex = defaultColors.length;

    return function(series, index) {
        var key = getKey(series);
        if (typeof dictionary[key] === 'function') {
            return dictionary[key]();
        } else if (dictionary[key] !== undefined) {
            return dictionary[key];
        } else {
            // no match in dictionary, use a default color
            if (!defIndex) {
                // used all the default colors, start over
                defIndex = defaultColors.length;
            }
            defIndex = defIndex - 1;
            return defaultColors[defIndex];
        }
    };
};


/*
From the PJAX example on d3js.org, while this is not really directly needed
it's a very cool method for doing pjax, I may expand upon it a little bit,
open to suggestions on anything that may be useful
*/
nv.utils.pjax = function(links, content) {

    var load = function(href) {
        d3.html(href, function(fragment) {
            var target = d3.select(content).node();
            target.parentNode.replaceChild(
                d3.select(fragment).select(content).node(),
                target);
            nv.utils.pjax(links, content);
        });
    };

    d3.selectAll(links).on("click", function() {
        history.pushState(this.href, this.textContent, this.href);
        load(this.href);
        d3.event.preventDefault();
    });

    d3.select(window).on("popstate", function() {
        if (d3.event.state) {
            load(d3.event.state);
        }
    });
};


/*
For when we want to approximate the width in pixels for an SVG:text element.
Most common instance is when the element is in a display:none; container.
Forumla is : text.length * font-size * constant_factor
*/
nv.utils.calcApproxTextWidth = function (svgTextElem) {
    if (typeof svgTextElem.style === 'function'
        && typeof svgTextElem.text === 'function') {

        var fontSize = parseInt(svgTextElem.style("font-size").replace("px",""));
        var textLength = svgTextElem.text().length;
        return textLength * fontSize * 0.5;
    }
    return 0;
};


/*
Numbers that are undefined, null or NaN, convert them to zeros.
*/
nv.utils.NaNtoZero = function(n) {
    if (typeof n !== 'number'
        || isNaN(n)
        || n === null
        || n === Infinity
        || n === -Infinity) {

        return 0;
    }
    return n;
};

/*
Add a way to watch for d3 transition ends to d3
*/
d3.selection.prototype.watchTransition = function(renderWatch){
    var args = [this].concat([].slice.call(arguments, 1));
    return renderWatch.transition.apply(renderWatch, args);
};


/*
Helper object to watch when d3 has rendered something
*/
nv.utils.renderWatch = function(dispatch, duration) {
    if (!(this instanceof nv.utils.renderWatch)) {
        return new nv.utils.renderWatch(dispatch, duration);
    }

    var _duration = duration !== undefined ? duration : 250;
    var renderStack = [];
    var self = this;

    this.models = function(models) {
        models = [].slice.call(arguments, 0);
        models.forEach(function(model){
            model.__rendered = false;
            (function(m){
                m.dispatch.on('renderEnd', function(arg){
                    m.__rendered = true;
                    self.renderEnd('model');
                });
            })(model);

            if (renderStack.indexOf(model) < 0) {
                renderStack.push(model);
            }
        });
    return this;
    };

    this.reset = function(duration) {
        if (duration !== undefined) {
            _duration = duration;
        }
        renderStack = [];
    };

    this.transition = function(selection, args, duration) {
        args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];

        if (args.length > 1) {
            duration = args.pop();
        } else {
            duration = _duration !== undefined ? _duration : 250;
        }
        selection.__rendered = false;

        if (renderStack.indexOf(selection) < 0) {
            renderStack.push(selection);
        }

        if (duration === 0) {
            selection.__rendered = true;
            selection.delay = function() { return this; };
            selection.duration = function() { return this; };
            return selection;
        } else {
            if (selection.length === 0) {
                selection.__rendered = true;
            } else if (selection.every( function(d){ return !d.length; } )) {
                selection.__rendered = true;
            } else {
                selection.__rendered = false;
            }

            var n = 0;
            return selection
                .transition()
                .duration(duration)
                .each(function(){ ++n; })
                .each('end', function(d, i) {
                    if (--n === 0) {
                        selection.__rendered = true;
                        self.renderEnd.apply(this, args);
                    }
                });
        }
    };

    this.renderEnd = function() {
        if (renderStack.every( function(d){ return d.__rendered; } )) {
            renderStack.forEach( function(d){ d.__rendered = false; });
            dispatch.renderEnd.apply(this, arguments);
        }
    }

};


/*
Takes multiple objects and combines them into the first one (dst)
example:  nv.utils.deepExtend({a: 1}, {a: 2, b: 3}, {c: 4});
gives:  {a: 2, b: 3, c: 4}
*/
nv.utils.deepExtend = function(dst){
    var sources = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
    sources.forEach(function(source) {
        for (key in source) {
            var isArray = dst[key] instanceof Array;
            var isObject = typeof dst[key] === 'object';
            var srcObj = typeof source[key] === 'object';

            if (isObject && !isArray && srcObj) {
                nv.utils.deepExtend(dst[key], source[key]);
            } else {
                dst[key] = source[key];
            }
        }
    });
};


/*
state utility object, used to track d3 states in the models
*/
nv.utils.state = function(){
    if (!(this instanceof nv.utils.state)) {
        return new nv.utils.state();
    }
    var state = {};
    var _self = this;
    var _setState = function(){};
    var _getState = function(){ return {}; };
    var init = null;
    var changed = null;

    this.dispatch = d3.dispatch('change', 'set');

    this.dispatch.on('set', function(state){
        _setState(state, true);
    });

    this.getter = function(fn){
        _getState = fn;
        return this;
    };

    this.setter = function(fn, callback) {
        if (!callback) {
            callback = function(){};
        }
        _setState = function(state, update){
            fn(state);
            if (update) {
                callback();
            }
        };
        return this;
    };

    this.init = function(state){
        init = init || {};
        nv.utils.deepExtend(init, state);
    };

    var _set = function(){
        var settings = _getState();

        if (JSON.stringify(settings) === JSON.stringify(state)) {
            return false;
        }

        for (var key in settings) {
            if (state[key] === undefined) {
                state[key] = {};
            }
            state[key] = settings[key];
            changed = true;
        }
        return true;
    };

    this.update = function(){
        if (init) {
            _setState(init, false);
            init = null;
        }
        if (_set.call(this)) {
            this.dispatch.change(state);
        }
    };

};


/*
Snippet of code you can insert into each nv.models.* to give you the ability to
do things like:
chart.options({
  showXAxis: true,
  tooltips: true
});

To enable in the chart:
chart.options = nv.utils.optionsFunc.bind(chart);
*/
nv.utils.optionsFunc = function(args) {
    nv.deprecated('nv.utils.optionsFunc');
    if (args) {
        d3.map(args).forEach((function(key,value) {
            if (typeof this[key] === "function") {
                this[key](value);
            }
        }).bind(this));
    }
    return this;
};


/*
numTicks:  requested number of ticks
data:  the chart data

returns the number of ticks to actually use on X axis, based on chart data
to avoid duplicate ticks with the same value
*/
nv.utils.calcTicksX = function(numTicks, data) {
    // find max number of values from all data streams
    var numValues = 1;
    var i = 0;
    for (i; i < data.length; i += 1) {
        var stream_len = data[i] && data[i].values ? data[i].values.length : 0;
        numValues = stream_len > numValues ? stream_len : numValues;
    }
    nv.log("Requested number of ticks: ", numTicks);
    nv.log("Calculated max values to be: ", numValues);
    // make sure we don't have more ticks than values to avoid duplicates
    numTicks = numTicks > numValues ? numTicks = numValues - 1 : numTicks;
    // make sure we have at least one tick
    numTicks = numTicks < 1 ? 1 : numTicks;
    // make sure it's an integer
    numTicks = Math.floor(numTicks);
    nv.log("Calculating tick count as: ", numTicks);
    return numTicks;
};


/*
returns number of ticks to actually use on Y axis, based on chart data
*/
nv.utils.calcTicksY = function(numTicks, data) {
    // currently uses the same logic but we can adjust here if needed later
    return nv.utils.calcTicksX(numTicks, data);
};


/*
Add a particular option from an options object onto chart
Options exposed on a chart are a getter/setter function that returns chart
on set to mimic typical d3 option chaining, e.g. svg.option1('a').option2('b');

option objects should be generated via Object.create() to provide
the option of manipulating data via get/set functions.
*/
nv.utils.initOption = function(chart, name) {
    // if it's a call option, just call it directly, otherwise do get/set
    if (chart._calls && chart._calls[name]) {
        chart[name] = chart._calls[name];
    } else {
        chart[name] = function (_) {
            if (!arguments.length) return chart._options[name];
            chart._options[name] = _;
            return chart;
        };
    }
};


/*
Add all options in an options object to the chart
*/
nv.utils.initOptions = function(chart) {
    var ops = Object.getOwnPropertyNames(chart._options || {});
    var calls = Object.getOwnPropertyNames(chart._calls || {});
    ops = ops.concat(calls);
    for (var i in ops) {
        nv.utils.initOption(chart, ops[i]);
    }
};


/*
Inherit options from a D3 object
d3.rebind makes calling the function on target actually call it on source
Also use _d3options so we can track what we inherit for documentation and chained inheritance
*/
nv.utils.inheritOptionsD3 = function(target, d3_source, oplist) {
    target._d3options = oplist.concat(target._d3options || []);
    oplist.unshift(d3_source);
    oplist.unshift(target);
    d3.rebind.apply(this, oplist);
};


/*
Remove duplicates from an array
*/
nv.utils.arrayUnique = function(a) {
    return a.sort().filter(function(item, pos) {
        return !pos || item != a[pos - 1];
    });
};


/*
Keeps a list of custom symbols to draw from in addition to d3.svg.symbol
Necessary since d3 doesn't let you extend its list -_-
Add new symbols by doing nv.utils.symbols.set('name', function(size){...});
*/
nv.utils.symbolMap = d3.map();


/*
Replaces d3.svg.symbol so that we can look both there and our own map
 */
nv.utils.symbol = function() {
    var type,
        size = 64;
    function symbol(d,i) {
        var t = type.call(this,d,i);
        var s = size.call(this,d,i);
        if (d3.svg.symbolTypes.indexOf(t) !== -1) {
            return d3.svg.symbol().type(t).size(s)();
        } else {
            return nv.utils.symbolMap.get(t)(s);
        }
    }
    symbol.type = function(_) {
        if (!arguments.length) return type;
        type = d3.functor(_);
        return symbol;
    };
    symbol.size = function(_) {
        if (!arguments.length) return size;
        size = d3.functor(_);
        return symbol;
    };
    return symbol;
};


/*
Inherit option getter/setter functions from source to target
d3.rebind makes calling the function on target actually call it on source
Also track via _inherited and _d3options so we can track what we inherit
for documentation generation purposes and chained inheritance
*/
nv.utils.inheritOptions = function(target, source) {
    // inherit all the things
    var ops = Object.getOwnPropertyNames(source._options || {});
    var calls = Object.getOwnPropertyNames(source._calls || {});
    var inherited = source._inherited || [];
    var d3ops = source._d3options || [];
    var args = ops.concat(calls).concat(inherited).concat(d3ops);
    args.unshift(source);
    args.unshift(target);
    d3.rebind.apply(this, args);
    // pass along the lists to keep track of them, don't allow duplicates
    target._inherited = nv.utils.arrayUnique(ops.concat(calls).concat(inherited).concat(ops).concat(target._inherited || []));
    target._d3options = nv.utils.arrayUnique(d3ops.concat(target._d3options || []));
};


/*
Runs common initialize code on the svg before the chart builds
*/
nv.utils.initSVG = function(svg) {
    svg.classed({'nvd3-svg':true});
};nv.models.axis = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var axis = d3.svg.axis();
    var scale = d3.scale.linear();

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 75 //only used for tickLabel currently
        , height = 60 //only used for tickLabel currently
        , axisLabelText = null
        , showMaxMin = true //TODO: showMaxMin should be disabled on all ordinal scaled axes
        , highlightZero = true
        , rotateLabels = 0
        , rotateYLabel = true
        , staggerLabels = false
        , isOrdinal = false
        , ticks = null
        , axisLabelDistance = 0
        , duration = 250
        , dispatch = d3.dispatch('renderEnd')
        , axisRendered = false
        , maxMinRendered = false
        ;
    axis
        .scale(scale)
        .orient('bottom')
        .tickFormat(function(d) { return d })
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var scale0;
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-axis').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-axis');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g')

            if (ticks !== null)
                axis.ticks(ticks);
            else if (axis.orient() == 'top' || axis.orient() == 'bottom')
                axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);

            //TODO: consider calculating width/height based on whether or not label is added, for reference in charts using this component
            g.watchTransition(renderWatch, 'axis').call(axis);

            scale0 = scale0 || axis.scale();

            var fmt = axis.tickFormat();
            if (fmt == null) {
                fmt = scale0.tickFormat();
            }

            var axisLabel = g.selectAll('text.nv-axislabel')
                .data([axisLabelText || null]);
            axisLabel.exit().remove();

            switch (axis.orient()) {
                case 'top':
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    var w;
                    if (scale.range().length < 2) {
                        w = 0;
                    } else if (scale.range().length === 2) {
                        w = scale.range()[1];
                    } else {
                        w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);
                    }
                    axisLabel
                        .attr('text-anchor', 'middle')
                        .attr('y', 0)
                        .attr('x', w/2);
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            .data(scale.domain());
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale(d)) + ',0)'
                            })
                            .select('text')
                            .attr('dy', '-0.5em')
                            .attr('y', -axis.tickPadding())
                            .attr('text-anchor', 'middle')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max top')
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale.range()[i]) + ',0)'
                            });
                    }
                    break;
                case 'bottom':
                    var xLabelMargin = axisLabelDistance + 36;
                    var maxTextWidth = 30;
                    var xTicks = g.selectAll('g').select("text");
                    if (rotateLabels%360) {
                        //Calculate the longest xTick width
                        xTicks.each(function(d,i){
                            var width = this.getBoundingClientRect().width;
                            if(width > maxTextWidth) maxTextWidth = width;
                        });
                        //Convert to radians before calculating sin. Add 30 to margin for healthy padding.
                        var sin = Math.abs(Math.sin(rotateLabels*Math.PI/180));
                        var xLabelMargin = (sin ? sin*maxTextWidth : maxTextWidth)+30;
                        //Rotate all xTicks
                        xTicks
                            .attr('transform', function(d,i,j) { return 'rotate(' + rotateLabels + ' 0,0)' })
                            .style('text-anchor', rotateLabels%360 > 0 ? 'start' : 'end');
                    }
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    var w;
                    if (scale.range().length < 2) {
                        w = 0;
                    } else if (scale.range().length === 2) {
                        w = scale.range()[1];
                    } else {
                        w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);
                    }
                    axisLabel
                        .attr('text-anchor', 'middle')
                        .attr('y', xLabelMargin)
                        .attr('x', w/2);
                    if (showMaxMin) {
                        //if (showMaxMin && !isOrdinal) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            //.data(scale.domain())
                            .data([scale.domain()[0], scale.domain()[scale.domain().length - 1]]);
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'
                            })
                            .select('text')
                            .attr('dy', '.71em')
                            .attr('y', axis.tickPadding())
                            .attr('transform', function(d,i,j) { return 'rotate(' + rotateLabels + ' 0,0)' })
                            .style('text-anchor', rotateLabels ? (rotateLabels%360 > 0 ? 'start' : 'end') : 'middle')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max bottom')
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'
                            });
                    }
                    if (staggerLabels)
                        xTicks
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + (i % 2 == 0 ? '0' : '12') + ')'
                            });

                    break;
                case 'right':
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    axisLabel
                        .style('text-anchor', rotateYLabel ? 'middle' : 'begin')
                        .attr('transform', rotateYLabel ? 'rotate(90)' : '')
                        .attr('y', rotateYLabel ? (-Math.max(margin.right,width) + 12) : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart
                        .attr('x', rotateYLabel ? (scale.range()[0] / 2) : axis.tickPadding());
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            .data(scale.domain());
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text')
                            .style('opacity', 0);
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale(d)) + ')'
                            })
                            .select('text')
                            .attr('dy', '.32em')
                            .attr('y', 0)
                            .attr('x', axis.tickPadding())
                            .style('text-anchor', 'start')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max right')
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'
                            })
                            .select('text')
                            .style('opacity', 1);
                    }
                    break;
                case 'left':
                    /*
                     //For dynamically placing the label. Can be used with dynamically-sized chart axis margins
                     var yTicks = g.selectAll('g').select("text");
                     yTicks.each(function(d,i){
                     var labelPadding = this.getBoundingClientRect().width + axis.tickPadding() + 16;
                     if(labelPadding > width) width = labelPadding;
                     });
                     */
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    axisLabel
                        .style('text-anchor', rotateYLabel ? 'middle' : 'end')
                        .attr('transform', rotateYLabel ? 'rotate(-90)' : '')
                        .attr('y', rotateYLabel ? (-Math.max(margin.left,width) + 25 - (axisLabelDistance || 0)) : -10)
                        .attr('x', rotateYLabel ? (-scale.range()[0] / 2) : -axis.tickPadding());
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            .data(scale.domain());
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text')
                            .style('opacity', 0);
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale0(d)) + ')'
                            })
                            .select('text')
                            .attr('dy', '.32em')
                            .attr('y', 0)
                            .attr('x', -axis.tickPadding())
                            .attr('text-anchor', 'end')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max right')
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'
                            })
                            .select('text')
                            .style('opacity', 1);
                    }
                    break;
            }
            axisLabel.text(function(d) { return d });

            if (showMaxMin && (axis.orient() === 'left' || axis.orient() === 'right')) {
                //check if max and min overlap other values, if so, hide the values that overlap
                g.selectAll('g') // the g's wrapping each tick
                    .each(function(d,i) {
                        d3.select(this).select('text').attr('opacity', 1);
                        if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) { // 10 is assuming text height is 16... if d is 0, leave it!
                            if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                                d3.select(this).attr('opacity', 0);

                            d3.select(this).select('text').attr('opacity', 0); // Don't remove the ZERO line!!
                        }
                    });

                //if Max and Min = 0 only show min, Issue #281
                if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0) {
                    wrap.selectAll('g.nv-axisMaxMin').style('opacity', function (d, i) {
                        return !i ? 1 : 0
                    });
                }
            }

            if (showMaxMin && (axis.orient() === 'top' || axis.orient() === 'bottom')) {
                var maxMinRange = [];
                wrap.selectAll('g.nv-axisMaxMin')
                    .each(function(d,i) {
                        try {
                            if (i) // i== 1, max position
                                maxMinRange.push(scale(d) - this.getBoundingClientRect().width - 4)  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                            else // i==0, min position
                                maxMinRange.push(scale(d) + this.getBoundingClientRect().width + 4)
                        }catch (err) {
                            if (i) // i== 1, max position
                                maxMinRange.push(scale(d) - 4);  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                            else // i==0, min position
                                maxMinRange.push(scale(d) + 4);
                        }
                    });
                // the g's wrapping each tick
                g.selectAll('g').each(function(d,i) {
                    if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {
                        if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                            d3.select(this).remove();
                        else
                            d3.select(this).select('text').remove(); // Don't remove the ZERO line!!
                    }
                });
            }

            //highlight zero line ... Maybe should not be an option and should just be in CSS?
            if (highlightZero) {
                g.selectAll('.tick')
                    .filter(function (d) {
                        return !parseFloat(Math.round(this.__data__ * 100000) / 1000000) && (this.__data__ !== undefined)
                    }) //this is because sometimes the 0 tick is a very small fraction, TODO: think of cleaner technique
                    .classed('zero', true);
            }
            //store old scales for use in transitions on update
            scale0 = scale.copy();

        });

        renderWatch.renderEnd('axis immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.axis = axis;
    chart.dispatch = dispatch;

    chart.options = nv.utils.optionsFunc.bind(chart);
    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        axisLabelDistance: {get: function(){return axisLabelDistance;}, set: function(_){axisLabelDistance=_;}},
        staggerLabels:     {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
        rotateLabels:      {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
        rotateYLabel:      {get: function(){return rotateYLabel;}, set: function(_){rotateYLabel=_;}},
        highlightZero:     {get: function(){return highlightZero;}, set: function(_){highlightZero=_;}},
        showMaxMin:        {get: function(){return showMaxMin;}, set: function(_){showMaxMin=_;}},
        axisLabel:         {get: function(){return axisLabelText;}, set: function(_){axisLabelText=_;}},
        height:            {get: function(){return height;}, set: function(_){height=_;}},
        ticks:             {get: function(){return ticks;}, set: function(_){ticks=_;}},
        width:             {get: function(){return width;}, set: function(_){width=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top !== undefined    ? _.top    : margin.top;
            margin.right  = _.right !== undefined  ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left !== undefined   ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration=_;
            renderWatch.reset(duration);
        }},
        scale: {get: function(){return scale;}, set: function(_){
            scale = _;
            axis.scale(scale);
            isOrdinal = typeof scale.rangeBands === 'function';
            nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);
        }}
    });

    nv.utils.initOptions(chart);
    nv.utils.inheritOptionsD3(chart, axis, ['orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat']);
    nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);

    return chart;
};

// Chart design based on the recommendations of Stephen Few. Implementation
// based on the work of Clint Ivy, Jamie Love, and Jason Davies.
// http://projects.instantcognition.com/protovis/bulletchart/

nv.models.bullet = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , orient = 'left' // TODO top & bottom
        , reverse = false
        , ranges = function(d) { return d.ranges }
        , markers = function(d) { return d.markers ? d.markers : [0] }
        , measures = function(d) { return d.measures }
        , rangeLabels = function(d) { return d.rangeLabels ? d.rangeLabels : [] }
        , markerLabels = function(d) { return d.markerLabels ? d.markerLabels : []  }
        , measureLabels = function(d) { return d.measureLabels ? d.measureLabels : []  }
        , forceX = [0] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
        , width = 380
        , height = 30
        , tickFormat = null
        , color = nv.utils.getColor(['#1f77b4'])
        , dispatch = d3.dispatch('elementMouseover', 'elementMouseout')
        ;

    function chart(selection) {
        selection.each(function(d, i) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            var rangez = ranges.call(this, d, i).slice().sort(d3.descending),
                markerz = markers.call(this, d, i).slice().sort(d3.descending),
                measurez = measures.call(this, d, i).slice().sort(d3.descending),
                rangeLabelz = rangeLabels.call(this, d, i).slice(),
                markerLabelz = markerLabels.call(this, d, i).slice(),
                measureLabelz = measureLabels.call(this, d, i).slice();

            // Setup Scales
            // Compute the new x-scale.
            var x1 = d3.scale.linear()
                .domain( d3.extent(d3.merge([forceX, rangez])) )
                .range(reverse ? [availableWidth, 0] : [0, availableWidth]);

            // Retrieve the old x-scale, if this is an update.
            var x0 = this.__chart__ || d3.scale.linear()
                .domain([0, Infinity])
                .range(x1.range());

            // Stash the new scale.
            this.__chart__ = x1;

            var rangeMin = d3.min(rangez), //rangez[2]
                rangeMax = d3.max(rangez), //rangez[0]
                rangeAvg = rangez[1];

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-bullet').data([d]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bullet');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('rect').attr('class', 'nv-range nv-rangeMax');
            gEnter.append('rect').attr('class', 'nv-range nv-rangeAvg');
            gEnter.append('rect').attr('class', 'nv-range nv-rangeMin');
            gEnter.append('rect').attr('class', 'nv-measure');
            gEnter.append('path').attr('class', 'nv-markerTriangle');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
                w1 = function(d) { return Math.abs(x1(d) - x1(0)) };
            var xp0 = function(d) { return d < 0 ? x0(d) : x0(0) },
                xp1 = function(d) { return d < 0 ? x1(d) : x1(0) };

            g.select('rect.nv-rangeMax')
                .attr('height', availableHeight)
                .attr('width', w1(rangeMax > 0 ? rangeMax : rangeMin))
                .attr('x', xp1(rangeMax > 0 ? rangeMax : rangeMin))
                .datum(rangeMax > 0 ? rangeMax : rangeMin)

            g.select('rect.nv-rangeAvg')
                .attr('height', availableHeight)
                .attr('width', w1(rangeAvg))
                .attr('x', xp1(rangeAvg))
                .datum(rangeAvg)

            g.select('rect.nv-rangeMin')
                .attr('height', availableHeight)
                .attr('width', w1(rangeMax))
                .attr('x', xp1(rangeMax))
                .attr('width', w1(rangeMax > 0 ? rangeMin : rangeMax))
                .attr('x', xp1(rangeMax > 0 ? rangeMin : rangeMax))
                .datum(rangeMax > 0 ? rangeMin : rangeMax)

            g.select('rect.nv-measure')
                .style('fill', color)
                .attr('height', availableHeight / 3)
                .attr('y', availableHeight / 3)
                .attr('width', measurez < 0 ?
                    x1(0) - x1(measurez[0])
                    : x1(measurez[0]) - x1(0))
                .attr('x', xp1(measurez))
                .on('mouseover', function() {
                    dispatch.elementMouseover({
                        value: measurez[0],
                        label: measureLabelz[0] || 'Current',
                        pos: [x1(measurez[0]), availableHeight/2]
                    })
                })
                .on('mouseout', function() {
                    dispatch.elementMouseout({
                        value: measurez[0],
                        label: measureLabelz[0] || 'Current'
                    })
                });

            var h3 =  availableHeight / 6;
            if (markerz[0]) {
                g.selectAll('path.nv-markerTriangle')
                    .attr('transform', function(d) { return 'translate(' + x1(markerz[0]) + ',' + (availableHeight / 2) + ')' })
                    .attr('d', 'M0,' + h3 + 'L' + h3 + ',' + (-h3) + ' ' + (-h3) + ',' + (-h3) + 'Z')
                    .on('mouseover', function() {
                        dispatch.elementMouseover({
                            value: markerz[0],
                            label: markerLabelz[0] || 'Previous',
                            pos: [x1(markerz[0]), availableHeight/2]
                        })
                    })
                    .on('mouseout', function() {
                        dispatch.elementMouseout({
                            value: markerz[0],
                            label: markerLabelz[0] || 'Previous'
                        })
                    });
            } else {
                g.selectAll('path.nv-markerTriangle').remove();
            }

            wrap.selectAll('.nv-range')
                .on('mouseover', function(d,i) {
                    var label = rangeLabelz[i] || (!i ? "Maximum" : i == 1 ? "Mean" : "Minimum");

                    dispatch.elementMouseover({
                        value: d,
                        label: label,
                        pos: [x1(d), availableHeight/2]
                    })
                })
                .on('mouseout', function(d,i) {
                    var label = rangeLabelz[i] || (!i ? "Maximum" : i == 1 ? "Mean" : "Minimum");

                    dispatch.elementMouseout({
                        value: d,
                        label: label
                    })
                });
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)
        markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)
        measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)
        forceX:      {get: function(){return forceX;}, set: function(_){forceX=_;}},
        width:    {get: function(){return width;}, set: function(_){width=_;}},
        height:    {get: function(){return height;}, set: function(_){height=_;}},
        tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom
            orient = _;
            reverse = orient == 'right' || orient == 'bottom';
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};



// Chart design based on the recommendations of Stephen Few. Implementation
// based on the work of Clint Ivy, Jamie Love, and Jason Davies.
// http://projects.instantcognition.com/protovis/bulletchart/
nv.models.bulletChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var bullet = nv.models.bullet()
        ;

    var orient = 'left' // TODO top & bottom
        , reverse = false
        , margin = {top: 5, right: 40, bottom: 20, left: 120}
        , ranges = function(d) { return d.ranges }
        , markers = function(d) { return d.markers ? d.markers : [0] }
        , measures = function(d) { return d.measures }
        , width = null
        , height = 55
        , tickFormat = null
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + x + '</h3>' +
                '<p>' + y + '</p>'
        }
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ) + margin.left,
            top = e.pos[1] + ( offsetElement.offsetTop || 0) + margin.top,
            content = tooltip(e.key, e.label, e.value, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);
    };

    function chart(selection) {
        selection.each(function(d, i) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                that = this;

            chart.update = function() { chart(selection) };
            chart.container = this;

            // Display No Data message if there's nothing to show.
            if (!d || !ranges.call(this, d, i)) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', 18 + margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            var rangez = ranges.call(this, d, i).slice().sort(d3.descending),
                markerz = markers.call(this, d, i).slice().sort(d3.descending),
                measurez = measures.call(this, d, i).slice().sort(d3.descending);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-bulletChart').data([d]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bulletChart');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-bulletWrap');
            gEnter.append('g').attr('class', 'nv-titles');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Compute the new x-scale.
            var x1 = d3.scale.linear()
                .domain([0, Math.max(rangez[0], markerz[0], measurez[0])])  // TODO: need to allow forceX and forceY, and xDomain, yDomain
                .range(reverse ? [availableWidth, 0] : [0, availableWidth]);

            // Retrieve the old x-scale, if this is an update.
            var x0 = this.__chart__ || d3.scale.linear()
                .domain([0, Infinity])
                .range(x1.range());

            // Stash the new scale.
            this.__chart__ = x1;

            var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
                w1 = function(d) { return Math.abs(x1(d) - x1(0)) };

            var title = gEnter.select('.nv-titles').append('g')
                .attr('text-anchor', 'end')
                .attr('transform', 'translate(-6,' + (height - margin.top - margin.bottom) / 2 + ')');
            title.append('text')
                .attr('class', 'nv-title')
                .text(function(d) { return d.title; });

            title.append('text')
                .attr('class', 'nv-subtitle')
                .attr('dy', '1em')
                .text(function(d) { return d.subtitle; });

            bullet
                .width(availableWidth)
                .height(availableHeight)

            var bulletWrap = g.select('.nv-bulletWrap');
            d3.transition(bulletWrap).call(bullet);

            // Compute the tick format.
            var format = tickFormat || x1.tickFormat( availableWidth / 100 );

            // Update the tick groups.
            var tick = g.selectAll('g.nv-tick')
                .data(x1.ticks( availableWidth / 50 ), function(d) {
                    return this.textContent || format(d);
                });

            // Initialize the ticks with the old scale, x0.
            var tickEnter = tick.enter().append('g')
                .attr('class', 'nv-tick')
                .attr('transform', function(d) { return 'translate(' + x0(d) + ',0)' })
                .style('opacity', 1e-6);

            tickEnter.append('line')
                .attr('y1', availableHeight)
                .attr('y2', availableHeight * 7 / 6);

            tickEnter.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '1em')
                .attr('y', availableHeight * 7 / 6)
                .text(format);

            // Transition the updating ticks to the new scale, x1.
            var tickUpdate = d3.transition(tick)
                .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
                .style('opacity', 1);

            tickUpdate.select('line')
                .attr('y1', availableHeight)
                .attr('y2', availableHeight * 7 / 6);

            tickUpdate.select('text')
                .attr('y', availableHeight * 7 / 6);

            // Transition the exiting ticks to the new scale, x1.
            d3.transition(tick.exit())
                .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
                .style('opacity', 1e-6)
                .remove();

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            dispatch.on('tooltipShow', function(e) {
                e.key = d.title;
                if (tooltips) showTooltip(e, that.parentNode);
            });

        });

        d3.timer.flush();
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    bullet.dispatch.on('elementMouseover.tooltip', function(e) {
        dispatch.tooltipShow(e);
    });

    bullet.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.bullet = bullet;
    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)
        markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)
        measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)
        width:    {get: function(){return width;}, set: function(_){width=_;}},
        height:    {get: function(){return height;}, set: function(_){height=_;}},
        tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom
            orient = _;
            reverse = orient == 'right' || orient == 'bottom';
        }}
    });

    nv.utils.inheritOptions(chart, bullet);
    nv.utils.initOptions(chart);

    return chart;
};



nv.models.cumulativeLineChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , controls = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 30, bottom: 50, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , tooltips = true
        , showControls = true
        , useInteractiveGuideline = false
        , rescaleY = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , id = lines.id()
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , average = function(d) { return d.average }
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , transitionDuration = 250
        , duration = 250
        , noErrorCheck = false  //if set to TRUE, will bypass an error check in the indexify function.
        ;

    state.index = 0;
    state.rescaleY = rescaleY;

    xAxis
        .orient('bottom')
        .tickPadding(7)
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
    ;

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var dx = d3.scale.linear()
        , index = {i: 0, x: 0}
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                index: index.i,
                rescaleY: rescaleY
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.index !== undefined)
                index.i = state.index;
            if (state.rescaleY !== undefined)
                rescaleY = state.rescaleY;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(lines);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);
        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);
            container.classed('nv-chart-' + id, true);
            var that = this;

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition().duration(duration).call(chart)
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            var indexDrag = d3.behavior.drag()
                .on('dragstart', dragStart)
                .on('drag', dragMove)
                .on('dragend', dragEnd);


            function dragStart(d,i) {
                d3.select(chart.container)
                    .style('cursor', 'ew-resize');
            }

            function dragMove(d,i) {
                index.x = d3.event.x;
                index.i = Math.round(dx.invert(index.x));
                updateZero();
            }

            function dragEnd(d,i) {
                d3.select(chart.container)
                    .style('cursor', 'auto');

                // update state and send stateChange with new index
                state.index = index.i;
                dispatch.stateChange(state);
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();

            if (!rescaleY) {
                var seriesDomains = data
                    .filter(function(series) { return !series.disabled })
                    .map(function(series,i) {
                        var initialDomain = d3.extent(series.values, lines.y());

                        //account for series being disabled when losing 95% or more
                        if (initialDomain[0] < -.95) initialDomain[0] = -.95;

                        return [
                                (initialDomain[0] - initialDomain[1]) / (1 + initialDomain[1]),
                                (initialDomain[1] - initialDomain[0]) / (1 + initialDomain[0])
                        ];
                    });

                var completeDomain = [
                    d3.min(seriesDomains, function(d) { return d[0] }),
                    d3.max(seriesDomains, function(d) { return d[1] })
                ];

                lines.yDomain(completeDomain);
            } else {
                lines.yDomain(null);
            }

            dx.domain([0, data[0].values.length - 1]) //Assumes all series have same length
                .range([0, availableWidth])
                .clamp(true);

            var data = indexify(index.i, data);

            // Setup containers and skeleton of chart
            var interactivePointerEvents = (useInteractiveGuideline) ? "none" : "all";
            var wrap = container.selectAll('g.nv-wrap.nv-cumulativeLine').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-cumulativeLine').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-interactive');
            gEnter.append('g').attr('class', 'nv-x nv-axis').style("pointer-events","none");
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-background');
            gEnter.append('g').attr('class', 'nv-linesWrap').style("pointer-events",interactivePointerEvents);
            gEnter.append('g').attr('class', 'nv-avgLinesWrap').style("pointer-events","none");
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    { key: 'Re-scale y-axis', disabled: !rescaleY }
                ];

                controls
                    .width(140)
                    .color(['#444', '#444', '#444'])
                    .rightAlign(false)
                    .margin({top: 5, right: 0, bottom: 5, left: 20})
                ;

                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
                    .call(controls);
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Show error if series goes below 100%
            var tempDisabled = data.filter(function(d) { return d.tempDisabled });

            wrap.select('.tempDisabled').remove(); //clean-up and prevent duplicates
            if (tempDisabled.length) {
                wrap.append('text').attr('class', 'tempDisabled')
                    .attr('x', availableWidth / 2)
                    .attr('y', '-.71em')
                    .style('text-anchor', 'end')
                    .text(tempDisabled.map(function(d) { return d.key }).join(', ') + ' values cannot be calculated for this time period.');
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left:margin.left,top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            gEnter.select('.nv-background')
                .append('rect');

            g.select('.nv-background rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            lines
                //.x(function(d) { return d.x })
                .y(function(d) { return d.display.y })
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled && !data[i].tempDisabled; }));

            var linesWrap = g.select('.nv-linesWrap')
                .datum(data.filter(function(d) { return  !d.disabled && !d.tempDisabled }));

            linesWrap.call(lines);

            //Store a series index number in the data array.
            data.forEach(function(d,i) {
                d.seriesIndex = i;
            });

            var avgLineData = data.filter(function(d) {
                return !d.disabled && !!average(d);
            });

            var avgLines = g.select(".nv-avgLinesWrap").selectAll("line")
                .data(avgLineData, function(d) { return d.key; });

            var getAvgLineY = function(d) {
                //If average lines go off the svg element, clamp them to the svg bounds.
                var yVal = y(average(d));
                if (yVal < 0) return 0;
                if (yVal > availableHeight) return availableHeight;
                return yVal;
            };

            avgLines.enter()
                .append('line')
                .style('stroke-width',2)
                .style('stroke-dasharray','10,10')
                .style('stroke',function (d,i) {
                    return lines.color()(d,d.seriesIndex);
                })
                .attr('x1',0)
                .attr('x2',availableWidth)
                .attr('y1', getAvgLineY)
                .attr('y2', getAvgLineY);

            avgLines
                .style('stroke-opacity',function(d){
                    //If average lines go offscreen, make them transparent
                    var yVal = y(average(d));
                    if (yVal < 0 || yVal > availableHeight) return 0;
                    return 1;
                })
                .attr('x1',0)
                .attr('x2',availableWidth)
                .attr('y1', getAvgLineY)
                .attr('y2', getAvgLineY);

            avgLines.exit().remove();

            //Create index line
            var indexLine = linesWrap.selectAll('.nv-indexLine')
                .data([index]);
            indexLine.enter().append('rect').attr('class', 'nv-indexLine')
                .attr('width', 3)
                .attr('x', -2)
                .attr('fill', 'red')
                .attr('fill-opacity', .5)
                .style("pointer-events","all")
                .call(indexDrag);

            indexLine
                .attr('transform', function(d) { return 'translate(' + dx(d.i) + ',0)' })
                .attr('height', availableHeight);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/70, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            function updateZero() {
                indexLine
                    .data([index]);

                //When dragging the index line, turn off line transitions.
                // Then turn them back on when done dragging.
                var oldDuration = chart.duration();
                chart.duration(0);
                chart.update();
                chart.duration(oldDuration);
            }

            g.select('.nv-background rect')
                .on('click', function() {
                    index.x = d3.mouse(this)[0];
                    index.i = Math.round(dx.invert(index.x));

                    // update state and send stateChange with new index
                    state.index = index.i;
                    dispatch.stateChange(state);

                    updateZero();
                });

            lines.dispatch.on('elementClick', function(e) {
                index.i = e.pointIndex;
                index.x = dx(index.i);

                // update state and send stateChange with new index
                state.index = index.i;
                dispatch.stateChange(state);

                updateZero();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                d.disabled = !d.disabled;
                rescaleY = !d.disabled;

                state.rescaleY = rescaleY;
                dispatch.stateChange(state);
                chart.update();
            });

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                lines.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];

                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        lines.highlightPoint(i, pointIndex, true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex)
                        });
                    });

                //Highlight the tooltip entry based on which point the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                    var threshold = 0.03 * domainExtent;
                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
                    if (indexToHighlight !== null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex), pointIndex);
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(function(d,i) {
                        return yAxis.tickFormat()(d);
                    })
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);
            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                lines.clearHighlights();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.index !== 'undefined') {
                    index.i = e.index;
                    index.x = dx(index.i);

                    state.index = e.index;

                    indexLine
                        .data([index]);
                }

                if (typeof e.rescaleY !== 'undefined') {
                    rescaleY = e.rescaleY;
                }

                chart.update();
            });

        });

        renderWatch.renderEnd('cumulativeLineChart immediate');

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Functions
    //------------------------------------------------------------

    var indexifyYGetter = null;
    /* Normalize the data according to an index point. */
    function indexify(idx, data) {
        if (!indexifyYGetter) indexifyYGetter = lines.y();
        return data.map(function(line, i) {
            if (!line.values) {
                return line;
            }
            var indexValue = line.values[idx];
            if (indexValue == null) {
                return line;
            }
            var v = indexifyYGetter(indexValue, idx);

            //TODO: implement check below, and disable series if series loses 100% or more cause divide by 0 issue
            if (v < -.95 && !noErrorCheck) {
                //if a series loses more than 100%, calculations fail.. anything close can cause major distortion (but is mathematically correct till it hits 100)

                line.tempDisabled = true;
                return line;
            }

            line.tempDisabled = false;

            line.values = line.values.map(function(point, pointIndex) {
                point.display = {'y': (indexifyYGetter(point, pointIndex) - v) / (1 + v) };
                return point;
            });

            return line;
        })
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.lines = lines;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;
    chart.state = state;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        rescaleY:     {get: function(){return rescaleY;}, set: function(_){rescaleY=_;}},
        showControls:     {get: function(){return showControls;}, set: function(_){showControls=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        average: {get: function(){return average;}, set: function(_){average=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        showXAxis:    {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        noErrorCheck:    {get: function(){return noErrorCheck;}, set: function(_){noErrorCheck=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (_ === true) {
                chart.interactive(false);
                chart.useVoronoi(false);
            }
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }},
        duration:    {get: function(){return duration;}, set: function(_){
            duration = _;
            lines.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
            renderWatch.reset(duration);
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};//TODO: consider deprecating by adding necessary features to multiBar model
nv.models.discreteBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.ordinal()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
        , color = nv.utils.defaultColor()
        , showValues = false
        , valueFormat = d3.format(',.2f')
        , xDomain
        , yDomain
        , xRange
        , yRange
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout','renderEnd')
        , rectClass = 'discreteBar'
        , duration = 250
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0;
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                data.map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i), y0: d.y0 }
                    })
                });

            x   .domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                .rangeBands(xRange || [0, availableWidth], .1);
            y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return d.y }).concat(forceY)));

            // If showValues, pad the Y axis range to account for label height
            if (showValues) y.range(yRange || [availableHeight - (y.domain()[0] < 0 ? 12 : 0), y.domain()[1] > 0 ? 12 : 0]);
            else y.range(yRange || [availableHeight, 0]);

            //store old scales if they exist
            x0 = x0 || x;
            y0 = y0 || y.copy().range([y(0),y(0)]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-discretebar').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discretebar');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            //TODO: by definition, the discrete bar should not have multiple groups, will modify/remove later
            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d) { return d.key });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);
            groups.exit()
                .watchTransition(renderWatch, 'discreteBar: exit groups')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6)
                .remove();
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover });
            groups
                .watchTransition(renderWatch, 'discreteBar: groups')
                .style('stroke-opacity', 1)
                .style('fill-opacity', .75);

            var bars = groups.selectAll('g.nv-bar')
                .data(function(d) { return d.values });
            bars.exit().remove();

            var barsEnter = bars.enter().append('g')
                .attr('transform', function(d,i,j) {
                    return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 ) + ', ' + y(0) + ')'
                })
                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    dispatch.elementClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    dispatch.elementDblClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });

            barsEnter.append('rect')
                .attr('height', 0)
                .attr('width', x.rangeBand() * .9 / data.length )

            if (showValues) {
                barsEnter.append('text')
                    .attr('text-anchor', 'middle')
                ;

                bars.select('text')
                    .text(function(d,i) { return valueFormat(getY(d,i)) })
                    .watchTransition(renderWatch, 'discreteBar: bars text')
                    .attr('x', x.rangeBand() * .9 / 2)
                    .attr('y', function(d,i) { return getY(d,i) < 0 ? y(getY(d,i)) - y(0) + 12 : -4 })

                ;
            } else {
                bars.selectAll('text').remove();
            }

            bars
                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive' })
                .style('fill', function(d,i) { return d.color || color(d,i) })
                .style('stroke', function(d,i) { return d.color || color(d,i) })
                .select('rect')
                .attr('class', rectClass)
                .watchTransition(renderWatch, 'discreteBar: bars rect')
                .attr('width', x.rangeBand() * .9 / data.length);
            bars.watchTransition(renderWatch, 'discreteBar: bars')
                //.delay(function(d,i) { return i * 1200 / data[0].values.length })
                .attr('transform', function(d,i) {
                    var left = x(getX(d,i)) + x.rangeBand() * .05,
                        top = getY(d,i) < 0 ?
                            y(0) :
                                y(0) - y(getY(d,i)) < 1 ?
                            y(0) - 1 : //make 1 px positive bars show up above y=0
                            y(getY(d,i));

                    return 'translate(' + left + ', ' + top + ')'
                })
                .select('rect')
                .attr('height', function(d,i) {
                    return  Math.max(Math.abs(y(getY(d,i)) - y((yDomain && yDomain[0]) || 0)) || 1)
                });


            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

        });

        renderWatch.renderEnd('discreteBar immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
        id:          {get: function(){return id;}, set: function(_){id=_;}},
        rectClass: {get: function(){return rectClass;}, set: function(_){rectClass=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.discreteBarChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var discretebar = nv.models.discreteBar()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        ;

    var margin = {top: 15, right: 10, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.getColor()
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , staggerLabels = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + x + '</h3>' +
                '<p>' +  y + '</p>'
        }
        , x
        , y
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'beforeUpdate','renderEnd')
        , duration = 250
        ;

    xAxis
        .orient('bottom')
        .highlightZero(false)
        .showMaxMin(false)
        .tickFormat(function(d) { return d })
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
        .tickFormat(d3.format(',.1f'))
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(discretebar.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(discretebar.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(discretebar);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                dispatch.beforeUpdate();
                container.transition().duration(duration).call(chart);
            };
            chart.container = this;

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = discretebar.xScale();
            y = discretebar.yScale().clamp(true);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-discreteBarWithAxes').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discreteBarWithAxes').append('g');
            var defsEnter = gEnter.append('defs');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis')
                .append('g').attr('class', 'nv-zeroLine')
                .append('line');

            gEnter.append('g').attr('class', 'nv-barsWrap');

            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Main Chart Component(s)
            discretebar
                .width(availableWidth)
                .height(availableHeight);

            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }))

            barsWrap.transition().call(discretebar);


            defsEnter.append('clipPath')
                .attr('id', 'nv-x-label-clip-' + discretebar.id())
                .append('rect');

            g.select('#nv-x-label-clip-' + discretebar.id() + ' rect')
                .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))
                .attr('height', 16)
                .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + (y.range()[0] + ((discretebar.showValues() && y.domain()[0] < 0) ? 16 : 0)) + ')');
                g.select('.nv-x.nv-axis').call(xAxis);

                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                if (staggerLabels) {
                    xTicks
                        .selectAll('text')
                        .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')' })
                }
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis').call(yAxis);
            }

            // Zero line
            g.select(".nv-zeroLine line")
                .attr("x1",0)
                .attr("x2",availableWidth)
                .attr("y1", y(0))
                .attr("y2", y(0))
            ;

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

        });

        renderWatch.renderEnd('discreteBar chart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    discretebar.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    discretebar.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.discretebar = discretebar;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            discretebar.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            discretebar.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }}
    });

    nv.utils.inheritOptions(chart, discretebar);
    nv.utils.initOptions(chart);

    return chart;
}

nv.models.distribution = function() {
    "use strict";
    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 400 //technically width or height depending on x or y....
        , size = 8
        , axis = 'x' // 'x' or 'y'... horizontal or vertical
        , getData = function(d) { return d[axis] }  // defaults d.x or d.y
        , color = nv.utils.defaultColor()
        , scale = d3.scale.linear()
        , domain
        , duration = 250
        , dispatch = d3.dispatch('renderEnd')
        ;

    //============================================================


    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var scale0;
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    //============================================================


    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableLength = width - (axis === 'x' ? margin.left + margin.right : margin.top + margin.bottom),
                naxis = axis == 'x' ? 'y' : 'x',
                container = d3.select(this);
            nv.utils.initSVG(container);

            //------------------------------------------------------------
            // Setup Scales

            scale0 = scale0 || scale;

            //------------------------------------------------------------


            //------------------------------------------------------------
            // Setup containers and skeleton of chart

            var wrap = container.selectAll('g.nv-distribution').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-distribution');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

            //------------------------------------------------------------


            var distWrap = g.selectAll('g.nv-dist')
                .data(function(d) { return d }, function(d) { return d.key });

            distWrap.enter().append('g');
            distWrap
                .attr('class', function(d,i) { return 'nv-dist nv-series-' + i })
                .style('stroke', function(d,i) { return color(d, i) });

            var dist = distWrap.selectAll('line.nv-dist' + axis)
                .data(function(d) { return d.values })
            dist.enter().append('line')
                .attr(axis + '1', function(d,i) { return scale0(getData(d,i)) })
                .attr(axis + '2', function(d,i) { return scale0(getData(d,i)) })
            renderWatch.transition(distWrap.exit().selectAll('line.nv-dist' + axis), 'dist exit')
                // .transition()
                .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
                .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })
                .style('stroke-opacity', 0)
                .remove();
            dist
                .attr('class', function(d,i) { return 'nv-dist' + axis + ' nv-dist' + axis + '-' + i })
                .attr(naxis + '1', 0)
                .attr(naxis + '2', size);
            renderWatch.transition(dist, 'dist')
                // .transition()
                .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
                .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })


            scale0 = scale.copy();

        });
        renderWatch.renderEnd('distribution immediate');
        return chart;
    }


    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------
    chart.options = nv.utils.optionsFunc.bind(chart);
    chart.dispatch = dispatch;

    chart.margin = function(_) {
        if (!arguments.length) return margin;
        margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
        margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
        margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
        margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        return chart;
    };

    chart.width = function(_) {
        if (!arguments.length) return width;
        width = _;
        return chart;
    };

    chart.axis = function(_) {
        if (!arguments.length) return axis;
        axis = _;
        return chart;
    };

    chart.size = function(_) {
        if (!arguments.length) return size;
        size = _;
        return chart;
    };

    chart.getData = function(_) {
        if (!arguments.length) return getData;
        getData = d3.functor(_);
        return chart;
    };

    chart.scale = function(_) {
        if (!arguments.length) return scale;
        scale = _;
        return chart;
    };

    chart.color = function(_) {
        if (!arguments.length) return color;
        color = nv.utils.getColor(_);
        return chart;
    };

    chart.duration = function(_) {
        if (!arguments.length) return duration;
        duration = _;
        renderWatch.reset(duration);
        return chart;
    };
    //============================================================


    return chart;
}
//TODO: consider deprecating and using multibar with single series for this
nv.models.historicalBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = null
        , height = null
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.linear()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , forceX = []
        , forceY = [0]
        , padData = false
        , clipEdge = true
        , color = nv.utils.defaultColor()
        , xDomain
        , yDomain
        , xRange
        , yRange
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        , interactive = true
        ;

    var renderWatch = nv.utils.renderWatch(dispatch, 0);

    function chart(selection) {
        selection.each(function(data) {
            renderWatch.reset();

            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            // Setup Scales
            x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));

            if (padData)
                x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
            else
                x.range(xRange || [0, availableWidth]);

            y.domain(yDomain || d3.extent(data[0].values.map(getY).concat(forceY) ))
                .range(yRange || [availableHeight, 0]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-historicalBar-' + id).data([data[0].values]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBar-' + id);
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-bars');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            container
                .on('click', function(d,i) {
                    dispatch.chartClick({
                        data: d,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                });

            defsEnter.append('clipPath')
                .attr('id', 'nv-chart-clip-path-' + id)
                .append('rect');

            wrap.select('#nv-chart-clip-path-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');

            var bars = wrap.select('.nv-bars').selectAll('.nv-bar')
                .data(function(d) { return d }, function(d,i) {return getX(d,i)});
            bars.exit().remove();

            var barsEnter = bars.enter().append('rect')
                .attr('x', 0 )
                .attr('y', function(d,i) {  return nv.utils.NaNtoZero(y(Math.max(0, getY(d,i)))) })
                .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.abs(y(getY(d,i)) - y(0))) })
                .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })
                .on('mouseover', function(d,i) {
                    if (!interactive) return;
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        point: d,
                        series: data[0],
                        pos: [x(getX(d,i)), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });

                })
                .on('mouseout', function(d,i) {
                    if (!interactive) return;
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        point: d,
                        series: data[0],
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    if (!interactive) return;
                    dispatch.elementClick({
                        //label: d[label],
                        value: getY(d,i),
                        data: d,
                        index: i,
                        pos: [x(getX(d,i)), y(getY(d,i))],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    if (!interactive) return;
                    dispatch.elementDblClick({
                        //label: d[label],
                        value: getY(d,i),
                        data: d,
                        index: i,
                        pos: [x(getX(d,i)), y(getY(d,i))],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                });

            bars
                .attr('fill', function(d,i) { return color(d, i); })
                .attr('class', function(d,i,j) { return (getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i })
                .watchTransition(renderWatch, 'bars')
                .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })
                //TODO: better width calculations that don't assume always uniform data spacing;w
                .attr('width', (availableWidth / data[0].values.length) * .9 );

            bars.watchTransition(renderWatch, 'bars')
                .attr('y', function(d,i) {
                    var rval = getY(d,i) < 0 ?
                        y(0) :
                            y(0) - y(getY(d,i)) < 1 ?
                        y(0) - 1 :
                        y(getY(d,i));
                    return nv.utils.NaNtoZero(rval);
                })
                .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.max(Math.abs(y(getY(d,i)) - y(0)),1)) });

        });

        renderWatch.renderEnd('historicalBar immediate');
        return chart;
    }

    //Create methods to allow outside functions to highlight a specific bar.
    chart.highlightPoint = function(pointIndex, isHoverOver) {
        d3.select(".nv-historicalBar-" + id)
            .select(".nv-bars .nv-bar-0-" + pointIndex)
            .classed("hover", isHoverOver)
        ;
    };

    chart.clearHighlights = function() {
        d3.select(".nv-historicalBar-" + id)
            .select(".nv-bars .nv-bar.hover")
            .classed("hover", false)
        ;
    };

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        forceX:  {get: function(){return forceX;}, set: function(_){forceX=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        padData: {get: function(){return padData;}, set: function(_){padData=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        id:          {get: function(){return id;}, set: function(_){id=_;}},
        interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.historicalBarChart = function(bar_model) {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var bars = bar_model || nv.models.historicalBar()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;


    var margin = {top: 30, right: 90, bottom: 50, left: 90}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , showLegend = false
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , useInteractiveGuideline = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , x
        , y
        , state = {}
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , transitionDuration = 250
        ;

    xAxis
        .orient('bottom')
        .tickPadding(7)
    ;
    yAxis
        .orient( (rightAlignYAxis) ? 'right' : 'left')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {

        // New addition to calculate position if SVG is scaled with viewBox, may move TODO: consider implementing everywhere else
        if (offsetElement) {
            var svg = d3.select(offsetElement).select('svg');
            var viewBox = (svg.node()) ? svg.attr('viewBox') : null;
            if (viewBox) {
                viewBox = viewBox.split(' ');
                var ratio = parseInt(svg.style('width')) / viewBox[2];
                e.pos[0] = e.pos[0] * ratio;
                e.pos[1] = e.pos[1] * ratio;
            }
        }

        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(bars.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(bars.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };
    var renderWatch = nv.utils.renderWatch(dispatch, 0);

    function chart(selection) {
        selection.each(function(data) {
            renderWatch.reset();
            renderWatch.models(bars);
            if (showXAxis) renderWatch.models(xAxis);
            if (showYAxis) renderWatch.models(yAxis);

            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;


            chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
            chart.container = this;

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = bars.xScale();
            y = bars.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-historicalBarChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBarChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-barsWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-interactive');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left:margin.left, top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }
            bars
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));

            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }));
            barsWrap.transition().call(bars);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .transition()
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .transition()
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                bars.clearHighlights();

                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        bars.highlightPoint(pointIndex,true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex),
                            data: series.values[pointIndex]
                        });
                    });

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(function(d,i) {
                        return yAxis.tickFormat()(d);
                    })
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                bars.clearHighlights();
            });

            legend.dispatch.on('legendClick', function(d,i) {
                d.disabled = !d.disabled;

                if (!data.filter(function(d) { return !d.disabled }).length) {
                    data.map(function(d) {
                        d.disabled = false;
                        wrap.selectAll('.nv-series').classed('disabled', false);
                        return d;
                    });
                }

                state.disabled = data.map(function(d) { return !!d.disabled });
                dispatch.stateChange(state);

                selection.transition().call(chart);
            });

            legend.dispatch.on('legendDblclick', function(d) {
                //Double clicking should always enable current series, and disabled all others.
                data.forEach(function(d) {
                    d.disabled = true;
                });
                d.disabled = false;

                state.disabled = data.map(function(d) { return !!d.disabled });
                dispatch.stateChange(state);
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                chart.update();
            });
        });

        renderWatch.renderEnd('historicalBarChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    bars.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.bars = bars;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            bars.color(color);
        }},
        duration:    {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration=_;
            renderWatch.reset(transitionDuration);
            yAxis.duration(transitionDuration);
            xAxis.duration(transitionDuration);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (_ === true) {
                chart.interactive(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, bars);
    nv.utils.initOptions(chart);

    return chart;
};


// ohlcChart is just a historical chart with oclc bars and some tweaks
nv.models.ohlcBarChart = function() {
    var chart = nv.models.historicalBarChart(nv.models.ohlcBar());

    // special default tooltip since we show multiple values per x
    chart.useInteractiveGuideline(true);
    chart.interactiveLayer.tooltip.contentGenerator(function(data) {
        // we assume only one series exists for this chart
        var d = data.series[0].data;
        // match line colors as defined in nv.d3.css
        var color = d.open < d.close ? "2ca02c" : "d62728";
        return '' +
            '<h3 style="color: #' + color + '">' + data.value + '</h3>' +
            '<table>' +
            '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' +
            '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' +
            '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' +
            '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' +
            '</table>';
    });
    return chart;
};nv.models.legend = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 5, right: 0, bottom: 5, left: 0}
        , width = 400
        , height = 20
        , getKey = function(d) { return d.key }
        , color = nv.utils.defaultColor()
        , align = true
        , rightAlign = true
        , updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.
        , radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)
        , dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange')
        ;

    function chart(selection) {
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-legend').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');
            var g = wrap.select('g');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var series = g.selectAll('.nv-series')
                .data(function(d) { return d });
            var seriesEnter = series.enter().append('g').attr('class', 'nv-series')
                .on('mouseover', function(d,i) {
                    dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects
                })
                .on('mouseout', function(d,i) {
                    dispatch.legendMouseout(d,i);
                })
                .on('click', function(d,i) {
                    dispatch.legendClick(d,i);
                    if (updateState) {
                        if (radioButtonMode) {
                            //Radio button mode: set every series to disabled,
                            //  and enable the clicked series.
                            data.forEach(function(series) { series.disabled = true});
                            d.disabled = false;
                        }
                        else {
                            d.disabled = !d.disabled;
                            if (data.every(function(series) { return series.disabled})) {
                                //the default behavior of NVD3 legends is, if every single series
                                // is disabled, turn all series' back on.
                                data.forEach(function(series) { series.disabled = false});
                            }
                        }
                        dispatch.stateChange({
                            disabled: data.map(function(d) { return !!d.disabled })
                        });
                    }
                })
                .on('dblclick', function(d,i) {
                    dispatch.legendDblclick(d,i);
                    if (updateState) {
                        //the default behavior of NVD3 legends, when double clicking one,
                        // is to set all other series' to false, and make the double clicked series enabled.
                        data.forEach(function(series) {
                            series.disabled = true;
                        });
                        d.disabled = false;
                        dispatch.stateChange({
                            disabled: data.map(function(d) { return !!d.disabled })
                        });
                    }
                });
            seriesEnter.append('circle')
                .style('stroke-width', 2)
                .attr('class','nv-legend-symbol')
                .attr('r', 5);
            seriesEnter.append('text')
                .attr('text-anchor', 'start')
                .attr('class','nv-legend-text')
                .attr('dy', '.32em')
                .attr('dx', '8');
            series.classed('nv-disabled', function(d) { return d.disabled });
            series.exit().remove();
            series.select('circle')
                .style('fill', function(d,i) { return d.color || color(d,i)})
                .style('stroke', function(d,i) { return d.color || color(d, i) });
            series.select('text').text(getKey);

            //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)
            // NEW ALIGNING CODE, TODO: clean up
            if (align) {

                var seriesWidths = [];
                series.each(function(d,i) {
                    var legendText = d3.select(this).select('text');
                    var nodeTextLength;
                    try {
                        nodeTextLength = legendText.node().getComputedTextLength();
                        // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead
                        if(nodeTextLength <= 0) throw Error();
                    }
                    catch(e) {
                        nodeTextLength = nv.utils.calcApproxTextWidth(legendText);
                    }

                    seriesWidths.push(nodeTextLength + 28); // 28 is ~ the width of the circle plus some padding
                });

                var seriesPerRow = 0;
                var legendWidth = 0;
                var columnWidths = [];

                while ( legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
                    columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
                    legendWidth += seriesWidths[seriesPerRow++];
                }
                if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row

                while ( legendWidth > availableWidth && seriesPerRow > 1 ) {
                    columnWidths = [];
                    seriesPerRow--;

                    for (var k = 0; k < seriesWidths.length; k++) {
                        if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0) )
                            columnWidths[k % seriesPerRow] = seriesWidths[k];
                    }

                    legendWidth = columnWidths.reduce(function(prev, cur, index, array) {
                        return prev + cur;
                    });
                }

                var xPositions = [];
                for (var i = 0, curX = 0; i < seriesPerRow; i++) {
                    xPositions[i] = curX;
                    curX += columnWidths[i];
                }

                series
                    .attr('transform', function(d, i) {
                        return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * 20) + ')';
                    });

                //position legend as far right as possible within the total width
                if (rightAlign) {
                    g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');
                }
                else {
                    g.attr('transform', 'translate(0' + ',' + margin.top + ')');
                }

                height = margin.top + margin.bottom + (Math.ceil(seriesWidths.length / seriesPerRow) * 20);

            } else {

                var ypos = 5,
                    newxpos = 5,
                    maxwidth = 0,
                    xpos;
                series
                    .attr('transform', function(d, i) {
                        var length = d3.select(this).select('text').node().getComputedTextLength() + 28;
                        xpos = newxpos;

                        if (width < margin.left + margin.right + xpos + length) {
                            newxpos = xpos = 5;
                            ypos += 20;
                        }

                        newxpos += length;
                        if (newxpos > maxwidth) maxwidth = newxpos;

                        return 'translate(' + xpos + ',' + ypos + ')';
                    });

                //position legend as far right as possible within the total width
                g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');

                height = margin.top + margin.bottom + ypos + 15;
            }
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        key: {get: function(){return getKey;}, set: function(_){getKey=_;}},
        align:      {get: function(){return align;}, set: function(_){align=_;}},
        rightAlign:    {get: function(){return rightAlign;}, set: function(_){rightAlign=_;}},
        updateState:    {get: function(){return updateState;}, set: function(_){updateState=_;}},
        radioButtonMode:    {get: function(){return radioButtonMode;}, set: function(_){radioButtonMode=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.line = function() {
    "use strict";
    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var  scatter = nv.models.scatter()
        ;

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , color = nv.utils.defaultColor() // a function that returns a color
        , getX = function(d) { return d.x } // accessor to get the x value from a data point
        , getY = function(d) { return d.y } // accessor to get the y value from a data point
        , defined = function(d,i) { return !isNaN(getY(d,i)) && getY(d,i) !== null } // allows a line to be not continuous when it is not defined
        , isArea = function(d) { return d.area } // decides if a line is an area or just a line
        , clipEdge = false // if true, masks lines within x and y scale
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , interpolate = "linear" // controls the line interpolation
        , duration = 250
        , dispatch = d3.dispatch('elementClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;

    scatter
        .pointSize(16) // default size
        .pointDomain([16,256]) //set to speed up calculation, needs to be unset if there is a custom size accessor
    ;

    //============================================================


    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0 //used to store previous scales
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    //============================================================


    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(scatter);
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup Scales
            x = scatter.xScale();
            y = scatter.yScale();

            x0 = x0 || x;
            y0 = y0 || y;

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-line').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-line');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            gEnter.append('g').attr('class', 'nv-scatterWrap');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            scatter
                .width(availableWidth)
                .height(availableHeight);

            var scatterWrap = wrap.select('.nv-scatterWrap');
            scatterWrap.call(scatter);

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + scatter.id())
                .append('rect');

            wrap.select('#nv-edge-clip-' + scatter.id() + ' rect')
                .attr('width', availableWidth)
                .attr('height', (availableHeight > 0) ? availableHeight : 0);

            g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');
            scatterWrap
                .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');

            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d) { return d.key });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);

            groups.exit().remove();

            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover })
                .style('fill', function(d,i){ return color(d, i) })
                .style('stroke', function(d,i){ return color(d, i)});
            groups.watchTransition(renderWatch, 'line: groups')
                .style('stroke-opacity', 1)
                .style('fill-opacity', .5);

            var areaPaths = groups.selectAll('path.nv-area')
                .data(function(d) { return isArea(d) ? [d] : [] }); // this is done differently than lines because I need to check if series is an area
            areaPaths.enter().append('path')
                .attr('class', 'nv-area')
                .attr('d', function(d) {
                    return d3.svg.area()
                        .interpolate(interpolate)
                        .defined(defined)
                        .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
                        .y0(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
                        .y1(function(d,i) { return y0( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                        .apply(this, [d.values])
                });
            groups.exit().selectAll('path.nv-area')
                .remove();

            areaPaths.watchTransition(renderWatch, 'line: areaPaths')
                .attr('d', function(d) {
                    return d3.svg.area()
                        .interpolate(interpolate)
                        .defined(defined)
                        .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
                        .y0(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
                        .y1(function(d,i) { return y( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                        .apply(this, [d.values])
                });

            var linePaths = groups.selectAll('path.nv-line')
                .data(function(d) { return [d.values] });
            linePaths.enter().append('path')
                .attr('class', 'nv-line')
                .attr('d',
                    d3.svg.line()
                    .interpolate(interpolate)
                    .defined(defined)
                    .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
                    .y(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
            );

            linePaths.watchTransition(renderWatch, 'line: linePaths')
                .attr('d',
                    d3.svg.line()
                    .interpolate(interpolate)
                    .defined(defined)
                    .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
                    .y(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
            );

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();
        });
        renderWatch.renderEnd('line immediate');
        return chart;
    }


    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.scatter = scatter;
    // Pass through events
    scatter.dispatch.on('elementClick', function(){ dispatch.elementClick.apply(this, arguments); })
    scatter.dispatch.on('elementMouseover', function(){ dispatch.elementMouseover.apply(this, arguments); })
    scatter.dispatch.on('elementMouseout', function(){ dispatch.elementMouseout.apply(this, arguments); })

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        defined: {get: function(){return defined;}, set: function(_){defined=_;}},
        interpolate:      {get: function(){return interpolate;}, set: function(_){interpolate=_;}},
        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            scatter.duration(duration);
        }},
        isArea: {get: function(){return isArea;}, set: function(_){
            isArea = d3.functor(_);
        }},
        x: {get: function(){return getX;}, set: function(_){
            getX = _;
            scatter.x(_);
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY = _;
            scatter.y(_);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            scatter.color(color);
        }}
    });

    nv.utils.inheritOptions(chart, scatter);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.lineChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 20, bottom: 50, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , useInteractiveGuideline = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , x
        , y
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , duration = 250
        ;

    xAxis
        .orient('bottom')
        .tickPadding(7)
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(lines);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;


            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition().duration(duration).call(chart)
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }


            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-lineChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineChart').append('g');
            var g = wrap.select('g');

            gEnter.append("rect").style("opacity",0);
            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-linesWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-interactive');

            g.select("rect")
                .attr("width",availableWidth)
                .attr("height",(availableHeight > 0) ? availableHeight : 0);

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left:margin.left, top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            lines
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));


            var linesWrap = g.select('.nv-linesWrap')
                .datum(data.filter(function(d) { return !d.disabled }));

            linesWrap.call(lines);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                lines.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        lines.highlightPoint(i, pointIndex, true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex)
                        });
                    });
                //Highlight the tooltip entry based on which point the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                    var threshold = 0.03 * domainExtent;
                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
                    if (indexToHighlight !== null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(function(d,i) {
                        return yAxis.tickFormat()(d);
                    })
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on('elementClick', function(e) {
                var pointXLocation, allData = [];

                data.filter(function(series, i) {
                    series.seriesIndex = i;
                    return !series.disabled;
                }).forEach(function(series) {
                    var pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                    var point = series.values[pointIndex];
                    if (typeof point === 'undefined') return;
                    if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                    var yPos = chart.yScale()(chart.y()(point,pointIndex));
                    allData.push({
                        point: point,
                        pointIndex: pointIndex,
                        pos: [pointXLocation, yPos],
                        seriesIndex: series.seriesIndex,
                        series: series
                    });
                });

                lines.dispatch.elementClick(allData);
            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                lines.clearHighlights();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                chart.update();
            });

        });

        renderWatch.renderEnd('lineChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.lines = lines;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            lines.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            lines.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( rightAlignYAxis ? 'right' : 'left');
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (useInteractiveGuideline) {
                lines.interactive(false);
                lines.useVoronoi(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.linePlusBarChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , lines2 = nv.models.line()
        , bars = nv.models.historicalBar()
        , bars2 = nv.models.historicalBar()
        , xAxis = nv.models.axis()
        , x2Axis = nv.models.axis()
        , y1Axis = nv.models.axis()
        , y2Axis = nv.models.axis()
        , y3Axis = nv.models.axis()
        , y4Axis = nv.models.axis()
        , legend = nv.models.legend()
        , brush = d3.svg.brush()
        ;

    var margin = {top: 30, right: 30, bottom: 30, left: 60}
        , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
        , width = null
        , height = null
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , color = nv.utils.defaultColor()
        , showLegend = true
        , focusEnable = true
        , focusShowAxisY = false
        , focusShowAxisX = true
        , focusHeight = 50
        , extent
        , brushExtent = null
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>';
        }
        , x
        , x2
        , y1
        , y2
        , y3
        , y4
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'brush', 'stateChange', 'changeState')
        , transitionDuration = 0
        , state = nv.utils.state()
        , defaultState = null
        , legendLeftAxisHint = ' (left axis)'
        , legendRightAxisHint = ' (right axis)'
        ;

    lines
        .clipEdge(true)
    ;
    lines2
        .interactive(false)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(5)
    ;
    y1Axis
        .orient('left')
    ;
    y2Axis
        .orient('right')
    ;
    x2Axis
        .orient('bottom')
        .tickPadding(5)
    ;
    y3Axis
        .orient('left')
    ;
    y4Axis
        .orient('right')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        if (extent) {
            e.pointIndex += Math.ceil(extent[0]);
        }
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight1 = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom - (focusEnable ? focusHeight : 0) ,
                availableHeight2 = focusHeight - margin2.top - margin2.bottom;

            chart.update = function() { container.transition().duration(transitionDuration).call(chart); };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight1 / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            var dataBars = data.filter(function(d) { return !d.disabled && d.bar });
            var dataLines = data.filter(function(d) { return !d.bar }); // removed the !d.disabled clause here to fix Issue #240

            x = bars.xScale();
            x2 = x2Axis.scale();
            y1 = bars.yScale();
            y2 = lines.yScale();
            y3 = bars2.yScale();
            y4 = lines2.yScale();

            var series1 = data
                .filter(function(d) { return !d.disabled && d.bar })
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i) }
                    })
                });

            var series2 = data
                .filter(function(d) { return !d.disabled && !d.bar })
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i) }
                    })
                });

            x.range([0, availableWidth]);

            x2  .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))
                .range([0, availableWidth]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-linePlusBar').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-legendWrap');

            // this is the main chart
            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
            focusEnter.append('g').attr('class', 'nv-x nv-axis');
            focusEnter.append('g').attr('class', 'nv-y1 nv-axis');
            focusEnter.append('g').attr('class', 'nv-y2 nv-axis');
            focusEnter.append('g').attr('class', 'nv-barsWrap');
            focusEnter.append('g').attr('class', 'nv-linesWrap');

            // context chart is where you can focus in
            var contextEnter = gEnter.append('g').attr('class', 'nv-context');
            contextEnter.append('g').attr('class', 'nv-x nv-axis');
            contextEnter.append('g').attr('class', 'nv-y1 nv-axis');
            contextEnter.append('g').attr('class', 'nv-y2 nv-axis');
            contextEnter.append('g').attr('class', 'nv-barsWrap');
            contextEnter.append('g').attr('class', 'nv-linesWrap');
            contextEnter.append('g').attr('class', 'nv-brushBackground');
            contextEnter.append('g').attr('class', 'nv-x nv-brush');

            //============================================================
            // Legend
            //------------------------------------------------------------

            if (showLegend) {
                legend.width( availableWidth / 2 );

                g.select('.nv-legendWrap')
                    .datum(data.map(function(series) {
                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                        series.key = series.originalKey + (series.bar ? legendLeftAxisHint : legendRightAxisHint);
                        return series;
                    }))
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight1 = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom - focusHeight;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + ( availableWidth / 2 ) + ',' + (-margin.top) +')');
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            //============================================================
            // Context chart (focus chart) components
            //------------------------------------------------------------

            // hide or show the focus context chart
            g.select('.nv-context').style('display', focusEnable ? 'initial' : 'none');

            bars2
                .width(availableWidth)
                .height(availableHeight2)
                .color(data.map(function (d, i) {
                    return d.color || color(d, i);
                }).filter(function (d, i) {
                    return !data[i].disabled && data[i].bar
                }));
            lines2
                .width(availableWidth)
                .height(availableHeight2)
                .color(data.map(function (d, i) {
                    return d.color || color(d, i);
                }).filter(function (d, i) {
                    return !data[i].disabled && !data[i].bar
                }));

            var bars2Wrap = g.select('.nv-context .nv-barsWrap')
                .datum(dataBars.length ? dataBars : [
                    {values: []}
                ]);
            var lines2Wrap = g.select('.nv-context .nv-linesWrap')
                .datum(!dataLines[0].disabled ? dataLines : [
                    {values: []}
                ]);

            g.select('.nv-context')
                .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')');

            bars2Wrap.transition().call(bars2);
            lines2Wrap.transition().call(lines2);

            // context (focus chart) axis controls
            if (focusShowAxisX) {
                x2Axis
                    .ticks(nv.utils.calcTicksX(availableWidth / 100, data))
                    .tickSize(-availableHeight2, 0);
                g.select('.nv-context .nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y3.range()[0] + ')');
                g.select('.nv-context .nv-x.nv-axis').transition()
                    .call(x2Axis);
            }

            if (focusShowAxisY) {
                y3Axis
                    .scale(y3)
                    .ticks( availableHeight2 / 36 )
                    .tickSize( -availableWidth, 0);
                y4Axis
                    .scale(y4)
                    .ticks( availableHeight2 / 36 )
                    .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none

                g.select('.nv-context .nv-y3.nv-axis')
                    .style('opacity', dataBars.length ? 1 : 0)
                    .attr('transform', 'translate(0,' + x2.range()[0] + ')');
                g.select('.nv-context .nv-y2.nv-axis')
                    .style('opacity', dataLines.length ? 1 : 0)
                    .attr('transform', 'translate(' + x2.range()[1] + ',0)');

                g.select('.nv-context .nv-y1.nv-axis').transition()
                    .call(y3Axis);
                g.select('.nv-context .nv-y2.nv-axis').transition()
                    .call(y4Axis);
            }

            // Setup Brush
            brush.x(x2).on('brush', onBrush);

            if (brushExtent) brush.extent(brushExtent);

            var brushBG = g.select('.nv-brushBackground').selectAll('g')
                .data([brushExtent || brush.extent()]);

            var brushBGenter = brushBG.enter()
                .append('g');

            brushBGenter.append('rect')
                .attr('class', 'left')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            brushBGenter.append('rect')
                .attr('class', 'right')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            var gBrush = g.select('.nv-x.nv-brush')
                .call(brush);
            gBrush.selectAll('rect')
                //.attr('y', -5)
                .attr('height', availableHeight2);
            gBrush.selectAll('.resize').append('path').attr('d', resizePath);

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                    state.disabled = e.disabled;
                }
                chart.update();
            });

            //============================================================
            // Functions
            //------------------------------------------------------------

            // Taken from crossfilter (http://square.github.com/crossfilter/)
            function resizePath(d) {
                var e = +(d == 'e'),
                    x = e ? 1 : -1,
                    y = availableHeight2 / 3;
                return 'M' + (.5 * x) + ',' + y
                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                    + 'V' + (2 * y - 6)
                    + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
                    + 'Z'
                    + 'M' + (2.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8)
                    + 'M' + (4.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8);
            }


            function updateBrushBG() {
                if (!brush.empty()) brush.extent(brushExtent);
                brushBG
                    .data([brush.empty() ? x2.domain() : brushExtent])
                    .each(function(d,i) {
                        var leftWidth = x2(d[0]) - x2.range()[0],
                            rightWidth = x2.range()[1] - x2(d[1]);
                        d3.select(this).select('.left')
                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);

                        d3.select(this).select('.right')
                            .attr('x', x2(d[1]))
                            .attr('width', rightWidth < 0 ? 0 : rightWidth);
                    });
            }

            function onBrush() {
                brushExtent = brush.empty() ? null : brush.extent();
                extent = brush.empty() ? x2.domain() : brush.extent();
                dispatch.brush({extent: extent, brush: brush});
                updateBrushBG();

                // Prepare Main (Focus) Bars and Lines
                bars
                    .width(availableWidth)
                    .height(availableHeight1)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled && data[i].bar }));

                lines
                    .width(availableWidth)
                    .height(availableHeight1)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled && !data[i].bar }));

                var focusBarsWrap = g.select('.nv-focus .nv-barsWrap')
                    .datum(!dataBars.length ? [{values:[]}] :
                        dataBars
                            .map(function(d,i) {
                                return {
                                    key: d.key,
                                    values: d.values.filter(function(d,i) {
                                        return bars.x()(d,i) >= extent[0] && bars.x()(d,i) <= extent[1];
                                    })
                                }
                            })
                );

                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                    .datum(dataLines[0].disabled ? [{values:[]}] :
                        dataLines
                            .map(function(d,i) {
                                return {
                                    key: d.key,
                                    values: d.values.filter(function(d,i) {
                                        return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                    })
                                }
                            })
                );

                // Update Main (Focus) X Axis
                if (dataBars.length) {
                    x = bars.xScale();
                } else {
                    x = lines.xScale();
                }

                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight1, 0);

                xAxis.domain([Math.ceil(extent[0]), Math.floor(extent[1])]);

                g.select('.nv-x.nv-axis').transition().duration(transitionDuration)
                    .call(xAxis);

                // Update Main (Focus) Bars and Lines
                focusBarsWrap.transition().duration(transitionDuration).call(bars);
                focusLinesWrap.transition().duration(transitionDuration).call(lines);

                // Setup and Update Main (Focus) Y Axes
                g.select('.nv-focus .nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y1.range()[0] + ')');

                y1Axis
                    .scale(y1)
                    .ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                    .tickSize(-availableWidth, 0);
                y2Axis
                    .scale(y2)
                    .ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                    .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none

                g.select('.nv-focus .nv-y1.nv-axis')
                    .style('opacity', dataBars.length ? 1 : 0);
                g.select('.nv-focus .nv-y2.nv-axis')
                    .style('opacity', dataLines.length && !dataLines[0].disabled ? 1 : 0)
                    .attr('transform', 'translate(' + x.range()[1] + ',0)');

                g.select('.nv-focus .nv-y1.nv-axis').transition().duration(transitionDuration)
                    .call(y1Axis);
                g.select('.nv-focus .nv-y2.nv-axis').transition().duration(transitionDuration)
                    .call(y2Axis);
            }

            onBrush();

        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    bars.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================


    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.legend = legend;
    chart.lines = lines;
    chart.lines2 = lines2;
    chart.bars = bars;
    chart.bars2 = bars2;
    chart.xAxis = xAxis;
    chart.x2Axis = x2Axis;
    chart.y1Axis = y1Axis;
    chart.y2Axis = y2Axis;
    chart.y3Axis = y3Axis;
    chart.y4Axis = y4Axis;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        brushExtent:    {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},
        focusHeight:    {get: function(){return focusHeight;}, set: function(_){focusHeight=_;}},
        focusShowAxisX:    {get: function(){return focusShowAxisX;}, set: function(_){focusShowAxisX=_;}},
        focusShowAxisY:    {get: function(){return focusShowAxisY;}, set: function(_){focusShowAxisY=_;}},
        legendLeftAxisHint:    {get: function(){return legendLeftAxisHint;}, set: function(_){legendLeftAxisHint=_;}},
        legendRightAxisHint:    {get: function(){return legendRightAxisHint;}, set: function(_){legendRightAxisHint=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration = _;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }},
        x: {get: function(){return getX;}, set: function(_){
            getX = _;
            lines.x(_);
            lines2.x(_);
            bars.x(_);
            bars2.x(_);
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY = _;
            lines.y(_);
            lines2.y(_);
            bars.y(_);
            bars2.y(_);
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.lineWithFocusChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , lines2 = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , x2Axis = nv.models.axis()
        , y2Axis = nv.models.axis()
        , legend = nv.models.legend()
        , brush = d3.svg.brush()
        ;

    var margin = {top: 30, right: 30, bottom: 30, left: 60}
        , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , height2 = 100
        , x
        , y
        , x2
        , y2
        , showLegend = true
        , brushExtent = null
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'brush', 'stateChange', 'changeState')
        , transitionDuration = 250
        , state = nv.utils.state()
        , defaultState = null
        ;

    lines
        .clipEdge(true)
    ;
    lines2
        .interactive(false)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(5)
    ;
    yAxis
        .orient('left')
    ;
    x2Axis
        .orient('bottom')
        .tickPadding(5)
    ;
    y2Axis
        .orient('left')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight1 = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom - height2,
                availableHeight2 = height2 - margin2.top - margin2.bottom;

            chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight1 / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();
            x2 = lines2.xScale();
            y2 = lines2.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-lineWithFocusChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineWithFocusChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-legendWrap');

            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
            focusEnter.append('g').attr('class', 'nv-x nv-axis');
            focusEnter.append('g').attr('class', 'nv-y nv-axis');
            focusEnter.append('g').attr('class', 'nv-linesWrap');

            var contextEnter = gEnter.append('g').attr('class', 'nv-context');
            contextEnter.append('g').attr('class', 'nv-x nv-axis');
            contextEnter.append('g').attr('class', 'nv-y nv-axis');
            contextEnter.append('g').attr('class', 'nv-linesWrap');
            contextEnter.append('g').attr('class', 'nv-brushBackground');
            contextEnter.append('g').attr('class', 'nv-x nv-brush');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight1 = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom - height2;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            lines
                .width(availableWidth)
                .height(availableHeight1)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            lines2
                .defined(lines.defined())
                .width(availableWidth)
                .height(availableHeight2)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            g.select('.nv-context')
                .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')')

            var contextLinesWrap = g.select('.nv-context .nv-linesWrap')
                .datum(data.filter(function(d) { return !d.disabled }))

            d3.transition(contextLinesWrap).call(lines2);

            // Setup Main (Focus) Axes
            xAxis
                .scale(x)
                .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight1, 0);

            yAxis
                .scale(y)
                .ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                .tickSize( -availableWidth, 0);

            g.select('.nv-focus .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + availableHeight1 + ')');

            // Setup Brush
            brush
                .x(x2)
                .on('brush', function() {
                    //When brushing, turn off transitions because chart needs to change immediately.
                    var oldTransition = chart.duration();
                    chart.duration(0);
                    onBrush();
                    chart.duration(oldTransition);
                });

            if (brushExtent) brush.extent(brushExtent);

            var brushBG = g.select('.nv-brushBackground').selectAll('g')
                .data([brushExtent || brush.extent()])

            var brushBGenter = brushBG.enter()
                .append('g');

            brushBGenter.append('rect')
                .attr('class', 'left')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            brushBGenter.append('rect')
                .attr('class', 'right')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            var gBrush = g.select('.nv-x.nv-brush')
                .call(brush);
            gBrush.selectAll('rect')
                //.attr('y', -5)
                .attr('height', availableHeight2);
            gBrush.selectAll('.resize').append('path').attr('d', resizePath);

            onBrush();

            // Setup Secondary (Context) Axes
            x2Axis
                .scale(x2)
                .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight2, 0);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');
            d3.transition(g.select('.nv-context .nv-x.nv-axis'))
                .call(x2Axis);

            y2Axis
                .scale(y2)
                .ticks( nv.utils.calcTicksY(availableHeight2/36, data) )
                .tickSize( -availableWidth, 0);

            d3.transition(g.select('.nv-context .nv-y.nv-axis'))
                .call(y2Axis);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                }
                chart.update();
            });

            //============================================================
            // Functions
            //------------------------------------------------------------

            // Taken from crossfilter (http://square.github.com/crossfilter/)
            function resizePath(d) {
                var e = +(d == 'e'),
                    x = e ? 1 : -1,
                    y = availableHeight2 / 3;
                return 'M' + (.5 * x) + ',' + y
                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                    + 'V' + (2 * y - 6)
                    + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
                    + 'Z'
                    + 'M' + (2.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8)
                    + 'M' + (4.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8);
            }


            function updateBrushBG() {
                if (!brush.empty()) brush.extent(brushExtent);
                brushBG
                    .data([brush.empty() ? x2.domain() : brushExtent])
                    .each(function(d,i) {
                        var leftWidth = x2(d[0]) - x.range()[0],
                            rightWidth = x.range()[1] - x2(d[1]);
                        d3.select(this).select('.left')
                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);

                        d3.select(this).select('.right')
                            .attr('x', x2(d[1]))
                            .attr('width', rightWidth < 0 ? 0 : rightWidth);
                    });
            }


            function onBrush() {
                brushExtent = brush.empty() ? null : brush.extent();
                var extent = brush.empty() ? x2.domain() : brush.extent();

                //The brush extent cannot be less than one.  If it is, don't update the line chart.
                if (Math.abs(extent[0] - extent[1]) <= 1) {
                    return;
                }

                dispatch.brush({extent: extent, brush: brush});


                updateBrushBG();

                // Update Main (Focus)
                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                    .datum(
                    data
                        .filter(function(d) { return !d.disabled })
                        .map(function(d,i) {
                            return {
                                key: d.key,
                                area: d.area,
                                values: d.values.filter(function(d,i) {
                                    return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                })
                            }
                        })
                );
                focusLinesWrap.transition().duration(transitionDuration).call(lines);


                // Update Main (Focus) Axes
                g.select('.nv-focus .nv-x.nv-axis').transition().duration(transitionDuration)
                    .call(xAxis);
                g.select('.nv-focus .nv-y.nv-axis').transition().duration(transitionDuration)
                    .call(yAxis);
            }
        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.legend = legend;
    chart.lines = lines;
    chart.lines2 = lines2;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.x2Axis = x2Axis;
    chart.y2Axis = y2Axis;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        focusHeight:     {get: function(){return height2;}, set: function(_){height2=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        brushExtent: {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            // line color is handled above?
        }},
        interpolate: {get: function(){return lines.interpolate();}, set: function(_){
            lines.interpolate(_);
            lines2.interpolate(_);
        }},
        xTickFormat: {get: function(){return xAxis.xTickFormat();}, set: function(_){
            xAxis.xTickFormat(_);
            x2Axis.xTickFormat(_);
        }},
        yTickFormat: {get: function(){return yAxis.yTickFormat();}, set: function(_){
            yAxis.yTickFormat(_);
            y2Axis.yTickFormat(_);
        }},
        duration:    {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration=_;
            yAxis.duration(transitionDuration);
            xAxis.duration(transitionDuration);
        }},
        x: {get: function(){return lines.x();}, set: function(_){
            lines.x(_);
            lines2.x(_);
        }},
        y: {get: function(){return lines.y();}, set: function(_){
            lines.y(_);
            lines2.y(_);
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.multiBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , x = d3.scale.ordinal()
        , y = d3.scale.linear()
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
        , clipEdge = true
        , stacked = false
        , stackOffset = 'zero' // options include 'silhouette', 'wiggle', 'expand', 'zero', or a custom function
        , color = nv.utils.defaultColor()
        , hideable = false
        , barColor = null // adding the ability to set the color for each rather than the whole group
        , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
        , duration = 500
        , xDomain
        , yDomain
        , xRange
        , yRange
        , groupSpacing = 0.1
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0 //used to store previous scales
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    var last_datalength = 0;

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // This function defines the requirements for render complete
            var endFn = function(d, i) {
                if (d.series === data.length - 1 && i === data[0].values.length - 1)
                    return true;
                return false;
            };

            if(hideable && data.length) hideable = [{
                values: data[0].values.map(function(d) {
                        return {
                            x: d.x,
                            y: 0,
                            series: d.series,
                            size: 0.01
                        };}
                )}];

            if (stacked)
                data = d3.layout.stack()
                    .offset(stackOffset)
                    .values(function(d){ return d.values })
                    .y(getY)
                (!data.length && hideable ? hideable : data);


            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // HACK for negative value stacking
            if (stacked)
                data[0].values.map(function(d,i) {
                    var posBase = 0, negBase = 0;
                    data.map(function(d) {
                        var f = d.values[i]
                        f.size = Math.abs(f.y);
                        if (f.y<0)  {
                            f.y1 = negBase;
                            negBase = negBase - f.size;
                        } else
                        {
                            f.y1 = f.size + posBase;
                            posBase = posBase + f.size;
                        }
                    });
                });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                data.map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }
                    })
                });

            x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                .rangeBands(xRange || [0, availableWidth], groupSpacing);

            y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 : d.y1 + d.y ) : d.y }).concat(forceY)))
                .range(yRange || [availableHeight, 0]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            x0 = x0 || x;
            y0 = y0 || y;

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-multibar').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibar');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g')

            gEnter.append('g').attr('class', 'nv-groups');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + id)
                .append('rect');
            wrap.select('#nv-edge-clip-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');

            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d,i) { return i });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);

            var exitTransition = renderWatch
                .transition(groups.exit().selectAll('rect.nv-bar'), 'multibarExit', Math.min(100, duration))
                .attr('y', function(d) { return (stacked ? y0(d.y0) : y0(0)) || 0 })
                .attr('height', 0)
                .remove();
            if (exitTransition.delay)
                exitTransition.delay(function(d,i) {
                    var delay = i * (duration / (last_datalength + 1)) - i;
                    return delay;
                });
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover })
                .style('fill', function(d,i){ return color(d, i) })
                .style('stroke', function(d,i){ return color(d, i) });
            groups
                .style('stroke-opacity', 1)
                .style('fill-opacity', 0.75);

            var bars = groups.selectAll('rect.nv-bar')
                .data(function(d) { return (hideable && !data.length) ? hideable.values : d.values });
            bars.exit().remove();

            var barsEnter = bars.enter().append('rect')
                    .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
                    .attr('x', function(d,i,j) {
                        return stacked ? 0 : (j * x.rangeBand() / data.length )
                    })
                    .attr('y', function(d) { return y0(stacked ? d.y0 : 0) || 0 })
                    .attr('height', 0)
                    .attr('width', x.rangeBand() / (stacked ? 1 : data.length) )
                    .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })
                ;
            bars
                .style('fill', function(d,i,j){ return color(d, j, i);  })
                .style('stroke', function(d,i,j){ return color(d, j, i); })
                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    dispatch.elementClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    dispatch.elementDblClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });
            bars
                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })

            if (barColor) {
                if (!disabled) disabled = data.map(function() { return true });
                bars
                    .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
                    .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
            }

            var barSelection =
                bars.watchTransition(renderWatch, 'multibar', Math.min(250, duration))
                    .delay(function(d,i) {
                        return i * duration / data[0].values.length;
                    });
            if (stacked)
                barSelection
                    .attr('y', function(d,i) {
                        return y((stacked ? d.y1 : 0));
                    })
                    .attr('height', function(d,i) {
                        return Math.max(Math.abs(y(d.y + (stacked ? d.y0 : 0)) - y((stacked ? d.y0 : 0))),1);
                    })
                    .attr('x', function(d,i) {
                        return stacked ? 0 : (d.series * x.rangeBand() / data.length )
                    })
                    .attr('width', x.rangeBand() / (stacked ? 1 : data.length) );
            else
                barSelection
                    .attr('x', function(d,i) {
                        return d.series * x.rangeBand() / data.length
                    })
                    .attr('width', x.rangeBand() / data.length)
                    .attr('y', function(d,i) {
                        return getY(d,i) < 0 ?
                            y(0) :
                                y(0) - y(getY(d,i)) < 1 ?
                            y(0) - 1 :
                            y(getY(d,i)) || 0;
                    })
                    .attr('height', function(d,i) {
                        return Math.max(Math.abs(y(getY(d,i)) - y(0)),1) || 0;
                    });

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

            // keep track of the last data value length for transition calculations
            if (data[0] && data[0].values) {
                last_datalength = data[0].values.length;
            }

        });

        renderWatch.renderEnd('multibar immediate');

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},
        stackOffset: {get: function(){return stackOffset;}, set: function(_){stackOffset=_;}},
        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        disabled:    {get: function(){return disabled;}, set: function(_){disabled=_;}},
        id:          {get: function(){return id;}, set: function(_){id=_;}},
        hideable:    {get: function(){return hideable;}, set: function(_){hideable=_;}},
        groupSpacing:{get: function(){return groupSpacing;}, set: function(_){groupSpacing=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        barColor:  {get: function(){return barColor;}, set: function(_){
            barColor = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.multiBarChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var multibar = nv.models.multiBar()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , controls = nv.models.legend()
        ;

    var margin = {top: 30, right: 20, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.defaultColor()
        , showControls = true
        , controlLabels = {}
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , reduceXTicks = true // if false a tick will show for every data point
        , staggerLabels = false
        , rotateLabels = 0
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' on ' + x + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , state = nv.utils.state()
        , defaultState = null
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , controlWidth = function() { return showControls ? 180 : 0 }
        , duration = 250
        ;

    state.stacked = false // DEPRECATED Maintained for backward compatibility

    multibar
        .stacked(false)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(7)
        .highlightZero(true)
        .showMaxMin(false)
        .tickFormat(function(d) { return d })
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
        .tickFormat(d3.format(',.1f'))
    ;

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);
    var stacked = false;

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                stacked: stacked
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.stacked !== undefined)
                stacked = state.stacked;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(multibar);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition()
                        .duration(duration)
                        .call(chart);
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = multibar.xScale();
            y = multibar.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-barsWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');

            // Legend
            if (showLegend) {
                legend.width(availableWidth - controlWidth());

                if (multibar.barColor())
                    data.forEach(function(series,i) {
                        series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
                    });

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },
                    { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }
                ];

                controls.width(controlWidth()).color(['#444', '#444', '#444']);
                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
                    .call(controls);
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Main Chart Component(s)
            multibar
                .disabled(data.map(function(series) { return series.disabled }))
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));


            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }));

            barsWrap.call(multibar);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .call(xAxis);

                var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');

                xTicks
                    .selectAll('line, text')
                    .style('opacity', 1)

                if (staggerLabels) {
                    var getTranslate = function(x,y) {
                        return "translate(" + x + "," + y + ")";
                    };

                    var staggerUp = 5, staggerDown = 17;  //pixels to stagger by
                    // Issue #140
                    xTicks
                        .selectAll("text")
                        .attr('transform', function(d,i,j) {
                            return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));
                        });

                    var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
                    g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text")
                        .attr("transform", function(d,i) {
                            return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);
                        });
                }

                if (reduceXTicks)
                    xTicks
                        .filter(function(d,i) {
                            return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
                        })
                        .selectAll('text, line')
                        .style('opacity', 0);

                if(rotateLabels)
                    xTicks
                        .selectAll('.tick text')
                        .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
                        .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');

                g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')
                    .style('opacity', 1);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                if (!d.disabled) return;
                controlsData = controlsData.map(function(s) {
                    s.disabled = true;
                    return s;
                });
                d.disabled = false;

                switch (d.key) {
                    case 'Grouped':
                        multibar.stacked(false);
                        break;
                    case 'Stacked':
                        multibar.stacked(true);
                        break;
                }

                state.stacked = multibar.stacked();
                dispatch.stateChange(state);

                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode)
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.stacked !== 'undefined') {
                    multibar.stacked(e.stacked);
                    state.stacked = e.stacked;
                    stacked = e.stacked;
                }

                chart.update();
            });
        });

        renderWatch.renderEnd('multibarchart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    multibar.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    multibar.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });
    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.multibar = multibar;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.state = state;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},
        controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        reduceXTicks:    {get: function(){return reduceXTicks;}, set: function(_){reduceXTicks=_;}},
        rotateLabels:    {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
        staggerLabels:    {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            multibar.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
            renderWatch.reset(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( rightAlignYAxis ? 'right' : 'left');
        }}
    });

    nv.utils.inheritOptions(chart, multibar);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.multiBarHorizontal = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.ordinal()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , getYerr = function(d) { return d.yErr }
        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
        , color = nv.utils.defaultColor()
        , barColor = null // adding the ability to set the color for each rather than the whole group
        , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
        , stacked = false
        , showValues = false
        , showBarLabels = false
        , valuePadding = 60
        , valueFormat = d3.format(',.2f')
        , delay = 1200
        , xDomain
        , yDomain
        , xRange
        , yRange
        , duration = 250
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout','renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0; //used to store previous scales
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            if (stacked)
                data = d3.layout.stack()
                    .offset('zero')
                    .values(function(d){ return d.values })
                    .y(getY)
                (data);

            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // HACK for negative value stacking
            if (stacked)
                data[0].values.map(function(d,i) {
                    var posBase = 0, negBase = 0;
                    data.map(function(d) {
                        var f = d.values[i]
                        f.size = Math.abs(f.y);
                        if (f.y<0)  {
                            f.y1 = negBase - f.size;
                            negBase = negBase - f.size;
                        } else
                        {
                            f.y1 = posBase;
                            posBase = posBase + f.size;
                        }
                    });
                });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                data.map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }
                    })
                });

            x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                .rangeBands(xRange || [0, availableHeight], .1);

            y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 + d.y : d.y1 ) : d.y }).concat(forceY)))

            if (showValues && !stacked)
                y.range(yRange || [(y.domain()[0] < 0 ? valuePadding : 0), availableWidth - (y.domain()[1] > 0 ? valuePadding : 0) ]);
            else
                y.range(yRange || [0, availableWidth]);

            x0 = x0 || x;
            y0 = y0 || d3.scale.linear().domain(y.domain()).range([y(0),y(0)]);

            // Setup containers and skeleton of chart
            var wrap = d3.select(this).selectAll('g.nv-wrap.nv-multibarHorizontal').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibarHorizontal');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d,i) { return i });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);
            groups.exit().watchTransition(renderWatch, 'multibarhorizontal: exit groups')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6)
                .remove();
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover })
                .style('fill', function(d,i){ return color(d, i) })
                .style('stroke', function(d,i){ return color(d, i) });
            groups.watchTransition(renderWatch, 'multibarhorizontal: groups')
                .style('stroke-opacity', 1)
                .style('fill-opacity', .75);

            var bars = groups.selectAll('g.nv-bar')
                .data(function(d) { return d.values });
            bars.exit().remove();

            var barsEnter = bars.enter().append('g')
                .attr('transform', function(d,i,j) {
                    return 'translate(' + y0(stacked ? d.y0 : 0) + ',' + (stacked ? 0 : (j * x.rangeBand() / data.length ) + x(getX(d,i))) + ')'
                });

            barsEnter.append('rect')
                .attr('width', 0)
                .attr('height', x.rangeBand() / (stacked ? 1 : data.length) )

            bars
                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [ y(getY(d,i) + (stacked ? d.y0 : 0)), x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    dispatch.elementClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    dispatch.elementDblClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });

            if (getYerr(data[0],0)) {
                barsEnter.append('polyline');

                bars.select('polyline')
                    .attr('fill', 'none')
                    .attr('points', function(d,i) {
                        var xerr = getYerr(d,i)
                            , mid = 0.8 * x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                        xerr = xerr.length ? xerr : [-Math.abs(xerr), Math.abs(xerr)];
                        xerr = xerr.map(function(e) { return y(e) - y(0); });
                        var a = [[xerr[0],-mid], [xerr[0],mid], [xerr[0],0], [xerr[1],0], [xerr[1],-mid], [xerr[1],mid]];
                        return a.map(function (path) { return path.join(',') }).join(' ');
                    })
                    .attr('transform', function(d,i) {
                        var mid = x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                        return 'translate(' + (getY(d,i) < 0 ? 0 : y(getY(d,i)) - y(0)) + ', ' + mid + ')'
                    });
            }

            barsEnter.append('text');

            if (showValues && !stacked) {
                bars.select('text')
                    .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'end' : 'start' })
                    .attr('y', x.rangeBand() / (data.length * 2))
                    .attr('dy', '.32em')
                    .html(function(d,i) {
                        var t = valueFormat(getY(d,i))
                            , yerr = getYerr(d,i);
                        if (yerr === undefined)
                            return t;
                        if (!yerr.length)
                            return t + '&plusmn;' + valueFormat(Math.abs(yerr));
                        return t + '+' + valueFormat(Math.abs(yerr[1])) + '-' + valueFormat(Math.abs(yerr[0]));
                    });
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .select('text')
                    .attr('x', function(d,i) { return getY(d,i) < 0 ? -4 : y(getY(d,i)) - y(0) + 4 })
            } else {
                bars.selectAll('text').text('');
            }

            if (showBarLabels && !stacked) {
                barsEnter.append('text').classed('nv-bar-label',true);
                bars.select('text.nv-bar-label')
                    .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'start' : 'end' })
                    .attr('y', x.rangeBand() / (data.length * 2))
                    .attr('dy', '.32em')
                    .text(function(d,i) { return getX(d,i) });
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .select('text.nv-bar-label')
                    .attr('x', function(d,i) { return getY(d,i) < 0 ? y(0) - y(getY(d,i)) + 4 : -4 });
            }
            else {
                bars.selectAll('text.nv-bar-label').text('');
            }

            bars
                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})

            if (barColor) {
                if (!disabled) disabled = data.map(function() { return true });
                bars
                    .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
                    .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
            }

            if (stacked)
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .attr('transform', function(d,i) {
                        return 'translate(' + y(d.y1) + ',' + x(getX(d,i)) + ')'
                    })
                    .select('rect')
                    .attr('width', function(d,i) {
                        return Math.abs(y(getY(d,i) + d.y0) - y(d.y0))
                    })
                    .attr('height', x.rangeBand() );
            else
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .attr('transform', function(d,i) {
                        //TODO: stacked must be all positive or all negative, not both?
                        return 'translate(' +
                            (getY(d,i) < 0 ? y(getY(d,i)) : y(0))
                            + ',' +
                            (d.series * x.rangeBand() / data.length
                                +
                                x(getX(d,i)) )
                            + ')'
                    })
                    .select('rect')
                    .attr('height', x.rangeBand() / data.length )
                    .attr('width', function(d,i) {
                        return Math.max(Math.abs(y(getY(d,i)) - y(0)),1)
                    });

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

        });

        renderWatch.renderEnd('multibarHorizontal immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        yErr:       {get: function(){return getYerr;}, set: function(_){getYerr=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},
        showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},
        // this shows the group name, seems pointless?
        //showBarLabels:    {get: function(){return showBarLabels;}, set: function(_){showBarLabels=_;}},
        disabled:     {get: function(){return disabled;}, set: function(_){disabled=_;}},
        id:           {get: function(){return id;}, set: function(_){id=_;}},
        valueFormat:  {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
        valuePadding: {get: function(){return valuePadding;}, set: function(_){valuePadding=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        barColor:  {get: function(){return color;}, set: function(_){
            barColor = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};
nv.models.multiBarHorizontalChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var multibar = nv.models.multiBarHorizontal()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend().height(30)
        , controls = nv.models.legend().height(30)
        ;

    var margin = {top: 30, right: 20, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.defaultColor()
        , showControls = true
        , controlLabels = {}
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , stacked = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + ' - ' + x + '</h3>' +
                '<p>' +  y + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        , controlWidth = function() { return showControls ? 180 : 0 }
        , duration = 250
        ;

    state.stacked = false; // DEPRECATED Maintained for backward compatibility

    multibar
        .stacked(stacked)
    ;
    xAxis
        .orient('left')
        .tickPadding(5)
        .highlightZero(false)
        .showMaxMin(false)
        .tickFormat(function(d) { return d })
    ;
    yAxis
        .orient('bottom')
        .tickFormat(d3.format(',.1f'))
    ;

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                stacked: stacked
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.stacked !== undefined)
                stacked = state.stacked;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(multibar);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() { container.transition().duration(duration).call(chart) };
            chart.container = this;

            stacked = multibar.stacked();

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = multibar.xScale();
            y = multibar.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-multiBarHorizontalChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarHorizontalChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis')
                .append('g').attr('class', 'nv-zeroLine')
                .append('line');
            gEnter.append('g').attr('class', 'nv-barsWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');

            // Legend
            if (showLegend) {
                legend.width(availableWidth - controlWidth());

                if (multibar.barColor())
                    data.forEach(function(series,i) {
                        series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
                    });

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },
                    { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }
                ];

                controls.width(controlWidth()).color(['#444', '#444', '#444']);
                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
                    .call(controls);
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            multibar
                .disabled(data.map(function(series) { return series.disabled }))
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));

            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }));

            barsWrap.transition().call(multibar);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksY(availableHeight/24, data) )
                    .tickSize(-availableWidth, 0);

                g.select('.nv-x.nv-axis').call(xAxis);

                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');

                xTicks
                    .selectAll('line, text');
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize( -availableHeight, 0);

                g.select('.nv-y.nv-axis')
                    .attr('transform', 'translate(0,' + availableHeight + ')');
                g.select('.nv-y.nv-axis').call(yAxis);
            }

            // Zero line
            g.select(".nv-zeroLine line")
                .attr("x1", y(0))
                .attr("x2", y(0))
                .attr("y1", 0)
                .attr("y2", -availableHeight)
            ;

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                if (!d.disabled) return;
                controlsData = controlsData.map(function(s) {
                    s.disabled = true;
                    return s;
                });
                d.disabled = false;

                switch (d.key) {
                    case 'Grouped':
                        multibar.stacked(false);
                        break;
                    case 'Stacked':
                        multibar.stacked(true);
                        break;
                }

                state.stacked = multibar.stacked();
                dispatch.stateChange(state);
                stacked = multibar.stacked();

                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.stacked !== 'undefined') {
                    multibar.stacked(e.stacked);
                    state.stacked = e.stacked;
                    stacked = e.stacked;
                }

                chart.update();
            });
        });
        renderWatch.renderEnd('multibar horizontal chart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    multibar.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    multibar.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });
    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.multibar = multibar;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.state = state;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},
        controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            multibar.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }}
    });

    nv.utils.inheritOptions(chart, multibar);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.multiChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 30, right: 20, bottom: 50, left: 60},
        color = nv.utils.defaultColor(),
        width = null,
        height = null,
        showLegend = true,
        tooltips = true,
        tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        },
        x,
        y,
        noData = 'No Data Available.',
        yDomain1,
        yDomain2,
        getX = function(d) { return d.x },
        getY = function(d) { return d.y},
        interpolate = 'monotone'
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x = d3.scale.linear(),
        yScale1 = d3.scale.linear(),
        yScale2 = d3.scale.linear(),

        lines1 = nv.models.line().yScale(yScale1),
        lines2 = nv.models.line().yScale(yScale2),

        bars1 = nv.models.multiBar().stacked(false).yScale(yScale1),
        bars2 = nv.models.multiBar().stacked(false).yScale(yScale2),

        stack1 = nv.models.stackedArea().yScale(yScale1),
        stack2 = nv.models.stackedArea().yScale(yScale2),

        xAxis = nv.models.axis().scale(x).orient('bottom').tickPadding(5),
        yAxis1 = nv.models.axis().scale(yScale1).orient('left'),
        yAxis2 = nv.models.axis().scale(yScale2).orient('right'),

        legend = nv.models.legend().height(30),
        dispatch = d3.dispatch('tooltipShow', 'tooltipHide');

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines1.x()(e.point, e.pointIndex)),
            y = ((e.series.yAxis == 2) ? yAxis2 : yAxis1).tickFormat()(lines1.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, undefined, undefined, offsetElement.offsetParent);
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);

            chart.update = function() { container.transition().call(chart); };
            chart.container = this;

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            var dataLines1 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 1});
            var dataLines2 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 2});
            var dataBars1 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 1});
            var dataBars2 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 2});
            var dataStack1 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 1});
            var dataStack2 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 2});

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            var series1 = data.filter(function(d) {return !d.disabled && d.yAxis == 1})
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: d.x, y: d.y }
                    })
                });

            var series2 = data.filter(function(d) {return !d.disabled && d.yAxis == 2})
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: d.x, y: d.y }
                    })
                });

            x   .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))
                .range([0, availableWidth]);

            var wrap = container.selectAll('g.wrap.multiChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'wrap nvd3 multiChart').append('g');

            gEnter.append('g').attr('class', 'x axis');
            gEnter.append('g').attr('class', 'y1 axis');
            gEnter.append('g').attr('class', 'y2 axis');
            gEnter.append('g').attr('class', 'lines1Wrap');
            gEnter.append('g').attr('class', 'lines2Wrap');
            gEnter.append('g').attr('class', 'bars1Wrap');
            gEnter.append('g').attr('class', 'bars2Wrap');
            gEnter.append('g').attr('class', 'stack1Wrap');
            gEnter.append('g').attr('class', 'stack2Wrap');
            gEnter.append('g').attr('class', 'legendWrap');

            var g = wrap.select('g');

            var color_array = data.map(function(d,i) {
                return data[i].color || color(d, i);
            });

            if (showLegend) {
                legend.color(color_array);
                legend.width( availableWidth / 2 );

                g.select('.legendWrap')
                    .datum(data.map(function(series) {
                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                        series.key = series.originalKey + (series.yAxis == 1 ? '' : ' (right axis)');
                        return series;
                    }))
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.legendWrap')
                    .attr('transform', 'translate(' + ( availableWidth / 2 ) + ',' + (-margin.top) +')');
            }

            lines1
                .width(availableWidth)
                .height(availableHeight)
                .interpolate(interpolate)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'line'}));
            lines2
                .width(availableWidth)
                .height(availableHeight)
                .interpolate(interpolate)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'line'}));
            bars1
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'bar'}));
            bars2
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'bar'}));
            stack1
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'area'}));
            stack2
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'area'}));

            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var lines1Wrap = g.select('.lines1Wrap')
                .datum(
                    dataLines1.filter(function(d){return !d.disabled})
                );
            var bars1Wrap = g.select('.bars1Wrap')
                .datum(
                    dataBars1.filter(function(d){return !d.disabled})
                );
            var stack1Wrap = g.select('.stack1Wrap')
                .datum(
                    dataStack1.filter(function(d){return !d.disabled})
                );

            var lines2Wrap = g.select('.lines2Wrap')
                .datum(
                    dataLines2.filter(function(d){return !d.disabled})
                );
            var bars2Wrap = g.select('.bars2Wrap')
                .datum(
                    dataBars2.filter(function(d){return !d.disabled})
                );
            var stack2Wrap = g.select('.stack2Wrap')
                .datum(
                    dataStack2.filter(function(d){return !d.disabled})
                );

            var extraValue1 = dataStack1.length ? dataStack1.map(function(a){return a.values}).reduce(function(a,b){
                return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
            }).concat([{x:0, y:0}]) : []
            var extraValue2 = dataStack2.length ? dataStack2.map(function(a){return a.values}).reduce(function(a,b){
                return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
            }).concat([{x:0, y:0}]) : []

            yScale1 .domain(yDomain1 || d3.extent(d3.merge(series1).concat(extraValue1), function(d) { return d.y } ))
                .range([0, availableHeight])

            yScale2 .domain(yDomain2 || d3.extent(d3.merge(series2).concat(extraValue2), function(d) { return d.y } ))
                .range([0, availableHeight])

            lines1.yDomain(yScale1.domain())
            bars1.yDomain(yScale1.domain())
            stack1.yDomain(yScale1.domain())

            lines2.yDomain(yScale2.domain())
            bars2.yDomain(yScale2.domain())
            stack2.yDomain(yScale2.domain())

            if(dataStack1.length){d3.transition(stack1Wrap).call(stack1);}
            if(dataStack2.length){d3.transition(stack2Wrap).call(stack2);}

            if(dataBars1.length){d3.transition(bars1Wrap).call(bars1);}
            if(dataBars2.length){d3.transition(bars2Wrap).call(bars2);}

            if(dataLines1.length){d3.transition(lines1Wrap).call(lines1);}
            if(dataLines2.length){d3.transition(lines2Wrap).call(lines2);}

            xAxis
                .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight, 0);

            g.select('.x.axis')
                .attr('transform', 'translate(0,' + availableHeight + ')');
            d3.transition(g.select('.x.axis'))
                .call(xAxis);

            yAxis1
                .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                .tickSize( -availableWidth, 0);


            d3.transition(g.select('.y1.axis'))
                .call(yAxis1);

            yAxis2
                .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                .tickSize( -availableWidth, 0);

            d3.transition(g.select('.y2.axis'))
                .call(yAxis2);

            g.select('.y1.axis')
                .classed('nv-disabled', series1.length ? false : true)
                .attr('transform', 'translate(' + x.range()[0] + ',0)');

            g.select('.y2.axis')
                .classed('nv-disabled', series2.length ? false : true)
                .attr('transform', 'translate(' + x.range()[1] + ',0)');

            legend.dispatch.on('stateChange', function(newState) {
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines1.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines1.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    lines2.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines2.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    bars1.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars1.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    bars2.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars2.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    stack1.dispatch.on('tooltipShow', function(e) {
        //disable tooltips when value ~= 0
        //// TODO: consider removing points from voronoi that have 0 value instead of this hack
        if (!Math.round(stack1.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range
            setTimeout(function() { d3.selectAll('.point.hover').classed('hover', false) }, 0);
            return false;
        }

        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
            dispatch.tooltipShow(e);
    });

    stack1.dispatch.on('tooltipHide', function(e) {
        dispatch.tooltipHide(e);
    });

    stack2.dispatch.on('tooltipShow', function(e) {
        //disable tooltips when value ~= 0
        //// TODO: consider removing points from voronoi that have 0 value instead of this hack
        if (!Math.round(stack2.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range
            setTimeout(function() { d3.selectAll('.point.hover').classed('hover', false) }, 0);
            return false;
        }

        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
            dispatch.tooltipShow(e);
    });

    stack2.dispatch.on('tooltipHide', function(e) {
        dispatch.tooltipHide(e);
    });

    lines1.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines1.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    lines2.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines2.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Global getters and setters
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.lines1 = lines1;
    chart.lines2 = lines2;
    chart.bars1 = bars1;
    chart.bars2 = bars2;
    chart.stack1 = stack1;
    chart.stack2 = stack2;
    chart.xAxis = xAxis;
    chart.yAxis1 = yAxis1;
    chart.yAxis2 = yAxis2;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        yDomain1:      {get: function(){return yDomain1;}, set: function(_){yDomain1=_;}},
        yDomain2:    {get: function(){return yDomain2;}, set: function(_){yDomain2=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        x: {get: function(){return getX;}, set: function(_){
            getX = _;
            lines1.x(_);
            bars1.x(_);
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY = _;
            lines1.y(_);
            bars1.y(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};


nv.models.ohlcBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = null
        , height = null
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.linear()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , getOpen = function(d) { return d.open }
        , getClose = function(d) { return d.close }
        , getHigh = function(d) { return d.high }
        , getLow = function(d) { return d.low }
        , forceX = []
        , forceY = []
        , padData     = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
        , clipEdge = true
        , color = nv.utils.defaultColor()
        , interactive = false
        , xDomain
        , yDomain
        , xRange
        , yRange
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            // Setup Scales
            x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));

            if (padData)
                x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
            else
                x.range(xRange || [0, availableWidth]);

            y.domain(yDomain || [
                    d3.min(data[0].values.map(getLow).concat(forceY)),
                    d3.max(data[0].values.map(getHigh).concat(forceY))
                ]
            ).range(yRange || [availableHeight, 0]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            // Setup containers and skeleton of chart
            var wrap = d3.select(this).selectAll('g.nv-wrap.nv-ohlcBar').data([data[0].values]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-ohlcBar');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-ticks');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            container
                .on('click', function(d,i) {
                    dispatch.chartClick({
                        data: d,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                });

            defsEnter.append('clipPath')
                .attr('id', 'nv-chart-clip-path-' + id)
                .append('rect');

            wrap.select('#nv-chart-clip-path-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');

            var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick')
                .data(function(d) { return d });
            ticks.exit().remove();

            var ticksEnter = ticks.enter().append('path')
                .attr('class', function(d,i,j) { return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i })
                .attr('d', function(d,i) {
                    var w = (availableWidth / data[0].values.length) * .9;
                    return 'm0,0l0,'
                        + (y(getOpen(d,i))
                            - y(getHigh(d,i)))
                        + 'l'
                        + (-w/2)
                        + ',0l'
                        + (w/2)
                        + ',0l0,'
                        + (y(getLow(d,i)) - y(getOpen(d,i)))
                        + 'l0,'
                        + (y(getClose(d,i))
                            - y(getLow(d,i)))
                        + 'l'
                        + (w/2)
                        + ',0l'
                        + (-w/2)
                        + ',0z';
                })
                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
                .attr('fill', function(d,i) { return color[0]; })
                .attr('stroke', function(d,i) { return color[0]; })
                .attr('x', 0 )
                .attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })
                .attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) });

            // the bar colors are controlled by CSS currently
            ticks.attr('class', function(d,i,j) {
                return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;
            });

            d3.transition(ticks)
                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
                .attr('d', function(d,i) {
                    var w = (availableWidth / data[0].values.length) * .9;
                    return 'm0,0l0,'
                        + (y(getOpen(d,i))
                            - y(getHigh(d,i)))
                        + 'l'
                        + (-w/2)
                        + ',0l'
                        + (w/2)
                        + ',0l0,'
                        + (y(getLow(d,i))
                            - y(getOpen(d,i)))
                        + 'l0,'
                        + (y(getClose(d,i))
                            - y(getLow(d,i)))
                        + 'l'
                        + (w/2)
                        + ',0l'
                        + (-w/2)
                        + ',0z';
                });
        });

        return chart;
    }


    //Create methods to allow outside functions to highlight a specific bar.
    chart.highlightPoint = function(pointIndex, isHoverOver) {
        chart.clearHighlights();
        d3.select(".nv-ohlcBar .nv-tick-0-" + pointIndex)
            .classed("hover", isHoverOver)
        ;
    };

    chart.clearHighlights = function() {
        d3.select(".nv-ohlcBar .nv-tick.hover")
            .classed("hover", false)
        ;
    };

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:    {get: function(){return width;}, set: function(_){width=_;}},
        height:   {get: function(){return height;}, set: function(_){height=_;}},
        xScale:   {get: function(){return x;}, set: function(_){x=_;}},
        yScale:   {get: function(){return y;}, set: function(_){y=_;}},
        xDomain:  {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain:  {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:   {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:   {get: function(){return yRange;}, set: function(_){yRange=_;}},
        forceX:   {get: function(){return forceX;}, set: function(_){forceX=_;}},
        forceY:   {get: function(){return forceY;}, set: function(_){forceY=_;}},
        padData:  {get: function(){return padData;}, set: function(_){padData=_;}},
        clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        id:       {get: function(){return id;}, set: function(_){id=_;}},
        interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},

        x:     {get: function(){return getX;}, set: function(_){getX=_;}},
        y:     {get: function(){return getY;}, set: function(_){getY=_;}},
        open:  {get: function(){return getOpen();}, set: function(_){getOpen=_;}},
        close: {get: function(){return getClose();}, set: function(_){getClose=_;}},
        high:  {get: function(){return getHigh;}, set: function(_){getHigh=_;}},
        low:   {get: function(){return getLow;}, set: function(_){getLow=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    != undefined ? _.top    : margin.top;
            margin.right  = _.right  != undefined ? _.right  : margin.right;
            margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   != undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

// Code adapted from Jason Davies' "Parallel Coordinates"
// http://bl.ocks.org/jasondavies/1341281

nv.models.parallelCoordinates = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 30, right: 10, bottom: 10, left: 10}
        , width = null
        , height = null
        , x = d3.scale.ordinal()
        , y = {}
        , dimensions = []
        , color = nv.utils.defaultColor()
        , filters = []
        , active = []
        , dispatch = d3.dispatch('brush')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            active = data; //set all active before first brush call

            //This is a placeholder until this chart is made resizeable
            chart.update = function() { };

            // Setup Scales
            x.rangePoints([0, availableWidth], 1).domain(dimensions);

            // Extract the list of dimensions and create a scale for each.
            dimensions.forEach(function(d) {
                y[d] = d3.scale.linear()
                    .domain(d3.extent(data, function(p) { return +p[d]; }))
                    .range([availableHeight, 0]);

                y[d].brush = d3.svg.brush().y(y[d]).on('brush', brush);

                return d != 'name';
            });

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-parallelCoordinates').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-parallelCoordinates');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-parallelCoordinatesWrap');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var line = d3.svg.line(),
                axis = d3.svg.axis().orient('left'),
                background,
                foreground;

            // Add grey background lines for context.
            background = gEnter.append('g')
                .attr('class', 'background')
                .selectAll('path')
                .data(data)
                .enter().append('path')
                .attr('d', path)
            ;

            // Add blue foreground lines for focus.
            foreground = gEnter.append('g')
                .attr('class', 'foreground')
                .selectAll('path')
                .data(data)
                .enter().append('path')
                .attr('d', path)
                .attr('stroke', color)
            ;

            // Add a group element for each dimension.
            var dimension = g.selectAll('.dimension')
                .data(dimensions)
                .enter().append('g')
                .attr('class', 'dimension')
                .attr('transform', function(d) { return 'translate(' + x(d) + ',0)'; });

            // Add an axis and title.
            dimension.append('g')
                .attr('class', 'axis')
                .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('y', -9)
                .text(String);

            // Add and store a brush for each axis.
            dimension.append('g')
                .attr('class', 'brush')
                .each(function(d) { d3.select(this).call(y[d].brush); })
                .selectAll('rect')
                .attr('x', -8)
                .attr('width', 16);

            // Returns the path for a given data point.
            function path(d) {
                return line(dimensions.map(function(p) { return [x(p), y[p](d[p])]; }));
            }

            // Handles a brush event, toggling the display of foreground lines.
            function brush() {
                var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
                    extents = actives.map(function(p) { return y[p].brush.extent(); });

                filters = []; //erase current filters
                actives.forEach(function(d,i) {
                    filters[i] = {
                        dimension: d,
                        extent: extents[i]
                    }
                });

                active = []; //erase current active list
                foreground.style('display', function(d) {
                    var isActive = actives.every(function(p, i) {
                        return extents[i][0] <= d[p] && d[p] <= extents[i][1];
                    });
                    if (isActive) active.push(d);
                    return isActive ? null : 'none';
                });

                dispatch.brush({
                    filters: filters,
                    active: active
                });
            }
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        dimensions: {get: function(){return dimensions;}, set: function(_){dimensions=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
            margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
            margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
            margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};
nv.models.pie = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 500
        , height = 500
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , color = nv.utils.defaultColor()
        , valueFormat = d3.format(',.2f')
        , labelFormat = d3.format('%')
        , showLabels = true
        , pieLabelsOutside = true
        , donutLabelsOutside = false
        , labelType = "key"
        , labelThreshold = .02 //if slice percentage is under this, don't show label
        , donut = false
        , title = false
        , growOnHover = true
        , titleOffset = 0
        , labelSunbeamLayout = false
        , startAngle = false
        , padAngle = false
        , endAngle = false
        , cornerRadius = 0
        , donutRatio = 0.5
        , duration = 250
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;


    //============================================================
    // chart function
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right
                ,availableHeight = height - margin.top - margin.bottom
                ,radius = Math.min(availableWidth, availableHeight) / 2
                ,arcRadius = radius-(radius / 5)
                ,container = d3.select(this)
                ;
            nv.utils.initSVG(container);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('.nv-wrap.nv-pie').data(data);
            var wrapEnter = wrap.enter().append('g').attr('class','nvd3 nv-wrap nv-pie nv-chart-' + id);
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');
            var g_pie = gEnter.append('g').attr('class', 'nv-pie');
            gEnter.append('g').attr('class', 'nv-pieLabels');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            g.select('.nv-pie').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
            g.select('.nv-pieLabels').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');

            //
            container.on('click', function(d,i) {
                dispatch.chartClick({
                    data: d,
                    index: i,
                    pos: d3.event,
                    id: id
                });
            });


            var arc = d3.svg.arc().outerRadius(arcRadius);
            var arcOver = d3.svg.arc().outerRadius(arcRadius + 5);

            if (startAngle) {
                arc.startAngle(startAngle);
                arcOver.startAngle(startAngle);
            }
            if (endAngle) {
                arc.endAngle(endAngle);
                arcOver.endAngle(endAngle);
            }
            if (donut) {
                arc.innerRadius(radius * donutRatio);
                arcOver.innerRadius(radius * donutRatio);
            }

            // Setup the Pie chart and choose the data element
            var pie = d3.layout.pie()
                .sort(null)
                .value(function(d) { return d.disabled ? 0 : getY(d) });

            // padAngle added in d3 3.5
            if (pie.padAngle && padAngle) {
                pie.padAngle(padAngle);
            }

            if (arc.cornerRadius && cornerRadius) {
                arc.cornerRadius(cornerRadius);
                arcOver.cornerRadius(cornerRadius);
            }

            // if title is specified and donut, put it in the middle
            if (donut && title) {
                var title_g = g_pie.append('g').attr('class', 'nv-pie');

                title_g.append("text")
                    .style("text-anchor", "middle")
                    .attr('class', 'nv-pie-title')
                    .text(function (d) {
                        return title;
                    })
                    .attr("dy", "0.35em") // trick to vertically center text
                    .attr('transform', function(d, i) {
                        return 'translate(0, '+ titleOffset + ')';
                    });
            }

            var slices = wrap.select('.nv-pie').selectAll('.nv-slice').data(pie);
            var pieLabels = wrap.select('.nv-pieLabels').selectAll('.nv-label').data(pie);

            slices.exit().remove();
            pieLabels.exit().remove();

            var ae = slices.enter().append('g')
            ae.attr('class', 'nv-slice')
            ae.on('mouseover', function(d,i){
                d3.select(this).classed('hover', true);
                if (growOnHover) {
                    d3.select(this).select("path").transition()
                        .duration(70)
                        .attr("d", arcOver);
                }
                dispatch.elementMouseover({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    pointIndex: i,
                    pos: [d3.event.pageX, d3.event.pageY],
                    id: id,
                    color: d3.select(this).style("fill")
                });
            });
            ae.on('mouseout', function(d,i){
                d3.select(this).classed('hover', false);
                if (growOnHover) {
                    d3.select(this).select("path").transition()
                        .duration(50)
                        .attr("d", arc);
                }
                dispatch.elementMouseout({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    id: id
                });
            });

            slices.attr('fill', function(d,i) { return color(d, i); })
            slices.attr('stroke', function(d,i) { return color(d, i); });

            var paths = ae.append('path').each(function(d) {
                this._current = d;
            });

            paths.on('click', function(d,i) {
                dispatch.elementClick({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    pos: d3.event,
                    id: id
                });
                d3.event.stopPropagation();
            });
            paths.on('dblclick', function(d,i) {
                dispatch.elementDblClick({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    pos: d3.event,
                    id: id
                });
                d3.event.stopPropagation();
            });
            slices.select('path')
                .transition()
                .attr('d', arc)
                .attrTween('d', arcTween);

            if (showLabels) {
                // This does the normal label
                var labelsArc = d3.svg.arc().innerRadius(0);

                if (pieLabelsOutside){
                    var labelsArc = arc;
                }

                if (donutLabelsOutside) {
                    labelsArc = d3.svg.arc().outerRadius(arc.outerRadius());
                }

                pieLabels.enter().append("g").classed("nv-label",true).each(function(d,i) {
                    var group = d3.select(this);

                    group.attr('transform', function(d) {
                        if (labelSunbeamLayout) {
                            d.outerRadius = arcRadius + 10; // Set Outer Coordinate
                            d.innerRadius = arcRadius + 15; // Set Inner Coordinate
                            var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                            if ((d.startAngle+d.endAngle)/2 < Math.PI) {
                                rotateAngle -= 90;
                            } else {
                                rotateAngle += 90;
                            }
                            return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';
                        } else {
                            d.outerRadius = radius + 10; // Set Outer Coordinate
                            d.innerRadius = radius + 15; // Set Inner Coordinate
                            return 'translate(' + labelsArc.centroid(d) + ')'
                        }
                    });

                    group.append('rect')
                        .style('stroke', '#fff')
                        .style('fill', '#fff')
                        .attr("rx", 3)
                        .attr("ry", 3);

                    group.append('text')
                        .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned
                        .style('fill', '#000')

                });

                var labelLocationHash = {};
                var avgHeight = 14;
                var avgWidth = 140;
                var createHashKey = function(coordinates) {
                    return Math.floor(coordinates[0]/avgWidth) * avgWidth + ',' + Math.floor(coordinates[1]/avgHeight) * avgHeight;
                };

                pieLabels.watchTransition(renderWatch,'pie labels').attr('transform', function(d) {
                    if (labelSunbeamLayout) {
                        d.outerRadius = arcRadius + 10; // Set Outer Coordinate
                        d.innerRadius = arcRadius + 15; // Set Inner Coordinate
                        var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                        if ((d.startAngle+d.endAngle)/2 < Math.PI) {
                            rotateAngle -= 90;
                        } else {
                            rotateAngle += 90;
                        }
                        return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';
                    } else {
                        d.outerRadius = radius + 10; // Set Outer Coordinate
                        d.innerRadius = radius + 15; // Set Inner Coordinate

                        /*
                         Overlapping pie labels are not good. What this attempts to do is, prevent overlapping.
                         Each label location is hashed, and if a hash collision occurs, we assume an overlap.
                         Adjust the label's y-position to remove the overlap.
                         */
                        var center = labelsArc.centroid(d);
                        if(d.value){
                            var hashKey = createHashKey(center);
                            if (labelLocationHash[hashKey]) {
                                center[1] -= avgHeight;
                            }
                            labelLocationHash[createHashKey(center)] = true;
                        }
                        return 'translate(' + center + ')'
                    }
                });

                pieLabels.select(".nv-label text")
                    .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned
                    .text(function(d, i) {
                        var percent = (d.endAngle - d.startAngle) / (2 * Math.PI);
                        var labelTypes = {
                            "key" : getX(d.data),
                            "value": getY(d.data),
                            "percent": labelFormat(percent)
                        };
                        return (d.value && percent > labelThreshold) ? labelTypes[labelType] : '';
                    })
                ;
            }


            // Computes the angle of an arc, converting from radians to degrees.
            function angle(d) {
                var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
                return a > 90 ? a - 180 : a;
            }

            function arcTween(a) {
                a.endAngle = isNaN(a.endAngle) ? 0 : a.endAngle;
                a.startAngle = isNaN(a.startAngle) ? 0 : a.startAngle;
                if (!donut) a.innerRadius = 0;
                var i = d3.interpolate(this._current, a);
                this._current = i(0);
                return function(t) {
                    return arc(i(t));
                };
            }
        });

        renderWatch.renderEnd('pie immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=_;}},
        title:      {get: function(){return title;}, set: function(_){title=_;}},
        titleOffset:    {get: function(){return titleOffset;}, set: function(_){titleOffset=_;}},
        labelThreshold: {get: function(){return labelThreshold;}, set: function(_){labelThreshold=_;}},
        labelFormat:    {get: function(){return labelFormat;}, set: function(_){labelFormat=_;}},
        valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
        x:          {get: function(){return getX;}, set: function(_){getX=_;}},
        id:         {get: function(){return id;}, set: function(_){id=_;}},
        endAngle:   {get: function(){return endAngle;}, set: function(_){endAngle=_;}},
        startAngle: {get: function(){return startAngle;}, set: function(_){startAngle=_;}},
        padAngle:   {get: function(){return padAngle;}, set: function(_){padAngle=_;}},
        cornerRadius: {get: function(){return cornerRadius;}, set: function(_){cornerRadius=_;}},
        donutRatio:   {get: function(){return donutRatio;}, set: function(_){donutRatio=_;}},
        pieLabelsOutside:   {get: function(){return pieLabelsOutside;}, set: function(_){pieLabelsOutside=_;}},
        donutLabelsOutside: {get: function(){return donutLabelsOutside;}, set: function(_){donutLabelsOutside=_;}},
        labelSunbeamLayout: {get: function(){return labelSunbeamLayout;}, set: function(_){labelSunbeamLayout=_;}},
        donut:              {get: function(){return donut;}, set: function(_){donut=_;}},
        growOnHover:        {get: function(){return growOnHover;}, set: function(_){growOnHover=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
            margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
            margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
            margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY=d3.functor(_);
        }},
        color: {get: function(){return color;}, set: function(_){
            color=nv.utils.getColor(_);
        }},
        labelType:          {get: function(){return labelType;}, set: function(_){
            labelType= _ || 'key';
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};
nv.models.pieChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var pie = nv.models.pie();
    var legend = nv.models.legend();

    var margin = {top: 30, right: 20, bottom: 20, left: 20}
        , width = null
        , height = null
        , showLegend = true
        , color = nv.utils.defaultColor()
        , tooltips = true
        , tooltip = function(key, y, e, graph) {
            return '<h3 style="background-color: '
                + e.color + '">' + key + '</h3>'
                + '<p>' +  y + '</p>';
        }
        , state = nv.utils.state()
        , defaultState = null
        , noData = "No Data Available."
        , duration = 250
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var tooltipLabel = pie.x()(e.point);
        var left = e.pos[0] + ( (offsetElement && offsetElement.offsetLeft) || 0 ),
            top = e.pos[1] + ( (offsetElement && offsetElement.offsetTop) || 0),
            y = pie.valueFormat()(pie.y()(e.point)),
            content = tooltip(tooltipLabel, y, e, chart)
            ;
        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch);

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined) {
                data.forEach(function (series, i) {
                    series.disabled = !state.active[i];
                });
            }
        }
    };

    //============================================================
    // Chart function
    //------------------------------------------------------------

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(pie);

        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var that = this;
            var availableWidth = (width || parseInt(container.style('width'), 10) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height'), 10) || 400)
                    - margin.top - margin.bottom
                ;

            chart.update = function() { container.transition().call(chart); };
            chart.container = this;

            state.setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-pieWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');

            // Legend
            if (showLegend) {
                legend.width( availableWidth ).key(pie.x());

                wrap.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')');
            }
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            pie.width(availableWidth).height(availableHeight);
            var pieWrap = g.select('.nv-pieWrap').datum([data]);
            d3.transition(pieWrap).call(pie);

            // Event Handling/Dispatching (in chart's scope)
            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState) {
                    state[key] = newState[key];
                }
                dispatch.stateChange(state);
                chart.update();
            });

            pie.dispatch.on('elementMouseout.tooltip', function(e) {
                dispatch.tooltipHide(e);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                    state.disabled = e.disabled;
                }
                chart.update();
            });

        });

        renderWatch.renderEnd('pieChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    pie.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.legend = legend;
    chart.dispatch = dispatch;
    chart.pie = pie;
    chart.options = nv.utils.optionsFunc.bind(chart);

    // use Object get/set functionality to map between vars and chart functions
    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        noData:         {get: function(){return noData;},         set: function(_){noData=_;}},
        tooltipContent: {get: function(){return tooltip;},        set: function(_){tooltip=_;}},
        tooltips:       {get: function(){return tooltips;},       set: function(_){tooltips=_;}},
        showLegend:     {get: function(){return showLegend;},     set: function(_){showLegend=_;}},
        defaultState:   {get: function(){return defaultState;},   set: function(_){defaultState=_;}},
        // options that require extra logic in the setter
        color: {get: function(){return color;}, set: function(_){
            color = _;
            legend.color(color);
            pie.color(color);
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }}
    });
    nv.utils.inheritOptions(chart, pie);
    nv.utils.initOptions(chart);
    return chart;
};

nv.models.scatter = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin       = {top: 0, right: 0, bottom: 0, left: 0}
        , width        = null
        , height       = null
        , color        = nv.utils.defaultColor() // chooses color
        , id           = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't select one
        , x            = d3.scale.linear()
        , y            = d3.scale.linear()
        , z            = d3.scale.linear() //linear because d3.svg.shape.size is treated as area
        , getX         = function(d) { return d.x } // accessor to get the x value
        , getY         = function(d) { return d.y } // accessor to get the y value
        , getSize      = function(d) { return d.size || 1} // accessor to get the point size
        , getShape     = function(d) { return d.shape || 'circle' } // accessor to get point shape
        , forceX       = [] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
        , forceY       = [] // List of numbers to Force into the Y scale
        , forceSize    = [] // List of numbers to Force into the Size scale
        , interactive  = true // If true, plots a voronoi overlay for advanced point intersection
        , pointActive  = function(d) { return !d.notActive } // any points that return false will be filtered out
        , padData      = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
        , padDataOuter = .1 //outerPadding to imitate ordinal scale outer padding
        , clipEdge     = false // if true, masks points within x and y scale
        , clipVoronoi  = true // if true, masks each point with a circle... can turn off to slightly increase performance
        , clipRadius   = function() { return 25 } // function to get the radius for voronoi point clips
        , xDomain      = null // Override x domain (skips the calculation from data)
        , yDomain      = null // Override y domain
        , xRange       = null // Override x range
        , yRange       = null // Override y range
        , sizeDomain   = null // Override point size domain
        , sizeRange    = null
        , singlePoint  = false
        , dispatch     = d3.dispatch('elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        , useVoronoi   = true
        , duration     = 250
        ;


    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0, z0 // used to store previous scales
        , timeoutID
        , needsUpdate = false // Flag for when the points are visually updating, but the interactive layer is behind, to disable tooltips
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain && sizeDomain) ? [] : // if we know xDomain and yDomain and sizeDomain, no need to calculate.... if Size is constant remember to set sizeDomain to speed up performance
                d3.merge(
                    data.map(function(d) {
                        return d.values.map(function(d,i) {
                            return { x: getX(d,i), y: getY(d,i), size: getSize(d,i) }
                        })
                    })
                );

            x   .domain(xDomain || d3.extent(seriesData.map(function(d) { return d.x; }).concat(forceX)))

            if (padData && data[0])
                x.range(xRange || [(availableWidth * padDataOuter +  availableWidth) / (2 *data[0].values.length), availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length)  ]);
            //x.range([availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
            else
                x.range(xRange || [0, availableWidth]);

            y   .domain(yDomain || d3.extent(seriesData.map(function(d) { return d.y }).concat(forceY)))
                .range(yRange || [availableHeight, 0]);

            z   .domain(sizeDomain || d3.extent(seriesData.map(function(d) { return d.size }).concat(forceSize)))
                .range(sizeRange || [16, 256]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] - y.domain()[0] * 0.01, y.domain()[1] + y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            if ( isNaN(x.domain()[0])) {
                x.domain([-1,1]);
            }

            if ( isNaN(y.domain()[0])) {
                y.domain([-1,1]);
            }

            x0 = x0 || x;
            y0 = y0 || y;
            z0 = z0 || z;

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-scatter').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatter nv-chart-' + id + (singlePoint ? ' nv-single-point' : ''));
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            gEnter.append('g').attr('class', 'nv-point-paths');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + id)
                .append('rect');

            wrap.select('#nv-edge-clip-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', (availableHeight > 0) ? availableHeight : 0);

            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');

            function updateInteractiveLayer() {

                if (!interactive) return false;

                var eventElements;

                var vertices = d3.merge(data.map(function(group, groupIndex) {
                        return group.values
                            .map(function(point, pointIndex) {
                                // *Adding noise to make duplicates very unlikely
                                // *Injecting series and point index for reference
                                /* *Adding a 'jitter' to the points, because there's an issue in d3.geom.voronoi.
                                 */
                                var pX = getX(point,pointIndex);
                                var pY = getY(point,pointIndex);

                                return [x(pX)+ Math.random() * 1e-7,
                                        y(pY)+ Math.random() * 1e-7,
                                    groupIndex,
                                    pointIndex, point]; //temp hack to add noise untill I think of a better way so there are no duplicates
                            })
                            .filter(function(pointArray, pointIndex) {
                                return pointActive(pointArray[4], pointIndex); // Issue #237.. move filter to after map, so pointIndex is correct!
                            })
                    })
                );

                //inject series and point index for reference into voronoi
                if (useVoronoi === true) {

                    if(vertices.length < 3) {
                        // Issue #283 - Adding 2 dummy points to the voronoi b/c voronoi requires min 3 points to work
                        vertices.push([x.range()[0] - 20, y.range()[0] - 20, null, null]);
                        vertices.push([x.range()[1] + 20, y.range()[1] + 20, null, null]);
                        vertices.push([x.range()[0] - 20, y.range()[0] + 20, null, null]);
                        vertices.push([x.range()[1] + 20, y.range()[1] - 20, null, null]);
                    }

                    // keep voronoi sections from going more than 10 outside of graph
                    // to avoid overlap with other things like legend etc
                    var bounds = d3.geom.polygon([
                        [-10,-10],
                        [-10,height + 10],
                        [width + 10,height + 10],
                        [width + 10,-10]
                    ]);

                    var voronoi = d3.geom.voronoi(vertices).map(function(d, i) {
                        return {
                            'data': bounds.clip(d),
                            'series': vertices[i][2],
                            'point': vertices[i][3]
                        }
                    });

                    // nuke all voronoi paths on reload and recreate them
                    wrap.select('.nv-point-paths').selectAll('path').remove();
                    var pointPaths = wrap.select('.nv-point-paths').selectAll('path').data(voronoi);
                    pointPaths
                        .enter().append("svg:path")
                        .attr("d", function(d) {
                            if (!d || !d.data || d.data.length === 0)
                                return 'M 0 0';
                            else
                                return "M" + d.data.join(",") + "Z";
                        })
                        .attr("id", function(d,i) {
                            return "nv-path-"+i; })
                        .attr("clip-path", function(d,i) { return "url(#nv-clip-"+i+")"; })
                        ;
                        // chain these to above to see the voronoi elements (good for debugging)
                        //.style("fill", d3.rgb(230, 230, 230))
                        //.style('fill-opacity', 0.4)
                        //.style('stroke-opacity', 1)
                        //.style("stroke", d3.rgb(200,200,200));

                    if (clipVoronoi) {
                        // voronoi sections are already set to clip,
                        // just create the circles with the IDs they expect
                        var clips = wrap.append("svg:g").attr("id", "nv-point-clips");
                        clips.selectAll("clipPath")
                            .data(vertices)
                            .enter().append("svg:clipPath")
                            .attr("id", function(d, i) { return "nv-clip-"+i;})
                            .append("svg:circle")
                            .attr('cx', function(d) { return d[0]; })
                            .attr('cy', function(d) { return d[1]; })
                            .attr('r', clipRadius);
                    }

                    var mouseEventCallback = function(d,mDispatch) {
                        if (needsUpdate) return 0;
                        var series = data[d.series];
                        if (typeof series === 'undefined') return;
                        var point  = series.values[d.point];

                        mDispatch({
                            point: point,
                            series: series,
                            pos: [x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top],
                            seriesIndex: d.series,
                            pointIndex: d.point
                        });
                    };

                    pointPaths
                        .on('click', function(d) {
                            mouseEventCallback(d, dispatch.elementClick);
                        })
                        .on('dblclick', function(d) {
                            mouseEventCallback(d, dispatch.elementDblClick);
                        })
                        .on('mouseover', function(d) {
                            mouseEventCallback(d, dispatch.elementMouseover);
                        })
                        .on('mouseout', function(d, i) {
                            mouseEventCallback(d, dispatch.elementMouseout);
                        });

                } else {
                    /*
                     // bring data in form needed for click handlers
                     var dataWithPoints = vertices.map(function(d, i) {
                     return {
                     'data': d,
                     'series': vertices[i][2],
                     'point': vertices[i][3]
                     }
                     });
                     */

                    // add event handlers to points instead voronoi paths
                    wrap.select('.nv-groups').selectAll('.nv-group')
                        .selectAll('.nv-point')
                        //.data(dataWithPoints)
                        //.style('pointer-events', 'auto') // recativate events, disabled by css
                        .on('click', function(d,i) {
                            //nv.log('test', d, i);
                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                            var series = data[d.series],
                                point  = series.values[i];

                            dispatch.elementClick({
                                point: point,
                                series: series,
                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        })
                        .on('mouseover', function(d,i) {
                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                            var series = data[d.series],
                                point  = series.values[i];

                            dispatch.elementMouseover({
                                point: point,
                                series: series,
                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        })
                        .on('mouseout', function(d,i) {
                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                            var series = data[d.series],
                                point  = series.values[i];

                            dispatch.elementMouseout({
                                point: point,
                                series: series,
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        });
                }

                needsUpdate = false;
            }

            needsUpdate = true;
            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d) { return d.key });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);
            groups.exit()
                .remove();
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover });
            groups.watchTransition(renderWatch, 'scatter: groups')
                .style('fill', function(d,i) { return color(d, i) })
                .style('stroke', function(d,i) { return color(d, i) })
                .style('stroke-opacity', 1)
                .style('fill-opacity', .5);

            // create the points
            var points = groups.selectAll('path.nv-point')
                .data(function(d) { return d.values });
            points.enter().append('path')
                .style('fill', function (d,i) { return d.color })
                .style('stroke', function (d,i) { return d.color })
                .attr('transform', function(d,i) {
                    return 'translate(' + x0(getX(d,i)) + ',' + y0(getY(d,i)) + ')'
                })
                .attr('d',
                    nv.utils.symbol()
                    .type(getShape)
                    .size(function(d,i) { return z(getSize(d,i)) })
            );
            points.exit().remove();
            groups.exit().selectAll('path.nv-point')
                .watchTransition(renderWatch, 'scatter exit')
                .attr('transform', function(d,i) {
                    return 'translate(' + x(getX(d,i)) + ',' + y(getY(d,i)) + ')'
                })
                .remove();
            points.each(function(d,i) {
                d3.select(this)
                    .classed('nv-point', true)
                    .classed('nv-point-' + i, true)
                    .classed('hover',false)
                ;
            });
            points
                .watchTransition(renderWatch, 'scatter points')
                .attr('transform', function(d,i) {
                    //nv.log(d,i,getX(d,i), x(getX(d,i)));
                    return 'translate(' + x(getX(d,i)) + ',' + y(getY(d,i)) + ')'
                })
                .attr('d',
                    nv.utils.symbol()
                    .type(getShape)
                    .size(function(d,i) { return z(getSize(d,i)) })
            );

            // Delay updating the invisible interactive layer for smoother animation
            clearTimeout(timeoutID); // stop repeat calls to updateInteractiveLayer
            timeoutID = setTimeout(updateInteractiveLayer, 300);
            //updateInteractiveLayer();

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();
            z0 = z.copy();

        });
        renderWatch.renderEnd('scatter immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    // utility function calls provided by this chart
    chart._calls = new function() {
        this.clearHighlights = function () {
            d3.selectAll(".nv-chart-" + id + " .nv-point.hover").classed("hover", false);
            return null;
        };
        this.highlightPoint = function (seriesIndex, pointIndex, isHoverOver) {
            d3.select(".nv-chart-" + id + " .nv-series-" + seriesIndex + " .nv-point-" + pointIndex)
                .classed("hover", isHoverOver);
        };
    };

    // trigger calls from events too
    dispatch.on('elementMouseover.point', function(d) {
        if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,true);
    });

    dispatch.on('elementMouseout.point', function(d) {
        if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,false);
    });

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:        {get: function(){return width;}, set: function(_){width=_;}},
        height:       {get: function(){return height;}, set: function(_){height=_;}},
        xScale:       {get: function(){return x;}, set: function(_){x=_;}},
        yScale:       {get: function(){return y;}, set: function(_){y=_;}},
        pointScale:   {get: function(){return z;}, set: function(_){z=_;}},
        xDomain:      {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain:      {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        pointDomain:  {get: function(){return sizeDomain;}, set: function(_){sizeDomain=_;}},
        xRange:       {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:       {get: function(){return yRange;}, set: function(_){yRange=_;}},
        pointRange:   {get: function(){return sizeRange;}, set: function(_){sizeRange=_;}},
        forceX:       {get: function(){return forceX;}, set: function(_){forceX=_;}},
        forceY:       {get: function(){return forceY;}, set: function(_){forceY=_;}},
        forcePoint:   {get: function(){return forceSize;}, set: function(_){forceSize=_;}},
        interactive:  {get: function(){return interactive;}, set: function(_){interactive=_;}},
        pointActive:  {get: function(){return pointActive;}, set: function(_){pointActive=_;}},
        padDataOuter: {get: function(){return padDataOuter;}, set: function(_){padDataOuter=_;}},
        padData:      {get: function(){return padData;}, set: function(_){padData=_;}},
        clipEdge:     {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        clipVoronoi:  {get: function(){return clipVoronoi;}, set: function(_){clipVoronoi=_;}},
        clipRadius:   {get: function(){return clipRadius;}, set: function(_){clipRadius=_;}},
        id:           {get: function(){return id;}, set: function(_){id=_;}},


        // simple functor options
        x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},
        y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},
        pointSize: {get: function(){return getSize;}, set: function(_){getSize = d3.functor(_);}},
        pointShape: {get: function(){return getShape;}, set: function(_){getShape = d3.functor(_);}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color: {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        useVoronoi: {get: function(){return useVoronoi;}, set: function(_){
            useVoronoi = _;
            if (useVoronoi === false) {
                clipVoronoi = false;
            }
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

nv.models.scatterChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var scatter      = nv.models.scatter()
        , xAxis        = nv.models.axis()
        , yAxis        = nv.models.axis()
        , legend       = nv.models.legend()
        , distX        = nv.models.distribution()
        , distY        = nv.models.distribution()
        ;

    var margin       = {top: 30, right: 20, bottom: 50, left: 75}
        , width        = null
        , height       = null
        , color        = nv.utils.defaultColor()
        , x            = scatter.xScale()
        , y            = scatter.yScale()
        , showDistX    = false
        , showDistY    = false
        , showLegend   = true
        , showXAxis    = true
        , showYAxis    = true
        , rightAlignYAxis = false
        , tooltips     = true
        , tooltipX     = function(key, x, y) { return '<strong>' + x + '</strong>' }
        , tooltipY     = function(key, x, y) { return '<strong>' + y + '</strong>' }
        , tooltip      = function(key, x, y, date) { return '<h3>' + key + '</h3>'
            + '<p>' + date + '</p>' }
        , state = nv.utils.state()
        , defaultState = null
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , noData       = "No Data Available."
        , duration = 250
        ;

    scatter
        .xScale(x)
        .yScale(y)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(10)
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
        .tickPadding(10)
    ;
    distX
        .axis('x')
    ;
    distY
        .axis('y')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0
        , renderWatch = nv.utils.renderWatch(dispatch, duration);

    var showTooltip = function(e, offsetElement) {
        //TODO: make tooltip style an option between single or dual on axes (maybe on all charts with axes?
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            leftX = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            topX = y.range()[0] + margin.top + ( offsetElement.offsetTop || 0),
            leftY = x.range()[0] + margin.left + ( offsetElement.offsetLeft || 0 ),
            topY = e.pos[1] + ( offsetElement.offsetTop || 0),
            xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)),
            yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));

        if( tooltipX != null )
            nv.tooltip.show([leftX, topX], tooltipX(e.series.key, xVal, yVal, e, chart), 'n', 1, offsetElement, 'x-nvtooltip');
        if( tooltipY != null )
            nv.tooltip.show([leftY, topY], tooltipY(e.series.key, xVal, yVal, e, chart), 'e', 1, offsetElement, 'y-nvtooltip');
        if( tooltip != null )
            nv.tooltip.show([left, top], tooltip(e.series.key, xVal, yVal, e.point.tooltip, e, chart), e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(scatter);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);
        if (showDistX) renderWatch.models(distX);
        if (showDistY) renderWatch.models(distY);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition().duration(duration).call(chart);
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                renderWatch.renderEnd('scatter immediate');

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = scatter.xScale();
            y = scatter.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            // background for pointer events
            gEnter.append('rect').attr('class', 'nvd3 nv-background').style("pointer-events","none");

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-scatterWrap');
            gEnter.append('g').attr('class', 'nv-regressionLinesWrap');
            gEnter.append('g').attr('class', 'nv-distWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Legend
            if (showLegend) {
                legend.width( availableWidth / 2 );

                wrap.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + (availableWidth / 2) + ',' + (-margin.top) +')');
            }

            // Main Chart Component(s)
            scatter
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));

            wrap.select('.nv-scatterWrap')
                .datum(data.filter(function(d) { return !d.disabled }))
                .call(scatter);


            wrap.select('.nv-regressionLinesWrap')
                .attr('clip-path', 'url(#nv-edge-clip-' + scatter.id() + ')');

            var regWrap = wrap.select('.nv-regressionLinesWrap').selectAll('.nv-regLines')
                .data(function (d) {
                    return d;
                });

            regWrap.enter().append('g').attr('class', 'nv-regLines');

            var regLine = regWrap.selectAll('.nv-regLine')
                .data(function (d) {
                    return [d]
                });

            regLine.enter()
                .append('line').attr('class', 'nv-regLine')
                .style('stroke-opacity', 0);

            // don't add lines unless we have slope and intercept to use
            regLine.filter(function(d) {
                return d.intercept && d.slope;
            })
                .watchTransition(renderWatch, 'scatterPlusLineChart: regline')
                .attr('x1', x.range()[0])
                .attr('x2', x.range()[1])
                .attr('y1', function (d, i) {
                    return y(x.domain()[0] * d.slope + d.intercept)
                })
                .attr('y2', function (d, i) {
                    return y(x.domain()[1] * d.slope + d.intercept)
                })
                .style('stroke', function (d, i, j) {
                    return color(d, j)
                })
                .style('stroke-opacity', function (d, i) {
                    return (d.disabled || typeof d.slope === 'undefined' || typeof d.intercept === 'undefined') ? 0 : 1
                });

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( xAxis.ticks() ? xAxis.ticks() : nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize( -availableHeight , 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')')
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( yAxis.ticks() ? yAxis.ticks() : nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }


            if (showDistX) {
                distX
                    .getData(scatter.x())
                    .scale(x)
                    .width(availableWidth)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled }));
                gEnter.select('.nv-distWrap').append('g')
                    .attr('class', 'nv-distributionX');
                g.select('.nv-distributionX')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')')
                    .datum(data.filter(function(d) { return !d.disabled }))
                    .call(distX);
            }

            if (showDistY) {
                distY
                    .getData(scatter.y())
                    .scale(y)
                    .width(availableHeight)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled }));
                gEnter.select('.nv-distWrap').append('g')
                    .attr('class', 'nv-distributionY');
                g.select('.nv-distributionY')
                    .attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size() ) + ',0)')
                    .datum(data.filter(function(d) { return !d.disabled }))
                    .call(distY);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });


            scatter.dispatch.on('elementMouseover.tooltip', function(e) {
                d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
                    .attr('y1', e.pos[1] - availableHeight);
                d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
                    .attr('x2', e.pos[0] + distX.size());

                e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];
                dispatch.tooltipShow(e);
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                chart.update();
            });

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

        });

        renderWatch.renderEnd('scatter with line immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    scatter.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);

        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
            .attr('y1', 0);
        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
            .attr('x2', distY.size());
    });
    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.scatter = scatter;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.distX = distX;
    chart.distY = distY;

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showDistX:  {get: function(){return showDistX;}, set: function(_){showDistX=_;}},
        showDistY:  {get: function(){return showDistY;}, set: function(_){showDistY=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis:  {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:  {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:   {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:   {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        tooltipXContent:  {get: function(){return tooltipX;}, set: function(_){tooltipX=_;}},
        tooltipYContent:  {get: function(){return tooltipY;}, set: function(_){tooltipY=_;}},
        defaultState:     {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:     {get: function(){return noData;}, set: function(_){noData=_;}},
        duration:   {get: function(){return duration;}, set: function(_){duration=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }},
        color: {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            distX.color(color);
            distY.color(color);
        }}
    });

    nv.utils.inheritOptions(chart, scatter);
    nv.utils.initOptions(chart);
    return chart;
};

nv.models.sparkline = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 2, right: 0, bottom: 2, left: 0}
        , width = 400
        , height = 32
        , animate = true
        , x = d3.scale.linear()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , color = nv.utils.getColor(['#000'])
        , xDomain
        , yDomain
        , xRange
        , yRange
        ;

    function chart(selection) {
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup Scales
            x   .domain(xDomain || d3.extent(data, getX ))
                .range(xRange || [0, availableWidth]);

            y   .domain(yDomain || d3.extent(data, getY ))
                .range(yRange || [availableHeight, 0]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-sparkline').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparkline');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

            var paths = wrap.selectAll('path')
                .data(function(d) { return [d] });
            paths.enter().append('path');
            paths.exit().remove();
            paths
                .style('stroke', function(d,i) { return d.color || color(d, i) })
                .attr('d', d3.svg.line()
                    .x(function(d,i) { return x(getX(d,i)) })
                    .y(function(d,i) { return y(getY(d,i)) })
            );

            // TODO: Add CURRENT data point (Need Min, Mac, Current / Most recent)
            var points = wrap.selectAll('circle.nv-point')
                .data(function(data) {
                    var yValues = data.map(function(d, i) { return getY(d,i); });
                    function pointIndex(index) {
                        if (index != -1) {
                            var result = data[index];
                            result.pointIndex = index;
                            return result;
                        } else {
                            return null;
                        }
                    }
                    var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])),
                        minPoint = pointIndex(yValues.indexOf(y.domain()[0])),
                        currentPoint = pointIndex(yValues.length - 1);
                    return [minPoint, maxPoint, currentPoint].filter(function (d) {return d != null;});
                });
            points.enter().append('circle');
            points.exit().remove();
            points
                .attr('cx', function(d,i) { return x(getX(d,d.pointIndex)) })
                .attr('cy', function(d,i) { return y(getY(d,d.pointIndex)) })
                .attr('r', 2)
                .attr('class', function(d,i) {
                    return getX(d, d.pointIndex) == x.domain()[1] ? 'nv-point nv-currentValue' :
                            getY(d, d.pointIndex) == y.domain()[0] ? 'nv-point nv-minValue' : 'nv-point nv-maxValue'
                });
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:     {get: function(){return width;}, set: function(_){width=_;}},
        height:    {get: function(){return height;}, set: function(_){height=_;}},
        xDomain:   {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain:   {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:    {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:    {get: function(){return yRange;}, set: function(_){yRange=_;}},
        xScale:    {get: function(){return x;}, set: function(_){x=_;}},
        yScale:    {get: function(){return y;}, set: function(_){y=_;}},
        animate:   {get: function(){return animate;}, set: function(_){animate=_;}},

        //functor options
        x: {get: function(){return getX;}, set: function(_){getX=d3.functor(_);}},
        y: {get: function(){return getY;}, set: function(_){getY=d3.functor(_);}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

nv.models.sparklinePlus = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var sparkline = nv.models.sparkline();

    var margin = {top: 15, right: 100, bottom: 10, left: 50}
        , width = null
        , height = null
        , x
        , y
        , index = []
        , paused = false
        , xTickFormat = d3.format(',r')
        , yTickFormat = d3.format(',.2f')
        , showValue = true
        , alignValue = true
        , rightAlignValue = false
        , noData = "No Data Available."
        ;

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() { chart(selection) };
            chart.container = this;

            // Display No Data message if there's nothing to show.
            if (!data || !data.length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            var currentValue = sparkline.y()(data[data.length-1], data.length-1);

            // Setup Scales
            x = sparkline.xScale();
            y = sparkline.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-sparklineplus').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparklineplus');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-sparklineWrap');
            gEnter.append('g').attr('class', 'nv-valueWrap');
            gEnter.append('g').attr('class', 'nv-hoverArea');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            var sparklineWrap = g.select('.nv-sparklineWrap');

            sparkline.width(availableWidth).height(availableHeight);
            sparklineWrap.call(sparkline);

            var valueWrap = g.select('.nv-valueWrap');
            var value = valueWrap.selectAll('.nv-currentValue')
                .data([currentValue]);

            value.enter().append('text').attr('class', 'nv-currentValue')
                .attr('dx', rightAlignValue ? -8 : 8)
                .attr('dy', '.9em')
                .style('text-anchor', rightAlignValue ? 'end' : 'start');

            value
                .attr('x', availableWidth + (rightAlignValue ? margin.right : 0))
                .attr('y', alignValue ? function(d) { return y(d) } : 0)
                .style('fill', sparkline.color()(data[data.length-1], data.length-1))
                .text(yTickFormat(currentValue));

            gEnter.select('.nv-hoverArea').append('rect')
                .on('mousemove', sparklineHover)
                .on('click', function() { paused = !paused })
                .on('mouseout', function() { index = []; updateValueLine(); });

            g.select('.nv-hoverArea rect')
                .attr('transform', function(d) { return 'translate(' + -margin.left + ',' + -margin.top + ')' })
                .attr('width', availableWidth + margin.left + margin.right)
                .attr('height', availableHeight + margin.top);

            //index is currently global (within the chart), may or may not keep it that way
            function updateValueLine() {
                if (paused) return;

                var hoverValue = g.selectAll('.nv-hoverValue').data(index)

                var hoverEnter = hoverValue.enter()
                    .append('g').attr('class', 'nv-hoverValue')
                    .style('stroke-opacity', 0)
                    .style('fill-opacity', 0);

                hoverValue.exit()
                    .transition().duration(250)
                    .style('stroke-opacity', 0)
                    .style('fill-opacity', 0)
                    .remove();

                hoverValue
                    .attr('transform', function(d) { return 'translate(' + x(sparkline.x()(data[d],d)) + ',0)' })
                    .transition().duration(250)
                    .style('stroke-opacity', 1)
                    .style('fill-opacity', 1);

                if (!index.length) return;

                hoverEnter.append('line')
                    .attr('x1', 0)
                    .attr('y1', -margin.top)
                    .attr('x2', 0)
                    .attr('y2', availableHeight);

                hoverEnter.append('text').attr('class', 'nv-xValue')
                    .attr('x', -6)
                    .attr('y', -margin.top)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.9em')

                g.select('.nv-hoverValue .nv-xValue')
                    .text(xTickFormat(sparkline.x()(data[index[0]], index[0])));

                hoverEnter.append('text').attr('class', 'nv-yValue')
                    .attr('x', 6)
                    .attr('y', -margin.top)
                    .attr('text-anchor', 'start')
                    .attr('dy', '.9em')

                g.select('.nv-hoverValue .nv-yValue')
                    .text(yTickFormat(sparkline.y()(data[index[0]], index[0])));
            }

            function sparklineHover() {
                if (paused) return;

                var pos = d3.mouse(this)[0] - margin.left;

                function getClosestIndex(data, x) {
                    var distance = Math.abs(sparkline.x()(data[0], 0) - x);
                    var closestIndex = 0;
                    for (var i = 0; i < data.length; i++){
                        if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {
                            distance = Math.abs(sparkline.x()(data[i], i) - x);
                            closestIndex = i;
                        }
                    }
                    return closestIndex;
                }

                index = [getClosestIndex(data, Math.round(x.invert(pos)))];
                updateValueLine();
            }

        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.sparkline = sparkline;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:           {get: function(){return width;}, set: function(_){width=_;}},
        height:          {get: function(){return height;}, set: function(_){height=_;}},
        xTickFormat:     {get: function(){return xTickFormat;}, set: function(_){xTickFormat=_;}},
        yTickFormat:     {get: function(){return yTickFormat;}, set: function(_){yTickFormat=_;}},
        showValue:       {get: function(){return showValue;}, set: function(_){showValue=_;}},
        alignValue:      {get: function(){return alignValue;}, set: function(_){alignValue=_;}},
        rightAlignValue: {get: function(){return rightAlignValue;}, set: function(_){rightAlignValue=_;}},
        noData:          {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }}
    });

    nv.utils.inheritOptions(chart, sparkline);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.stackedArea = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , color = nv.utils.defaultColor() // a function that computes the color
        , id = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't selet one
        , getX = function(d) { return d.x } // accessor to get the x value from a data point
        , getY = function(d) { return d.y } // accessor to get the y value from a data point
        , style = 'stack'
        , offset = 'zero'
        , order = 'default'
        , interpolate = 'linear'  // controls the line interpolation
        , clipEdge = false // if true, masks lines within x and y scale
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , scatter = nv.models.scatter()
        , duration = 250
        , dispatch =  d3.dispatch('tooltipShow', 'tooltipHide', 'areaClick', 'areaMouseover', 'areaMouseout','renderEnd')
        ;

    // scatter is interactive by default, but this chart isn't so must disable
    scatter.interactive(false);

    scatter
        .pointSize(2.2) // default size
        .pointDomain([2.2, 2.2]) // all the same size by default
    ;

    /************************************
     * offset:
     *   'wiggle' (stream)
     *   'zero' (stacked)
     *   'expand' (normalize to 100%)
     *   'silhouette' (simple centered)
     *
     * order:
     *   'inside-out' (stream)
     *   'default' (input order)
     ************************************/

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(scatter);
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup Scales
            x = scatter.xScale();
            y = scatter.yScale();

            var dataRaw = data;
            // Injecting point index into each point because d3.layout.stack().out does not give index
            data.forEach(function(aseries, i) {
                aseries.seriesIndex = i;
                aseries.values = aseries.values.map(function(d, j) {
                    d.index = j;
                    d.seriesIndex = i;
                    return d;
                });
            });

            var dataFiltered = data.filter(function(series) {
                return !series.disabled;
            });

            data = d3.layout.stack()
                .order(order)
                .offset(offset)
                .values(function(d) { return d.values })  //TODO: make values customizeable in EVERY model in this fashion
                .x(getX)
                .y(getY)
                .out(function(d, y0, y) {
                    var yHeight = (getY(d) === 0) ? 0 : y;
                    d.display = {
                        y: yHeight,
                        y0: y0
                    };
                })
            (dataFiltered);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-stackedarea').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedarea');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-areaWrap');
            gEnter.append('g').attr('class', 'nv-scatterWrap');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            scatter
                .width(availableWidth)
                .height(availableHeight)
                .x(getX)
                .y(function(d) { return d.display.y + d.display.y0 })
                .forceY([0])
                .color(data.map(function(d,i) {
                    return d.color || color(d, d.seriesIndex);
                }));

            var scatterWrap = g.select('.nv-scatterWrap')
                .datum(data);

            scatterWrap.call(scatter);

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + id)
                .append('rect');

            wrap.select('#nv-edge-clip-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');

            var area = d3.svg.area()
                .x(function(d,i)  { return x(getX(d,i)) })
                .y0(function(d) {
                    return y(d.display.y0)
                })
                .y1(function(d) {
                    return y(d.display.y + d.display.y0)
                })
                .interpolate(interpolate);

            var zeroArea = d3.svg.area()
                .x(function(d,i)  { return x(getX(d,i)) })
                .y0(function(d) { return y(d.display.y0) })
                .y1(function(d) { return y(d.display.y0) });

            var path = g.select('.nv-areaWrap').selectAll('path.nv-area')
                .data(function(d) { return d });

            path.enter().append('path').attr('class', function(d,i) { return 'nv-area nv-area-' + i })
                .attr('d', function(d,i){
                    return zeroArea(d.values, d.seriesIndex);
                })
                .on('mouseover', function(d,i) {
                    d3.select(this).classed('hover', true);
                    dispatch.areaMouseover({
                        point: d,
                        series: d.key,
                        pos: [d3.event.pageX, d3.event.pageY],
                        seriesIndex: d.seriesIndex
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.areaMouseout({
                        point: d,
                        series: d.key,
                        pos: [d3.event.pageX, d3.event.pageY],
                        seriesIndex: d.seriesIndex
                    });
                })
                .on('click', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.areaClick({
                        point: d,
                        series: d.key,
                        pos: [d3.event.pageX, d3.event.pageY],
                        seriesIndex: d.seriesIndex
                    });
                });

            path.exit().remove();
            path.style('fill', function(d,i){
                    return d.color || color(d, d.seriesIndex)
                })
                .style('stroke', function(d,i){ return d.color || color(d, d.seriesIndex) });
            path.watchTransition(renderWatch,'stackedArea path')
                .attr('d', function(d,i) {
                    return area(d.values,i)
                });

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            scatter.dispatch.on('elementMouseover.area', function(e) {
                g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', true);
            });
            scatter.dispatch.on('elementMouseout.area', function(e) {
                g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', false);
            });

            //Special offset functions
            chart.d3_stackedOffset_stackPercent = function(stackData) {
                var n = stackData.length,    //How many series
                    m = stackData[0].length,     //how many points per series
                    k = 1 / n,
                    i,
                    j,
                    o,
                    y0 = [];

                for (j = 0; j < m; ++j) { //Looping through all points
                    for (i = 0, o = 0; i < dataRaw.length; i++) { //looping through series'
                        o += getY(dataRaw[i].values[j]);   //total value of all points at a certian point in time.
                    }

                    if (o) for (i = 0; i < n; i++) {
                        stackData[i][j][1] /= o;
                    } else {
                        for (i = 0; i < n; i++) {
                            stackData[i][j][1] = k;
                        }
                    }
                }
                for (j = 0; j < m; ++j) y0[j] = 0;
                return y0;
            };

        });

        renderWatch.renderEnd('stackedArea immediate');
        return chart;
    }


    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    scatter.dispatch.on('elementClick.area', function(e) {
        dispatch.areaClick(e);
    });
    scatter.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
            dispatch.tooltipShow(e);
    });
    scatter.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    //============================================================
    // Global getters and setters
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.scatter = scatter;

    chart.interpolate = function(_) {
        if (!arguments.length) return interpolate;
        interpolate = _;
        return chart;
    };

    chart.duration = function(_) {
        if (!arguments.length) return duration;
        duration = _;
        renderWatch.reset(duration);
        scatter.duration(duration);
        return chart;
    };

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        offset:      {get: function(){return offset;}, set: function(_){offset=_;}},
        order:    {get: function(){return order;}, set: function(_){order=_;}},
        interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},

        // simple functor options
        x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},
        y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        style: {get: function(){return style;}, set: function(_){
            style = _;
            switch (style) {
                case 'stack':
                    chart.offset('zero');
                    chart.order('default');
                    break;
                case 'stream':
                    chart.offset('wiggle');
                    chart.order('inside-out');
                    break;
                case 'stream-center':
                    chart.offset('silhouette');
                    chart.order('inside-out');
                    break;
                case 'expand':
                    chart.offset('expand');
                    chart.order('default');
                    break;
                case 'stack_percent':
                    chart.offset(chart.d3_stackedOffset_stackPercent);
                    chart.order('default');
                    break;
            }
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            scatter.duration(duration);
        }}
    });

    nv.utils.inheritOptions(chart, scatter);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.stackedAreaChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var stacked = nv.models.stackedArea()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , controls = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 25, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.defaultColor()
        , showControls = true
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , useInteractiveGuideline = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' on ' + x + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , yAxisTickFormat = d3.format(',.2f')
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        , controlWidth = 250
        , cData = ['Stacked','Stream','Expanded']
        , controlLabels = {}
        , duration = 250
        ;

    state.style = stacked.style();
    xAxis.orient('bottom').tickPadding(7);
    yAxis.orient((rightAlignYAxis) ? 'right' : 'left');

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);
    var style = stacked.style();

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(stacked.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(stacked.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                style: stacked.style()
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.style !== undefined)
                style = state.style;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(stacked);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() { container.transition().duration(duration).call(chart); };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = stacked.xScale();
            y = stacked.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-stackedAreaChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedAreaChart').append('g');
            var g = wrap.select('g');

            gEnter.append("rect").style("opacity",0);
            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-stackedWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');
            gEnter.append('g').attr('class', 'nv-interactive');

            g.select("rect").attr("width",availableWidth).attr("height",availableHeight);

            // Legend
            if (showLegend) {
                var legendWidth = (showControls) ? availableWidth - controlWidth : availableWidth;

                legend.width(legendWidth);
                g.select('.nv-legendWrap').datum(data).call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + (availableWidth-legendWidth) + ',' + (-margin.top) +')');
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    {
                        key: controlLabels.stacked || 'Stacked',
                        metaKey: 'Stacked',
                        disabled: stacked.style() != 'stack',
                        style: 'stack'
                    },
                    {
                        key: controlLabels.stream || 'Stream',
                        metaKey: 'Stream',
                        disabled: stacked.style() != 'stream',
                        style: 'stream'
                    },
                    {
                        key: controlLabels.expanded || 'Expanded',
                        metaKey: 'Expanded',
                        disabled: stacked.style() != 'expand',
                        style: 'expand'
                    },
                    {
                        key: controlLabels.stack_percent || 'Stack %',
                        metaKey: 'Stack_Percent',
                        disabled: stacked.style() != 'stack_percent',
                        style: 'stack_percent'
                    }
                ];

                controlWidth = (cData.length/3) * 260;
                controlsData = controlsData.filter(function(d) {
                    return cData.indexOf(d.metaKey) !== -1;
                });

                controls
                    .width( controlWidth )
                    .color(['#444', '#444', '#444']);

                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .call(controls);

                if ( margin.top != Math.max(controls.height(), legend.height()) ) {
                    margin.top = Math.max(controls.height(), legend.height());
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-controlsWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')');
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left: margin.left, top: margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            stacked
                .width(availableWidth)
                .height(availableHeight);

            var stackedWrap = g.select('.nv-stackedWrap')
                .datum(data);

            stackedWrap.transition().call(stacked);

            // Setup Axes
            if (showXAxis) {
                xAxis.scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize( -availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + availableHeight + ')');

                g.select('.nv-x.nv-axis')
                    .transition().duration(0)
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis.scale(y)
                    .ticks(stacked.offset() == 'wiggle' ? 0 : nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize(-availableWidth, 0)
                    .setTickFormat( (stacked.style() == 'expand' || stacked.style() == 'stack_percent')
                        ? d3.format('%') : yAxisTickFormat);

                g.select('.nv-y.nv-axis')
                    .transition().duration(0)
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            stacked.dispatch.on('areaClick.toggle', function(e) {
                if (data.filter(function(d) { return !d.disabled }).length === 1)
                    data.forEach(function(d) {
                        d.disabled = false;
                    });
                else
                    data.forEach(function(d,i) {
                        d.disabled = (i != e.seriesIndex);
                    });

                state.disabled = data.map(function(d) { return !!d.disabled });
                dispatch.stateChange(state);

                chart.update();
            });

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                if (!d.disabled) return;

                controlsData = controlsData.map(function(s) {
                    s.disabled = true;
                    return s;
                });
                d.disabled = false;

                stacked.style(d.style);


                state.style = stacked.style();
                dispatch.stateChange(state);

                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                stacked.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        stacked.highlightPoint(i, pointIndex, true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));

                        //If we are in 'expand' mode, use the stacked percent value instead of raw value.
                        var tooltipValue = (stacked.style() == 'expand') ? point.display.y : chart.y()(point,pointIndex);
                        allData.push({
                            key: series.key,
                            value: tooltipValue,
                            color: color(series,series.seriesIndex),
                            stackedValue: point.display
                        });
                    });

                allData.reverse();

                //Highlight the tooltip entry based on which stack the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var yDistMax = Infinity, indexToHighlight = null;
                    allData.forEach(function(series,i) {

                        //To handle situation where the stacked area chart is negative, we need to use absolute values
                        //when checking if the mouse Y value is within the stack area.
                        yValue = Math.abs(yValue);
                        var stackedY0 = Math.abs(series.stackedValue.y0);
                        var stackedY = Math.abs(series.stackedValue.y);
                        if ( yValue >= stackedY0 && yValue <= (stackedY + stackedY0))
                        {
                            indexToHighlight = i;
                            return;
                        }
                    });
                    if (indexToHighlight != null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));

                //If we are in 'expand' mode, force the format to be a percentage.
                var valueFormatter = (stacked.style() == 'expand') ?
                    function(d,i) {return d3.format(".1%")(d);} :
                    function(d,i) {return yAxis.tickFormat()(d); };
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(valueFormatter)
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                stacked.clearHighlights();
            });


            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.style !== 'undefined') {
                    stacked.style(e.style);
                    style = e.style;
                }

                chart.update();
            });

        });

        renderWatch.renderEnd('stacked Area chart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    stacked.dispatch.on('tooltipShow', function(e) {
        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    stacked.dispatch.on('tooltipHide', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.stacked = stacked;
    chart.legend = legend;
    chart.controls = controls;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;

    yAxis.setTickFormat = yAxis.tickFormat;

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        showControls:    {get: function(){return showControls;}, set: function(_){showControls=_;}},
        controlLabels:    {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
        yAxisTickFormat:    {get: function(){return yAxisTickFormat;}, set: function(_){yAxisTickFormat=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            stacked.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            stacked.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( rightAlignYAxis ? 'right' : 'left');
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = !!_;
            if (_) {
                chart.interactive(false);
                chart.useVoronoi(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, stacked);
    nv.utils.initOptions(chart);

    return chart;
};

nv.version = "1.7.1";
})();
},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/index.js":[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
//loading hacks
var jQuery = require('jquery');

//loading jquery is colliding in GIS module, so we only load it if
//it is not loaded or if there is a jquery loaded but version is older than 2.x.x
if (window.$ == undefined || $.fn.jquery.split(' ')[0].split('.')[0] < 2) {
	window.jQuery = window.$ = Backbone.$ = jQuery;
}

var bootstrap_enabled = (typeof $().modal == 'function');
if (bootstrap_enabled) {
	require('bootstrap/dist/js/bootstrap');
}

var HeaderView = require('./src/views/header-view.js');
var FooterView = require('./src/views/footer-view.js');
var Translator = require('amp-translate');
var LayoutModel = require('./src/models/amp-layout-model.js');

/* example of use
 * this.menus = new Menus({
 *   translator: this.translator,
 *   caller: 'GIS'
 * });
 */

function Widget() {
	this.initialize.apply(this, arguments);
}

_.extend(Widget.prototype, Backbone.Events, {
	layoutFetched : new $.Deferred(),
	initialize : function(options) {
		options = _.defaults(options, {
			showFooterAdmin : true,
			showDGFooter : true,
			showLogin : true,
			useSingleRowHeader : false
		});
		if (_.has(options, 'sync')) {
			Backbone.sync = options.sync;
		}

		var self = this;
		this.createTranslator();
		this.createViews(options);		
		 _.bindAll(this, 'createTranslator', 'createViews','bubbleViewEvents','onMenuRendered');
	},
	createTranslator : function() {
		var defaultKeys = JSON.parse("{\n\"amp.common:footer\": \"Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and DG\",\n\"amp.common:title\": \"AMP Toolbar\",\n\"amp.common:title-help\": \"Help\",\n\"amp.common:subtitle-amp-help\": \"AMP Help\",\n\"amp.common:subtitle-glossary\": \"Glossary\",\n\"amp.common:subtitle-email-support-team\": \"Email Support Team\",\n\"amp.common:title-logout\": \"Log Out\",\n\"amp.common:platform\": \"Aid Management Platform (AMP)\",\n\"[title]amp.common:platform\": \"Aid Management Platform\",\n\"amp.common:platform-short\": \"AMP\",\n\"amp.common:title-login\": \"Login\",\n\"amp.dashboard:close\": \"Close\",\n\"amp.about:modal.title\": \"About AMP\",\n\"amp.about:credits\": \"Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and Development Gateway Foundation.\",\n\"amp.about:trademark\": \"The Development Gateway and the The Development Gateway logo are trademarks for The Development Gateway Foundation\",\n\"amp.about:rights\": \"All Rights Reserved\",\n\"amp.about:version\": \"Version\"\n}\n\n");
		this.translator = new Translator({
			defaultKeys : defaultKeys
		});
	},
	createViews : function(options) {
		var self = this;
		options.translator = this.translator;
		this.layoutModel = new LayoutModel();		
		options.layoutFetched = this.layoutFetched;
		this.layoutModel.fetch().then(function(layout) {
			options.model = layout;
			window.buildDate = layout.buildDate;
			window.ampVersion = layout.ampVersion;
			self.header = new HeaderView(options);		
			self.footer = new FooterView(options);
			self.onMenuRendered();
			self.bubbleViewEvents();			
			self.layoutFetched.resolve();
		});
	},
	bubbleViewEvents : function() {
		this.listenTo(this.footer, 'all', function() {
			this.trigger.apply(this, arguments);
		});

		this.listenTo(this.header, 'all', function() {
			this.trigger.apply(this, arguments);
		});
	},
	onMenuRendered: function(){
		var self = this;
		$.when(this.header.menuRendered, this.layoutFetched).then(function() {
			self.translator.translateDOM(document);
			if ($.fn.dropdown !== undefined) {
				$('.dropdown-toggle').dropdown();
			}
		});
	}	

});

module.exports = {
	layout : Widget
};
window.boilerplate = Widget;

},{"./src/models/amp-layout-model.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/amp-layout-model.js","./src/views/footer-view.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/footer-view.js","./src/views/header-view.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/header-view.js","amp-translate":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js":[function(require,module,exports){
/*!
 * Bootstrap v3.3.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}

+function ($) {
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.0
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.0'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.0
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.0'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', e.type == 'focus')
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.0
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.0'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var delta = direction == 'prev' ? -1 : 1
    var activeIndex = this.getItemIndex(active)
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.item')[fallback]()
    }

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.0
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $(this.options.trigger).filter('[href="#' + element.id + '"], [data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.0'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true,
    trigger: '[data-toggle="collapse"]'
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.find('> .panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && option == 'show') options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $.extend({}, $this.data(), { trigger: this })

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.0
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.0'

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.divider):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--                        // up
    if (e.which == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0

    $items.eq(index).trigger('focus')
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options        = options
    this.$body          = $(document.body)
    this.$element       = $(element)
    this.$backdrop      =
    this.isShown        = null
    this.scrollbarWidth = 0

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.0'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.$body.addClass('modal-open')

    this.setScrollbar()
    this.escape()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .prependTo(this.$element)
        .on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (e.target !== e.currentTarget) return
          this.options.backdrop == 'static'
            ? this.$element[0].focus.call(this.$element[0])
            : this.hide.call(this)
        }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  Modal.prototype.checkScrollbar = function () {
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', '')
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    if (document.body.clientWidth >= window.innerWidth) return 0
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.0
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.0'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
    this.arrow()
      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isHorizontal ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.tooltip')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.tooltip', (data = {}))
        if (!data[selector]) data[selector] = new Tooltip(this, options)
      } else {
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.0
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.0'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.popover')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.popover', (data = {}))
        if (!data[selector]) data[selector] = new Popover(this, options)
      } else {
        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.0
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    var process  = $.proxy(this.process, this)

    this.$body          = $('body')
    this.$scrollElement = $(element).is('body') ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', process)
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.0'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = 'offset'
    var offsetBase   = 0

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.offsets = []
    this.targets = []
    this.scrollHeight = this.getScrollHeight()

    var self     = this

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        self.offsets.push(this[0])
        self.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.0
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.VERSION = '3.3.0'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu')) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.0
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      =
    this.unpin        =
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.0'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && colliderTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = $('body').height()

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/collections/amp-menus-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var MenuModel = require('../models/amp-menus-model.js');

module.exports = Backbone.Collection.extend({
  url: '/rest/security/menus',
  model: MenuModel,

  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }

});

},{"../models/amp-menus-model.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/amp-menus-model.js","backbone":"backbone"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/collections/language-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
module.exports  = Backbone.Collection.extend({
	url: function() {
		return '/rest/translations/languages'
	}
});
},{"backbone":"backbone"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/amp-layout-model.js":[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  url: '/rest/security/layout',

  defaults: {
    email: undefined
  },
  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }

});

},{"backbone":"backbone"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/amp-menus-model.js":[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  url: '/rest/security/menus',

  defaults: {
    name: "Default",
    children: []
  },
  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }

});

},{"backbone":"backbone"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/settings.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
module.exports = Backbone.Model.extend({
	url: '/rest/amp/settings'
});
},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/about-view.js":[function(require,module,exports){

var $ = require('jquery');
var Backbone = require('backbone');
var _ = require('underscore');
var Template = "<div class=\"modal fade\" id=\"about-popup\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n<div class=\"modal-dialog\">\r\n <div class=\"modal-content\">\r\n <div class=\"modal-header\">\r\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\r\n        <h4 class=\"modal-title text-primary\" data-i18n=\"amp.about:modal.title\">About AMP</h4>\r\n </div>\r\n<table width=\"474\" border=\"0\" style=\"margin:15px;\">\r\n\t<tbody><tr>\r\n\t\t<td width=\"257\">\r\n\t\t<p align=\"center\" style=\"font-size: 16px;\"><strong>&nbsp;<span data-i18n=\"amp.common:platform\">Aid Management Platform (AMP)</span></strong></p>\r\n\t\t<p align=\"center\"> Version <%= ampVersion %></p>\r\n\t\t</td>\r\n\t\t<td width=\"220\"><img width=\"220\" height=\"100\" src=\"/TEMPLATE/ampTemplate/img_2/logo-development-gateway.png\"></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td colspan=\"2\">\r\n\t\t<p  style=\"font-size: 12px;\">&nbsp;<span data-i18n=\"amp.common:platform\">Aid Management Platform (AMP)</span>\r\n\t\t <span data-i18n=\"amp.about:version\">Version</span> <%= ampVersion %> <%= buildDate %>\r\n\t\t<span data-i18n=\"amp.about:credits\">Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and Development Gateway Foundation</span>.\r\n\t\t</p>\r\n\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td colspan=\"2\">\r\n\t\t<p style=\"font-size: 12px;\">\r\n\t\t<span data-i18n=\"amp.about:trademark\">The Development Gateway and the The Development Gateway logo are trademarks for The Development Gateway Foundation</span>.<span data-i18n=\"amp.about:rights\">All Rights Reserved</span>.</p>\r\n\t\t</td>\r\n\t</tr>\r\n</tbody></table>\r\n</div>\r\n</div>\r\n</div>";

module.exports = Backbone.View.extend({
  template: _.template(Template),
  id: 'aboutModal',  
  initialize: function(options) {
	  this.app = options.app;
    _.bindAll(this, 'render');

  },

  render: function() {
	var self = this;
	_.defaults(window, {ampVersion: "0", buildDate: "0"});
    this.$el.html(self.template({
      ampVersion: window.ampVersion,
      buildDate: window.buildDate
    }));
    return this;
  }
  
});


},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/footer-view.js":[function(require,module,exports){

var Backbone = require('backbone');
var _ = require('underscore');
require('bootstrap/dist/js/bootstrap');

var Template = "<style>\r\n    .footerText {\r\n    padding: 0;\r\n    font-family: arial;\r\n    font-size: 11px;\r\n    border: 0px;\r\n    }\r\n    .footer {\r\n    background-color: #8B8B8B;\r\n    color: #FFF;\r\n    margin-top: 0;\r\n    padding-bottom: 10px;\r\n    padding-top: 10px;\r\n    text-align: center;\r\n    }\r\n    .dgf_footer {\r\n    color: #8B8B8B;\r\n    line-height: 18px;\r\n    text-align: center;\r\n    background-color:white;\r\n    padding-top:10px;\r\n    }\r\n    .dgf_footer img {\r\n    line-height: 18px;\r\n    margin-bottom: 5px;\r\n    }\r\n    .loading{   \r\n      margin: 10px 20px 10px 20px;\r\n    }\r\n    \r\n</style>\r\n\r\n<div class=\"footer footerText\">\r\n    AMP <b><%=  properties.ampVersion %></b> build <b><%=  properties.buildDate %></b> - <%= properties.footerText %>\r\n    <% if(showAdminLinks == true  && properties.adminLinks != undefined) { %>\r\n    <a href='<%=  properties.adminLinks[0].url %>'><%=  properties.adminLinks[0].name %></a>\r\n    <% } %>\r\n</div>\r\n<% if(showDGFooter == true)  { %>\r\n<div class=\"dgf_footer footerText\">\r\n    <img src=\"/TEMPLATE/ampTemplate/img_2/dgf_logo_bottom.gif\" class=\"dgf_logo_footer\">\r\n    <br/>\r\n    Development Gateway\r\n    <br/>\r\n    1110 Vermont Ave, NW, Suite 500\r\n    <br/>\r\n    Washington, DC 20005 USA\r\n    <br/>\r\n    info@developmentgateway.org, Tel: +1.202.572.9200\r\n</div>\r\n<% } %>\r\n\r\n<% if(properties.trackingEnabled === true) { %>\r\n<!-- Piwik\r\nSite id can be checked here: http://stats.ampsite.net/index.php?module=SitesManager&action=index&idSite=1&period=range&date=last30\r\nAlso,the wiki for piwik: https://wiki.dgfoundation.org/display/AMPDOC/Integrating+AMP+with+Piwik\r\n-->\r\n<script type=\"text/javascript\">\r\n\t  var _paq = _paq || [];\r\n    if (window.PiwikAlreadyFetched === undefined ) {\r\n      _paq.push(['setUserId', \"<%= properties.email %>\"]);\r\n      _paq.push(['setCustomVariable',\r\n          1,\r\n          \"Workspace|WID\",\r\n          \"<%= properties.workspace %>|<%= properties.workspaceId %>\",\r\n          \"page\"]);\r\n  \t  _paq.push([\"trackPageView\"]);\r\n  \t  _paq.push([\"enableLinkTracking\"]);\r\n\r\n      /* TDK: keep track of whether we put the script DOM node on the page already\r\n       *   in case the page reparses this javascript on another modification.\r\n       */\r\n      window.PiwikAlreadyFetched = true;\r\n\r\n      /* Stock Piwik code: */\r\n  \t  (function() {\r\n  \t    var u=\"<%=  properties.trackingUrl %>\";\r\n  \t    _paq.push([\"setTrackerUrl\", u+\"piwik.php\"]);\r\n  \t    _paq.push([\"setSiteId\", \"<%=properties.siteId %>\"]);\r\n  \t    var d=document, g=d.createElement(\"script\"), s=d.getElementsByTagName(\"script\")[0]; g.type=\"text/javascript\";\r\n  \t    g.defer=true; g.async=true; g.src=u+\"piwik.js\"; s.parentNode.insertBefore(g,s);\r\n  \t  })();\r\n    }\r\n\t</script>\r\n<!-- End Piwik Code -->\r\n<% } %>\r\n";
var LayoutModel = require('../models/amp-layout-model.js');

module.exports = Backbone.View.extend({
  model: null,
  template: _.template(Template),
  el: '#amp-footer',
  layoutFetched: new $.Deferred(),
  showAdminFooter: true,
  showDGFooter: true,  
  initialize: function(options) {
    this.showAdminFooter = options.showAdminFooter;
    this.showDGFooter = options.showDGFooter;
    this.model = options.model;
    this.render();    
    _.bindAll(this, 'render');
  },
  render: function() {
    if (this.model) {
      var self = this;
      this.$el.html(this.template({
        properties: self.model,
        showAdminLinks: self.showAdminFooter,
        showDGFooter: self.showDGFooter
      }));
    }
    return this;
  }  

});

},{"../models/amp-layout-model.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/amp-layout-model.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/header-view.js":[function(require,module,exports){

var Backbone = require('backbone');
require('bootstrap/dist/js/bootstrap');
var _ = require('underscore');
var Template = "<link rel=\"stylesheet\" href=\"/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/css/main.css\">\n<% if(currentLanguage.get(\"ltr-direction\") === false) { %>\n  <link rel=\"stylesheet\" href=\"/TEMPLATE/ampTemplate/css_2/amp-rtl.css\">\n  <link rel=\"stylesheet\" href=\"/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/css/boilerplate-rtl.css\">\n<% } %>\n<script type=\"text/javascript\">\n  function switchTranslation (url) {\n    $('#backUrl').val(document.location.href);\n    document.modeSwitchForm.action = url;\n    document.modeSwitchForm.submit();\n  }\n</script>\n<form name=\"modeSwitchForm\" method=\"post\" action=\"/translation/switchMode.do\" style=\"display:none;\">\n  <input type=\"hidden\" name=\"backUrl\" id=\"backUrl\" value=\"\">\n</form>\n<%\n/***\n * Single Row Header Design (used when optionally requested: on GIS)\n * Useful for fixed height apps.\n *\n * Container-fluid structure:\n * row\n *  column navbar-brand (logo)\n *  column navbar-collapse\n *    nested row:\n *      columns AmpMenus (public or internal menus shown as provided by API)\n *      nested row ampUserLoggedInMenus (shown when logged in, incl: workspace, user, logout):\n *        3 columns\n *  login_here (ignores bootstrap container structure; shown when logged out)\n *  div#logincontainer: inserted by jQuery + rendered by JSP\n ***/\n\n  if (useSingleRowHeader) {\n %>\n<nav class=\"navbar navbar-default single-row\" role=\"navigation\">\n  <div class=\"container-fluid <%= properties.logged === true ? 'ampUserLoggedIn' : '' %>\">\n    <div class=\"row no-gutters\">\n      <!-- .ampUserLoggedIn hides public version-->\n\n      <!-- Brand and toggle get grouped for better mobile display -->\n      <div class=\"navbar-header col-sm-1\">\n        <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\">\n          <span class=\"sr-only\">Toggle navigation</span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n        </button>\n          <a id=\"headerUrl\" class=\"navbar-brand\" href=\"<%= properties.logged === true ? '/aim' : '/' %>\" data-i18n=\"[title]amp.common:platform\">\n          <span>\n            <img class=\"flag\" src=\"/aim/default/displayFlag.do\" height=\"20\" width=\"30\">\n          </span>\n          <span data-i18n=\"amp.common:platform-short\">AMP</span></a>\n      </div>\n\n      <div class=\"col-sm-11\">\n        <div class=\"collapse navbar-collapse row no-gutters\" id=\"bs-example-navbar-collapse-1\">\n          <div class=\"col-md-8 col-sm-10\">\n            <ul id=\"AmpMenus\" class=\"nav navbar-nav menus\">\n\n              <!-- File -->\n\n            </ul>\n            <div class=\"clearfix\"></div>\n          </div>\n          <div class=\"col-md-4 col-sm-2\">\n              <ul class=\"row no-gutters nav navbar-nav ampUserLoggedIn ampLoggedInMenus\">\n                <li id=\"header-workspace-li\" class=\"col-sm-9 col-md-6\"><a title=\"Workspace\" class=\"workspace-name\" id=\"header-workspace\" title=\"<%= properties.workspace ? properties.workspace : '' %>\"><%= properties.workspace ? properties.workspace : \" \" %></a></li>\n                <li id=\"header-name\" class=\"hidden-xs hidden-sm col-md-4\">\n                  <a class=\"user-url\">\n                    <span id=\"header-first-name\"><%= properties.firstName ? properties.firstName : \" \"  %></span>&nbsp;<span id=\"header-last-name\"><%= properties.lastName ? properties.lastName : \" \" %></span>\n                  </a>\n                </li>\n                <li id=\"header-logout\" class=\"col-sm-2\"><a data-i18n=\"amp.common:title-logout\" href=\"/aim/j_spring_logout\" >Logout</a></li>\n              </ul>\n              <% if(showLogin) { %>\n                <% if(loginDropdown){ %>\n                  <div class=\"login_here\" id=\"show_login_pop\">\n                    <div class=\"login_here_cont\">\n                      <a data-i18n=\"amp.common:title-login\" href=\"javascript:void(0)\">Login</a>\n                    </div>\n                  </div>\n                <% } else { %>\n                  <ul class=\"nav navbar-nav ampPublic navbar-right\">\n                    <li id=\"header-login\"><a data-i18n=\"amp.common:title-login\" href=\"/login.do\" >Login</a></li>\n                  </ul>\n                <% } %>\n              <% } %>\n              <!-- div#logincontainer with anchors gets appended here -->\n          </div>\n        </div>\n      </div>\n\n    </div>\n    <!-- Collect the nav links, forms, and other content for toggling -->\n  </div><!-- /.container-fluid -->\n</nav>\n <% } else { %>\n\n<% /***\n * Double Row Header Design (used by default)\n *\n * Container-Fluid structure:\n * row\n *  column navbar-brand (logo)\n *  column navbar-collapse\n *    nested row:\n *        nested row ampUserLoggedInMenus (shown when logged in, incl: workspace, user, logout):\n            3 columns\n * row\n *    columns AmpMenus (public or internal menus shown as provided by API)\n *  login_here (ignores bootstrap container structure, shown when logged out)\n *  div#logincontainer: inserted by jQuery + rendered by JSP\n ***/ %>\n<nav class=\"navbar navbar-default double-row\" role=\"navigation\">\n  <div class=\"container-fluid no-gutters <%= properties.logged === true ? 'ampUserLoggedIn' : '' %>\">\n    <div class=\"row no-gutters\">\n      <!-- .ampUserLoggedIn hides public version-->\n\n      <!-- Brand and toggle get grouped for better mobile display -->\n      <div class=\"navbar-header col-sm-1 col-sm-offset-1\">\n        <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\">\n          <span class=\"sr-only\">Toggle navigation</span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n        </button>\n          <a id=\"headerUrl\" class=\"navbar-brand\" href=\"<%= properties.logged === true ? '/aim' : '/' %>\" data-i18n=\"[title]amp.common:platform\">\n          <span>\n            <img class=\"flag\" src=\"/aim/default/displayFlag.do\" height=\"20\" width=\"30\">\n          </span>\n          <span data-i18n=\"amp.common:platform-short\">AMP</span></a>\n      </div>\n\n      <div class=\"col-sm-9\">\n        <div class=\"collapse navbar-collapse row no-gutters\" id=\"bs-example-navbar-collapse-1\">\n          <!-- To change workspace/user truncation length, edit the offset and grid number below:-->\n          <div class=\"col-sm-offset-5 col-sm-7\">\n            <ul class=\"row no-gutters nav navbar-nav ampUserLoggedIn ampLoggedInMenus\">\n              <li id=\"header-workspace-li\" class=\"col-sm-9 col-md-6\"><a title=\"Workspace\" class=\"workspace-name\" id=\"header-workspace\" title=\"<%= properties.workspace ? properties.workspace : '' %>\"><%= properties.workspace ? properties.workspace : \" \" %></a></li>\n              <li id=\"header-name\" class=\"hidden-xs hidden-sm col-md-4\">\n                <a class=\"user-url\">\n                  <span id=\"header-first-name\"><%= properties.firstName ? properties.firstName : \" \"  %></span>&nbsp;<span id=\"header-last-name\"><%= properties.lastName ? properties.lastName : \" \" %></span>\n                </a>\n              </li>\n              <li id=\"header-logout\" class=\"col-sm-2\"><a data-i18n=\"amp.common:title-logout\" href=\"/aim/j_spring_logout\" >Logout</a></li>\n            </ul>\n            <% if(showLogin) { %>\n              <% if(loginDropdown){ %>\n                <div class=\"login_here\" id=\"show_login_pop\">\n                  <div class=\"login_here_cont\">\n                    <a data-i18n=\"amp.common:title-login\" href=\"javascript:void(0)\">Login</a>\n                  </div>\n                </div>\n              <% } else { %>\n                <ul class=\"nav navbar-nav ampPublic navbar-right\">\n                  <li id=\"header-login\"><a data-i18n=\"amp.common:title-login\" href=\"/login.do\" >Login</a></li>\n                </ul>\n              <% } %>\n            <% } %>\n            <!-- div#logincontainer with anchors gets appended here -->\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"row no-gutters\">\n      <div class=\"col-sm-11 col-sm-offset-1\">\n        <ul id=\"AmpMenus\" class=\"nav navbar-nav menus\">\n\n          <!-- File -->\n\n        </ul>\n        <div class=\"clearfix\"></div>\n      </div>\n    </div>\n    <!-- Collect the nav links, forms, and other content for toggling -->\n  </div><!-- /.container-fluid -->\n</nav>\n\n<%\n  } %>\n";
var MenuCollection = require('../collections/amp-menus-collection.js');
var MenuModel = require('../models/amp-menus-model.js');
var SubmenuView = require('./submenu-compositeview.js');
var AboutView = require('./about-view.js');
var UserProfileView = require('./user-profile-view.js');
var Settings = require('../models/settings');
var Languages = require('../collections/language-collection');

module.exports = Backbone.View.extend({
  el: '#amp-header',
  appendEl: '#AmpMenus',
  template: _.template(Template),
  menuRendered: new $.Deferred(),  
  events: {
    'click #show_login_pop': 'openLoginBox',
    'click .user-url' : 'showUserProfile'
  },

  initialize: function(options) {
    this.collection = new MenuCollection();
    this.translator = options.translator;
    this.showLogin = options.showLogin;
    this.useSingleRowHeader = options.useSingleRowHeader;
    this.loginDropdown = !!options.loginDropdown;
    this.model = options.model;
    this.settings = new Settings();
    this.languages = new Languages();
    var self = this;     
    $.when.apply($, [this.settings.fetch(), this.collection.fetch(), this.languages.fetch()]).then(function () {
    	self.render();
    });
    
    this.firstRender = true;
    this.about = new AboutView(options);
    this.userProfile = new UserProfileView(options);
    _.bindAll(this, 'addOne', 'addAll', 'showAbout', 'showUserProfile');

  },

  addAll: function() {
    this.collection.each(this.addOne);
    this.menuRendered.resolve();
  },

  addOne: function(model) {
    view = new SubmenuView({
      model: model
    });
    this.listenTo(view, 'showAbout', this.showAbout);
    var self = this;
    this.listenTo(view, 'switchLanguage', function(lng) {
      self.translator.setLanguage(lng.language).always(function(data, textStatus, jqXHR) {
    	  if (textStatus !== "error") {
    		  location.reload();
    	  } else {
    		  // AMP-21714: For some unknown reason there are 2 async calls to the endpoint and FF sometimes takes the error from the 1st call.
        	  self.translator.setLanguage(lng.language).always(function(data, textStatus, jqXHR) {
    			  location.reload();
    		  });
    	  }
      });
    });
    view.render();
    $(this.appendEl).append(view.el);
  },

  render: function() {
    var self = this;
    var currentLanguage = this.languages.findWhere({"id": this.settings.get('language')});
    if (this.firstRender) {
      this.$el.html(this.template({
        showLogin: self.showLogin,
        loginDropdown: self.loginDropdown,
        useSingleRowHeader: self.useSingleRowHeader,
        properties: this.model,
        currentLanguage: currentLanguage
      }));
      this.addAll();
      this.firstRender = false;
      //Ashamed still, I'm forced to this, because the form comes from `loginWidget3.js` and I'm too afraid to touch it
      $('#show_login_pop_box').insertBefore('#show_login_pop');
      $('#logincontainer').insertAfter('#show_login_pop');
    }

    return this;
  },

  showAbout: function() {
    if ($('#about-popup').length == 0) {
      this.$el.parent().append(this.about.render().el);
    }
    if (typeof $().modal !== 'function') {
      $.noConflict();
    }
    $('#about-popup').modal({
      show: true,
      backdrop: false
    });
    this.translator.translateDOM($('#about-popup')[0]);
    return false;
  },

  openLoginBox: function() {
    $("div#show_login_pop_box").show();
    $("#j_username").focus();
  },
  
  showUserProfile: function(){
	  if ($('#user-profile').length == 0) {
	      this.$el.parent().append(this.userProfile.render().el);
	  }
	  this.userProfile.showUserProfile();
}
});

},{"../collections/amp-menus-collection.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/collections/amp-menus-collection.js","../collections/language-collection":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/collections/language-collection.js","../models/amp-menus-model.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/amp-menus-model.js","../models/settings":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/settings.js","./about-view.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/about-view.js","./submenu-compositeview.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/submenu-compositeview.js","./user-profile-view.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/user-profile-view.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/submenu-compositeview.js":[function(require,module,exports){

var Backbone = require('backbone');
var _ = require('underscore');
var Template = "<%\n  /* Prepare the A tag at top level menus */\n  if (!obj.url) {\n      obj.url = '#';\n      obj.className = 'dropdown-toggle';\n      obj.dataToggle = 'data-toggle=\"dropdown\"';\n    }\n    else {\n      obj.className = '';\n      obj.dataToggle = '';\n    }\n\n    if (obj.tab) {\n      obj.tabTarget = 'target=\"_blank\"';\n    }\n    else {\n      obj.tabTarget = '';\n    }\n    %>\n<%\n/* TODO escape the code in HTML */\n%>\n<a href=\"<%= url %>\" class=\"<%= className %>\" <%= dataToggle %> <%= obj.tabTarget %> >\n  <span class=\"dropdown-text\" title=\"<%= obj.name.trim() %>\"><%= obj.name.trim() %>&nbsp;</span><% if (obj.children && obj.children.length > 0) { %><span class=\"caret\"></span><% } %>\n</a>\n<% if (obj.children && obj.children.length !== 0) { %>\n  <ul class=\"children dropdown-menu\" role=\"menu\">\n  <% _.each(obj.children, function(model) { %>\n\n    <%\n      /* Prepare the A tag at second level menus */\n      if (model.children && model.children.length !== 0) {\n        model.dropdownSubmenu = 'dropdown-submenu';\n       };\n\n       if (!model.tooltip) {\n         model.tooltip = '';\n       };\n       var elementClass = '2nd-level-item';\n       if (model.language) {\n\t\t\t elementClass = elementClass+ ' language';\n\t   }\n       if (model.popup) {\n       \t elementClass = elementClass + ' popup';\n       }\n       if (model.tab) {\n         model.tabTarget = 'target=\"_blank\"';\n       } else {\n         model.tabTarget = '';\n       }\n       var elementUrl = model.url;\n       if (model.post === true) {\n         elementUrl = 'javascript:switchTranslation (\"'+elementUrl+'\")';\n\n       }\n       if (!model.url) {\n        elementUrl = 'javascript:;';\n       }\n       /* if it doesn't have children, nor url. then it is the About */\n       if (!model.url && !model.children) {\n       elementClass = elementClass + ' about-amp';\n       }\n    %>\n\n    <li class='dropdown <%= model.dropdownSubmenu %>' >\n    <a href='<%=  elementUrl %>' title=\"<%= model.tooltip %>\" onclick=\"return canExit()\" class=\"<%= elementClass %>\" <%= model.tabTarget %> ><%= model.name %></a>\n\n    <%\n      if (model.children && model.children.length !== 0) {\n     %>\n\n      <ul class=\"children dropdown-menu scrollable-menu\" role=\"menu\">\n      <% _.each(model.children, function(submodel) { %>\n\n        <%\n          /* Prepare the A tag at third level menus */\n          if (!submodel.url) {\n            submodel.url = '#';\n          };\n\t\t  var itemClass = '3rd-level-item';\n\t\t  if (submodel.language) {\n\t\t\t itemClass = itemClass+ ' language';\n\t\t   }\n\t\t  if (!submodel.tooltip) {\n            submodel.tooltip = '';\n          };\n\n          if (submodel.tab) {\n            submodel.tabTarget='target=\"_blank\"';\n          } else {\n            submodel.tabTarget = '';\n          };\n        %>\n\n        <li class=\"menu-item\"><a href=\"<%= submodel.url %>\" onclick=\"return canExit()\" class=\"<%= itemClass %>\" <%= submodel.tabTarget %> title=\"<%= submodel.tooltip %>\"><%= submodel.name %></a></li>\n\n      <% }) %>\n      </ul>\n    <% } %>\n\n    </li>\n\n  <% }); %>\n  </ul>\n<% }%>\n<!--\n<li class=\"menu-item dropdown dropdown-submenu\"><a class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n<ul class=\"children dropdown-menu scrollable-menu\" role=\"menu\">\n      <li class=\"menu-item first-of-type\" id=\"yui-gen4\" groupindex=\"0\" index=\"0\">\n  <a class=\"yuiampmenuitemlabel yuimenuitemlabel\" href=\"/selectTeam.do?id=680\" onclick=\"return canExit()\">\n    Academy of Sciences\n  </a>\n</li>--!>\n";


module.exports = Backbone.View.extend({
  tagName: 'li',
  className: 'dropdown',
  events: {
    'click .language': 'switchLanguage',
    'click .popup': 'openPopup',
    'click .about-amp': 'about'
  },

  template: _.template(Template),

  initialize:function(options) {
    _.bindAll(this, 'render','switchLanguage','about');
  },

  render: function() {
      var self = this;
      this.$el.html(this.template(self.model.attributes));

      return this;
    },
   switchLanguage:function (event) {
	   var index = event.currentTarget.href.lastIndexOf ('/');
	   var lng = event.currentTarget.href.substr (index +1);
	   //if the SwithLanguageMenu exists, let the jsp handle how to change language.
	   //TODO trigger an event and handle on the jsp
	   if (typeof SwitchLanguageMenu !== 'undefined' && $.isFunction(SwitchLanguageMenu)) {
		   event.preventDefault();
		   var url = "/translation/switchLanguage.do?code="+lng+"&rfr=";
		   SwitchLanguageMenu (url);
	   }
	   else {
		   this.trigger ('switchLanguage',{language:lng});
	   }
	   /*var self = this;
	   this.Translator.setLanguage(lng).then(function() {
		   self.Translator.translateDOM(document); 
       });*/
	  
   },
   openPopup:function (event) {
	   window.name = "opener" + new Date().getTime();
	   var wndWidth = 768; 
	   var wndHeight = 1024;
	   var t = ((screen.width)-768)/2;
	   var l = ((screen.height)-1024)/2;
	   var wparams = "height=" + wndHeight + ",width=" + wndWidth + ",top=" + l + ",left=" + t +",menubar=no,scrollbars=yes";
	   popupPointer = window.open(event.currentTarget.href, "forumPopup", wparams);
	   event.preventDefault();
	   return popupPointer;
   },
   about:function (event) {
	   this.trigger ('showAbout',{});
	   return false;
   }

});


},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/views/user-profile-view.js":[function(require,module,exports){

var Backbone = require('backbone');
var _ = require('underscore');
require('bootstrap/dist/js/bootstrap');
var Template = "<div id=\"user-profile\" class=\"modal fade\"  tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n<div class=\"modal-dialog\">\r\n <div class=\"modal-content\">\r\n <div class=\"modal-header\">\r\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\r\n        <h4 class=\"modal-title text-primary\" data-i18n=\"amp.profile:modal.title\">Member Details</h4>\r\n </div>\r\n <div class=\"user-profile-content\">\r\n   <div class='loading' data-i18n=\"amp.profile:modal.loading\">Loading...</div>\r\n </div> \r\n </div>\r\n </div>\r\n </div>";

module.exports = Backbone.View.extend({
  model: null,
  template: _.template(Template),
  id: 'userProfileModal',  
  initialize: function(options) {
    this.model = options.model;
    this.render();
    _.bindAll(this, 'render');
  },
  render: function() {
    if (this.model) {
      var self = this;
      this.$el.html(this.template({
        properties: self.model
      }));
    }
    return this;
  },
  showUserProfile: function(){
	  if (this.model.email) {
		  var url = '/aim/default/userProfile.do~edit=true~id=' + this.model.userId;       
		  if(!this.profileLoaded ){    	  
			  this.$('.user-profile-content').load(url);  
			  this.profileLoaded = true;
		  }            
		  if (typeof $().modal !== 'function') {
			  $.noConflict();
		  }   
		  this.$('#user-profile').modal({
			  show: true,
			  backdrop: false
		  });
	  }
  }
});

},{"backbone":"backbone","bootstrap/dist/js/bootstrap":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/bootstrap/dist/js/bootstrap.js":[function(require,module,exports){
module.exports=require("/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js")
},{"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js":[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

},{"jquery":"jquery"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/datepicker.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./core');

/*!
 * jQuery UI Datepicker 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.10.4" } });

var PROP_NAME = "datepicker",
	instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.10.4";

})(jQuery);

},{"./core":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js","jquery":"jquery"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/draggable.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./mouse');
require('./widget');

/*!
 * jQuery UI Draggable 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.10.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
			return false;
		}

		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if(!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
			pageX = event.pageX,
			pageY = event.pageY;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( this.originalPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				}
				else {
					containment = this.containment;
				}

				if(event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("ui-draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, "ui-sortable");
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("ui-draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if(this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("ui-draggable"), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function() {
		var t = $("body"), o = $(this).data("ui-draggable").options;
		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function() {
		var o = $(this).data("ui-draggable").options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function() {
		var i = $(this).data("ui-draggable");
		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

			if(!o.axis || o.axis !== "x") {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== "y") {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== "x") {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== "y") {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function() {

		var i = $(this).data("ui-draggable"),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data("ui-draggable"),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function() {
		var min,
			o = this.data("ui-draggable").options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

})(jQuery);

},{"./core":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js","./mouse":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/mouse.js","./widget":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js","jquery":"jquery"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/mouse.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./widget');

/*!
 * jQuery UI Mouse 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

},{"./widget":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js","jquery":"jquery"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js":[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

},{"jquery":"jquery"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/collections/all-filters-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var OrgRoleFilterModel = require('../models/org-role-filter-model');
var YearsFilterModel = require('../models/years-filter-model');
var YearsOnlyFilterModel = require('../models/years-only-filter-model');


//TODO: move most code from filters-view here.
module.exports = Backbone.Collection.extend({
  url: '/rest/filters',
  _loaded: null,
  _allDeferreds: [],
  orgCollection: null,
  orgGroupCollection: null,
  orgTypeCollection: null,
  componentCaller: null,

  initialize: function(models,options) {
    this.on('add', this._cleanUpAfterAdd);
    this.load();
    if (options.caller) {
    	componentCaller = options.caller;
    }
  },

  load: function() {
    var self = this;

    if(!this._loaded){
      this._loaded = new $.Deferred();
      this._allDeferreds.push(this._createOrgFilters());

      this.fetch({remove: false}).then(function() {
        // when all child calls are done resolve.
        $.when.apply($, self._allDeferreds)
          .done(self._loaded.resolve)
          .fail(self._loaded.reject);
      }).fail(self._loaded.reject);
    }

    return this._loaded;
  },

  _cleanUpAfterAdd: function(model) {
    var self = this;
    // remove if ui false also catches empty dummy filters we add in 'model' function below.
    if (!model.get('ui')) {
      self.remove(model);
    }
    //remove if the endpoint returns the filter type (dashboard,tabs,reports and/or GIS) for which
    //the model should be visible and the caller is not of the same tpe
    
    if (model.get('filterType')) {
    	// CONSTANTIN: here filtering irrelevant columns for the set filter type are filtered out
    	var isOfRequiredType = _.some( model.get('filterType'), function( type ) {
    	    return type === componentCaller || type === "ALL";
    	});
    	//console.log("decided whether to show column " + model.get("name") + ": " + isOfRequiredType)
    	if (!isOfRequiredType) {
    		self.remove (model);
    	}
    }
    // Expose this field for later usage.
    this.componentCaller = componentCaller;
  },


//  contains: function(key) {
//	  if ()
//  },
  
  parse: function(data) {
    //only keep filters with ui == true;
    data = _.filter(data, function(obj) {
      return obj.ui;
    });

    //remove orgs, groups, and types, because they are not filters on their own.
    // We use them down below.
    data = _.filter(data, function(obj) {
      return (obj.endpoint !== '/rest/filters/org-groups' &&
        obj.endpoint !== '/rest/filters/org-types' &&
        obj.endpoint !== '/rest/filters/org-roles' &&
        obj.endpoint !== '/rest/filters/orgs');
    });


    return data;
  },


  model: function(attrs, options) {
    var tmpModel = null;

    // slightly unconventional, but model is special case since it's called with
    // new so 'this' wont be the collection.
    var self = options.collection;

    // switch for model polymorphism.
    switch (attrs.id) {
      case 'Programs':
      case 'Sectors':
        self._allDeferreds.push(self._goOneDeeper(self, attrs));
        //tmp hack because we need to return something.
        tmpModel = new Backbone.Model({ui:false});
        break;
        
      default:
    	  
    	  if (attrs.id == 'date' || (attrs.id.indexOf('-date') != -1 ) || (attrs.id.indexOf('date-') != -1 )) {
    		  tmpModel = new YearsFilterModel(attrs);  // hacky but less hacky than enumerating them. Long term solution -> the endpoint should return a field telling the type of a field
    	  } else if (attrs.id == 'computed-year') {
    		  tmpModel = new YearsOnlyFilterModel(attrs);
    	  } else {
    		  tmpModel = new GenericFilterModel(attrs);
    		  self._allDeferreds.push(tmpModel.getTree());
    	  }
    }

    return tmpModel;
  },

  // get endpoint's children and load them into self...
  _goOneDeeper: function(self, attrs) {
    var url = attrs.endpoint;
    var deferred = $.Deferred();
    var tmpDeferreds = [];

    var tmpCollection = new Backbone.Collection();
    tmpCollection.url = url;
    tmpCollection.fetch().then(function(data) {
      _.each(data, function(APIFilter) {
        var tmpModel = new GenericFilterModel({
          url: url + '/' + APIFilter.id,
          name: APIFilter.name,
          tab: APIFilter.tab,
          ui: true,
          group: attrs.id,
          empty: false
        });
        self.add(tmpModel);
        tmpDeferreds.push(tmpModel.getTree());
      });

      if (_.isEmpty(data)) {
        console.warn('Filters API returned empty', url);
        // Create empty model so the view doesnt fail.
        var tmpModel = new GenericFilterModel({
            url: url,
            name: attrs.name,
            ui: true,
            group: attrs.id,
            empty: true
          });
          self.add(tmpModel);
          tmpDeferreds.push(tmpModel.getTree());
      }
      
      $.when.apply($, tmpDeferreds).then(function() {
          deferred.resolve();
        });

    });

    return deferred;
  },


// ---------------------
// Special org and donor specific code since it has special behaviour
// ---------------------

  _createOrgFilters:function() {
    var self = this;

    // Create 'joins' for each type add ref to groups, and for each group add refs to orgs.
    return this._fetchOrgCollections().then(function() {

      // jsonify orgs and set them as children in groups.

      self.makeTreeHelper(self.orgGroupCollection, self.orgCollection, 'orgIds', 'children');


      // For each role create a filter with collection of just orgs that match.
      self.orgRolesCollection.each(function(role) {
        var tmpJSON = role.toJSON();

        // treat donor differently...
        if (role.get('name') === 'Donor') {
          self.makeTreeHelper(self.orgTypeCollection, self.orgGroupCollection, 'groupIds', 'children');
          // Create tree rootNode and raw JSON.
          _.extend(tmpJSON,
            {
              ui: true,
              group: 'Donor',
              tab: 'Funding Organizations',
              data: self.orgTypeCollection.toJSON()
            });

          // filter orgs...
          tmpJSON.data = self._filterDonorOrgs(tmpJSON.data, role.id);
        } else {
          // Create tree rootNode and raw JSON.
          _.extend(tmpJSON,
            {
              ui: true,
              group: 'Role', //TODO: ?should this be 'Role' or role.id or role.get('name')?
              tab: 'All Agencies',
              data: self.orgGroupCollection.toJSON()
            });

          //remove all orgs that don't belong in this role
          tmpJSON.data = self._filterOrgs(tmpJSON.data, role.id);
        }

        if (tmpJSON.data.length > 0) {
        	var currentFilterId;
        	if (role.get('filterId')) {
        		currentFilterId = role.get('filterId');
        	} else {
        		currentFilterId = role.get('name') + " Id";
        	}        	
        	tmpJSON.data = self._setFilterId(tmpJSON.data, currentFilterId);            
        	self.add(new OrgRoleFilterModel(tmpJSON));
        }
      });

      //only needed for donor if we want to do special listening....:
      // self.joinHelper(self.orgTypeCollection, self.orgGroupCollection, 'groupIds', 'groups');
      // self.joinHelper(self.orgGroupCollection, self.orgCollection, 'orgIds', 'orgs');
    });
  },

  // explicitly sets the filter id on all the orgs.
  _setFilterId: function(collection, filterId){
    var self = this;
    _.each(collection, function(org) {
      //only set filterId on orgs, not group or type, or it will cause bugs.
      if(org.rolesIds){
        org.filterId = filterId;
      }
      if(org.children){
        org.children = self._setFilterId(org.children, filterId);
      }
    });

    return collection;
  },



  // filter orgs tree to only orgs that appear as the given roleID
  _filterOrgs: function(orgGroupsJSON, roleID) {
    orgGroupsJSON = _.filter(orgGroupsJSON, function(group) {
      group.isOrgGroup = true;
      group.children = _.filter(group.children, function(org) {
        return (org.rolesIds.indexOf(roleID) > -1);
      });
      group.isSelectable = false; //stops tree from creating 'unkown' children.
      return (group.children.length > 0);
    });
    return orgGroupsJSON;
  },


	  // special case for donor tree, since it has type
	_filterDonorOrgs : function(orgTypesJSON, roleID) {
		var self = this;
		orgTypesJSON = _.filter(orgTypesJSON, function(type) {
			type.children = self._filterOrgs(type.children, roleID);
			_.each(type.children, function(group) {
				group.filterId = 'donor-group';
			});	

			type.filterId = 'donor-type';
			type.isSelectable = false; // stops tree from creating 'unkown' children.
			return (type.children.length > 0);
		});
		return orgTypesJSON;
	},

    // 1. get all orgs, groups, types, and roles
  _fetchOrgCollections: function() {
    var filterDeferreds = [];

    this.orgCollection = new Backbone.Collection();
    this.orgCollection.url = '/rest/filters/orgs';
    filterDeferreds.push(this.orgCollection.fetch());

    this.orgGroupCollection = new Backbone.Collection();
    this.orgGroupCollection.url = '/rest/filters/org-groups';
    filterDeferreds.push(this.orgGroupCollection.fetch());

    this.orgTypeCollection = new Backbone.Collection();
    this.orgTypeCollection.url = '/rest/filters/org-types';
    filterDeferreds.push(this.orgTypeCollection.fetch());

    this.orgRolesCollection = new Backbone.Collection();
    this.orgRolesCollection.url = '/rest/filters/org-roles';
    filterDeferreds.push(this.orgRolesCollection.fetch({}));

    return $.when.apply($, filterDeferreds);
  },


  // Adds references to collectionB into collectionA joining on given foreign key
  // TODO: option to add bi-directional reference.
  joinHelper: function(collectionA, collectionB, keyForForeignID, keyForCollectionDestination) {
    collectionA.each(function(modelA) {
      var idsToJoin = modelA.get(keyForForeignID);
      var tempCollection = collectionB.filter(function(modelB) {
        return _.indexOf(idsToJoin, modelB.get('id')) >= 0;
      });

      modelA.set(keyForCollectionDestination, tempCollection);
    });
  },

  makeTreeHelper : function(parentCollection, childCollection, keyForForeignID, keyForCollectionDestination) {
	  var self = this;
	  var donorRole = _.filter(self.orgRolesCollection.models, function(item) {
			return item.get('name') === 'Donor';
		})[0];
		parentCollection.each(function(parent) {
			var idsToJoin = parent.get(keyForForeignID);
			var tempCollection = childCollection.toJSON();
			
			// Because of the business logic of old filters, if an organization has been used as a funding org
			// (present in amp_funding) then we need to
			// add it to the list of 'Donors' no matter which is the 'role' of that organization, so in order to
			// make it appear in the tree we also need to
			// add the 'DN' rol to it, otherwise it will be ignored even if its in tempCollection.
			tempCollection = _.each(tempCollection,function(aux) {
				if (aux.hasFundings === true && aux.rolesIds != undefined) {
					aux.rolesIds.push(donorRole);
				}
			});
			tempCollection = _.filter(tempCollection,function(val) {
				return _.contains(idsToJoin, val.id);
			});
			parent.set(keyForCollectionDestination, tempCollection);
		});
	}
});

},{"../models/generic-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/generic-filter-model.js","../models/org-role-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/org-role-filter-model.js","../models/years-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-filter-model.js","../models/years-only-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-only-filter-model.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/lib/jquery-ui-i18n.js":[function(require,module,exports){
/*! jQuery UI - v1.10.4 - 2014-01-17
* http://jqueryui.com
* Includes: jquery.ui.datepicker-af.js, jquery.ui.datepicker-ar-DZ.js, jquery.ui.datepicker-ar.js, jquery.ui.datepicker-az.js, jquery.ui.datepicker-be.js, jquery.ui.datepicker-bg.js, jquery.ui.datepicker-bs.js, jquery.ui.datepicker-ca.js, jquery.ui.datepicker-cs.js, jquery.ui.datepicker-cy-GB.js, jquery.ui.datepicker-da.js, jquery.ui.datepicker-de.js, jquery.ui.datepicker-el.js, jquery.ui.datepicker-en-AU.js, jquery.ui.datepicker-en-GB.js, jquery.ui.datepicker-en-NZ.js, jquery.ui.datepicker-eo.js, jquery.ui.datepicker-es.js, jquery.ui.datepicker-et.js, jquery.ui.datepicker-eu.js, jquery.ui.datepicker-fa.js, jquery.ui.datepicker-fi.js, jquery.ui.datepicker-fo.js, jquery.ui.datepicker-fr-CA.js, jquery.ui.datepicker-fr-CH.js, jquery.ui.datepicker-fr.js, jquery.ui.datepicker-gl.js, jquery.ui.datepicker-he.js, jquery.ui.datepicker-hi.js, jquery.ui.datepicker-hr.js, jquery.ui.datepicker-hu.js, jquery.ui.datepicker-hy.js, jquery.ui.datepicker-id.js, jquery.ui.datepicker-is.js, jquery.ui.datepicker-it.js, jquery.ui.datepicker-ja.js, jquery.ui.datepicker-ka.js, jquery.ui.datepicker-kk.js, jquery.ui.datepicker-km.js, jquery.ui.datepicker-ko.js, jquery.ui.datepicker-ky.js, jquery.ui.datepicker-lb.js, jquery.ui.datepicker-lt.js, jquery.ui.datepicker-lv.js, jquery.ui.datepicker-mk.js, jquery.ui.datepicker-ml.js, jquery.ui.datepicker-ms.js, jquery.ui.datepicker-nb.js, jquery.ui.datepicker-nl-BE.js, jquery.ui.datepicker-nl.js, jquery.ui.datepicker-nn.js, jquery.ui.datepicker-no.js, jquery.ui.datepicker-pl.js, jquery.ui.datepicker-pt-BR.js, jquery.ui.datepicker-pt.js, jquery.ui.datepicker-rm.js, jquery.ui.datepicker-ro.js, jquery.ui.datepicker-ru.js, jquery.ui.datepicker-sk.js, jquery.ui.datepicker-sl.js, jquery.ui.datepicker-sq.js, jquery.ui.datepicker-sr-SR.js, jquery.ui.datepicker-sr.js, jquery.ui.datepicker-sv.js, jquery.ui.datepicker-ta.js, jquery.ui.datepicker-th.js, jquery.ui.datepicker-tj.js, jquery.ui.datepicker-tr.js, jquery.ui.datepicker-uk.js, jquery.ui.datepicker-vi.js, jquery.ui.datepicker-zh-CN.js, jquery.ui.datepicker-zh-HK.js, jquery.ui.datepicker-zh-TW.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
/* Afrikaans initialisation for the jQuery UI date picker plugin. */
/* Written by Renier Pretorius. */
/*ALTERED FOR AMP -- ADDED TETUM LOCALE*/
jQuery(function($){
	$.datepicker.regional['af'] = {
		closeText: 'Selekteer',
		prevText: 'Vorige',
		nextText: 'Volgende',
		currentText: 'Vandag',
		monthNames: ['Januarie','Februarie','Maart','April','Mei','Junie',
		'Julie','Augustus','September','Oktober','November','Desember'],
		monthNamesShort: ['Jan', 'Feb', 'Mrt', 'Apr', 'Mei', 'Jun',
		'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
		dayNames: ['Sondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrydag', 'Saterdag'],
		dayNamesShort: ['Son', 'Maa', 'Din', 'Woe', 'Don', 'Vry', 'Sat'],
		dayNamesMin: ['So','Ma','Di','Wo','Do','Vr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['af']);
});

/* Algerian Arabic Translation for jQuery UI date picker plugin. (can be used for Tunisia)*/
/* Mohamed Cherif BOUCHELAGHEM -- cherifbouchelaghem@yahoo.fr */

jQuery(function($){
	$.datepicker.regional['ar-DZ'] = {
		closeText: 'إغلاق',
		prevText: '&#x3C;السابق',
		nextText: 'التالي&#x3E;',
		currentText: 'اليوم',
		monthNames: ['جانفي', 'فيفري', 'مارس', 'أفريل', 'ماي', 'جوان',
		'جويلية', 'أوت', 'سبتمبر','أكتوبر', 'نوفمبر', 'ديسمبر'],
		monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
		dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesShort: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesMin: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		weekHeader: 'أسبوع',
		dateFormat: 'dd/mm/yy',
		firstDay: 6,
  		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ar-DZ']);
});

/* Arabic Translation for jQuery UI date picker plugin. */
/* Khaled Alhourani -- me@khaledalhourani.com */
/* NOTE: monthNames are the original months names and they are the Arabic names, not the new months name فبراير - يناير and there isn't any Arabic roots for these months */
jQuery(function($){
	$.datepicker.regional['ar'] = {
		closeText: 'إغلاق',
		prevText: '&#x3C;السابق',
		nextText: 'التالي&#x3E;',
		currentText: 'اليوم',
		monthNames: ['كانون الثاني', 'شباط', 'آذار', 'نيسان', 'مايو', 'حزيران',
		'تموز', 'آب', 'أيلول',	'تشرين الأول', 'تشرين الثاني', 'كانون الأول'],
		monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
		dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesShort: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesMin: ['ح', 'ن', 'ث', 'ر', 'خ', 'ج', 'س'],
		weekHeader: 'أسبوع',
		dateFormat: 'dd/mm/yy',
		firstDay: 6,
  		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ar']);
});

/* Azerbaijani (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Jamil Najafov (necefov33@gmail.com). */
jQuery(function($) {
	$.datepicker.regional['az'] = {
		closeText: 'Bağla',
		prevText: '&#x3C;Geri',
		nextText: 'İrəli&#x3E;',
		currentText: 'Bugün',
		monthNames: ['Yanvar','Fevral','Mart','Aprel','May','İyun',
		'İyul','Avqust','Sentyabr','Oktyabr','Noyabr','Dekabr'],
		monthNamesShort: ['Yan','Fev','Mar','Apr','May','İyun',
		'İyul','Avq','Sen','Okt','Noy','Dek'],
		dayNames: ['Bazar','Bazar ertəsi','Çərşənbə axşamı','Çərşənbə','Cümə axşamı','Cümə','Şənbə'],
		dayNamesShort: ['B','Be','Ça','Ç','Ca','C','Ş'],
		dayNamesMin: ['B','B','Ç','С','Ç','C','Ş'],
		weekHeader: 'Hf',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['az']);
});

/* Belarusian initialisation for the jQuery UI date picker plugin. */
/* Written by Pavel Selitskas <p.selitskas@gmail.com> */
jQuery(function($){
	$.datepicker.regional['be'] = {
		closeText: 'Зачыніць',
		prevText: '&larr;Папяр.',
		nextText: 'Наст.&rarr;',
		currentText: 'Сёньня',
		monthNames: ['Студзень','Люты','Сакавік','Красавік','Травень','Чэрвень',
		'Ліпень','Жнівень','Верасень','Кастрычнік','Лістапад','Сьнежань'],
		monthNamesShort: ['Сту','Лют','Сак','Кра','Тра','Чэр',
		'Ліп','Жні','Вер','Кас','Ліс','Сьн'],
		dayNames: ['нядзеля','панядзелак','аўторак','серада','чацьвер','пятніца','субота'],
		dayNamesShort: ['ндз','пнд','аўт','срд','чцв','птн','сбт'],
		dayNamesMin: ['Нд','Пн','Аў','Ср','Чц','Пт','Сб'],
		weekHeader: 'Тд',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['be']);
});

/* Bulgarian initialisation for the jQuery UI date picker plugin. */
/* Written by Stoyan Kyosev (http://svest.org). */
jQuery(function($){
	$.datepicker.regional['bg'] = {
		closeText: 'затвори',
		prevText: '&#x3C;назад',
		nextText: 'напред&#x3E;',
		nextBigText: '&#x3E;&#x3E;',
		currentText: 'днес',
		monthNames: ['Януари','Февруари','Март','Април','Май','Юни',
		'Юли','Август','Септември','Октомври','Ноември','Декември'],
		monthNamesShort: ['Яну','Фев','Мар','Апр','Май','Юни',
		'Юли','Авг','Сеп','Окт','Нов','Дек'],
		dayNames: ['Неделя','Понеделник','Вторник','Сряда','Четвъртък','Петък','Събота'],
		dayNamesShort: ['Нед','Пон','Вто','Сря','Чет','Пет','Съб'],
		dayNamesMin: ['Не','По','Вт','Ср','Че','Пе','Съ'],
		weekHeader: 'Wk',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['bg']);
});

/* Bosnian i18n for the jQuery UI date picker plugin. */
/* Written by Kenan Konjo. */
jQuery(function($){
	$.datepicker.regional['bs'] = {
		closeText: 'Zatvori',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Danas',
		monthNames: ['Januar','Februar','Mart','April','Maj','Juni',
		'Juli','August','Septembar','Oktobar','Novembar','Decembar'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['Nedelja','Ponedeljak','Utorak','Srijeda','Četvrtak','Petak','Subota'],
		dayNamesShort: ['Ned','Pon','Uto','Sri','Čet','Pet','Sub'],
		dayNamesMin: ['Ne','Po','Ut','Sr','Če','Pe','Su'],
		weekHeader: 'Wk',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['bs']);
});

/* Inicialització en català per a l'extensió 'UI date picker' per jQuery. */
/* Writers: (joan.leon@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ca'] = {
		closeText: 'Tanca',
		prevText: 'Anterior',
		nextText: 'Següent',
		currentText: 'Avui',
		monthNames: ['gener','febrer','març','abril','maig','juny',
		'juliol','agost','setembre','octubre','novembre','desembre'],
		monthNamesShort: ['gen','feb','març','abr','maig','juny',
		'jul','ag','set','oct','nov','des'],
		dayNames: ['diumenge','dilluns','dimarts','dimecres','dijous','divendres','dissabte'],
		dayNamesShort: ['dg','dl','dt','dc','dj','dv','ds'],
		dayNamesMin: ['dg','dl','dt','dc','dj','dv','ds'],
		weekHeader: 'Set',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ca']);
});

/* Czech initialisation for the jQuery UI date picker plugin. */
/* Written by Tomas Muller (tomas@tomas-muller.net). */
jQuery(function($){
	$.datepicker.regional['cs'] = {
		closeText: 'Zavřít',
		prevText: '&#x3C;Dříve',
		nextText: 'Později&#x3E;',
		currentText: 'Nyní',
		monthNames: ['leden','únor','březen','duben','květen','červen',
		'červenec','srpen','září','říjen','listopad','prosinec'],
		monthNamesShort: ['led','úno','bře','dub','kvě','čer',
		'čvc','srp','zář','říj','lis','pro'],
		dayNames: ['neděle', 'pondělí', 'úterý', 'středa', 'čtvrtek', 'pátek', 'sobota'],
		dayNamesShort: ['ne', 'po', 'út', 'st', 'čt', 'pá', 'so'],
		dayNamesMin: ['ne','po','út','st','čt','pá','so'],
		weekHeader: 'Týd',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['cs']);
});

/* Welsh/UK initialisation for the jQuery UI date picker plugin. */
/* Written by William Griffiths. */
jQuery(function($){
	$.datepicker.regional['cy-GB'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['Ionawr','Chwefror','Mawrth','Ebrill','Mai','Mehefin',
		'Gorffennaf','Awst','Medi','Hydref','Tachwedd','Rhagfyr'],
		monthNamesShort: ['Ion', 'Chw', 'Maw', 'Ebr', 'Mai', 'Meh',
		'Gor', 'Aws', 'Med', 'Hyd', 'Tac', 'Rha'],
		dayNames: ['Dydd Sul', 'Dydd Llun', 'Dydd Mawrth', 'Dydd Mercher', 'Dydd Iau', 'Dydd Gwener', 'Dydd Sadwrn'],
		dayNamesShort: ['Sul', 'Llu', 'Maw', 'Mer', 'Iau', 'Gwe', 'Sad'],
		dayNamesMin: ['Su','Ll','Ma','Me','Ia','Gw','Sa'],
		weekHeader: 'Wy',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['cy-GB']);
});

/* Danish initialisation for the jQuery UI date picker plugin. */
/* Written by Jan Christensen ( deletestuff@gmail.com). */
jQuery(function($){
	$.datepicker.regional['da'] = {
		closeText: 'Luk',
		prevText: '&#x3C;Forrige',
		nextText: 'Næste&#x3E;',
		currentText: 'Idag',
		monthNames: ['Januar','Februar','Marts','April','Maj','Juni',
		'Juli','August','September','Oktober','November','December'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['Søndag','Mandag','Tirsdag','Onsdag','Torsdag','Fredag','Lørdag'],
		dayNamesShort: ['Søn','Man','Tir','Ons','Tor','Fre','Lør'],
		dayNamesMin: ['Sø','Ma','Ti','On','To','Fr','Lø'],
		weekHeader: 'Uge',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['da']);
});

/* German initialisation for the jQuery UI date picker plugin. */
/* Written by Milian Wolff (mail@milianw.de). */
jQuery(function($){
	$.datepicker.regional['de'] = {
		closeText: 'Schließen',
		prevText: '&#x3C;Zurück',
		nextText: 'Vor&#x3E;',
		currentText: 'Heute',
		monthNames: ['Januar','Februar','März','April','Mai','Juni',
		'Juli','August','September','Oktober','November','Dezember'],
		monthNamesShort: ['Jan','Feb','Mär','Apr','Mai','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dez'],
		dayNames: ['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],
		dayNamesShort: ['So','Mo','Di','Mi','Do','Fr','Sa'],
		dayNamesMin: ['So','Mo','Di','Mi','Do','Fr','Sa'],
		weekHeader: 'KW',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['de']);
});

/* Greek (el) initialisation for the jQuery UI date picker plugin. */
/* Written by Alex Cicovic (http://www.alexcicovic.com) */
jQuery(function($){
	$.datepicker.regional['el'] = {
		closeText: 'Κλείσιμο',
		prevText: 'Προηγούμενος',
		nextText: 'Επόμενος',
		currentText: 'Τρέχων Μήνας',
		monthNames: ['Ιανουάριος','Φεβρουάριος','Μάρτιος','Απρίλιος','Μάιος','Ιούνιος',
		'Ιούλιος','Αύγουστος','Σεπτέμβριος','Οκτώβριος','Νοέμβριος','Δεκέμβριος'],
		monthNamesShort: ['Ιαν','Φεβ','Μαρ','Απρ','Μαι','Ιουν',
		'Ιουλ','Αυγ','Σεπ','Οκτ','Νοε','Δεκ'],
		dayNames: ['Κυριακή','Δευτέρα','Τρίτη','Τετάρτη','Πέμπτη','Παρασκευή','Σάββατο'],
		dayNamesShort: ['Κυρ','Δευ','Τρι','Τετ','Πεμ','Παρ','Σαβ'],
		dayNamesMin: ['Κυ','Δε','Τρ','Τε','Πε','Πα','Σα'],
		weekHeader: 'Εβδ',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['el']);
});

/* English/Australia initialisation for the jQuery UI date picker plugin. */
/* Based on the en-GB initialisation. */
jQuery(function($){
	$.datepicker.regional['en-AU'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-AU']);
});

/* English/UK initialisation for the jQuery UI date picker plugin. */
/* Written by Stuart. */
jQuery(function($){
	$.datepicker.regional['en-GB'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-GB']);
});

/* English/New Zealand initialisation for the jQuery UI date picker plugin. */
/* Based on the en-GB initialisation. */
jQuery(function($){
	$.datepicker.regional['en-NZ'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-NZ']);
});

/* Esperanto initialisation for the jQuery UI date picker plugin. */
/* Written by Olivier M. (olivierweb@ifrance.com). */
jQuery(function($){
	$.datepicker.regional['eo'] = {
		closeText: 'Fermi',
		prevText: '&#x3C;Anta',
		nextText: 'Sekv&#x3E;',
		currentText: 'Nuna',
		monthNames: ['Januaro','Februaro','Marto','Aprilo','Majo','Junio',
		'Julio','Aŭgusto','Septembro','Oktobro','Novembro','Decembro'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aŭg','Sep','Okt','Nov','Dec'],
		dayNames: ['Dimanĉo','Lundo','Mardo','Merkredo','Ĵaŭdo','Vendredo','Sabato'],
		dayNamesShort: ['Dim','Lun','Mar','Mer','Ĵaŭ','Ven','Sab'],
		dayNamesMin: ['Di','Lu','Ma','Me','Ĵa','Ve','Sa'],
		weekHeader: 'Sb',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['eo']);
});

/* Inicialización en español para la extensión 'UI date picker' para jQuery. */
/* Traducido por Vester (xvester@gmail.com). */
jQuery(function($){
	$.datepicker.regional['es'] = {
		closeText: 'Cerrar',
		prevText: '&#x3C;Ant',
		nextText: 'Sig&#x3E;',
		currentText: 'Hoy',
		monthNames: ['enero','febrero','marzo','abril','mayo','junio',
		'julio','agosto','septiembre','octubre','noviembre','diciembre'],
		monthNamesShort: ['ene','feb','mar','abr','may','jun',
		'jul','ogo','sep','oct','nov','dic'],
		dayNames: ['domingo','lunes','martes','miércoles','jueves','viernes','sábado'],
		dayNamesShort: ['dom','lun','mar','mié','juv','vie','sáb'],
		dayNamesMin: ['D','L','M','X','J','V','S'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['es']);
});

/* Estonian initialisation for the jQuery UI date picker plugin. */
/* Written by Mart Sõmermaa (mrts.pydev at gmail com). */
jQuery(function($){
	$.datepicker.regional['et'] = {
		closeText: 'Sulge',
		prevText: 'Eelnev',
		nextText: 'Järgnev',
		currentText: 'Täna',
		monthNames: ['Jaanuar','Veebruar','Märts','Aprill','Mai','Juuni',
		'Juuli','August','September','Oktoober','November','Detsember'],
		monthNamesShort: ['Jaan', 'Veebr', 'Märts', 'Apr', 'Mai', 'Juuni',
		'Juuli', 'Aug', 'Sept', 'Okt', 'Nov', 'Dets'],
		dayNames: ['Pühapäev', 'Esmaspäev', 'Teisipäev', 'Kolmapäev', 'Neljapäev', 'Reede', 'Laupäev'],
		dayNamesShort: ['Pühap', 'Esmasp', 'Teisip', 'Kolmap', 'Neljap', 'Reede', 'Laup'],
		dayNamesMin: ['P','E','T','K','N','R','L'],
		weekHeader: 'näd',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['et']);
});

/* Euskarako oinarria 'UI date picker' jquery-ko extentsioarentzat */
/* Karrikas-ek itzulia (karrikas@karrikas.com) */
jQuery(function($){
	$.datepicker.regional['eu'] = {
		closeText: 'Egina',
		prevText: '&#x3C;Aur',
		nextText: 'Hur&#x3E;',
		currentText: 'Gaur',
		monthNames: ['urtarrila','otsaila','martxoa','apirila','maiatza','ekaina',
			'uztaila','abuztua','iraila','urria','azaroa','abendua'],
		monthNamesShort: ['urt.','ots.','mar.','api.','mai.','eka.',
			'uzt.','abu.','ira.','urr.','aza.','abe.'],
		dayNames: ['igandea','astelehena','asteartea','asteazkena','osteguna','ostirala','larunbata'],
		dayNamesShort: ['ig.','al.','ar.','az.','og.','ol.','lr.'],
		dayNamesMin: ['ig','al','ar','az','og','ol','lr'],
		weekHeader: 'As',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['eu']);
});

/* Persian (Farsi) Translation for the jQuery UI date picker plugin. */
/* Javad Mowlanezhad -- jmowla@gmail.com */
/* Jalali calendar should supported soon! (Its implemented but I have to test it) */
jQuery(function($) {
	$.datepicker.regional['fa'] = {
		closeText: 'بستن',
		prevText: '&#x3C;قبلی',
		nextText: 'بعدی&#x3E;',
		currentText: 'امروز',
		monthNames: [
			'فروردين',
			'ارديبهشت',
			'خرداد',
			'تير',
			'مرداد',
			'شهريور',
			'مهر',
			'آبان',
			'آذر',
			'دی',
			'بهمن',
			'اسفند'
		],
		monthNamesShort: ['1','2','3','4','5','6','7','8','9','10','11','12'],
		dayNames: [
			'يکشنبه',
			'دوشنبه',
			'سه‌شنبه',
			'چهارشنبه',
			'پنجشنبه',
			'جمعه',
			'شنبه'
		],
		dayNamesShort: [
			'ی',
			'د',
			'س',
			'چ',
			'پ',
			'ج',
			'ش'
		],
		dayNamesMin: [
			'ی',
			'د',
			'س',
			'چ',
			'پ',
			'ج',
			'ش'
		],
		weekHeader: 'هف',
		dateFormat: 'yy/mm/dd',
		firstDay: 6,
		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fa']);
});

/* Finnish initialisation for the jQuery UI date picker plugin. */
/* Written by Harri Kilpiö (harrikilpio@gmail.com). */
jQuery(function($){
	$.datepicker.regional['fi'] = {
		closeText: 'Sulje',
		prevText: '&#xAB;Edellinen',
		nextText: 'Seuraava&#xBB;',
		currentText: 'Tänään',
		monthNames: ['Tammikuu','Helmikuu','Maaliskuu','Huhtikuu','Toukokuu','Kesäkuu',
		'Heinäkuu','Elokuu','Syyskuu','Lokakuu','Marraskuu','Joulukuu'],
		monthNamesShort: ['Tammi','Helmi','Maalis','Huhti','Touko','Kesä',
		'Heinä','Elo','Syys','Loka','Marras','Joulu'],
		dayNamesShort: ['Su','Ma','Ti','Ke','To','Pe','La'],
		dayNames: ['Sunnuntai','Maanantai','Tiistai','Keskiviikko','Torstai','Perjantai','Lauantai'],
		dayNamesMin: ['Su','Ma','Ti','Ke','To','Pe','La'],
		weekHeader: 'Vk',
		dateFormat: 'd.m.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fi']);
});

/* Faroese initialisation for the jQuery UI date picker plugin */
/* Written by Sverri Mohr Olsen, sverrimo@gmail.com */
jQuery(function($){
	$.datepicker.regional['fo'] = {
		closeText: 'Lat aftur',
		prevText: '&#x3C;Fyrra',
		nextText: 'Næsta&#x3E;',
		currentText: 'Í dag',
		monthNames: ['Januar','Februar','Mars','Apríl','Mei','Juni',
		'Juli','August','September','Oktober','November','Desember'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Mei','Jun',
		'Jul','Aug','Sep','Okt','Nov','Des'],
		dayNames: ['Sunnudagur','Mánadagur','Týsdagur','Mikudagur','Hósdagur','Fríggjadagur','Leyardagur'],
		dayNamesShort: ['Sun','Mán','Týs','Mik','Hós','Frí','Ley'],
		dayNamesMin: ['Su','Má','Tý','Mi','Hó','Fr','Le'],
		weekHeader: 'Vk',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fo']);
});

/* Canadian-French initialisation for the jQuery UI date picker plugin. */
jQuery(function ($) {
	$.datepicker.regional['fr-CA'] = {
		closeText: 'Fermer',
		prevText: 'Précédent',
		nextText: 'Suivant',
		currentText: 'Aujourd\'hui',
		monthNames: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
			'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
		monthNamesShort: ['janv.', 'févr.', 'mars', 'avril', 'mai', 'juin',
			'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
		dayNames: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
		dayNamesShort: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
		dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
		weekHeader: 'Sem.',
		dateFormat: 'yy-mm-dd',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['fr-CA']);
});

/* Swiss-French initialisation for the jQuery UI date picker plugin. */
/* Written Martin Voelkle (martin.voelkle@e-tc.ch). */
jQuery(function($){
	$.datepicker.regional['fr-CH'] = {
		closeText: 'Fermer',
		prevText: '&#x3C;Préc',
		nextText: 'Suiv&#x3E;',
		currentText: 'Courant',
		monthNames: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
			'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
		monthNamesShort: ['janv.', 'févr.', 'mars', 'avril', 'mai', 'juin',
			'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
		dayNames: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
		dayNamesShort: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
		dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
		weekHeader: 'Sm',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fr-CH']);
});

/* French initialisation for the jQuery UI date picker plugin. */
/* Written by Keith Wood (kbwood{at}iinet.com.au),
			  Stéphane Nahmani (sholby@sholby.net),
			  Stéphane Raimbault <stephane.raimbault@gmail.com> */
jQuery(function($){
	$.datepicker.regional['fr'] = {
		closeText: 'Fermer',
		prevText: 'Précédent',
		nextText: 'Suivant',
		currentText: 'Aujourd\'hui',
		monthNames: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
			'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
		monthNamesShort: ['janv.', 'févr.', 'mars', 'avril', 'mai', 'juin',
			'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
		dayNames: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
		dayNamesShort: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
		dayNamesMin: ['D','L','M','M','J','V','S'],
		weekHeader: 'Sem.',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fr']);
});

/* Galician localization for 'UI date picker' jQuery extension. */
/* Translated by Jorge Barreiro <yortx.barry@gmail.com>. */
jQuery(function($){
	$.datepicker.regional['gl'] = {
		closeText: 'Pechar',
		prevText: '&#x3C;Ant',
		nextText: 'Seg&#x3E;',
		currentText: 'Hoxe',
		monthNames: ['Xaneiro','Febreiro','Marzo','Abril','Maio','Xuño',
		'Xullo','Agosto','Setembro','Outubro','Novembro','Decembro'],
		monthNamesShort: ['Xan','Feb','Mar','Abr','Mai','Xuñ',
		'Xul','Ago','Set','Out','Nov','Dec'],
		dayNames: ['Domingo','Luns','Martes','Mércores','Xoves','Venres','Sábado'],
		dayNamesShort: ['Dom','Lun','Mar','Mér','Xov','Ven','Sáb'],
		dayNamesMin: ['Do','Lu','Ma','Mé','Xo','Ve','Sá'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['gl']);
});

/* Hebrew initialisation for the UI Datepicker extension. */
/* Written by Amir Hardon (ahardon at gmail dot com). */
jQuery(function($){
	$.datepicker.regional['he'] = {
		closeText: 'סגור',
		prevText: '&#x3C;הקודם',
		nextText: 'הבא&#x3E;',
		currentText: 'היום',
		monthNames: ['ינואר','פברואר','מרץ','אפריל','מאי','יוני',
		'יולי','אוגוסט','ספטמבר','אוקטובר','נובמבר','דצמבר'],
		monthNamesShort: ['ינו','פבר','מרץ','אפר','מאי','יוני',
		'יולי','אוג','ספט','אוק','נוב','דצמ'],
		dayNames: ['ראשון','שני','שלישי','רביעי','חמישי','שישי','שבת'],
		dayNamesShort: ['א\'','ב\'','ג\'','ד\'','ה\'','ו\'','שבת'],
		dayNamesMin: ['א\'','ב\'','ג\'','ד\'','ה\'','ו\'','שבת'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['he']);
});

/* Hindi initialisation for the jQuery UI date picker plugin. */
/* Written by Michael Dawart. */
jQuery(function($){
	$.datepicker.regional['hi'] = {
		closeText: 'बंद',
		prevText: 'पिछला',
		nextText: 'अगला',
		currentText: 'आज',
		monthNames: ['जनवरी ','फरवरी','मार्च','अप्रेल','मई','जून',
		'जूलाई','अगस्त ','सितम्बर','अक्टूबर','नवम्बर','दिसम्बर'],
		monthNamesShort: ['जन', 'फर', 'मार्च', 'अप्रेल', 'मई', 'जून',
		'जूलाई', 'अग', 'सित', 'अक्ट', 'नव', 'दि'],
		dayNames: ['रविवार', 'सोमवार', 'मंगलवार', 'बुधवार', 'गुरुवार', 'शुक्रवार', 'शनिवार'],
		dayNamesShort: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
		dayNamesMin: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
		weekHeader: 'हफ्ता',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hi']);
});

/* Croatian i18n for the jQuery UI date picker plugin. */
/* Written by Vjekoslav Nesek. */
jQuery(function($){
	$.datepicker.regional['hr'] = {
		closeText: 'Zatvori',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Danas',
		monthNames: ['Siječanj','Veljača','Ožujak','Travanj','Svibanj','Lipanj',
		'Srpanj','Kolovoz','Rujan','Listopad','Studeni','Prosinac'],
		monthNamesShort: ['Sij','Velj','Ožu','Tra','Svi','Lip',
		'Srp','Kol','Ruj','Lis','Stu','Pro'],
		dayNames: ['Nedjelja','Ponedjeljak','Utorak','Srijeda','Četvrtak','Petak','Subota'],
		dayNamesShort: ['Ned','Pon','Uto','Sri','Čet','Pet','Sub'],
		dayNamesMin: ['Ne','Po','Ut','Sr','Če','Pe','Su'],
		weekHeader: 'Tje',
		dateFormat: 'dd.mm.yy.',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hr']);
});

/* Hungarian initialisation for the jQuery UI date picker plugin. */
/* Written by Istvan Karaszi (jquery@spam.raszi.hu). */
jQuery(function($){
	$.datepicker.regional['hu'] = {
		closeText: 'bezár',
		prevText: 'vissza',
		nextText: 'előre',
		currentText: 'ma',
		monthNames: ['Január', 'Február', 'Március', 'Április', 'Május', 'Június',
		'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December'],
		monthNamesShort: ['Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún',
		'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
		dayNames: ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat'],
		dayNamesShort: ['Vas', 'Hét', 'Ked', 'Sze', 'Csü', 'Pén', 'Szo'],
		dayNamesMin: ['V', 'H', 'K', 'Sze', 'Cs', 'P', 'Szo'],
		weekHeader: 'Hét',
		dateFormat: 'yy.mm.dd.',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hu']);
});

/* Armenian(UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Levon Zakaryan (levon.zakaryan@gmail.com)*/
jQuery(function($){
	$.datepicker.regional['hy'] = {
		closeText: 'Փակել',
		prevText: '&#x3C;Նախ.',
		nextText: 'Հաջ.&#x3E;',
		currentText: 'Այսօր',
		monthNames: ['Հունվար','Փետրվար','Մարտ','Ապրիլ','Մայիս','Հունիս',
		'Հուլիս','Օգոստոս','Սեպտեմբեր','Հոկտեմբեր','Նոյեմբեր','Դեկտեմբեր'],
		monthNamesShort: ['Հունվ','Փետր','Մարտ','Ապր','Մայիս','Հունիս',
		'Հուլ','Օգս','Սեպ','Հոկ','Նոյ','Դեկ'],
		dayNames: ['կիրակի','եկուշաբթի','երեքշաբթի','չորեքշաբթի','հինգշաբթի','ուրբաթ','շաբաթ'],
		dayNamesShort: ['կիր','երկ','երք','չրք','հնգ','ուրբ','շբթ'],
		dayNamesMin: ['կիր','երկ','երք','չրք','հնգ','ուրբ','շբթ'],
		weekHeader: 'ՇԲՏ',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hy']);
});

/* Indonesian initialisation for the jQuery UI date picker plugin. */
/* Written by Deden Fathurahman (dedenf@gmail.com). */
jQuery(function($){
	$.datepicker.regional['id'] = {
		closeText: 'Tutup',
		prevText: '&#x3C;mundur',
		nextText: 'maju&#x3E;',
		currentText: 'hari ini',
		monthNames: ['Januari','Februari','Maret','April','Mei','Juni',
		'Juli','Agustus','September','Oktober','Nopember','Desember'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Mei','Jun',
		'Jul','Agus','Sep','Okt','Nop','Des'],
		dayNames: ['Minggu','Senin','Selasa','Rabu','Kamis','Jumat','Sabtu'],
		dayNamesShort: ['Min','Sen','Sel','Rab','kam','Jum','Sab'],
		dayNamesMin: ['Mg','Sn','Sl','Rb','Km','jm','Sb'],
		weekHeader: 'Mg',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['id']);
});

/* Icelandic initialisation for the jQuery UI date picker plugin. */
/* Written by Haukur H. Thorsson (haukur@eskill.is). */
jQuery(function($){
	$.datepicker.regional['is'] = {
		closeText: 'Loka',
		prevText: '&#x3C; Fyrri',
		nextText: 'Næsti &#x3E;',
		currentText: 'Í dag',
		monthNames: ['Janúar','Febrúar','Mars','Apríl','Maí','Júní',
		'Júlí','Ágúst','September','Október','Nóvember','Desember'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maí','Jún',
		'Júl','Ágú','Sep','Okt','Nóv','Des'],
		dayNames: ['Sunnudagur','Mánudagur','Þriðjudagur','Miðvikudagur','Fimmtudagur','Föstudagur','Laugardagur'],
		dayNamesShort: ['Sun','Mán','Þri','Mið','Fim','Fös','Lau'],
		dayNamesMin: ['Su','Má','Þr','Mi','Fi','Fö','La'],
		weekHeader: 'Vika',
		dateFormat: 'dd.mm.yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['is']);
});

/* Italian initialisation for the jQuery UI date picker plugin. */
/* Written by Antonello Pasella (antonello.pasella@gmail.com). */
jQuery(function($){
	$.datepicker.regional['it'] = {
		closeText: 'Chiudi',
		prevText: '&#x3C;Prec',
		nextText: 'Succ&#x3E;',
		currentText: 'Oggi',
		monthNames: ['Gennaio','Febbraio','Marzo','Aprile','Maggio','Giugno',
			'Luglio','Agosto','Settembre','Ottobre','Novembre','Dicembre'],
		monthNamesShort: ['Gen','Feb','Mar','Apr','Mag','Giu',
			'Lug','Ago','Set','Ott','Nov','Dic'],
		dayNames: ['Domenica','Lunedì','Martedì','Mercoledì','Giovedì','Venerdì','Sabato'],
		dayNamesShort: ['Dom','Lun','Mar','Mer','Gio','Ven','Sab'],
		dayNamesMin: ['Do','Lu','Ma','Me','Gi','Ve','Sa'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['it']);
});

/* Japanese initialisation for the jQuery UI date picker plugin. */
/* Written by Kentaro SATO (kentaro@ranvis.com). */
jQuery(function($){
	$.datepicker.regional['ja'] = {
		closeText: '閉じる',
		prevText: '&#x3C;前',
		nextText: '次&#x3E;',
		currentText: '今日',
		monthNames: ['1月','2月','3月','4月','5月','6月',
		'7月','8月','9月','10月','11月','12月'],
		monthNamesShort: ['1月','2月','3月','4月','5月','6月',
		'7月','8月','9月','10月','11月','12月'],
		dayNames: ['日曜日','月曜日','火曜日','水曜日','木曜日','金曜日','土曜日'],
		dayNamesShort: ['日','月','火','水','木','金','土'],
		dayNamesMin: ['日','月','火','水','木','金','土'],
		weekHeader: '週',
		dateFormat: 'yy/mm/dd',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['ja']);
});

/* Georgian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Lado Lomidze (lado.lomidze@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ka'] = {
		closeText: 'დახურვა',
		prevText: '&#x3c; წინა',
		nextText: 'შემდეგი &#x3e;',
		currentText: 'დღეს',
		monthNames: ['იანვარი','თებერვალი','მარტი','აპრილი','მაისი','ივნისი', 'ივლისი','აგვისტო','სექტემბერი','ოქტომბერი','ნოემბერი','დეკემბერი'],
		monthNamesShort: ['იან','თებ','მარ','აპრ','მაი','ივნ', 'ივლ','აგვ','სექ','ოქტ','ნოე','დეკ'],
		dayNames: ['კვირა','ორშაბათი','სამშაბათი','ოთხშაბათი','ხუთშაბათი','პარასკევი','შაბათი'],
		dayNamesShort: ['კვ','ორშ','სამ','ოთხ','ხუთ','პარ','შაბ'],
		dayNamesMin: ['კვ','ორშ','სამ','ოთხ','ხუთ','პარ','შაბ'],
		weekHeader: 'კვირა',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ka']);
});

/* Kazakh (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Dmitriy Karasyov (dmitriy.karasyov@gmail.com). */
jQuery(function($){
	$.datepicker.regional['kk'] = {
		closeText: 'Жабу',
		prevText: '&#x3C;Алдыңғы',
		nextText: 'Келесі&#x3E;',
		currentText: 'Бүгін',
		monthNames: ['Қаңтар','Ақпан','Наурыз','Сәуір','Мамыр','Маусым',
		'Шілде','Тамыз','Қыркүйек','Қазан','Қараша','Желтоқсан'],
		monthNamesShort: ['Қаң','Ақп','Нау','Сәу','Мам','Мау',
		'Шіл','Там','Қыр','Қаз','Қар','Жел'],
		dayNames: ['Жексенбі','Дүйсенбі','Сейсенбі','Сәрсенбі','Бейсенбі','Жұма','Сенбі'],
		dayNamesShort: ['жкс','дсн','ссн','срс','бсн','жма','снб'],
		dayNamesMin: ['Жк','Дс','Сс','Ср','Бс','Жм','Сн'],
		weekHeader: 'Не',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['kk']);
});

/* Khmer initialisation for the jQuery calendar extension. */
/* Written by Chandara Om (chandara.teacher@gmail.com). */
jQuery(function($){
	$.datepicker.regional['km'] = {
		closeText: 'ធ្វើ​រួច',
		prevText: 'មុន',
		nextText: 'បន្ទាប់',
		currentText: 'ថ្ងៃ​នេះ',
		monthNames: ['មករា','កុម្ភៈ','មីនា','មេសា','ឧសភា','មិថុនា',
		'កក្កដា','សីហា','កញ្ញា','តុលា','វិច្ឆិកា','ធ្នូ'],
		monthNamesShort: ['មករា','កុម្ភៈ','មីនា','មេសា','ឧសភា','មិថុនា',
		'កក្កដា','សីហា','កញ្ញា','តុលា','វិច្ឆិកា','ធ្នូ'],
		dayNames: ['អាទិត្យ', 'ចន្ទ', 'អង្គារ', 'ពុធ', 'ព្រហស្បតិ៍', 'សុក្រ', 'សៅរ៍'],
		dayNamesShort: ['អា', 'ច', 'អ', 'ពុ', 'ព្រហ', 'សុ', 'សៅ'],
		dayNamesMin: ['អា', 'ច', 'អ', 'ពុ', 'ព្រហ', 'សុ', 'សៅ'],
		weekHeader: 'សប្ដាហ៍',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['km']);
});

/* Korean initialisation for the jQuery calendar extension. */
/* Written by DaeKwon Kang (ncrash.dk@gmail.com), Edited by Genie. */
jQuery(function($){
	$.datepicker.regional['ko'] = {
		closeText: '닫기',
		prevText: '이전달',
		nextText: '다음달',
		currentText: '오늘',
		monthNames: ['1월','2월','3월','4월','5월','6월',
		'7월','8월','9월','10월','11월','12월'],
		monthNamesShort: ['1월','2월','3월','4월','5월','6월',
		'7월','8월','9월','10월','11월','12월'],
		dayNames: ['일요일','월요일','화요일','수요일','목요일','금요일','토요일'],
		dayNamesShort: ['일','월','화','수','목','금','토'],
		dayNamesMin: ['일','월','화','수','목','금','토'],
		weekHeader: 'Wk',
		dateFormat: 'yy-mm-dd',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '년'};
	$.datepicker.setDefaults($.datepicker.regional['ko']);
});

/* Kyrgyz (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Sergey Kartashov (ebishkek@yandex.ru). */
jQuery(function($){
	$.datepicker.regional['ky'] = {
		closeText: 'Жабуу',
		prevText: '&#x3c;Мур',
		nextText: 'Кий&#x3e;',
		currentText: 'Бүгүн',
		monthNames: ['Январь','Февраль','Март','Апрель','Май','Июнь',
		'Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь'],
		monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
		'Июл','Авг','Сен','Окт','Ноя','Дек'],
		dayNames: ['жекшемби', 'дүйшөмбү', 'шейшемби', 'шаршемби', 'бейшемби', 'жума', 'ишемби'],
		dayNamesShort: ['жек', 'дүй', 'шей', 'шар', 'бей', 'жум', 'ише'],
		dayNamesMin: ['Жк','Дш','Шш','Шр','Бш','Жм','Иш'],
		weekHeader: 'Жум',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['ky']);
});

/* Luxembourgish initialisation for the jQuery UI date picker plugin. */
/* Written by Michel Weimerskirch <michel@weimerskirch.net> */
jQuery(function($){
	$.datepicker.regional['lb'] = {
		closeText: 'Fäerdeg',
		prevText: 'Zréck',
		nextText: 'Weider',
		currentText: 'Haut',
		monthNames: ['Januar','Februar','Mäerz','Abrëll','Mee','Juni',
		'Juli','August','September','Oktober','November','Dezember'],
		monthNamesShort: ['Jan', 'Feb', 'Mäe', 'Abr', 'Mee', 'Jun',
		'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
		dayNames: ['Sonndeg', 'Méindeg', 'Dënschdeg', 'Mëttwoch', 'Donneschdeg', 'Freideg', 'Samschdeg'],
		dayNamesShort: ['Son', 'Méi', 'Dën', 'Mët', 'Don', 'Fre', 'Sam'],
		dayNamesMin: ['So','Mé','Dë','Më','Do','Fr','Sa'],
		weekHeader: 'W',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['lb']);
});

/* Lithuanian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* @author Arturas Paleicikas <arturas@avalon.lt> */
jQuery(function($){
	$.datepicker.regional['lt'] = {
		closeText: 'Uždaryti',
		prevText: '&#x3C;Atgal',
		nextText: 'Pirmyn&#x3E;',
		currentText: 'Šiandien',
		monthNames: ['Sausis','Vasaris','Kovas','Balandis','Gegužė','Birželis',
		'Liepa','Rugpjūtis','Rugsėjis','Spalis','Lapkritis','Gruodis'],
		monthNamesShort: ['Sau','Vas','Kov','Bal','Geg','Bir',
		'Lie','Rugp','Rugs','Spa','Lap','Gru'],
		dayNames: ['sekmadienis','pirmadienis','antradienis','trečiadienis','ketvirtadienis','penktadienis','šeštadienis'],
		dayNamesShort: ['sek','pir','ant','tre','ket','pen','šeš'],
		dayNamesMin: ['Se','Pr','An','Tr','Ke','Pe','Še'],
		weekHeader: 'SAV',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['lt']);
});

/* Latvian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* @author Arturas Paleicikas <arturas.paleicikas@metasite.net> */
jQuery(function($){
	$.datepicker.regional['lv'] = {
		closeText: 'Aizvērt',
		prevText: 'Iepr.',
		nextText: 'Nāk.',
		currentText: 'Šodien',
		monthNames: ['Janvāris','Februāris','Marts','Aprīlis','Maijs','Jūnijs',
		'Jūlijs','Augusts','Septembris','Oktobris','Novembris','Decembris'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Mai','Jūn',
		'Jūl','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['svētdiena','pirmdiena','otrdiena','trešdiena','ceturtdiena','piektdiena','sestdiena'],
		dayNamesShort: ['svt','prm','otr','tre','ctr','pkt','sst'],
		dayNamesMin: ['Sv','Pr','Ot','Tr','Ct','Pk','Ss'],
		weekHeader: 'Ned.',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['lv']);
});

/* Macedonian i18n for the jQuery UI date picker plugin. */
/* Written by Stojce Slavkovski. */
jQuery(function($){
	$.datepicker.regional['mk'] = {
		closeText: 'Затвори',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Денес',
		monthNames: ['Јануари','Февруари','Март','Април','Мај','Јуни',
		'Јули','Август','Септември','Октомври','Ноември','Декември'],
		monthNamesShort: ['Јан','Фев','Мар','Апр','Мај','Јун',
		'Јул','Авг','Сеп','Окт','Ное','Дек'],
		dayNames: ['Недела','Понеделник','Вторник','Среда','Четврток','Петок','Сабота'],
		dayNamesShort: ['Нед','Пон','Вто','Сре','Чет','Пет','Саб'],
		dayNamesMin: ['Не','По','Вт','Ср','Че','Пе','Са'],
		weekHeader: 'Сед',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['mk']);
});

/* Malayalam (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Saji Nediyanchath (saji89@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ml'] = {
		closeText: 'ശരി',
		prevText: 'മുന്നത്തെ',
		nextText: 'അടുത്തത് ',
		currentText: 'ഇന്ന്',
		monthNames: ['ജനുവരി','ഫെബ്രുവരി','മാര്‍ച്ച്','ഏപ്രില്‍','മേയ്','ജൂണ്‍',
		'ജൂലൈ','ആഗസ്റ്റ്','സെപ്റ്റംബര്‍','ഒക്ടോബര്‍','നവംബര്‍','ഡിസംബര്‍'],
		monthNamesShort: ['ജനു', 'ഫെബ്', 'മാര്‍', 'ഏപ്രി', 'മേയ്', 'ജൂണ്‍',
		'ജൂലാ', 'ആഗ', 'സെപ്', 'ഒക്ടോ', 'നവം', 'ഡിസ'],
		dayNames: ['ഞായര്‍', 'തിങ്കള്‍', 'ചൊവ്വ', 'ബുധന്‍', 'വ്യാഴം', 'വെള്ളി', 'ശനി'],
		dayNamesShort: ['ഞായ', 'തിങ്ക', 'ചൊവ്വ', 'ബുധ', 'വ്യാഴം', 'വെള്ളി', 'ശനി'],
		dayNamesMin: ['ഞാ','തി','ചൊ','ബു','വ്യാ','വെ','ശ'],
		weekHeader: 'ആ',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ml']);
});

/* Malaysian initialisation for the jQuery UI date picker plugin. */
/* Written by Mohd Nawawi Mohamad Jamili (nawawi@ronggeng.net). */
jQuery(function($){
	$.datepicker.regional['ms'] = {
		closeText: 'Tutup',
		prevText: '&#x3C;Sebelum',
		nextText: 'Selepas&#x3E;',
		currentText: 'hari ini',
		monthNames: ['Januari','Februari','Mac','April','Mei','Jun',
		'Julai','Ogos','September','Oktober','November','Disember'],
		monthNamesShort: ['Jan','Feb','Mac','Apr','Mei','Jun',
		'Jul','Ogo','Sep','Okt','Nov','Dis'],
		dayNames: ['Ahad','Isnin','Selasa','Rabu','Khamis','Jumaat','Sabtu'],
		dayNamesShort: ['Aha','Isn','Sel','Rab','kha','Jum','Sab'],
		dayNamesMin: ['Ah','Is','Se','Ra','Kh','Ju','Sa'],
		weekHeader: 'Mg',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ms']);
});

/* Norwegian Bokmål initialisation for the jQuery UI date picker plugin. */
/* Written by Bjørn Johansen (post@bjornjohansen.no). */
jQuery(function($){
	$.datepicker.regional['nb'] = {
		closeText: 'Lukk',
		prevText: '&#xAB;Forrige',
		nextText: 'Neste&#xBB;',
		currentText: 'I dag',
		monthNames: ['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember'],
		monthNamesShort: ['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des'],
		dayNamesShort: ['søn','man','tir','ons','tor','fre','lør'],
		dayNames: ['søndag','mandag','tirsdag','onsdag','torsdag','fredag','lørdag'],
		dayNamesMin: ['sø','ma','ti','on','to','fr','lø'],
		weekHeader: 'Uke',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['nb']);
});

/* Dutch (Belgium) initialisation for the jQuery UI date picker plugin. */
/* David De Sloovere @DavidDeSloovere */
jQuery(function($){
	$.datepicker.regional['nl-BE'] = {
		closeText: 'Sluiten',
		prevText: '←',
		nextText: '→',
		currentText: 'Vandaag',
		monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni',
		'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
		monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun',
		'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
		dayNames: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
		dayNamesShort: ['zon', 'maa', 'din', 'woe', 'don', 'vri', 'zat'],
		dayNamesMin: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['nl-BE']);
});

/* Dutch (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Mathias Bynens <http://mathiasbynens.be/> */
jQuery(function($){
	$.datepicker.regional.nl = {
		closeText: 'Sluiten',
		prevText: '←',
		nextText: '→',
		currentText: 'Vandaag',
		monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni',
		'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
		monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun',
		'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
		dayNames: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
		dayNamesShort: ['zon', 'maa', 'din', 'woe', 'don', 'vri', 'zat'],
		dayNamesMin: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
		weekHeader: 'Wk',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional.nl);
});

/* Norwegian Nynorsk initialisation for the jQuery UI date picker plugin. */
/* Written by Bjørn Johansen (post@bjornjohansen.no). */
jQuery(function($){
	$.datepicker.regional['nn'] = {
		closeText: 'Lukk',
		prevText: '&#xAB;Førre',
		nextText: 'Neste&#xBB;',
		currentText: 'I dag',
		monthNames: ['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember'],
		monthNamesShort: ['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des'],
		dayNamesShort: ['sun','mån','tys','ons','tor','fre','lau'],
		dayNames: ['sundag','måndag','tysdag','onsdag','torsdag','fredag','laurdag'],
		dayNamesMin: ['su','må','ty','on','to','fr','la'],
		weekHeader: 'Veke',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['nn']);
});

/* Norwegian initialisation for the jQuery UI date picker plugin. */
/* Written by Naimdjon Takhirov (naimdjon@gmail.com). */

jQuery(function($){
	$.datepicker.regional['no'] = {
		closeText: 'Lukk',
		prevText: '&#xAB;Forrige',
		nextText: 'Neste&#xBB;',
		currentText: 'I dag',
		monthNames: ['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember'],
		monthNamesShort: ['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des'],
		dayNamesShort: ['søn','man','tir','ons','tor','fre','lør'],
		dayNames: ['søndag','mandag','tirsdag','onsdag','torsdag','fredag','lørdag'],
		dayNamesMin: ['sø','ma','ti','on','to','fr','lø'],
		weekHeader: 'Uke',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['no']);
});

/* Polish initialisation for the jQuery UI date picker plugin. */
/* Written by Jacek Wysocki (jacek.wysocki@gmail.com). */
jQuery(function($){
	$.datepicker.regional['pl'] = {
		closeText: 'Zamknij',
		prevText: '&#x3C;Poprzedni',
		nextText: 'Następny&#x3E;',
		currentText: 'Dziś',
		monthNames: ['Styczeń','Luty','Marzec','Kwiecień','Maj','Czerwiec',
		'Lipiec','Sierpień','Wrzesień','Październik','Listopad','Grudzień'],
		monthNamesShort: ['Sty','Lu','Mar','Kw','Maj','Cze',
		'Lip','Sie','Wrz','Pa','Lis','Gru'],
		dayNames: ['Niedziela','Poniedziałek','Wtorek','Środa','Czwartek','Piątek','Sobota'],
		dayNamesShort: ['Nie','Pn','Wt','Śr','Czw','Pt','So'],
		dayNamesMin: ['N','Pn','Wt','Śr','Cz','Pt','So'],
		weekHeader: 'Tydz',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['pl']);
});

/* Brazilian initialisation for the jQuery UI date picker plugin. */
/* Written by Leonildo Costa Silva (leocsilva@gmail.com). */
jQuery(function($){
	$.datepicker.regional['pt-BR'] = {
		closeText: 'Fechar',
		prevText: '&#x3C;Anterior',
		nextText: 'Próximo&#x3E;',
		currentText: 'Hoje',
		monthNames: ['Janeiro','Fevereiro','Março','Abril','Maio','Junho',
		'Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],
		monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun',
		'Jul','Ago','Set','Out','Nov','Dez'],
		dayNames: ['Domingo','Segunda-feira','Terça-feira','Quarta-feira','Quinta-feira','Sexta-feira','Sábado'],
		dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		dayNamesMin: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['pt-BR']);
});

/* Portuguese initialisation for the jQuery UI date picker plugin. */
jQuery(function($){
	$.datepicker.regional['pt'] = {
		closeText: 'Fechar',
		prevText: 'Anterior',
		nextText: 'Seguinte',
		currentText: 'Hoje',
		monthNames: ['Janeiro','Fevereiro','Março','Abril','Maio','Junho',
		'Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],
		monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun',
		'Jul','Ago','Set','Out','Nov','Dez'],
		dayNames: ['Domingo','Segunda-feira','Terça-feira','Quarta-feira','Quinta-feira','Sexta-feira','Sábado'],
		dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		dayNamesMin: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		weekHeader: 'Sem',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['pt']);
});

/* Romansh initialisation for the jQuery UI date picker plugin. */
/* Written by Yvonne Gienal (yvonne.gienal@educa.ch). */
jQuery(function($){
	$.datepicker.regional['rm'] = {
		closeText: 'Serrar',
		prevText: '&#x3C;Suandant',
		nextText: 'Precedent&#x3E;',
		currentText: 'Actual',
		monthNames: ['Schaner','Favrer','Mars','Avrigl','Matg','Zercladur', 'Fanadur','Avust','Settember','October','November','December'],
		monthNamesShort: ['Scha','Fev','Mar','Avr','Matg','Zer', 'Fan','Avu','Sett','Oct','Nov','Dec'],
		dayNames: ['Dumengia','Glindesdi','Mardi','Mesemna','Gievgia','Venderdi','Sonda'],
		dayNamesShort: ['Dum','Gli','Mar','Mes','Gie','Ven','Som'],
		dayNamesMin: ['Du','Gl','Ma','Me','Gi','Ve','So'],
		weekHeader: 'emna',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['rm']);
});

/* Romanian initialisation for the jQuery UI date picker plugin.
 *
 * Written by Edmond L. (ll_edmond@walla.com)
 * and Ionut G. Stan (ionut.g.stan@gmail.com)
 */
jQuery(function($){
	$.datepicker.regional['ro'] = {
		closeText: 'Închide',
		prevText: '&#xAB; Luna precedentă',
		nextText: 'Luna următoare &#xBB;',
		currentText: 'Azi',
		monthNames: ['Ianuarie','Februarie','Martie','Aprilie','Mai','Iunie',
		'Iulie','August','Septembrie','Octombrie','Noiembrie','Decembrie'],
		monthNamesShort: ['Ian', 'Feb', 'Mar', 'Apr', 'Mai', 'Iun',
		'Iul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Duminică', 'Luni', 'Marţi', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'],
		dayNamesShort: ['Dum', 'Lun', 'Mar', 'Mie', 'Joi', 'Vin', 'Sâm'],
		dayNamesMin: ['Du','Lu','Ma','Mi','Jo','Vi','Sâ'],
		weekHeader: 'Săpt',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ro']);
});

/* Russian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Andrew Stromnov (stromnov@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ru'] = {
		closeText: 'Закрыть',
		prevText: '&#x3C;Пред',
		nextText: 'След&#x3E;',
		currentText: 'Сегодня',
		monthNames: ['Январь','Февраль','Март','Апрель','Май','Июнь',
		'Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь'],
		monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
		'Июл','Авг','Сен','Окт','Ноя','Дек'],
		dayNames: ['воскресенье','понедельник','вторник','среда','четверг','пятница','суббота'],
		dayNamesShort: ['вск','пнд','втр','срд','чтв','птн','сбт'],
		dayNamesMin: ['Вс','Пн','Вт','Ср','Чт','Пт','Сб'],
		weekHeader: 'Нед',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ru']);
});

/* Slovak initialisation for the jQuery UI date picker plugin. */
/* Written by Vojtech Rinik (vojto@hmm.sk). */
jQuery(function($){
	$.datepicker.regional['sk'] = {
		closeText: 'Zavrieť',
		prevText: '&#x3C;Predchádzajúci',
		nextText: 'Nasledujúci&#x3E;',
		currentText: 'Dnes',
		monthNames: ['január','február','marec','apríl','máj','jún',
		'júl','august','september','október','november','december'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Máj','Jún',
		'Júl','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['nedeľa','pondelok','utorok','streda','štvrtok','piatok','sobota'],
		dayNamesShort: ['Ned','Pon','Uto','Str','Štv','Pia','Sob'],
		dayNamesMin: ['Ne','Po','Ut','St','Št','Pia','So'],
		weekHeader: 'Ty',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sk']);
});

/* Slovenian initialisation for the jQuery UI date picker plugin. */
/* Written by Jaka Jancar (jaka@kubje.org). */
/* c = č, s = š z = ž C = Č S = Š Z = Ž */
jQuery(function($){
	$.datepicker.regional['sl'] = {
		closeText: 'Zapri',
		prevText: '&#x3C;Prejšnji',
		nextText: 'Naslednji&#x3E;',
		currentText: 'Trenutni',
		monthNames: ['Januar','Februar','Marec','April','Maj','Junij',
		'Julij','Avgust','September','Oktober','November','December'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Avg','Sep','Okt','Nov','Dec'],
		dayNames: ['Nedelja','Ponedeljek','Torek','Sreda','Četrtek','Petek','Sobota'],
		dayNamesShort: ['Ned','Pon','Tor','Sre','Čet','Pet','Sob'],
		dayNamesMin: ['Ne','Po','To','Sr','Če','Pe','So'],
		weekHeader: 'Teden',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sl']);
});

/* Albanian initialisation for the jQuery UI date picker plugin. */
/* Written by Flakron Bytyqi (flakron@gmail.com). */
jQuery(function($){
	$.datepicker.regional['sq'] = {
		closeText: 'mbylle',
		prevText: '&#x3C;mbrapa',
		nextText: 'Përpara&#x3E;',
		currentText: 'sot',
		monthNames: ['Janar','Shkurt','Mars','Prill','Maj','Qershor',
		'Korrik','Gusht','Shtator','Tetor','Nëntor','Dhjetor'],
		monthNamesShort: ['Jan','Shk','Mar','Pri','Maj','Qer',
		'Kor','Gus','Sht','Tet','Nën','Dhj'],
		dayNames: ['E Diel','E Hënë','E Martë','E Mërkurë','E Enjte','E Premte','E Shtune'],
		dayNamesShort: ['Di','Hë','Ma','Më','En','Pr','Sh'],
		dayNamesMin: ['Di','Hë','Ma','Më','En','Pr','Sh'],
		weekHeader: 'Ja',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sq']);
});

/* Serbian i18n for the jQuery UI date picker plugin. */
/* Written by Dejan Dimić. */
jQuery(function($){
	$.datepicker.regional['sr-SR'] = {
		closeText: 'Zatvori',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Danas',
		monthNames: ['Januar','Februar','Mart','April','Maj','Jun',
		'Jul','Avgust','Septembar','Oktobar','Novembar','Decembar'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Avg','Sep','Okt','Nov','Dec'],
		dayNames: ['Nedelja','Ponedeljak','Utorak','Sreda','Četvrtak','Petak','Subota'],
		dayNamesShort: ['Ned','Pon','Uto','Sre','Čet','Pet','Sub'],
		dayNamesMin: ['Ne','Po','Ut','Sr','Če','Pe','Su'],
		weekHeader: 'Sed',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sr-SR']);
});

/* Serbian i18n for the jQuery UI date picker plugin. */
/* Written by Dejan Dimić. */
jQuery(function($){
	$.datepicker.regional['sr'] = {
		closeText: 'Затвори',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Данас',
		monthNames: ['Јануар','Фебруар','Март','Април','Мај','Јун',
		'Јул','Август','Септембар','Октобар','Новембар','Децембар'],
		monthNamesShort: ['Јан','Феб','Мар','Апр','Мај','Јун',
		'Јул','Авг','Сеп','Окт','Нов','Дец'],
		dayNames: ['Недеља','Понедељак','Уторак','Среда','Четвртак','Петак','Субота'],
		dayNamesShort: ['Нед','Пон','Уто','Сре','Чет','Пет','Суб'],
		dayNamesMin: ['Не','По','Ут','Ср','Че','Пе','Су'],
		weekHeader: 'Сед',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sr']);
});

/* Swedish initialisation for the jQuery UI date picker plugin. */
/* Written by Anders Ekdahl ( anders@nomadiz.se). */
jQuery(function($){
	$.datepicker.regional['sv'] = {
		closeText: 'Stäng',
		prevText: '&#xAB;Förra',
		nextText: 'Nästa&#xBB;',
		currentText: 'Idag',
		monthNames: ['Januari','Februari','Mars','April','Maj','Juni',
		'Juli','Augusti','September','Oktober','November','December'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dec'],
		dayNamesShort: ['Sön','Mån','Tis','Ons','Tor','Fre','Lör'],
		dayNames: ['Söndag','Måndag','Tisdag','Onsdag','Torsdag','Fredag','Lördag'],
		dayNamesMin: ['Sö','Må','Ti','On','To','Fr','Lö'],
		weekHeader: 'Ve',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sv']);
});

/* Tamil (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by S A Sureshkumar (saskumar@live.com). */
jQuery(function($){
	$.datepicker.regional['ta'] = {
		closeText: 'மூடு',
		prevText: 'முன்னையது',
		nextText: 'அடுத்தது',
		currentText: 'இன்று',
		monthNames: ['தை','மாசி','பங்குனி','சித்திரை','வைகாசி','ஆனி',
		'ஆடி','ஆவணி','புரட்டாசி','ஐப்பசி','கார்த்திகை','மார்கழி'],
		monthNamesShort: ['தை','மாசி','பங்','சித்','வைகா','ஆனி',
		'ஆடி','ஆவ','புர','ஐப்','கார்','மார்'],
		dayNames: ['ஞாயிற்றுக்கிழமை','திங்கட்கிழமை','செவ்வாய்க்கிழமை','புதன்கிழமை','வியாழக்கிழமை','வெள்ளிக்கிழமை','சனிக்கிழமை'],
		dayNamesShort: ['ஞாயிறு','திங்கள்','செவ்வாய்','புதன்','வியாழன்','வெள்ளி','சனி'],
		dayNamesMin: ['ஞா','தி','செ','பு','வி','வெ','ச'],
		weekHeader: 'Не',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ta']);
});

/* Thai initialisation for the jQuery UI date picker plugin. */
/* Written by pipo (pipo@sixhead.com). */
jQuery(function($){
	$.datepicker.regional['th'] = {
		closeText: 'ปิด',
		prevText: '&#xAB;&#xA0;ย้อน',
		nextText: 'ถัดไป&#xA0;&#xBB;',
		currentText: 'วันนี้',
		monthNames: ['มกราคม','กุมภาพันธ์','มีนาคม','เมษายน','พฤษภาคม','มิถุนายน',
		'กรกฎาคม','สิงหาคม','กันยายน','ตุลาคม','พฤศจิกายน','ธันวาคม'],
		monthNamesShort: ['ม.ค.','ก.พ.','มี.ค.','เม.ย.','พ.ค.','มิ.ย.',
		'ก.ค.','ส.ค.','ก.ย.','ต.ค.','พ.ย.','ธ.ค.'],
		dayNames: ['อาทิตย์','จันทร์','อังคาร','พุธ','พฤหัสบดี','ศุกร์','เสาร์'],
		dayNamesShort: ['อา.','จ.','อ.','พ.','พฤ.','ศ.','ส.'],
		dayNamesMin: ['อา.','จ.','อ.','พ.','พฤ.','ศ.','ส.'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['th']);
});

/* Tajiki (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Abdurahmon Saidov (saidovab@gmail.com). */
jQuery(function($){
	$.datepicker.regional['tj'] = {
		closeText: 'Идома',
		prevText: '&#x3c;Қафо',
		nextText: 'Пеш&#x3e;',
		currentText: 'Имрӯз',
		monthNames: ['Январ','Феврал','Март','Апрел','Май','Июн',
		'Июл','Август','Сентябр','Октябр','Ноябр','Декабр'],
		monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
		'Июл','Авг','Сен','Окт','Ноя','Дек'],
		dayNames: ['якшанбе','душанбе','сешанбе','чоршанбе','панҷшанбе','ҷумъа','шанбе'],
		dayNamesShort: ['якш','душ','сеш','чор','пан','ҷум','шан'],
		dayNamesMin: ['Як','Дш','Сш','Чш','Пш','Ҷм','Шн'],
		weekHeader: 'Хф',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['tj']);
});

/* Tetum (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Alexandru Cartaleanu (acartaleanu@developmentgateway.org). */
/* LOCAL AMP CODE -- THIS WILL DISAPPEAR */
jQuery(function($){
	$.datepicker.regional['tm'] = {
		closeText: 'Halo ona',
		prevText: 'Uluk',
		nextText: 'Tuir mai',
		currentText: 'Ohin loron',
		monthNames: ['Janeiru','Fevreiru','Marsu','Abril','Maiu','Junhu',
		'Julhu','Agostu','Septembru','Otubru','Novembru','Dezrembru'],
		monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun',
		'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dez'],
		dayNames: ['Dumingu', 'Segunda', 'Tersa', 'Kuarta', 'Kinta', 'Sesta', 'Sabadu'],
		dayNamesShort: ['Dum', 'Seg', 'Ter', 'Krt', 'Kin', 'Ses', 'Sab'],
		dayNamesMin: ['Dm','Sg','Tr','Kt','Kn','Ss','Sb'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['tm']);
});
/* Turkish initialisation for the jQuery UI date picker plugin. */
/* Written by Izzet Emre Erkan (kara@karalamalar.net). */
jQuery(function($){
	$.datepicker.regional['tr'] = {
		closeText: 'kapat',
		prevText: '&#x3C;geri',
		nextText: 'ileri&#x3e',
		currentText: 'bugün',
		monthNames: ['Ocak','Şubat','Mart','Nisan','Mayıs','Haziran',
		'Temmuz','Ağustos','Eylül','Ekim','Kasım','Aralık'],
		monthNamesShort: ['Oca','Şub','Mar','Nis','May','Haz',
		'Tem','Ağu','Eyl','Eki','Kas','Ara'],
		dayNames: ['Pazar','Pazartesi','Salı','Çarşamba','Perşembe','Cuma','Cumartesi'],
		dayNamesShort: ['Pz','Pt','Sa','Ça','Pe','Cu','Ct'],
		dayNamesMin: ['Pz','Pt','Sa','Ça','Pe','Cu','Ct'],
		weekHeader: 'Hf',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['tr']);
});

/* Ukrainian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Maxim Drogobitskiy (maxdao@gmail.com). */
/* Corrected by Igor Milla (igor.fsp.milla@gmail.com). */
jQuery(function($){
	$.datepicker.regional['uk'] = {
		closeText: 'Закрити',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Сьогодні',
		monthNames: ['Січень','Лютий','Березень','Квітень','Травень','Червень',
		'Липень','Серпень','Вересень','Жовтень','Листопад','Грудень'],
		monthNamesShort: ['Січ','Лют','Бер','Кві','Тра','Чер',
		'Лип','Сер','Вер','Жов','Лис','Гру'],
		dayNames: ['неділя','понеділок','вівторок','середа','четвер','п’ятниця','субота'],
		dayNamesShort: ['нед','пнд','вів','срд','чтв','птн','сбт'],
		dayNamesMin: ['Нд','Пн','Вт','Ср','Чт','Пт','Сб'],
		weekHeader: 'Тиж',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['uk']);
});

/* Vietnamese initialisation for the jQuery UI date picker plugin. */
/* Translated by Le Thanh Huy (lthanhhuy@cit.ctu.edu.vn). */
jQuery(function($){
	$.datepicker.regional['vi'] = {
		closeText: 'Đóng',
		prevText: '&#x3C;Trước',
		nextText: 'Tiếp&#x3E;',
		currentText: 'Hôm nay',
		monthNames: ['Tháng Một', 'Tháng Hai', 'Tháng Ba', 'Tháng Tư', 'Tháng Năm', 'Tháng Sáu',
		'Tháng Bảy', 'Tháng Tám', 'Tháng Chín', 'Tháng Mười', 'Tháng Mười Một', 'Tháng Mười Hai'],
		monthNamesShort: ['Tháng 1', 'Tháng 2', 'Tháng 3', 'Tháng 4', 'Tháng 5', 'Tháng 6',
		'Tháng 7', 'Tháng 8', 'Tháng 9', 'Tháng 10', 'Tháng 11', 'Tháng 12'],
		dayNames: ['Chủ Nhật', 'Thứ Hai', 'Thứ Ba', 'Thứ Tư', 'Thứ Năm', 'Thứ Sáu', 'Thứ Bảy'],
		dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
		dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
		weekHeader: 'Tu',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['vi']);
});

/* Chinese initialisation for the jQuery UI date picker plugin. */
/* Written by Cloudream (cloudream@gmail.com). */
jQuery(function($){
	$.datepicker.regional['zh-CN'] = {
		closeText: '关闭',
		prevText: '&#x3C;上月',
		nextText: '下月&#x3E;',
		currentText: '今天',
		monthNames: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		monthNamesShort: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		dayNames: ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
		dayNamesShort: ['周日','周一','周二','周三','周四','周五','周六'],
		dayNamesMin: ['日','一','二','三','四','五','六'],
		weekHeader: '周',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['zh-CN']);
});

/* Chinese initialisation for the jQuery UI date picker plugin. */
/* Written by SCCY (samuelcychan@gmail.com). */
jQuery(function($){
	$.datepicker.regional['zh-HK'] = {
		closeText: '關閉',
		prevText: '&#x3C;上月',
		nextText: '下月&#x3E;',
		currentText: '今天',
		monthNames: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		monthNamesShort: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		dayNames: ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
		dayNamesShort: ['周日','周一','周二','周三','周四','周五','周六'],
		dayNamesMin: ['日','一','二','三','四','五','六'],
		weekHeader: '周',
		dateFormat: 'dd-mm-yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['zh-HK']);
});

/* Chinese initialisation for the jQuery UI date picker plugin. */
/* Written by Ressol (ressol@gmail.com). */
jQuery(function($){
	$.datepicker.regional['zh-TW'] = {
		closeText: '關閉',
		prevText: '&#x3C;上月',
		nextText: '下月&#x3E;',
		currentText: '今天',
		monthNames: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		monthNamesShort: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		dayNames: ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
		dayNamesShort: ['周日','周一','周二','周三','周四','周五','周六'],
		dayNamesMin: ['日','一','二','三','四','五','六'],
		weekHeader: '周',
		dateFormat: 'yy/mm/dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['zh-TW']);
});


/* English/EN initialisation for the jQuery UI date picker plugin. */
/* Written by Stuart. */
jQuery(function($){
	$.datepicker.regional['en'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-GB']);
});
},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/lib/jquery.nouislider.min.js":[function(require,module,exports){
/*

$.Link (part of noUiSlider) - WTFPL */
(function(c){function m(a,c,d){if((a[c]||a[d])&&a[c]===a[d])throw Error("(Link) '"+c+"' can't match '"+d+"'.'");}function r(a){void 0===a&&(a={});if("object"!==typeof a)throw Error("(Format) 'format' option must be an object.");var h={};c(u).each(function(c,n){if(void 0===a[n])h[n]=A[c];else if(typeof a[n]===typeof A[c]){if("decimals"===n&&(0>a[n]||7<a[n]))throw Error("(Format) 'format.decimals' option must be between 0 and 7.");h[n]=a[n]}else throw Error("(Format) 'format."+n+"' must be a "+typeof A[c]+
".");});m(h,"mark","thousand");m(h,"prefix","negative");m(h,"prefix","negativeBefore");this.r=h}function k(a,h){"object"!==typeof a&&c.error("(Link) Initialize with an object.");return new k.prototype.p(a.target||function(){},a.method,a.format||{},h)}var u="decimals mark thousand prefix postfix encoder decoder negative negativeBefore to from".split(" "),A=[2,".","","","",function(a){return a},function(a){return a},"-","",function(a){return a},function(a){return a}];r.prototype.a=function(a){return this.r[a]};
r.prototype.L=function(a){function c(a){return a.split("").reverse().join("")}a=this.a("encoder")(a);var d=this.a("decimals"),n="",k="",m="",r="";0===parseFloat(a.toFixed(d))&&(a="0");0>a&&(n=this.a("negative"),k=this.a("negativeBefore"));a=Math.abs(a).toFixed(d).toString();a=a.split(".");this.a("thousand")?(m=c(a[0]).match(/.{1,3}/g),m=c(m.join(c(this.a("thousand"))))):m=a[0];this.a("mark")&&1<a.length&&(r=this.a("mark")+a[1]);return this.a("to")(k+this.a("prefix")+n+m+r+this.a("postfix"))};r.prototype.w=
function(a){function c(a){return a.replace(/[\-\/\\\^$*+?.()|\[\]{}]/g,"\\$&")}var d;if(null===a||void 0===a)return!1;a=this.a("from")(a);a=a.toString();d=a.replace(RegExp("^"+c(this.a("negativeBefore"))),"");a!==d?(a=d,d="-"):d="";a=a.replace(RegExp("^"+c(this.a("prefix"))),"");this.a("negative")&&(d="",a=a.replace(RegExp("^"+c(this.a("negative"))),"-"));a=a.replace(RegExp(c(this.a("postfix"))+"$"),"").replace(RegExp(c(this.a("thousand")),"g"),"").replace(this.a("mark"),".");a=this.a("decoder")(parseFloat(d+
a));return isNaN(a)?!1:a};k.prototype.K=function(a,h){this.method=h||"html";this.j=c(a.replace("-tooltip-","")||"<div/>")[0]};k.prototype.H=function(a){this.method="val";this.j=document.createElement("input");this.j.name=a;this.j.type="hidden"};k.prototype.G=function(a){function h(a,c){return[c?null:a,c?a:null]}var d=this;this.method="val";this.target=a.on("change",function(a){d.B.val(h(c(a.target).val(),d.t),{link:d,set:!0})})};k.prototype.p=function(a,h,d,k){this.g=d;this.update=!k;if("string"===
typeof a&&0===a.indexOf("-tooltip-"))this.K(a,h);else if("string"===typeof a&&0!==a.indexOf("-"))this.H(a);else if("function"===typeof a)this.target=!1,this.method=a;else{if(a instanceof c||c.zepto&&c.zepto.isZ(a)){if(!h){if(a.is("input, select, textarea")){this.G(a);return}h="html"}if("function"===typeof h||"string"===typeof h&&a[h]){this.method=h;this.target=a;return}}throw new RangeError("(Link) Invalid Link.");}};k.prototype.write=function(a,c,d,k){if(!this.update||!1!==k)if(this.u=a,this.F=a=
this.format(a),"function"===typeof this.method)this.method.call(this.target[0]||d[0],a,c,d);else this.target[this.method](a,c,d)};k.prototype.q=function(a){this.g=new r(c.extend({},a,this.g instanceof r?this.g.r:this.g))};k.prototype.J=function(a){this.B=a};k.prototype.I=function(a){this.t=a};k.prototype.format=function(a){return this.g.L(a)};k.prototype.A=function(a){return this.g.w(a)};k.prototype.p.prototype=k.prototype;c.Link=k})(window.jQuery||window.Zepto);/*

$.fn.noUiSlider - WTFPL - refreshless.com/nouislider/ */
(function(c){function m(e){return"number"===typeof e&&!isNaN(e)&&isFinite(e)}function r(e){return c.isArray(e)?e:[e]}function k(e,b){e.addClass(b);setTimeout(function(){e.removeClass(b)},300)}function u(e,b){return 100*b/(e[1]-e[0])}function A(e,b){if(b>=e.d.slice(-1)[0])return 100;for(var a=1,c,f,d;b>=e.d[a];)a++;c=e.d[a-1];f=e.d[a];d=e.c[a-1];c=[c,f];return d+u(c,0>c[0]?b+Math.abs(c[0]):b-c[0])/(100/(e.c[a]-d))}function a(e,b){if(100<=b)return e.d.slice(-1)[0];for(var a=1,c,f,d;b>=e.c[a];)a++;c=
e.d[a-1];f=e.d[a];d=e.c[a-1];c=[c,f];return 100/(e.c[a]-d)*(b-d)*(c[1]-c[0])/100+c[0]}function h(a,b){for(var c=1,g;(a.dir?100-b:b)>=a.c[c];)c++;if(a.m)return g=a.c[c-1],c=a.c[c],b-g>(c-g)/2?c:g;a.h[c-1]?(g=a.h[c-1],c=a.c[c-1]+Math.round((b-a.c[c-1])/g)*g):c=b;return c}function d(a,b){if(!m(b))throw Error("noUiSlider: 'step' is not numeric.");a.h[0]=b}function n(a,b){if("object"!==typeof b||c.isArray(b))throw Error("noUiSlider: 'range' is not an object.");if(void 0===b.min||void 0===b.max)throw Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
c.each(b,function(b,g){var d;"number"===typeof g&&(g=[g]);if(!c.isArray(g))throw Error("noUiSlider: 'range' contains invalid value.");d="min"===b?0:"max"===b?100:parseFloat(b);if(!m(d)||!m(g[0]))throw Error("noUiSlider: 'range' value isn't numeric.");a.c.push(d);a.d.push(g[0]);d?a.h.push(isNaN(g[1])?!1:g[1]):isNaN(g[1])||(a.h[0]=g[1])});c.each(a.h,function(b,c){if(!c)return!0;a.h[b]=u([a.d[b],a.d[b+1]],c)/(100/(a.c[b+1]-a.c[b]))})}function E(a,b){"number"===typeof b&&(b=[b]);if(!c.isArray(b)||!b.length||
2<b.length)throw Error("noUiSlider: 'start' option is incorrect.");a.b=b.length;a.start=b}function I(a,b){a.m=b;if("boolean"!==typeof b)throw Error("noUiSlider: 'snap' option must be a boolean.");}function J(a,b){if("lower"===b&&1===a.b)a.i=1;else if("upper"===b&&1===a.b)a.i=2;else if(!0===b&&2===a.b)a.i=3;else if(!1===b)a.i=0;else throw Error("noUiSlider: 'connect' option doesn't match handle count.");}function D(a,b){switch(b){case "horizontal":a.k=0;break;case "vertical":a.k=1;break;default:throw Error("noUiSlider: 'orientation' option is invalid.");
}}function K(a,b){if(2<a.c.length)throw Error("noUiSlider: 'margin' option is only supported on linear sliders.");a.margin=u(a.d,b);if(!m(b))throw Error("noUiSlider: 'margin' option must be numeric.");}function L(a,b){switch(b){case "ltr":a.dir=0;break;case "rtl":a.dir=1;a.i=[0,2,1,3][a.i];break;default:throw Error("noUiSlider: 'direction' option was not recognized.");}}function M(a,b){if("string"!==typeof b)throw Error("noUiSlider: 'behaviour' must be a string containing options.");var c=0<=b.indexOf("snap");
a.n={s:0<=b.indexOf("tap")||c,extend:0<=b.indexOf("extend"),v:0<=b.indexOf("drag"),fixed:0<=b.indexOf("fixed"),m:c}}function N(a,b,d){a.o=[b.lower,b.upper];a.g=b.format;c.each(a.o,function(a,e){if(!c.isArray(e))throw Error("noUiSlider: 'serialization."+(a?"upper":"lower")+"' must be an array.");c.each(e,function(){if(!(this instanceof c.Link))throw Error("noUiSlider: 'serialization."+(a?"upper":"lower")+"' can only contain Link instances.");this.I(a);this.J(d);this.q(b.format)})});a.dir&&1<a.b&&a.o.reverse()}
function O(a,b){var f={c:[],d:[],h:[!1],margin:0},g;g={step:{e:!1,f:d},start:{e:!0,f:E},connect:{e:!0,f:J},direction:{e:!0,f:L},range:{e:!0,f:n},snap:{e:!1,f:I},orientation:{e:!1,f:D},margin:{e:!1,f:K},behaviour:{e:!0,f:M},serialization:{e:!0,f:N}};a=c.extend({connect:!1,direction:"ltr",behaviour:"tap",orientation:"horizontal"},a);a.serialization=c.extend({lower:[],upper:[],format:{}},a.serialization);c.each(g,function(c,d){if(void 0===a[c]){if(d.e)throw Error("noUiSlider: '"+c+"' is required.");
return!0}d.f(f,a[c],b)});f.style=f.k?"top":"left";return f}function P(a,b){var d=c("<div><div/></div>").addClass(f[2]),g=["-lower","-upper"];a.dir&&g.reverse();d.children().addClass(f[3]+" "+f[3]+g[b]);return d}function Q(a,b){b.j&&(b=new c.Link({target:c(b.j).clone().appendTo(a),method:b.method,format:b.g},!0));return b}function R(a,b){var d,f=[];for(d=0;d<a.b;d++){var k=f,h=d,m=a.o[d],n=b[d].children(),r=a.g,s=void 0,v=[],s=new c.Link({},!0);s.q(r);v.push(s);for(s=0;s<m.length;s++)v.push(Q(n,m[s]));
k[h]=v}return f}function S(a,b,c){switch(a){case 1:b.addClass(f[7]);c[0].addClass(f[6]);break;case 3:c[1].addClass(f[6]);case 2:c[0].addClass(f[7]);case 0:b.addClass(f[6])}}function T(a,b){var c,d=[];for(c=0;c<a.b;c++)d.push(P(a,c).appendTo(b));return d}function U(a,b){b.addClass([f[0],f[8+a.dir],f[4+a.k]].join(" "));return c("<div/>").appendTo(b).addClass(f[1])}function V(d,b,m){function g(){return t[["width","height"][b.k]]()}function n(a){var b,c=[q.val()];for(b=0;b<a.length;b++)q.trigger(a[b],
c)}function u(d,p,e){var g=d[0]!==l[0][0]?1:0,H=x[0]+b.margin,k=x[1]-b.margin;e&&1<l.length&&(p=g?Math.max(p,H):Math.min(p,k));100>p&&(p=h(b,p));p=Math.max(Math.min(parseFloat(p.toFixed(7)),100),0);if(p===x[g])return 1===l.length?!1:p===H||p===k?0:!1;d.css(b.style,p+"%");d.is(":first-child")&&d.toggleClass(f[17],50<p);x[g]=p;b.dir&&(p=100-p);c(y[g]).each(function(){this.write(a(b,p),d.children(),q)});return!0}function B(a,b,c){c||k(q,f[14]);u(a,b,!1);n(["slide","set","change"])}function w(a,c,d,e){a=
a.replace(/\s/g,".nui ")+".nui";c.on(a,function(a){var c=q.attr("disabled");if(q.hasClass(f[14])||void 0!==c&&null!==c)return!1;a.preventDefault();var c=0===a.type.indexOf("touch"),p=0===a.type.indexOf("mouse"),F=0===a.type.indexOf("pointer"),g,k,l=a;0===a.type.indexOf("MSPointer")&&(F=!0);a.originalEvent&&(a=a.originalEvent);c&&(g=a.changedTouches[0].pageX,k=a.changedTouches[0].pageY);if(p||F)F||void 0!==window.pageXOffset||(window.pageXOffset=document.documentElement.scrollLeft,window.pageYOffset=
document.documentElement.scrollTop),g=a.clientX+window.pageXOffset,k=a.clientY+window.pageYOffset;l.C=[g,k];l.cursor=p;a=l;a.l=a.C[b.k];d(a,e)})}function C(a,c){var b=c.b||l,d,e=!1,e=100*(a.l-c.start)/g(),f=b[0][0]!==l[0][0]?1:0;var k=c.D;d=e+k[0];e+=k[1];1<b.length?(0>d&&(e+=Math.abs(d)),100<e&&(d-=e-100),d=[Math.max(Math.min(d,100),0),Math.max(Math.min(e,100),0)]):d=[d,e];e=u(b[0],d[f],1===b.length);1<b.length&&(e=u(b[1],d[f?0:1],!1)||e);e&&n(["slide"])}function s(a){c("."+f[15]).removeClass(f[15]);
a.cursor&&c("body").css("cursor","").off(".nui");G.off(".nui");q.removeClass(f[12]);n(["set","change"])}function v(a,b){1===b.b.length&&b.b[0].children().addClass(f[15]);a.stopPropagation();w(z.move,G,C,{start:a.l,b:b.b,D:[x[0],x[l.length-1]]});w(z.end,G,s,null);a.cursor&&(c("body").css("cursor",c(a.target).css("cursor")),1<l.length&&q.addClass(f[12]),c("body").on("selectstart.nui",!1))}function D(a){var d=a.l,e=0;a.stopPropagation();c.each(l,function(){e+=this.offset()[b.style]});e=d<e/2||1===l.length?
0:1;d-=t.offset()[b.style];d=100*d/g();B(l[e],d,b.n.m);b.n.m&&v(a,{b:[l[e]]})}function E(a){var c=(a=a.l<t.offset()[b.style])?0:100;a=a?0:l.length-1;B(l[a],c,!1)}var q=c(d),x=[-1,-1],t,y,l;if(q.hasClass(f[0]))throw Error("Slider was already initialized.");t=U(b,q);l=T(b,t);y=R(b,l);S(b.i,q,l);(function(a){var b;if(!a.fixed)for(b=0;b<l.length;b++)w(z.start,l[b].children(),v,{b:[l[b]]});a.s&&w(z.start,t,D,{b:l});a.extend&&(q.addClass(f[16]),a.s&&w(z.start,q,E,{b:l}));a.v&&(b=t.find("."+f[7]).addClass(f[10]),
a.fixed&&(b=b.add(t.children().not(b).children())),w(z.start,b,v,{b:l}))})(b.n);d.vSet=function(){var a=Array.prototype.slice.call(arguments,0),d,e,g,h,m,s,t=r(a[0]);"object"===typeof a[1]?(d=a[1].set,e=a[1].link,g=a[1].update,h=a[1].animate):!0===a[1]&&(d=!0);b.dir&&1<b.b&&t.reverse();h&&k(q,f[14]);a=1<l.length?3:1;1===t.length&&(a=1);for(m=0;m<a;m++)h=e||y[m%2][0],h=h.A(t[m%2]),!1!==h&&(h=A(b,h),b.dir&&(h=100-h),!0!==u(l[m%2],h,!0)&&c(y[m%2]).each(function(a){if(!a)return s=this.u,!0;this.write(s,
l[m%2].children(),q,g)}));!0===d&&n(["set"]);return this};d.vGet=function(){var a,c=[];for(a=0;a<b.b;a++)c[a]=y[a][0].F;return 1===c.length?c[0]:b.dir?c.reverse():c};d.destroy=function(){c.each(y,function(){c.each(this,function(){this.target&&this.target.off(".nui")})});c(this).off(".nui").removeClass(f.join(" ")).empty();return m};q.val(b.start)}function W(a){if(!this.length)throw Error("noUiSlider: Can't initialize slider on empty selection.");var b=O(a,this);return this.each(function(){V(this,
b,a)})}function X(a){return this.each(function(){var b=c(this).val(),d=this.destroy(),f=c.extend({},d,a);c(this).noUiSlider(f);d.start===f.start&&c(this).val(b)})}function B(){return this[0][arguments.length?"vSet":"vGet"].apply(this[0],arguments)}var G=c(document),C=c.fn.val,z=window.navigator.pointerEnabled?{start:"pointerdown",move:"pointermove",end:"pointerup"}:window.navigator.msPointerEnabled?{start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:{start:"mousedown touchstart",move:"mousemove touchmove",
end:"mouseup touchend"},f="noUi-target noUi-base noUi-origin noUi-handle noUi-horizontal noUi-vertical noUi-background noUi-connect noUi-ltr noUi-rtl noUi-dragable  noUi-state-drag  noUi-state-tap noUi-active noUi-extended noUi-stacking".split(" ");c.fn.val=function(){var a=arguments,b=c(this[0]);return arguments.length?this.each(function(){(c(this).hasClass(f[0])?B:C).apply(c(this),a)}):(b.hasClass(f[0])?B:C).call(b)};c.noUiSlider={Link:c.Link};c.fn.noUiSlider=function(a,b){return(b?X:W).call(this,
a)}})(window.jQuery||window.Zepto);

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/main.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

// loading hacks
var jQuery = require('jquery');
//loading jqueryÑ only load it if
//it is not loaded or if there is a jquery loaded but version is older than 2.x.x
if (window.$ == undefined || $.fn.jquery.split(' ')[0].split('.')[0] < 2) {
	window.jQuery = window.$ = Backbone.$ = jQuery;
}
require('jquery-ui/draggable');
require('bootstrap/dist/js/bootstrap');
require('./lib/jquery-ui-i18n')

var FilterView = require('./views/filters-view');

// see README.md for documentation on using widget.


function Widget() {
  this.initialize.apply(this, arguments);
}

_.extend(Widget.prototype, Backbone.Events, {

  initialize: function(options) {
    var self = this;
    options = _.defaults(options, { draggable: true });
    if (_.has(options, 'sync')) {
      Backbone.sync = options.sync;
    }
    this.view = new FilterView(options);

    // used to make all filters request faster.
    this._cachedAllFilters = null;

    // loaded deferred to allow for other code to wait for filters to finish loading.
    this.loaded = this.view._loaded.promise();

    // proxy all filter events through here
    this.listenTo(this.view, 'all', function() {
      this.trigger.apply(this, arguments);
    });
  },

  // put the filters into the DOM tree post-initialization
  setElement: function() {
    this.view.setElement(arguments);
  },

  // this will stash current filter state, so it can be restored on cancel.
  showFilters: function() {
    this.view.showFilters();
  },

  setStash: function() {
    this.view.setStash();
  },

  // return models of all filters, even unselected ones..
  getAllFilters: function() {
    var self = this;
    return this.loaded.then(function(){
      // cache, because won't change. avoids calling serialize everytime.
      if(!this._cachedAllFilters){
        this._cachedAllFilters = self.view.serialize({includeUnselected: true, wholeModel: true});
      }
      return this._cachedAllFilters;
    });
  },

  // return models of serialized filter state, has entire models instead of just ids.
  serializeToModels: function() {
    return this.view.serialize({wholeModel: true});
  },

  formatDate: function(date){
	  return this.view.formatDate(date);  
  },
  
  // return json blob of serialized filter state, ids only.
  serialize: function() {
    return this.view.serialize({});
  },

  // restores filter state given a json blob, ids only.
  deserialize: function(stateBlob, options) {
    return this.view.deserialize(stateBlob, options);
  },

  // reset filters to empty state
  reset: function(options) {
    this.view.resetFilters();
    if (!options || !options.silent) {
      this.view.applyFilters();
    }
  },
  /**
   * searches the settings array of models for the ones which hold the min/max values instructed to and, if found,
   * writes them in filtersOut.date.{start}{end}
   *
   * use it as an utility function (it does not reference 'this', so
   * it is safe to use it at any point in the lifecycle of the widget
   */
  extractDates: function(settings, filtersOut, minName, maxName) {
	  filtersOut = filtersOut || {};  
	  if(_.isUndefined(filtersOut.date) || _.isEmpty(filtersOut.date)){
		  filtersOut.date = filtersOut.date || {
			  start: '',
			  end: ''
		  };

		  var defaultMinDate = settings.get(minName);    
		  if (defaultMinDate !== undefined && defaultMinDate !== '') {
			  filtersOut.date.start = defaultMinDate;
		  }
		  var defaultMaxDate = settings.get(maxName);
		  if (defaultMaxDate !== undefined && defaultMaxDate !== '') {
			  filtersOut.date.end = defaultMaxDate;
		  }
	  }    
  }

});

module.exports = Widget;
},{"./lib/jquery-ui-i18n":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/lib/jquery-ui-i18n.js","./views/filters-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/filters-view.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/bootstrap/dist/js/bootstrap.js","jquery":"jquery","jquery-ui/draggable":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/draggable.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/base-filter-model.js":[function(require,module,exports){
var Backbone = require('backbone');

  // Parent model for filters.
module.exports = Backbone.Model.extend({
  defaults: {
    name: 'Filter Name',
    method: 'GET',
    totalCount: 0,
    activeCount: 0,
    _loaded: false,
    empty: false
  },

  initialize:function(options) {
    this.set('name', options.name);
    this.set('group', options.group || options.id);
    this.set('method', options.method);
    this.set('columns', options.columns);
    this.set('empty', options.empty || false);
    this.url =  options.url || options.endpoint;
  }

});

},{"backbone":"backbone"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/general-settings.js":[function(require,module,exports){
module.exports=require("/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/settings.js")
},{"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/settings.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/src/models/settings.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/generic-filter-model.js":[function(require,module,exports){
var _ = require('underscore');

var BaseFilterModel = require('../models/base-filter-model');
var TreeNodeModel = require('../tree/tree-node-model');


module.exports = BaseFilterModel.extend({

  initialize:function(options) {
    BaseFilterModel.prototype.initialize.apply(this, [options]);
    this.set('modelType', 'TREE');
    this.getTree(); // starts getTree calls
  },

  // load tree if needed, else return what we already have..
  getTree: function() {
    var self = this;
    var loaded = this.get('_loaded');

    if (!loaded) {
      self.set('_loaded', this._createTree().then(function() {

        // trickle up numSelected.
    	  if(self.get('tree')!= undefined){
        self.get('tree').on('change:numSelected', function(model, value) {
          self.set('numSelected', value);
          self.set('numPossible', self.get('tree').get('numPossible'));
        });
    	  }
        return self.get('tree');
      }));
      
    }

    return this.get('_loaded');
  },

  getNumSelected: function(){
    var numSelected = this.get('numSelected');
    // if none selected, or all selected, treat the same.
    if (!numSelected || this.get('numSelected') === this.get('numPossible')) {
      return 0;
    } else {
      return numSelected;
    }
  },

  serialize: function(options) {
    var tree = this.get('tree');
    if (!tree) {
      //console.warn('no tree found', this.attributes);
      return {}; //no tree, nothing to serialize.
    } else {
      var tmpAry = tree.serialize(options);
      return tmpAry;
    }
  },

  deserialize: function(listOfSelected) {
    var self = this;
    var tree = this.get('tree');
    if (listOfSelected) {
      if (!tree) {
        console.warn('deserialize no tree found', self);
        return false; //no tree, nothing to serialize.
      } else {
        tree.deserialize(listOfSelected);
      }
    }
  },

  reset: function() {
    var tree = this.get('tree');
    if (tree) {
      // TODO: add a third type for semi-filled
      // force trigger, because otherwise nodes that are 'half-filled' but false won't refresh.
      tree.set('selected', true);
      tree.set('selected', false);

    }
  },

  _createTree: function() {
    if (!this.url) {
      this.url = this.get('endpoint');
    }

    return this.fetch({
      type: this.get('method'),
      data:'{}'
    })
    .fail(function(jqXHR, textStatus, errorThrown) {
      console.error('failed to get filter ', jqXHR, textStatus, errorThrown);
    });
  },

  parse: function(data) {
    var self = this;    

    //if it's an obj, jam it into an array first, helps solve inconsistancy in API format.
    if (!_.isArray(data)) {
      data = [data];
    }

    if (_.isArray(data) && data.length > 0) {
      var rootNodeObj = null;
      // Builds tree of views from returned data
      // If data is a single element, just make it the root..
      
      /* TODO-CONSTANTIN: temporary comment until I finish learning Filters frontend
      console.log("iterating " + data.length + " elems...");
      _.each(data, function(elem) {
    	  console.log("\tname = " + elem.name + ", id = " + elem.id);
      });
      */
      if (data.length === 1) {
    	if(data[0].filterId && !data[0].name) {
          data[0].name =  data[0].filterId;
        }
        if(data[0].values){
          data[0].children =  data[0].values;
        }

        data[0].isSelectable = false;
        
        //data[0].filterName = data[0].displayName;

        rootNodeObj = data[0];

      } else {
        rootNodeObj = {
          id: -1,
          code: '-1',
          name: self.get('name'),
          children: data,
          selected: undefined,
          expanded: false,
          isSelectable: false,
          createUnkowns: true/*,
          filterName: self.get('displayName')*/
        };
      }

      var treeModel = new TreeNodeModel(rootNodeObj);
      self.set('tree', treeModel);
    }

    return;
  }

});


},{"../models/base-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/base-filter-model.js","../tree/tree-node-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-model.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/org-role-filter-model.js":[function(require,module,exports){
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var TreeNodeModel = require('../tree/tree-node-model');


module.exports = GenericFilterModel.extend({


  initialize:function(options) {
    this.loaded = $.Deferred();
    this._createTree(options.data);
    GenericFilterModel.prototype.initialize.apply(this, [options]);
  },

  //org doesn't have async part, but still use deferred, so behaves same as generic filter model
  getTree: function() {
    return this.loaded;
  },

  _createTree:function(data) {
    var self = this;
    var rootNodeObj = {};
    if (data.length === 1) {
      rootNodeObj = data[0];
    } else {
      rootNodeObj = {
        id: -1,
        code: '-1',
        name: self.get('displayName'),
        filterId: self.get('filterId'),
        children: data,
        selected: undefined,
        expanded: false,
        isSelectable: false,
        createUnkowns: false
      };
    }

    var treeModel = new TreeNodeModel(rootNodeObj);
    this.set('tree', treeModel);

    // trickle up numSelected.
    self.get('tree').on('change:numSelected', function(model, value) {
      self.set('numSelected', value);
      self.set('numPossible', self.get('tree').get('numPossible'));
    });

    this.loaded.resolve(treeModel);
  }

});


},{"../models/generic-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/generic-filter-model.js","../tree/tree-node-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-model.js","jquery":"jquery"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-filter-model.js":[function(require,module,exports){
var $ = require('jquery');
var _ = require('underscore');
var BaseFilterModel = require('../models/base-filter-model');


module.exports = BaseFilterModel.extend({


  defaults: {
    selectedStart: null,
    selectedEnd: null,
    // range is provided by api, but will fallback to this if not provided, or set to -1
    startYear: '',
    endYear: '',
    modelType: 'DATE-RANGE-VALUES'
  },
  
  sync: function () {
	  /**
	   * hackish: the data coming off the /dates endpoint should be ignored at all moments, because
	   * 1. for tabs/saiku, it should always be empty
	   * 2. for gis/dashboards, it is coming off the /setting endpoint
	   * 
	   * All the other years-filter-model should by spec be always empty at this point. In case this would cease to be true in the future,
	   * just filter by "name"
	   */ 
	  	
	  //console.error('SYNCING YEARS MODEL: ' + this.get('name'));
	  return $.when(true);
  },

  initialize: function(options) {
    BaseFilterModel.prototype.initialize.apply(this, [options]);
    this.url = options.endpoint;
    this.set('_loaded', $.Deferred());
  },

  parse: function(data) {
	  console.log('years-filter-model.parse: data = ' + JSON.stringify(data));
    if (!data.startYear || data.startYear === -1) {
      data.startYear = this.defaults.startYear;
    } else {
      data.startYear = data.startYear + '-01-01';
    }
    if (!data.endYear || data.endYear === -1) {
      data.endYear = this.defaults.endYear;
    } else {
      data.endYear = data.endYear + '-12-31';
    }

    if (!data.selectedStart) {
    	// good ole' partial copy-paste off postprocess()
    	data.selectedStart = data.startYear;
    	data.selectedEnd = data.endYear;
    }
    this.get('_loaded').resolve();
    return data;
  },

  serialize: function(options) {
	// AMP-21041: Enabled filtering by start OR end date.
    if (this.get('selectedStart') || this.get('selectedEnd')) {
    	  var key = this.get('id');    	   	  
    	  var obj = {};
    	  if(options.wholeModel === true){
    		  obj[key] = {			
    				  modelType : this.get('modelType'),    		  
    				  start: this.get('selectedStart'),
    				  end: this.get('selectedEnd')			  
    			 };
    	  } else {
    		  obj[key] = {				  
    				  start: this.get('selectedStart'),
    				  end: this.get('selectedEnd')			  
    			 }; 
    	  }
    	  return obj;
    } else {
      return null;
    }
  },

  /**
   * postprocess model after having fetched data from the server
   */
  postprocess: function() {
	  // only set if not set by deserialize
	  if (!this.get('selectedStart')) {
	  	  this.set('selectedStart', this.get('startYear'));
	  }
	  // AMP-21041: Enabled filtering by start OR end date.
      if (!this.get('selectedEnd')) {                  
          this.set('selectedEnd', this.get('endYear'));
      }
  },
  
  deserialize: function(obj) {
	var key = this.get('id');
	if (obj && obj[key]) {
	  this.set('selectedStart', this._dateConvert(obj[key].start));
	  this.set('selectedEnd', this._dateConvert(obj[key].end));
      this.postprocess();
	}else{
		this.set('selectedStart', this.get('startYear'));
	    this.set('selectedEnd', this.get('endYear'));
	}
  },

  reset: function() {
    this.set('selectedStart', this.get('startYear'));
    this.set('selectedEnd', this.get('endYear'));
  },

  // converts: 03/01/1961 ==> 1961-01-01 IF NEEDED.
  // DOES NOT CONVERT from the "-" format to "/" format anymore
  // 
  // amp expects with '-' and jQuery wants with '/'
  _dateConvert: function(input){
	  console.log('asked to convert input: ' + input);
    var output = null;
    if (input) {
      if (input.indexOf('/')>-1){
        input = input.split('/');
        output = input[2] + '-' + input[1] + '-' + input[0];
      } else {
    	  output = input;
      }
      /* else if(input.indexOf('-')>-1){
      }
        input = input.split('-');
        output = input[2] + '/' + input[1] + '/' + input[0];
      }*/
    }
    return output;
  }

});

},{"../models/base-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/base-filter-model.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-only-filter-model.js":[function(require,module,exports){
var $ = require('jquery');
var _ = require('underscore');
var BaseFilterModel = require('../models/base-filter-model');

module.exports = BaseFilterModel.extend({

	defaults : {
		selectedYear : undefined,
		defaultYear : undefined,
		modelType : 'YEAR-SINGLE-VALUE'
	},

	initialize : function(options) {
		BaseFilterModel.prototype.initialize.apply(this, [ options ]);
		this.url = options.endpoint;
		this.set('_loaded', $.Deferred());
	},

	parse : function(data) {
		if (data && data.value && data.value.options) {
			data.defaultYear = _.find(data.value.options, function(item) {
				return item.id === data.value.defaultId;
			}).value;
		}
		// console.log(data);
		this.get('_loaded').resolve();
		return data;
	},

	serialize : function(options) {	
		if (this.get('selectedYear')) {
			var key = this.get('id');
			var obj = {};
			if(options.wholeModel === true){
				obj[key] = {
						year : this.get('selectedYear'),
						modelType : this.get('modelType'),
						displayName : this.get('name')
					};
			} else {
				obj[key] = this.get('selectedYear');	
			}	
			return obj;
		} else {
			return null;
		}
	},

	deserialize : function(obj) {
		var key = this.get('id');
		if (obj && obj[key]) {
			this.set('selectedYear', obj[key]);			
		} else {
			this.reset();
		}
	},

	reset : function() {
		this.set('selectedYear', '');
		this.set('displayName', '')
	},

});

},{"../models/base-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/base-filter-model.js","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-model.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var TreeNodeModel; // declare here to help with ref loop of collection and model
var TreeNodeCollection = Backbone.Collection.extend({  model:TreeNodeModel });

//TODO: propagation bug if mid level node is half filled and you 'deselect all' it won't propogate to children.

TreeNodeModel = Backbone.Model.extend({
  defaults:{
    selected: undefined,  // default is selected. change to string / ternary, for off, semi, and on
    expanded: true,
    visible: true,
    numSelected: 0,
    numPossible: 0,
    children: null,     // type TreeNodeCollection
    isSelectable: false  // is this node itself selectable (ie. should it have an 'unkown' child)
  },
  ignoreList: ['donor-group', 'donor-type', 'implementing-agency', 'beneficiary-agency', 'executing-agency', 'responsible-organization', 'component-funding-organization', 'component-second-responsible-organization'],//list of filterIds to ignore when serializing
  ignoreOrgGroupList: ['implementing-agency','beneficiary-agency', 'executing-agency', 'responsible-organization', 'component-funding-organization', 'component-second-responsible-organization'], // for this filterIds we do not deserialize org groups to avoid issues with same ids
  initialize:function(obj) {
    var self = this;
    var childrenCollection = new TreeNodeCollection();
    this.set('children', childrenCollection);
    //iterate over children
    if (Array.isArray(obj.children)) {
      _.each(obj.children, function(child) {
        var newChild = new TreeNodeModel(child);
        childrenCollection.add(newChild);
      });
    }

    // if we have children, then add self as a leaf node, 'unkown'
    if (!childrenCollection.isEmpty() &&  this.get('isSelectable')) {
      var unkownNode = new TreeNodeModel(self.toJSON());
      unkownNode.set('name', 'unkown: ' + this.get('name'));
      childrenCollection.add(unkownNode);
    }

    this._addListenersToChildren();

    this.on('change:selected', self._onSelectChange);

    this._updateCount();
  },


// merge based on filterId as we serialize....
// options.wholeModel returns whole Models instead of just ids
// options.includeUnselected returns full tree, even if nodes are not selected.
// Code explicitly ignores donor-group,donor-type and the rest of the organizations.
//   they only have FilterIds for deserialize for backwards compatibility.
// TODO: consider pulling out options.includeUnselected into its own function getAllFilters()
serialize: function(options) {
	 var tmpSerialized = {};
	 var children = this.get('children');
     if (options.includeUnselected) {
    	if (this.get('filterId') && !this._isInIgnoreList(this.get('filterId'))) {
    			tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    	} else{
    		tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
    	}
    	this._serializeChildren(tmpSerialized, children, options);
     } else {
       // AMP-28683: Before checking if it has children, check if the "parent" is selected too.
       if (this.get('selected')) {
         if (this.get('filterId') && !this._isInIgnoreList(this.get('filterId')) ) {
           tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
         } else {
           tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
         }
       }
    	if (children.length > 0) {
            //Until we refactor filters in 3.x we will serialize even if the whole tree is selected
            this._serializeChildren(tmpSerialized, children, options);
      } else {
    	  //no children so just return self.
    	  if (this.get('selected')) {
    		  if (this.get('filterId') && !this._isInIgnoreList(this.get('filterId')) ) {
    			  	tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    		  } else {
    			  tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
    		  }
    	  }
      }
   }
   this._mergeUnassigned(tmpSerialized);
   return tmpSerialized;
},
_isInIgnoreList:  function(filterId){
 return this.ignoreList.indexOf(filterId) > -1;
},
_serializeChildren: function(tmpSerialized, children, options){
    children.each(function(child) {
      var serializedChild = child.serialize(options);
      _.each(serializedChild, function(v,k){
        if(v){
          //merge if key exists
          if (tmpSerialized[k]) {
            tmpSerialized[k] = tmpSerialized[k].concat(v);
          } else {
            tmpSerialized[k] = v;
          }
        }
      });
    });
  },

  _mergeUnassigned: function(tmpSerialized){
    // if current node has a filterId put all 'unassigned' elements under this.
    if(this.get('filterId')){
      var filterId = this.get('filterId');
      if(tmpSerialized[filterId] && tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized[filterId].concat(tmpSerialized.unassigned);
        delete tmpSerialized.unassigned;
      } else if (tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized.unassigned;
        delete tmpSerialized.unassigned;
      }
    }
  },

  deserialize: function(blob) {
    var self = this;
    var children = this.get('children');
    if (children.length > 0) {
      children.each(function(child) {
        if(!child.get('filterId') && self.get('filterId')){
          child.set('filterId', self.get('filterId'));
        }
        child.deserialize(blob);
      });
    }

    if(blob[this.get('filterId')]){    		
        if (this.isInFilters(blob, this.id)){    		  
          this.set('selected', true, {propagation: true});
        } else if (children.length === 0) {
          this.set('selected', false, {propagation: true});
        }
    }
  },

  isInFilters: function(blob, id){	 
	  var result = false;
	  if (!(this.ignoreOrgGroupList.indexOf(this.get('filterId')) > -1 &&  this.get('isOrgGroup') == true)){			  
		 result = (blob[this.get('filterId')]).indexOf(this.id) > -1
	  }	  
	  return result;
  },
  
  _onSelectChange:function(model, argument, options) {
    var self = this;
    var children = this.get('children');

    if (this.get('selected')) {
      this.set('numSelected', this.get('numPossible'));
    } else {
      this.set('numSelected', 0);
    }

    if (!children.isEmpty()) {
      self._updateChildNodes(options.propagation);
    }

    if (options.propagation) {
      self.trigger('updateCount');
    }
  },


  _addListenersToChildren:function() {
    var self = this;
    var children = this.get('children');
    children.each(function(child) {
      child.on('change:visible', function() {
        // If no children are visible, then hide self.
        if (!children.findWhere({visible: true})) {
          self.set({visible: false});
        } else {
          self.set({visible: true});
        }
      });
      child.on('updateCount', function() {
        self._updateCount();
        self.trigger('updateCount');
      });
    });
  },

  _updateCount:function() {
    var children = this.get('children');
    var countTotal = {
      selected: 0,
      possible:0
    };

    if (!children.isEmpty()) {
      children.each(function(child) {
        countTotal.selected += child.get('numSelected');
        countTotal.possible += child.get('numPossible');
      });
    } else {
      countTotal = {
        selected: (this.get('selected') ? 1 : 0),
        possible: 1
      };
    }

    this.set('numSelected', countTotal.selected);
    this.set('numPossible', countTotal.possible);
  },

  _updateChildNodes:function(propagation) {
    var self = this;
    var children = this.get('children');

    if (!children.isEmpty()) {
      children.each(function(child) {
        child.set('selected', self.get('selected'), {propagation: propagation});
      });
    }
  },

  filterText: function(txt) {
    var children = this.get('children');

    if (!children.isEmpty()) {
      // if the node itself matches, turn it on, even if no children are visible.
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      }

      // FYI: putting inside an else above keeps children visible if parent matches.
      children.each(function(child) {
        child.filterText(txt);
      });

    } else {
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      } else {
        this.set('visible', false);
      }
    }
  }

});


module.exports = TreeNodeModel;

},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-view.js":[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var $ = require('jquery');

var Template = "<div class=\"node small\">\n  <div class=\"selectable\"></div>\n  <div class=\"toggle-nav\">\n    <% if(name.length > 63){ %>\n      <span title=\"<%= name %>\"><%= name.substring(0,60) %>...</span>\n    <% } else { %>\n      <%= name %>\n    <% } %>\n\n\n    <span class=\"count\">(<%= numSelected %> / <%= numPossible %>)</span>\n    <span class=\"expanded\">+</span>\n  </div>\n\n  <% /*TODO: fix hardcode of 'unkown' */\n  if (obj.name && obj.name.indexOf(\"unkown\")>-1) { %>\n    &nbsp;<a href=\"#\"\n      data-toggle=\"popover\"\n      data-container=\"body\"\n      data-placement=\"right\"\n      data-trigger=\"click\"\n      data-content=\"projects that aren't tagged to a specific child.\">\n      <span class=\"glyphicon glyphicon-info-sign\"></span>\n    </a>\n  <%}%>\n</div>\n";


var TreeNodeView = Backbone.View.extend({

  tagName: 'li',
  className: 'parent_li',

  //TODO: debug after usability testing, currently setting in addUIListeners
  // won't work on second use of widget.
  // events: {
  //   'click .selectable': 'select',
  //   'click  .toggle-nav': 'clickName'
  // },

  template: _.template(Template),
  isRoot: false,
  initialize:function(options) {
	 if(!_.isUndefined(options) && !_.isUndefined(options.isRoot)){
		 this.isRoot = options.isRoot;
	 }
	  
  },


  render:function(model) {
    this.model = model;
    if (model) {
      this.$el.html(this.template(model.toJSON()));
      this.renderChildren();
    }

    return this;
  },

  renderChildren:function() {
    var ul = $('<ul>');
    this.$el.append(ul);

    var children = this.model.get('children');
    if (!children.isEmpty()) {
      children.each(function(child) {
        var tmpView = new TreeNodeView();
        ul.append(tmpView.render(child).$el);
      });
    } else {
      this.$('.expanded').remove();
      this.$('> .node > .toggle-nav > .count').text('');
    }

    this._addModelListeners();
    this._addUIListeners();

    this._updateSelection();
    this._updateExpanded(ul);
  },

  _addModelListeners:function() {
    var self = this;

    //Add model listeneres
    this.model.on('change:selected', function() {
      self._updateSelection();
    });

    this.model.on('change:expanded', function() {
      self._updateExpanded();
    });

    this.model.on('change:numSelected', function() {
      self._updateCountUI();
    });

    this.model.on('change:visible', function() {
      self._updateVisibility();
    });
  },

  _addUIListeners:function() {
    var self = this;
    this.$('> .node > .selectable').on('click', function() {
      self.clickBox();

    });
    this.$('> .node > .toggle-nav').on('click', function() {
      self.clickName();
    });
  },

  _updateSelection:function() {
    this._updateCheckboxFill();
  },

  _updateCountUI:function() {
    if (!this.model.get('children').isEmpty()) {
      this.$('> .node > .toggle-nav > .count').text(
        '(' + this.model.get('numSelected') + ' / ' + this.model.get('numPossible') + ')');
      this._updateCheckboxFill();
    }
  },

  _updateVisibility: function() {
    if (this.model.get('visible')) {
      this.$el.show();
    } else {
      this.$el.hide();
    }
  },


  // For updating non-leaf nodes
  _updateCheckboxFill:function() {
    if (!this.model.get('children').isEmpty()) {
      if (this.model.get('numSelected') > 0) {
        if (this.model.get('numSelected') < this.model.get('numPossible')) {
          this.$('> .node > .selectable').addClass('half-fill');
          this.$('> .node > .selectable').removeClass('selected');
        } else {
          this.$('> .node > .selectable').removeClass('half-fill');
          this.$('> .node > .selectable').addClass('selected');
        }
      } else if (this.model.get('numSelected') === 0) {
        this.$('> .node > .selectable').removeClass('half-fill');
        this.$('> .node > .selectable').removeClass('selected');
      }
    } else { // else leaf node
      if (this.model.get('selected')) {
        this.$('> .node > .selectable').addClass('selected');
      } else {
        this.$('> .node > .selectable').removeClass('selected');
      }
    }
  },

  _updateExpanded:function(ul) {
    var iElement = this.$('> .node > .toggle-nav > .expanded');
    if (this.model.get('expanded')) {
      this.expand();
      iElement.text('-');
      iElement.addClass('open').removeClass('closed');
    } else {
      this.collapse();

      // to run on first time...need to use ul, since el is not on DOM yet
      if (ul) {
        ul.find('> li').hide();
      }

      iElement.text('+');
      iElement.addClass('closed').removeClass('open');
    }
  },


  clickBox:function() {
	  if(this.isRoot){
		  this.model.set('selected', !this.model.get('selected'));		  
	  }else{
		  this.model.set('selected', !this.model.get('selected'), {propagation: true});  
	  }    
  },


  clickName:function() {
    // if we have children expand
    if (!this.model.get('children').isEmpty()) {
      this.model.set('expanded', !this.model.get('expanded'));
    } else {
      // leaf node, so pretend the clicked on the box
      this.clickBox();
    }
  },


  collapse:function() {
    var children = this.$el.find(' > ul > li');
    children.hide('fast');

  },

  expand:function() {
    var children = this.$el.find(' > ul > li');
    children.show('fast');
  }

});

module.exports = TreeNodeView;

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/utils/date-utils.js":[function(require,module,exports){
var _ = require('underscore');

var extractDates = function(settings, filtersOut, minName, maxName) {
	filtersOut = filtersOut || {};  
	if(_.isUndefined(filtersOut.date) || _.isEmpty(filtersOut.date)){
		  filtersOut.date = filtersOut.date || {
			  start: '',
			  end: ''
		  };

		  var defaultMinDate = settings.get(minName);    
		  if (defaultMinDate !== undefined && defaultMinDate !== '') {
			  filtersOut.date.start = defaultMinDate;
		  }
		  var defaultMaxDate = settings.get(maxName);
		  if (defaultMaxDate !== undefined && defaultMaxDate !== '') {
			  filtersOut.date.end = defaultMaxDate;
		  }
	  }  
  }

module.exports = {
		extractDates: extractDates
}

},{"underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/base-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var $ = require('jquery');

var Backbone = require('backbone');
var TitleTemplate = "<li>\n\t<a href=\"#\">\n\t\t<span data-i18n=\"amp.gis:pane-subfilters-<%= name.replace(/ /g,'') %>\">\n\t\t\t<%= name %>\n\t\t</span>   \n\t\t<span class='filter-count small pull-right'></span>\n\t</a>\n</li>";
var ContentTemplate = "<%\n  // this renders the \"big\" filter list (the tabs)\n%>\n<div class=\"panel-heading\">\n  <a type=\"button\" class=\"close cancel\"  aria-hidden=\"true\">&times;</a>\n  <h3 data-i18n=\"amp.gis:title-filters\" class=\"panel-title\">Filters</h3>\n</div>\n<div class=\"panel-body filter-body\">\n\n  <ul class=\"nav nav-tabs filter-titles\" role=\"tablist\">\n  </ul>\n\n  <div class=\"tab-content filter-options\">\n    <img src=\"img_2/loading-icon.gif\" />\n  </div>\n</div>\n<div class=\"panel-footer\">\n  &nbsp;\n  <div class=\"pull-right\" style=\"display: inline-block; margin-bottom: 5px;\">\n    <button type=\"button\" class=\"btn btn-sm btn-danger reset\"  data-i18n=\"amp.gis:button-reset\"  title=\"Turn off all filters.\">Reset</button>\n    <button type=\"button\" class=\"btn btn-sm btn-warning cancel\"  data-i18n=\"amp.gis:button-cancel\"  title=\"Revert filters to state when opened.\">Cancel</button>\n    <button type=\"button\" class=\"btn btn-sm btn-success apply\"  data-i18n=\"amp.gis:button-apply\" >Apply</button>\n  </div>\n</div>\n";

// Parent base view for filters.
module.exports = Backbone.View.extend({

  className: 'filter-type',

  titleTemplate: _.template(TitleTemplate),
  contentTemplate: _.template(ContentTemplate),

  initialize:function(options) {
    this.app = options.app;
  },

  renderFilters: function() {

  },

  renderTitle: function() {	  
    var self = this;
    this.titleEl = this.titleTemplate(this.model.toJSON());
    this.$titleEl = $(this.titleEl);
    this.$titleEl.on('click', function(evt) {
      $(this).siblings().removeClass('active');
      $(this).addClass('active');
      self.$el.html('');
      self.renderFilters();
      return false;
    });

    return this;
  }

});

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/filters-view.js":[function(require,module,exports){
/**
 * this is the view which renders the big Filter contents (the tabs)
 */

var $ = require('jquery');
var _ = require('underscore');
var Backbone = require('backbone');

var Translator = require('amp-translate');

var TopLevelFilterView = require('../views/top-level-filter-view');
var AllFilterCollection = require('../collections/all-filters-collection');


var Template = "<%\n  // this renders the \"big\" filter list (the tabs)\n%>\n<div class=\"panel-heading\">\n  <a type=\"button\" class=\"close cancel\"  aria-hidden=\"true\">&times;</a>\n  <h3 data-i18n=\"amp.gis:title-filters\" class=\"panel-title\">Filters</h3>\n</div>\n<div class=\"panel-body filter-body\">\n\n  <ul class=\"nav nav-tabs filter-titles\" role=\"tablist\">\n  </ul>\n\n  <div class=\"tab-content filter-options\">\n    <img src=\"img_2/loading-icon.gif\" />\n  </div>\n</div>\n<div class=\"panel-footer\">\n  &nbsp;\n  <div class=\"pull-right\" style=\"display: inline-block; margin-bottom: 5px;\">\n    <button type=\"button\" class=\"btn btn-sm btn-danger reset\"  data-i18n=\"amp.gis:button-reset\"  title=\"Turn off all filters.\">Reset</button>\n    <button type=\"button\" class=\"btn btn-sm btn-warning cancel\"  data-i18n=\"amp.gis:button-cancel\"  title=\"Revert filters to state when opened.\">Cancel</button>\n    <button type=\"button\" class=\"btn btn-sm btn-success apply\"  data-i18n=\"amp.gis:button-apply\" >Apply</button>\n  </div>\n</div>\n";
var TitleTemplate = "<%\n// renders the title of a tab \n%>\n<li class=\"\"><a data-i18n=\"amp.gis:pane-filters-<%= name.replace(/ /g,'') %>\" href=\"#filter-pane-<%= name.replace(/ /g,'') %>\" role=\"tab\" data-toggle=\"tab\"><%= name %></a></li>\n";
var filtersViewLog = require("../../../../../reamp/tools/log")('amp:filters:top-level:view');

var GeneralSettings = require('../models/general-settings');

var DateUtils = require('../utils/date-utils');

var filterInstancesNames = {donors: 'Funding Organizations', sectors : 'Sectors', programs: 'Programs', 
	  activity: 'Activity', allAgencies: 'All Agencies', financials: 'Financial',
		  locations: 'Location', others: 'Other'};


module.exports = Backbone.View.extend({
  id: 'tool-filters',
  name: 'Filters',
  apiURL: '/rest/filters',

  events: {
    'click .apply': 'applyFilters',
    'click .cancel': 'cancel',
    'click .reset': 'resetFilters'
  },
  PARAMS_DATE_FORMAT:'yy-mm-dd', //backend expects filters to be submitted in this format
  initialize:function(options) {
    var self = this;
    this.draggable = options.draggable;
    this.caller = options.caller;
    this.settings = new GeneralSettings();
    this.settings.fetch();
    this.filterViewsInstances = {};
    this.template = _.template(Template);
    this.titleTemplate = _.template(TitleTemplate);    
    this.dateFormatMappings = [];
    this.dateFormatMappings.push({ampformat: 'dd/MMM/yyyy', datepickerformat:'dd/M/yy'});
    this.dateFormatMappings.push({ampformat: 'MMM/dd/yyyy', datepickerformat:'M/dd/yy'});
    this.dateFormatMappings.push({ampformat: 'dd/MM/yyyy', datepickerformat:'dd/mm/yy'});
    this.dateFormatMappings.push({ampformat: 'MM/dd/yyyy', datepickerformat:'mm/dd/yy'});
    
    if(options.translator === undefined) {
      this.createTranslator();
    } else {
      this.translator = options.translator;
    }

    this.firstRender = true;
    this._createTopLevelFilterViews();
    this.allFilters = new AllFilterCollection([],options);
    this._loaded =  this.allFilters._loaded;
    this._getFilterList().then(function() {    	
        self.allFilters.each(function(model) {        	
      	  if(model.get('empty')){      		     		  
      		for (key in filterInstancesNames) {
    			if (filterInstancesNames.hasOwnProperty(key)) {
    				if(filterInstancesNames[key] == model.get('group')){
    					// remove tab if there is no data for the tab
    					delete filterInstancesNames[key];
    					delete self.filterViewsInstances[key];
    				}    				
    				
    			}
    		}      		
      	  }else{
      		self._createFilterViews(model);  
      	  }
      	  
      });        
   
      return this;
    });

  },

  _createTopLevelFilterViews: function() {    
    		for (key in filterInstancesNames) {
    			if (filterInstancesNames.hasOwnProperty(key)) {
    				
    				this.filterViewsInstances[key] = new TopLevelFilterView({name:filterInstancesNames[key], translator: this.translator, translate: this.translate, filterView: this});
    			}
    		}    		
  },


  render: function() {
    var self = this;
    this.$el.addClass('panel panel-primary');
    if (this.draggable) {
      this.$el.draggable({cursor: 'move', containment: 'window' });
    }
    this.firstRender = true;

    if (this.firstRender) {
      this.$el.html(this.template({}));
      this.$el.show();

      this._getFilterList().done(function() {
        self.renderFilters();
        self.translate(this.$el);
      });
      
      // handle click on a Tab's title: http://getbootstrap.com/javascript/#tabs-events
      $(document).on('shown.bs.tab click', "ul.nav.filter-titles>li>a[data-toggle='tab']", function (e) {  // <- this line makes little sense but works in Saiku/Tabs also
        //this.$el.find("ul.nav.filter-titles>li>a[data-toggle='tab']").on('shown.bs.tab', function (e) {   // <- this line works in anything except Saiku/Tabs
        /**
         * the 'click' event added because (weirdly) the shown.bs.tab event not being fired AT ALL under Saiku/Tabs. Until this is investigated
         * on GIS/Dashboard tabs this second event is superfluous
         */

        var activeTab = $(e.target.parentElement).index(); // shameful hack, but haven't been able to find a cleaner solution
        var oldTabNr = e.relatedTarget ? $(e.relatedTarget.parentElement).index() : -1;
        filtersViewLog.log('switching from filters tab', oldTabNr, 'to tab', activeTab);
        $(e.target).closest('ul.filter-titles').attr('active-tab-number', activeTab); // not used in the current implementation of the code

        // render the first item of the tab
        var tabId = $(e.target).attr('href');
        var tabFirstChild = $(tabId).find('ul.sub-filters-titles>li:first a');
        if (tabFirstChild)
          tabFirstChild.click();
      });

      this.firstRender = false;
    } else {
      self.translate();
    }

    return this;
  },

  createTranslator: function(force) {
    var self = this;
    var filterTranslateKeys = JSON.parse("{\n  \"amp.gis:title-Country\": \"Country\",\n  \"amp.gis:title-Region\": \"Region\",\n  \"amp.gis:title-Zone\": \"Zone\",\n  \"amp.gis:title-District\": \"District\",\n  \"amp.gis:title-filters\": \"Filter\",\n  \"amp.gis:pane-filters-search\": \"Go\",\n  \"amp.gis:pane-filters-select\": \"select all\",\n  \"amp.gis:pane-filters-deselect\": \"deselect all\",\n  \"[placeholder]amp.gis:pane-filters-search-placeholder\": \"Search...\",\n  \"amp.gis:pane-filters-FundingOrganizations\": \"Funding Organizations\",\n  \"amp.gis:pane-filters-Sector\": \"Sector\",\n  \"amp.gis:pane-filters-Sectors\": \"Sectors\",\n  \"amp.gis:pane-filters-Programs\": \"Programs\",\n  \"amp.gis:pane-filters-Activity\": \"Activity\",\n  \"amp.gis:pane-filters-AllAgencies\": \"All Agencies\",\n  \"amp.gis:pane-filters-Financial\": \"Financial\",\n  \"amp.gis:pane-filters-Location\": \"Location\",\n  \"amp.gis:pane-filters-Other\": \"Other\",\n  \"amp.gis:pane-subfilters-Donor\": \"Donor\",\n  \"amp.gis:pane-subfilters-Primary\": \"Primary\",\n  \"amp.gis:pane-subfilters-Secondary\": \"Secondary\",\n  \"amp.gis:pane-subfilters-NationalPlanObjective\": \"National Plan Objective\",\n  \"amp.gis:pane-subfilters-ActivityStatus\": \"Activity Status\",\n  \"amp.gis:pane-subfilters-ApprovalStatus\": \"Approval Status\",\n  \"amp.gis:pane-subfilters-ImplementingAgency\": \"Implementing Agency\",\n  \"amp.gis:pane-subfilters-ExecutingAgency\": \"Executing Agency\",\n  \"amp.gis:pane-subfilters-BeneficiaryAgency\": \"Beneficiary Agency\",\n  \"amp.gis:pane-subfilters-ContractingAgency\": \"Contracting Agency\",\n  \"amp.gis:pane-subfilters-AidModality\": \"Aid Modality\",\n  \"amp.gis:pane-subfilters-TypeOfAssistance\": \"Type Of Assistance\",\n  \"amp.gis:pane-subfilters-ResponsibleOrganization\": \"Responsible Organization\",\n  \"amp.gis:pane-subfilters-ComponentFundingOrganization\": \"Component Funding Organization\",\n  \"amp.gis:pane-subfilters-ComponentSecondResponsibleOrganization\": \"Component Second Responsible Organization\",\n  \"amp.gis:pane-subfilters-Dates\": \"Dates\",\n  \"amp.gis:pane-subfilters-RegionalGroup\": \"Regional Group\",\n  \"amp.gis:pane-subfilters-SectorGroup\": \"Sector Group\",\n  \"amp.gis:pane-subfilters-TertiarySectors\": \"Tertiary Sectors\",\n  \"amp.gis:pane-subfilters-FinancingInstruments\": \"Financing Instruments\",\n  \"amp.gis:pane-filters-all\": \"all\",\n  \"amp.gis:button-reset\": \"Reset\",\n  \"amp.gis:button-cancel\": \"Cancel\",\n  \"amp.gis:button-apply\": \"Apply\",\n  \"amp.gis:pane-subfilters-startdate\": \"Start Date:\",\n  \"amp.gis:pane-subfilters-enddate\": \"End Date:\",\n  \"amp.gis:pane-subfilters-empty\": \"No data for this filter\",\n  \"amp.gis:date-from\": \"From\",\n  \"amp.gis:date-until\": \"Until\"\n}\n");
    // setup any popovers as needed...
    self.popovers = self.$('[data-toggle="popover"]');
    self.popovers.popover();
    if (force === true || self.translator === undefined) {
      filtersViewLog.onDebug(function() {
        filtersViewLog.log('Creating translator for filters because', force === true ? 'I was forced' : 'there is no translator');
      });
      self.translator = new Translator({defaultKeys: filterTranslateKeys});
    }
  },

  translate: function(target) {
    var element = this;
    if (target !== undefined) {
      element = target;
    }
    if (element.el !== undefined) {
      this.translator.translateDOM(element.el);
    } else {
      this.translator.translateDOM(element);
    }
  },

  /**
   * renders the tabs within the filters, only rendering the first item of the active tab (the others don't have their first item's contents rendered for performance reasons)
   */
  renderFilters: function() {
    this.$('.filter-options').html('');

    var renderingTitleNumber = -1;
    var activeTitleNumber = this.$('.filter-titles').attr('active-tab-number') || 0;

    for (var filterView in this.filterViewsInstances) {
      if (this.filterViewsInstances.hasOwnProperty(filterView)) {
    	  contained = false;
    	  var index;
    	  for (index = 0; index < this.allFilters.length; index++) {
    		  if ((this.allFilters.models[index].attributes.tab === this.filterViewsInstances[filterView].name) || 
    		  (this.allFilters.models[index].attributes.group === this.filterViewsInstances[filterView].name)){
    			  contained = true;
    			  break;
    		  } 
    	  }
    	  if (!contained) {
    		  delete this.filterViewsInstances[filterView];
    		  continue;
    	  }
    		  
        var tmpFilterView = this.filterViewsInstances[filterView];
        renderingTitleNumber = renderingTitleNumber + 1;
        this.$('.filter-titles').append(tmpFilterView.renderTitle().titleEl);
        var active = renderingTitleNumber == activeTitleNumber;
        this.$('.filter-options').append(tmpFilterView.renderFilters(active).el);
      }
    }

    // Opens the first tab in the filter
    this.$('.filter-titles a:first').tab('show');
  },


  _getFilterList: function() {
    return this.allFilters.load();
  },

  _createFilterViews: function(tmpModel) {
    // TODO: magic strings are dangerous, config somewhere...
	switch (tmpModel.get('group')) {
      case 'ActivityBudgetList':
      case 'type-of-assistance':
      case 'mode-of-payment':
      case 'expenditure-class':
      case 'financing-instrument':
      case 'funding-status':
      case 'effective-funding-date':
      case 'funding-closing-date':
      case 'concessionality-level':
        this.filterViewsInstances.financials.filterCollection.add(tmpModel);
        break;
      case 'status':
      case 'performance-alert-level':
      case 'approval-status':
        this.filterViewsInstances.activity.filterCollection.add(tmpModel);
        break;
      case 'Programs':
        this.filterViewsInstances.programs.filterCollection.add(tmpModel);
        break;
      case 'Sectors':
        this.filterViewsInstances.sectors.filterCollection.add(tmpModel);
        break;
      case 'Donor':
        this.filterViewsInstances.donors.filterCollection.add(tmpModel);
        break;
      case 'Role':
        this.filterViewsInstances.allAgencies.filterCollection.add(tmpModel);
        break;
      case 'location':
        this.filterViewsInstances.locations.filterCollection.add(tmpModel);
        break;
      default:
        this.filterViewsInstances.others.filterCollection.add(tmpModel);
    }

  },
  
  serializeToModels: function(filter) {
	  var _self = this;
	  _self.values = {0: [], 1: [], 2: [], 3: []}; //TODO: Implement calculateFilterDept() function.
	  if (filter.get('tree')) {
		  var entryPoint = filter.get('tree').get('children');
		  var currentLevel = 0;
		  if (filter.get('numSelected') !== filter.get('numPossible')) {
			  _.each(entryPoint.models, function(item) {
				  _self.serializeLevel(item, 0, _self.values);
			  });
		  }
	  } else {
		  _self.values = filter;
	  }
	  return _self.values;
  },
    
  serializeLevel: function(node, level, values) {
	// When we enter here it means the parent is not 'fully selected'.
	  var _self = this;
	  if (node.get('children').models.length > 0) {
		  // "Double check" because some selected middle nodes have get('selected') === false. 
		  if (node.get('numSelected') !== node.get('numPossible') && node.get('selected') === false) {
			  _.each(node.get('children').models, function(node2) {				  
				  _self.serializeLevel(node2, level + 1, values);
			  });
		  } else {
			  if (values[level] === undefined) {
				  values << [];
			  }
			  values[level].push({'level': level, 'levelName': node.get('filterId'), name: node.get('name')});
		  }
	  } else { // We reached the last level..
		  if (node.get('selected') === true) {
			  if (values[level] === undefined) {
				  values << [];
			  }
			  values[level].push({'level': level, 'levelName': node.get('filterId'), name: node.get('name')});
		  }
	  }	  
  },
  
  //TODO: move from view to all-collection
  serialize: function(options) {
    var self = this;
    var serializedFilters = {filters:{}};

    this.allFilters.each(function(filter) {
      // TODO: build a util for bettermerge that concat's array if
      // duplicate keys in objects...
      if (filter.get('id') || filter.url) {
        if (filter.get('modelType') === 'DATE-RANGE-VALUES' || filter.get('modelType') === 'YEAR-SINGLE-VALUE') {
          _.extend(serializedFilters.filters, filter.serialize(options));
        } else {
          var serialized = filter.serialize(options);
          if (options.wholeModel === true) {
            var keys = [];
            for(var k in serialized) keys.push(k);
            if (keys[0] !== undefined && serialized[keys[0]] !== undefined) {
              serialized[keys[0]].filterName = (filter.get('displayName') || filter.get('name'));
              serialized[keys[0]].serializedToModels = self.serializeToModels(filter);
            }
          }
          _.extend(serializedFilters.filters, serialized);
        }
      }
    });

    //remove empty / false values.
    _.each(serializedFilters, function(v, k) {
      if(!v || _.isEmpty(v)) {
        delete serializedFilters.filters[k];
      }
    });

    return serializedFilters;
  },
 deserialize: function(filtersObject, options) {
	var blob = filtersObject.filters || {};
    if (blob) {
      if(_.isUndefined(this.initialFilters)){
    	  this.initialFilters = blob;
      }     
      var that = this;
      that.allFilters.each(function(filter) {
    	filter.reset();
        if (filter.get('id') || filter.url) {
          if(filter.get('modelType') === 'DATE-RANGE-VALUES') {
         	that.setDefaultDates(blob);            
            filter.deserialize(blob);
          } else{
            filter.deserialize(blob);
          }
        }
      });
    } else {
      console.warn('could not deserialize blob:', blob);
    }
    if (!options || !options.silent) {
      this.applyFilters();  // triggers the "apply" event
    }
  },

  showFilters: function() {
    this.render();
    this.filterStash = null;  // in case they haven't loaded yet, don't try to .serialize()
    this._loaded.done(_.bind(function() { this.filterStash = this.serialize({}); }, this));
  },

  setStash: function() {
    this.filterStash = null;  // in case they haven't loaded yet, don't try to .serialize()
    this._loaded.done(_.bind(function() { this.filterStash = this.serialize({}); }, this));
  },

  resetFilters: function() {
	var self = this;
	 var blob = !_.isUndefined(this.initialFilters) ? JSON.parse(JSON.stringify(this.initialFilters)) : {};//clone initial filters
    this.allFilters.each(function(filter) {
    if (filter.get('modelType') === 'DATE-RANGE-VALUES') {
    	 self.setDefaultDates(blob);          	 
    	 filter.deserialize(blob);
     }else{
    	 filter.reset();
     }      
    });
  },

  applyFilters: function() {
    this._loaded.done(_.bind(function() {
      var state = this.serialize({});
      this.trigger('apply', state);
    }, this));
  },

  getDateFormat: function(){
	  if(this.dFormat){
		  return this.dFormat;
	  }	
	  
	  var dateFormatSetting = this.settings.get('default-date-format');
	  if(dateFormatSetting){			
			var foundMapping =_.findWhere(this.dateFormatMappings, {ampformat: dateFormatSetting});
			if(foundMapping){
				this.dFormat = foundMapping.datepickerformat;
			}
	  }	  
	  if(!this.dFormat){
		  this.dFormat = this.PARAMS_DATE_FORMAT;
	  }	  
	  return this.dFormat;
   },
  
   formatDate: function(date){
	   return $.datepicker.formatDate(this.getDateFormat(), ($.datepicker.parseDate(this.PARAMS_DATE_FORMAT,date)));
   }, 
   setDefaultDates: function(blob){
	 var self = this;
  	 if(self.caller === "DASHBOARD"){
  		 return DateUtils.extractDates(self.settings, blob, 'dashboard-default-min-date', 'dashboard-default-max-date'); 	 
  	 }else if(self.caller === "GIS"){
  		return DateUtils.extractDates(self.settings, blob, 'gis-default-min-date', 'gis-default-max-date');
  	 }
  	 return blob
   },
  cancel: function() {
	if(this.filterStash){    	
      this.deserialize(this.filterStash, {silent: true});
    }
    this.trigger('cancel', this.filterStash);
  }
});


},{"../../../../../reamp/tools/log":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/reamp/tools/log/index.js","../collections/all-filters-collection":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/collections/all-filters-collection.js","../models/general-settings":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/general-settings.js","../utils/date-utils":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/utils/date-utils.js","../views/top-level-filter-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/top-level-filter-view.js","amp-translate":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/generic-filter-view.js":[function(require,module,exports){

var _ = require('underscore');

// var GenericFilterModel = require('../models/generic-filter-model');
var TreeNodeView = require('../tree/tree-node-view');
var BaseFilterView = require('../views/base-filter-view');
var Template = "<% if (!empty) { %>\n\t<div class=\"search-form\">\n\t  <div class=\"input-group form-group\">\n\t    <input type=\"text\" data-i18n=\"[placeholder]amp.gis:pane-filters-search-placeholder\" class=\"form-control search-text\" placeholder=\"Search...\">\n\t    <span class=\"input-group-btn\">\n\t      <button data-i18n=\"amp.gis:pane-filters-search\" class=\"btn btn-success\">Go</button>\n\t    </span>\n\t  </div><!-- /input-group -->\n\t</div>\n\t<div class=\"toggle-all\">\n\t  <em>\n\t    <a href=\"#\" data-i18n=\"amp.gis:pane-filters-select\" class=\"select-all\" >select all</a> /\n\t    <a href=\"#\"  data-i18n=\"amp.gis:pane-filters-deselect\" class=\"select-none\" >deselect all</a>\n\t  </em>\n\t</div>\n\t\n\t<div class=\"tree tree-container\" style=\"\"></div><!--display:none;-->\n<% } else { %>\n\t<span data-i18n='amp.gis:pane-subfilters-empty'></span>\n<% } %>\n";


// This is a generic model for filters. It assumes a tree structure.
// If you don't want a tree structure just extend base-filter
module.exports = BaseFilterView.extend({

  className: BaseFilterView.prototype.className + ' filter-generic',
  template: _.template(Template),
  _loaded: null,

  events:{
  },

  initialize:function(options) {
    var self = this;
    BaseFilterView.prototype.initialize.apply(this, [options]);

    this.model = options.model;
    this.translator = options.translator;
    this.translate = options.translate;
    this.treeView = new TreeNodeView({isRoot:true});

    // Create tree view
    // TODO: make tree loading content responsibility of model, not view...
    this.model.getTree().then(function(treeModel) {
      if (treeModel) {
        self._updateCountInMenu();
        treeModel.on('change:numSelected', function() {
          self._updateCountInMenu();
        });
      } else {
        console.warn('no tree for: ', self.model);
      }
    });
  },

  searchKeyUp: function(event) {
    if (event.keyCode === 13 || // Pressed 'enter'
      this.$('.search-text').val() === '' ||
      this.$('.search-text').val().length > 1
      ) {
      this.model.get('tree').filterText(this.$('.search-text').val().toLowerCase());
    }
  },


  _updateCountInMenu:function() {	
    if (this.$titleEl && this.model.get('tree')) {
      if (this.model.get('tree').get('numSelected') === this.model.get('tree').get('numPossible') ||
          this.model.get('tree').get('numSelected') === 0) {    	  
    	  this.$titleEl.find('.filter-count').attr('data-i18n','amp.gis:pane-filters-all');
    	  this.$el.removeClass('active');     	  
    	  this.translate(this.$titleEl.find('.filter-count').parent());
      } else {    	
        this.$titleEl.find('.filter-count').text(this.model.get('tree').get('numSelected') +
          '/' +
          this.model.get('tree').get('numPossible'));
        this.$el.addClass('active');
        this.$titleEl.find('.filter-count').attr('data-i18n','');
      }
    }
  },	
  renderTitle : function() {	  
	  BaseFilterView.prototype.renderTitle.apply(this);
	  this._updateCountInMenu();
	  return this;
  },

  renderFilters:function() {
    var self = this;
    BaseFilterView.prototype.renderFilters.apply(this);

    this.model.getTree().then(function(treeModel) {
      self.$el.html(self.template(self.model.toJSON()));

      // add event listeners
      self.$('.select-none').on('click', function() {self._selectNone(); return false;}); //return false to stop page refresh.
      self.$('.select-all').on('click', function() {self._selectAll(); return false;}); //return false to stop page refresh.
      self.$('input.search-text').on('keyup', function(event) {self.searchKeyUp(event);});

      if (treeModel) {
        self.$('.tree-container').append(self.treeView.render(self.model.get('tree')).$el);
        treeModel.set('expanded', true);
        treeModel.filterText('');//default no filter.
      } else{
        self.$('.tree-container').append("");
      }
    })
    .done(function() {
    	self.translate(self);
    })
    .fail(function(){
      console.error('renderFilters failed :(');
    });

    return this;
  },

  _selectAll: function() {
    // force trigger even if already this state (important for half-fill ui
    this.model.get('tree').set('selected', false);
    this.model.get('tree').set('selected', true);    
  },

  _selectNone: function() {
    // force trigger even if already this state (important for half-fill ui)
    this.model.get('tree').set('selected', true);
    this.model.get('tree').set('selected', false);    
  }

});


},{"../tree/tree-node-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-view.js","../views/base-filter-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/base-filter-view.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/top-level-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var $ = require('jquery');

var Backbone = require('backbone');
var TitleTemplate = "<%\n// renders the title of a tab \n%>\n<li class=\"\"><a data-i18n=\"amp.gis:pane-filters-<%= name.replace(/ /g,'') %>\" href=\"#filter-pane-<%= name.replace(/ /g,'') %>\" role=\"tab\" data-toggle=\"tab\"><%= name %></a></li>\n";
var ContentTemplate = "<%\n // renders the contents of a filter's tab (e.g. for example the \"Contracting / Implementing / Executing / Primary Beneficiary / Secondary Beneficiary Agency\" list of the \"All Agencies\" tab)\n // <h6>mde  %- Math.random() </h6>\n%>\n<ul class=\"sub-filters-titles nav nav-pills nav-stacked\">\n</ul>\n<div class=\"sub-filters-content\">\n  <img src=\"img_2/loading-icon.gif\" />\n</div>\n";

var GenericFilterView = require('../views/generic-filter-view');
var YearsFilterView = require('../views/years-filter-view');
var YearsOnlyFilterView = require('../views/years-only-filter-view');

var YearsFilterModel = require('../models/years-filter-model');
var YearsOnlyFilterModel = require('../models/years-only-filter-model');

var filtersViewLog = require("../../../../../reamp/tools/log")('amp:filters:top-level:view');

//TODO: rename to 'group' to be consistent
// Parent base view for filters.
module.exports = Backbone.View.extend({
  className:  'tab-pane',
  titleTemplate: _.template(TitleTemplate),
  contentTemplate: _.template(ContentTemplate),
  filterCollection: null,
  viewList:[],
  name: 'tbd',

  initialize:function(options) {
    var self = this;
    this.name = options.name;
    this.translator = options.translator;
    this.translate = options.translate;
    this.filterView = options.filterView; 
    this.filterCollection = new Backbone.Collection();    
    this.filterCollection.on('change:numSelected', function(){
      self._refreshTitle();
    });
  },

  cleanupUnusedTabs: function() {
	  console.log(this);
//	debugger(self);
  },
  
  
  /**
   * renders the items in a tab
   * the first element of the tab's contents will be rendered IFF options.renderFirstElement has been specified
   */
  renderFilters: function(renderFirstElement) {
    var self = this;
    var view = null;
    var first = true;
    this.$el.attr('id', 'filter-pane-' + this.name.replace(/ /g,''));
    this.$el.html(this.contentTemplate());
    // renders the tabs of the filter (one tab for each filterCollection element)
    this.filterCollection.each(function(filter) {
        	if (filter instanceof YearsFilterModel) {    		
    		view = new YearsFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate,
    			filterView: self.filterView    			
    		});
    		self.viewList.push(view);
    	} else if (filter instanceof YearsOnlyFilterModel) {
    		view = new YearsOnlyFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate,
    			filterView: self.filterView    			
    		});
    		self.viewList.push(view);
    	} else {
    		view = new GenericFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate
    		});
    		self.viewList.push(view);
    	}

    	var titleElem = view.renderTitle().$titleEl;
    	self.$('.sub-filters-titles').append(titleElem);

    	// hacky way to open first one for now.
    	if (first && renderFirstElement) {
    		first = false;
    		view.renderFilters();
    		self.$('.sub-filters-titles li:first').addClass('active');
    	}
    });
    
    // We need to re-translate some strings from the right panel.
	self.translate(this);

   	return this;
  },

  _refreshTitle: function(){
    var totalSelected = 0;
    var countStr ='';

    this.filterCollection.each(function(filter) {
      if(filter.getNumSelected){
        totalSelected += filter.getNumSelected();
      }
    });

    if( totalSelected !== 0) {
      countStr = totalSelected;
    }

    // TODO: should be locally scoped, not global jquery.
    $('#'+this.name.replace(/ /g,'') + ' .title-count').text(countStr);
  },

  /**
   * renders the title of a tab
   */
  renderTitle: function() {
    this.titleEl = this.titleTemplate({name: this.name});
    return this;
  }
});

},{"../../../../../reamp/tools/log":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/reamp/tools/log/index.js","../models/years-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-filter-model.js","../models/years-only-filter-model":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-only-filter-model.js","../views/generic-filter-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/generic-filter-view.js","../views/years-filter-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/years-filter-view.js","../views/years-only-filter-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/years-only-filter-view.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/years-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var BaseFilterView = require('../views/base-filter-view');

require('../lib/jquery.nouislider.min.js');
require('jquery-ui/datepicker');

var Template = "\n  <h3 class=\"title text-center\"><span class=\"dates\"></span></h3>\n   <div class=\"year-slider\"></div>\n\n   <span data-i18n=\"amp.gis:pane-subfilters-startdate\">Start Date:</span>&nbsp<p><input type=\"text\" id=\"start-date\" class=\"date-picker\"></p>\n   <span data-i18n=\"amp.gis:pane-subfilters-enddate\">End Date:</span>&nbsp<p><input type=\"text\" id=\"end-date\" class=\"date-picker\"></p>\n";

module.exports = BaseFilterView.extend({

  className: BaseFilterView.prototype.className + ' filter-years',
  template: _.template(Template),
  _loaded: null, 
  initialize:function(options) {
    var self = this;
    
    this.filterView = options.filterView;    
    BaseFilterView.prototype.initialize.apply(this, [options]);
    this.model = options.model;
    this.translator = options.translator;
    this.translate = options.translate;    

    this._loaded = this.model.fetch().then(function() { });

    this.listenTo(this.model, 'change', this._updateTitle);
  },


  renderFilters:function() {
    var self = this;
    BaseFilterView.prototype.renderFilters.apply(this);

    this.$el.html(this.template(this.model.toJSON()));

    this._loaded.then(function() {
      //self._renderSlider();
      self._renderDatePickers();
      self._updateTitle();
      
      // We need to re-translate some strings from the right panel.
      self.translate(self);
    });

    return this;
  },

  _renderDatePickers: function() {		
	
	

    var self = this;

    // TODO: format based on admin setting....maybe get from year api..
    // TODO: abstract common properties from object inits below...
    // var commonObj = {};

    this.$('#start-date').datepicker({
      defaultDate: this.model.get('selectedStart'),
      dateFormat: this.filterView.getDateFormat(),
      changeMonth: true,
      changeYear: true,
      numberOfMonths: 1,
      yearRange: 'c-60:c+60',
      onClose: function(selectedDate) {
        self.$('#end-date').datepicker('option', 'minDate', selectedDate);        
        self.model.set('selectedStart', $.datepicker.formatDate(self.filterView.PARAMS_DATE_FORMAT, $.datepicker.parseDate(self.filterView.getDateFormat(), selectedDate)));        
      }
    });    

    this.$('#end-date').datepicker({
      defaultDate: this.model.get('selectedEnd'),
      dateFormat: this.filterView.getDateFormat(),
      changeMonth: true,
      changeYear: true,
      numberOfMonths: 1,
      yearRange: 'c-60:c+60',
      onClose: function(selectedDate) {
        self.$('#start-date').datepicker('option', 'maxDate', selectedDate);        
        self.model.set('selectedEnd', $.datepicker.formatDate(self.filterView.PARAMS_DATE_FORMAT, $.datepicker.parseDate(self.filterView.getDateFormat(), selectedDate)));        
      }
    });

    // Set the language for datepickers here (instead of doing it in filters-view.js) to prevent race conditions that would set the wrong language.
    var lang = this.filterView.settings.get('language');
	if (lang) {
		//English is default so we dont set it.
        lang = (lang === 'en') ?  '' : lang; 		
		$.datepicker.setDefaults($.datepicker.regional[lang]);
	}
  },

  renderTitle:function() {
	BaseFilterView.prototype.renderTitle.apply(this);
    this._updateTitle();

    return this;
  },

  //TODO: do more in template.
  _updateTitle:function() {	  
	var selectedStart = this.model.get('selectedStart') ? $.datepicker.formatDate(this.filterView.getDateFormat(), ($.datepicker.parseDate(this.filterView.PARAMS_DATE_FORMAT, this.model.get('selectedStart')))) : "";
	var selectedEnd = this.model.get('selectedEnd') ? $.datepicker.formatDate(this.filterView.getDateFormat(), ($.datepicker.parseDate(this.filterView.PARAMS_DATE_FORMAT, this.model.get('selectedEnd'))))	: "";
	$('#datePicker').datepicker({ dateFormat: this.filterView.getDateFormat() });
	this.$('#start-date').datepicker("setDate", selectedStart);
	this.$('#end-date').datepicker("setDate", selectedEnd);	
	var dates = "";
	if(selectedStart.length > 0 && selectedEnd.length > 0){
		dates = selectedStart + ' - ' +  selectedEnd;		
	}else if(selectedStart.length > 0 && selectedEnd.length == 0){
		dates = this.translator.translateSync('amp.gis:date-from', 'From') + ' ' + selectedStart;				
	}else if(selectedStart.length == 0 && selectedEnd.length > 0){
		dates = this.translator.translateSync('amp.gis:date-until', 'Until') + ' ' + selectedEnd;			
	}
	this.$titleEl.find('.filter-count').text(dates);
	this.$('.dates').text(dates);	
  },

  _renderSlider: function() {
    var self = this;

    // uses window.jQuery because that was the only way I had luck with browserify shim...
    // uses https://github.com/leongersen/noUiSlider
    this.slider = window.jQuery(this.$('.year-slider')).noUiSlider({
      start: [self.model.get('selectedStart'), self.model.get('selectedEnd')],
      step: 1,
      connect: true,
      range: {min: self.model.get('startYear'), max:self.model.get('endYear')},
      serialization: {
        lower: [
          window.jQuery.Link({
            target: window.jQuery('.start-year')
          })
        ],
        upper: [
          window.jQuery.Link({
            target: window.jQuery('.end-year')
          })
        ],
        format: {
          decimals: 0
        }
      }
    });

    //ugly, too much data in the dom...but it's how the example goes.
    this.slider.on('change', function() {
      self.model.set('selectedStart', parseInt(self.$('.start-year').text(), 10));
    });

    //ugly, too much data in the dom...but it's how the example goes.
    this.slider.on('change', function() {
      self.model.set('selectedEnd',  parseInt(self.$('.end-year').text(), 10));
    });
  }

});

},{"../lib/jquery.nouislider.min.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/lib/jquery.nouislider.min.js","../views/base-filter-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/base-filter-view.js","jquery-ui/datepicker":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/datepicker.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/years-only-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var BaseFilterView = require('../views/base-filter-view');

var Template = "<span data-i18n=\"amp.gis:pane-subfilters-year\">Year:</span>\r\n&nbsp\r\n<p>\r\n\t<select id=\"year-select\" class=\"\"></select>\r\n</p>";

module.exports = BaseFilterView.extend({
	className : BaseFilterView.prototype.className + ' filter-years',
	template : _.template(Template),
	_loaded : null,
	initialize : function(options) {
		var self = this;
		this.filterView = options.filterView;
		BaseFilterView.prototype.initialize.apply(this, [ options ]);
		this.model = options.model;
		this.translator = options.translator;
		this.translate = options.translate;
		this._loaded = this.model.fetch().then(function() {});
		this.listenTo(this.model, 'change', this._updateTitle);
	},

	renderFilters : function() {
		var self = this;
		BaseFilterView.prototype.renderFilters.apply(this);
		this.$el.html(this.template(this.model.toJSON()));
		this._loaded.then(function() {
			self._renderSelector();
			// We need to re-translate some strings from the right panel.
			self.translate(self);
		});

		return this;
	},

	_renderSelector : function() {
		var self = this;
		var selector = this.$('#year-select');
		selector.append($("<option>").attr('value', '').text(''));
		_.each(this.model.get('value').options, function(item, i) {
			var option = $("<option>").attr('value', item.value).text(item.value);
			if (item.value === self.model.get('selectedYear').toString()) {
				$(option).attr('selected', 'selected');
			}
			selector.append(option);
		});

		$(selector).on('change', function() {
			self.model.set('selectedYear', this.value);
		});
	},

	_updateTitle : function() {
		var selectedYear = this.model.get('selectedYear');
		this.$("#year-select").val(selectedYear);
	},

});

},{"../views/base-filter-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/base-filter-view.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/node_modules/bootstrap/dist/js/bootstrap.js":[function(require,module,exports){
module.exports=require("/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js")
},{"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-boilerplate/node_modules/bootstrap/dist/js/bootstrap.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/node_modules/jquery-ui/core.js":[function(require,module,exports){
module.exports=require("/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js")
},{"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/node_modules/jquery-ui/draggable.js":[function(require,module,exports){
module.exports=require("/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/draggable.js")
},{"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/draggable.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/draggable.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/node_modules/jquery-ui/mouse.js":[function(require,module,exports){
module.exports=require("/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/mouse.js")
},{"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/mouse.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/mouse.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/node_modules/jquery-ui/widget.js":[function(require,module,exports){
module.exports=require("/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js")
},{"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/collections/settings-definitions-collection.js":[function(require,module,exports){
var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var Backbone = require('backbone');
var Setting = require('../models/settings-definitions');
var Config = require('../common/config');
var Constants = require('../common/constants');

module.exports  = Backbone.Collection.extend({
	model : Setting,
	comparator: 'id',
	firstTime: true,
	initialize: function(models, options) {
		this.options = options;
		this.url = options.definitionUrl;
		this.app = options.app;
		this.loaded = new Deferred();
		_.bindAll(this,'load');
	},
	parse: function(settings) {
		return settings;	    
	},
	load: function() {
		if (this.firstTime) {
			this.firstTime = false;
			if (this.loaded.state() !== 'pending') { return this.loaded.promise(); }
			this.fetch({})
			.then(_(function() {
				this.loaded.resolve();
			}).bind(this))
			.fail(_(function() {			       
				this.loaded.reject();
			}).bind(this));
		}    
		return this.loaded.promise();
	},
	findCurrencyById: function(id){
		return _.find(this.get(Constants.CURRENCY_ID).get('value').options, function(option){ return option.id === id });		 
	},
    findAmountUnitsById: function(id){
		return _.find(this.get(Constants.AMOUNT_UNIT_ID).get('value').options, function(option){ return option.id === id });
	},
    findAmountUnitsByValue: function(value){
		return _.find(this.get(Constants.AMOUNT_UNIT_ID).get('value').options, function(option){ return option.value === value });
	},
	findCalendarById: function(id){
		return _.find(this.get(Constants.CALENDAR_ID).get('value').options, function(option){ return option.id === id });
	},
	findFundingTypeById: function(id){
		return _.find(this.get(Constants.FUNDING_TYPE_ID).get('value').options, function(option){ return option.id === id });
	},
	getCurrencySetting: function(){
		return this.get(Constants.CURRENCY_ID);
	},
	getAmountUnitsSetting: function(){
		return this.get(Constants.AMOUNT_UNIT_ID);
	},
	getCalendarSetting: function(){
		return this.get(Constants.CALENDAR_ID);
	},	
	getFundingTypeSetting:function(){
		return this.get(Constants.FUNDING_TYPE_ID);
	},
	getDefaultCurrencyId: function(){
		return this.getCurrencySetting().get('value').defaultId;
	},
	getDefaultAmountUnitsId: function(){
		return this.getAmountUnitsSetting().get('value').defaultId;
	},
	getDefaultCalendarId: function(){
		return this.getCalendarSetting().get('value').defaultId;
	},
	getDefaultFundingTypeById: function(){
		return this.getFundingTypeSetting().get('value').defaultId;
	},
	getSelectedOrDefaultCurrencyId : function() {
	    return this.app.toAPIFormat()[Constants.CURRENCY_ID] || this.getDefaultCurrencyId();
	},
	getSelectedOrDefaultCalendarId : function() {
		return this.app.toAPIFormat()[Constants.CALENDAR_ID] || this.getDefaultCalendarId();
	},
	getSelectedOrDefaultFundingTypeId : function() {
		return this.app.toAPIFormat()[Constants.FUNDING_TYPE_ID] || this.getDefaultFundingTypeById();
	}
});


},{"../common/config":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/common/config.js","../common/constants":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/common/constants.js","../models/settings-definitions":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/models/settings-definitions.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/common/config.js":[function(require,module,exports){
module.exports = {
	IS_POPUP : true
};

},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/common/constants.js":[function(require,module,exports){
module.exports = {
	YEAR_RANGE_ID : 'year-range',
	CALENDAR_ID : 'calendar-id',
	CURRENCY_ID : 'currency-code',
	FUNDING_TYPE_ID : 'funding-type',
	CALENDAR_CURRENCIES_ID : 'calendar-currencies',
    AMOUNT_FORMAT_ID : 'amount-format',
    AMOUNT_UNIT_ID : 'number-divider',
    AMOUNTS_OPTION_THOUSANDS : 1000,
    AMOUNTS_OPTION_MILLIONS : 1000000,
	YEAR_FROM_ID: "from",
	YEAR_TO_ID: "to",	
	CONTEXT : {
		GIS : 'GIS',
		DASHBOARDS : 'DASHBOARDS',
		REPORTS : 'REPORTS',
		TABS : 'TABS'
	}
}
},{}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/index.js":[function(require,module,exports){

var jQuery = require('jquery');
var _ = require('underscore');
var Backbone = require('backbone');
//loading hacks
require('jquery-ui/draggable');
var Config = require('./common/config');
var Constants = require('./common/constants');
var SettingsDefinitionsCollection = require('./collections/settings-definitions-collection');
var SettingsView = require('./views/settings-view');
var GeneralSettings = require('./models/general-settings');
//jquery is colliding in GIS module, so we only load it if it is not loaded or if there is a jquery loaded but version is older than 2.x.x
if (window.$ == undefined || $.fn.jquery.split(' ')[0].split('.')[0] < 2) {	
	window.jQuery = window.$ = Backbone.$ = jQuery;	
	$.noConflict(true);
}
var bootstrap_enabled = (typeof $().modal == 'function');
if (bootstrap_enabled) {
	require('bootstrap/dist/js/bootstrap');
}


function Widget() {
	this.initialize.apply(this, arguments);
}

_.extend(Widget.prototype, Backbone.Events, {	
	Constants: Constants, //expose constants
	
	initialize : function(options) {
		if (_.isUndefined(options) || _.isUndefined(options.definitionUrl) || _.isUndefined(options.caller)) {
		    throw new Error('definitionUrl and caller are required for the Settings Widget to function correctly.');
		}
		
		options = _.defaults(options, {
			draggable : true
		});		
		options = _.defaults(options, {
			isPopup : Config.IS_POPUP
		});		
		options.app = this;
		this.definitions = new SettingsDefinitionsCollection([], options);
		options.definitions = this.definitions;
		this.view = new SettingsView(options);
		this.listenTo(this.view, 'all', function() {
			this.trigger.apply(this, arguments);
		});
		this.definitions.load();
		_.bindAll(this, 'show', 'toAPIFormat', 'restoreFromSaved', 'setElement');				
	},
	show : function() {
		this.view.render();
	},
	toAPIFormat : function() {
		return this.view.getCurrent();
	},
	restoreFromSaved : function(state) {
		return this.view.restoreFromSaved(state);
	},
	setElement : function(arguments) {
		this.view.setElement(arguments);
	}	
});
module.exports = {SettingsWidget: Widget, GeneralSettings: GeneralSettings}
window.AMPSettings = {SettingsWidget: Widget, GeneralSettings: GeneralSettings};
},{"./collections/settings-definitions-collection":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/collections/settings-definitions-collection.js","./common/config":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/common/config.js","./common/constants":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/common/constants.js","./models/general-settings":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/models/general-settings.js","./views/settings-view":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/views/settings-view.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/node_modules/bootstrap/dist/js/bootstrap.js","jquery":"jquery","jquery-ui/draggable":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/node_modules/jquery-ui/draggable.js","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/models/general-settings.js":[function(require,module,exports){
var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var Backbone = require('backbone');
module.exports = Backbone.Model.extend({
	url: '/rest/amp/settings',	
	firstTime: true,
	initialize: function() {
		this.loaded = new Deferred();
		_.bindAll(this,'load');
	},
	parse: function(settings){
	  return settings;
	},	
	load: function() {
		if (this.firstTime) {
			this.firstTime = false;
			if (this.loaded.state() !== 'pending') { return this.loaded.promise(); }
			this.fetch({})
			.then(_(function() {
				this.loaded.resolve();
			}).bind(this))
			.fail(_(function() {			       
				this.loaded.reject();
			}).bind(this));
		}    
		return this.loaded.promise();
	}
});
},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/models/settings-definitions.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
module.exports = Backbone.Model.extend({	
});
},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/views/settings-view.js":[function(require,module,exports){

var $ = require('jquery');
var _ = require('underscore');
var Backbone = require('backbone');
var Translator = require('amp-translate');
var Template = "<% if(obj.isPopup) {%>\r\n<div class=\"panel-heading\">\r\n\t\t\t<button type=\"button\" class=\"close cancel\" aria-hidden=\"true\">x</button>\r\n\t\t\t<h3 class=\"panel-title\" data-i18n=\"amp.settings:title\">Settings</h3>\r\n</div>\r\n<%}%>\r\n<div class=\"panel-body\">\t\t\r\n<div class=\"container-fluid\">\r\n  <div class=\"settings\">\r\n    Loading...\r\n  </div>\r\n  <% if(!obj.isPopup) {%>\r\n  <div class=\"form-group\">\r\n  \t<button type=\"button\" class=\"btn btn-success apply-btn\" data-i18n=\"amp.settings:apply-button\">Apply</button>\r\n  </div>\r\n  <%}%>\r\n</div>\r\n</div>\r\n<% if(obj.isPopup) {%>\r\n<div class=\"panel-footer setting-dialog-footer\">\r\n    <button type=\"button\" class=\"btn btn-warning cancel-btn cancel\" data-i18n=\"amp.settings:cancel-button\">Cancel</button>\r\n  \t<button type=\"button\" class=\"btn btn-success apply-btn\" data-i18n=\"amp.settings:apply-button\">Apply</button>\r\n </div>\r\n <%}%>\r\n \r\n \r\n";
var SelectTemplate = "<div class=\"form-group\">\n  <label class=\"control-label\" data-i18n=\"amp.settings:label-<%= obj.setting.id %>\"><%= obj.setting.name %></label>\n  <select class=\"form-control\" id=\"<%= obj.setting.id %>\">\n  <% _.each(obj.setting.value.options, function(option){ %>\n  <% var selected = obj.settingsSelections[obj.setting.id] || obj.appliedSettings[obj.setting.id];%>\n    <option value=\"<%= option.id %>\"  <% if(selected == option.id){ %> selected <% } %> >\n      <%= option.name %>\n    </option>\n  <%}); %>\n  </select>\n</div>\n";
var SelectAmountUnitTemplate = "<div class=\"form-group\">\n  <label class=\"control-label\" data-i18n=\"amp.settings:label-<%= obj.setting.id %>\"><%= obj.setting.name %></label>\n  <select class=\"form-control\" id=\"<%= obj.setting.id %>\">\n  <% _.each(obj.setting.value.options, function(option){ %>\n  <% var selected = obj.settingsSelections[obj.setting.id] || obj.appliedSettings['amount-format'][obj.setting.id];%>\n    <option value=\"<%= option.value %>\"  <% if(selected == option.value){ %> selected <% } %> >\n      <%= option.name %>\n    </option>\n  <%}); %>\n  </select>\n</div>\n";
var YearRangeTemplate = "<div class=\"form-group\"> \r\n<label data-i18n=\"amp.settings:label-<%= obj.id %>\"><%= obj.name %></label> \r\n <div class=\"row year-range \"> \r\n \r\n </div>  \r\n</div>";
var YearSelectTemplate = "<div class=\"col-xs-2\">\r\n   <label data-i18n=\"amp.settings:label-<%= obj.setting.id %>\" ><%= obj.setting.name %></label>\r\n </div>\r\n  <div class=\"col-xs-4\">\r\n  <select class=\"form-control\" id=\"<%= obj.setting.id %>\">\r\n    <%\r\n      var applied = obj.appliedSettings['year-range'] ? obj.appliedSettings['year-range'][obj.setting.id] : null;\r\n      var selected = obj.settingsSelections[obj.setting.id];\r\n    %>\r\n    <option data-i18n=\"amp.settings:all\" value=\"-1\"<% if((selected || applied) == -1){ %> selected <% } %>>All</option>\r\n    <% for (i = obj.setting.rangeFrom; i <= obj.setting.rangeTo; i++) { %>\r\n      <option value=\"<%= i %>\"<% if((selected || applied) == i){ %> selected <% } %>>\r\n      <%= i %>\r\n      </option>\r\n    <% } %>\r\n  </select>\r\n  </div>";
var Constants = require('../common/constants');

module.exports = Backbone.View.extend({
	template : _.template(Template),
	selectTemplate : _.template(SelectTemplate),
    selectAmountUnitTemplate : _.template(SelectAmountUnitTemplate),
	yearRangeTemplate : _.template(YearRangeTemplate),
	yearSelectTemplate : _.template(YearSelectTemplate),
	events : {
		'click .apply-btn' : 'applySettings',
		'change select' : 'optionChanged',
		'click .cancel' : 'close',
		'click .close' : 'close'
	},
	appliedSettings : {},
	settingsSelections : {},
	initialize : function(options) {
		this.definitions = options.definitions;
		this.isPopup = options.isPopup;
		this.caller = options.caller;
		if (options.translator === undefined) {
			this.createTranslator(true);
		} else {
			this.translator = options.translator;
		}
		this.appliedSettings = {};
		this.settingsSelections = {};
		_.bindAll(this, 'render', 'applySettings', 'updateUI', 'appendSetting', 'appendYearRangeSetting', 'configureUI','selectDefaults');
	},
	render : function() {
		var self = this;
		self.$el.html(self.template({
			isPopup : this.isPopup
		}));		
		
		this.definitions.load().done(function() {
			self.selectDefaults();
			self.updateUI();
			self.$el.show();
		});
		return this;
	},
	selectDefaults: function(){		
		this.settingsSelections = {};
		if(_.isEmpty(this.appliedSettings)){
			this.settingsSelections[Constants.CALENDAR_ID] = this.definitions.findWhere({id : Constants.CALENDAR_ID }).get('value').defaultId;
			this.settingsSelections[Constants.CURRENCY_ID] = this.definitions.findWhere({id : Constants.CURRENCY_ID }).get('value').defaultId;
			if (this.caller === Constants.CONTEXT.REPORTS) {
                this.settingsSelections[Constants.AMOUNT_UNIT_ID] = this.definitions.findWhere({id : Constants.AMOUNT_UNIT_ID }).get('value').defaultId;
            }
			
			var fundingType = this.definitions.findWhere({id : Constants.FUNDING_TYPE_ID });
			if (this.caller !== Constants.CONTEXT.DASHBOARDS && fundingType) {
			   this.settingsSelections[Constants.FUNDING_TYPE_ID] = fundingType.get('value').defaultId;
			}
			
			var yearRangeSetting = this.definitions.findWhere({
				id : Constants.YEAR_RANGE_ID
			});
			if (yearRangeSetting) {				
				this.settingsSelections[Constants.YEAR_FROM_ID] = _.findWhere(yearRangeSetting.get('value'), {id: Constants.YEAR_FROM_ID}).value.defaultId;
				this.settingsSelections[Constants.YEAR_TO_ID] = _.findWhere(yearRangeSetting.get('value'), {id: Constants.YEAR_TO_ID}).value.defaultId;
			}			
		}
	},
	configureUI : function() {
		if (this.isPopup) {
			this.$el.addClass('panel panel-primary amp-settings-dialog');
			this.$('.panel-heading').show();
			this.$('.cancel-settings').show();
		} else {
			this.$('.panel-heading').hide();
			this.$('.cancel-settings').hide();
		}
	},
	updateUI : function() {
		this.configureUI();
		this.$('.settings').html('');
		this.appendSetting(Constants.CALENDAR_ID);
		this.appendSetting(Constants.CURRENCY_ID);
        if (this.caller === Constants.CONTEXT.REPORTS) {
            this.appendAmountUnitSetting();
        }
		if (this.caller !== Constants.CONTEXT.DASHBOARDS) {
			this.appendSetting(Constants.FUNDING_TYPE_ID);
		}
		this.appendYearRangeSetting();
		this.translate(this.$el);
	},
	appendSetting : function(settingID) {
		var setting = this.definitions.findWhere({
			id : settingID
		});
		if (setting) {
			this.$('.settings').append(this.selectTemplate({
				setting : setting.toJSON(),
				appliedSettings : this.appliedSettings,
				settingsSelections: this.settingsSelections
			}));
			if (settingID === Constants.CURRENCY_ID && _.isUndefined(this.allCurrencies)) {
				this.allCurrencies = setting.get('value').options;
			}
		}		
	},
	appendAmountUnitSetting : function() {
		var setting = this.definitions.findWhere({
			id : Constants.AMOUNT_UNIT_ID
		});
		if (setting) {
			this.$('.settings').append(this.selectAmountUnitTemplate({
				setting : setting.toJSON(),
				appliedSettings : this.appliedSettings,
				settingsSelections: this.settingsSelections
			}));
		}
	},
	appendYearRangeSetting : function() {
		var yearRangeSetting = this.definitions.findWhere({
			id : Constants.YEAR_RANGE_ID
		});
		if (yearRangeSetting) {
			this.$('.settings').append(this.yearRangeTemplate(yearRangeSetting.toJSON()));
			this.appendYearSelect(yearRangeSetting.get('value'), Constants.YEAR_FROM_ID);
			this.appendYearSelect(yearRangeSetting.get('value'), Constants.YEAR_TO_ID);
		}
	},
	appendYearSelect : function(yearRangeSetting, settingID) {
		var setting = {
			"name" : settingID,
			"id" : settingID,
			"rangeFrom" : yearRangeSetting['rangeFrom'],
			"rangeTo" : yearRangeSetting['rangeTo'],
			"from" : yearRangeSetting['from'],
			"to" : yearRangeSetting['to']
		};

		this.$('.year-range').append(this.yearSelectTemplate({
			setting : setting,
			appliedSettings : this.appliedSettings,
			settingsSelections: this.settingsSelections
		}));
	},
	getCurrenciesByCalendar : function(calendarId) {
		var calendarCurrencies = this.definitions.findWhere({
			id : Constants.CALENDAR_CURRENCIES_ID
		});
		var currencies = [];
		if (calendarCurrencies) {
			currencies = _.uniq(_.findWhere(calendarCurrencies.get('value').options, {
				id : calendarId
			}).value.split(','));
		}
		return currencies;
	},
	optionChanged : function(evt) {
		var self = this;
		var settingID = $(evt.currentTarget).attr('id');
		var selectedID = $(evt.currentTarget).val();
		this.updateSelected(settingID, selectedID);
		if (settingID === Constants.CALENDAR_ID) {
			this.updateCurrencyList(selectedID);
			this.updateUI();
		}
	},
	updateCurrencyList : function(selectedCalendarId) {
		var self = this;
		// update currency select when calendar changes
		var availableCurrenciesForCalendar = self.getCurrenciesByCalendar(selectedCalendarId);
		self.definitions.get(Constants.CURRENCY_ID).get('value').options = [];
		$.each(availableCurrenciesForCalendar, function(index, object) {
			self.definitions.get(Constants.CURRENCY_ID).get('value').options.push(_.find(self.allCurrencies, function(item) {
				return item.id === object
			}));
		});
		
		
		var selectedCurrency = _.filter(availableCurrenciesForCalendar, function(curr){ return curr === self.settingsSelections[Constants.CURRENCY_ID] ; })[0];
		var appliedCurrency = _.filter(availableCurrenciesForCalendar, function(curr){ return curr === self.appliedSettings[Constants.CURRENCY_ID] ; })[0];
		var firstCurrency = availableCurrenciesForCalendar[0];
		this.updateSelected(Constants.CURRENCY_ID, selectedCurrency || appliedCurrency || firstCurrency);	
	},
	updateSelected : function(settingID, selectedID) {
		// store user selections in a temp object - only transfered to the applied settings if the apply button is clicked
		this.settingsSelections[settingID] = selectedID;
	},
    updateAppliedSettings: function () {
        // transfer user selections to applied settings object
        var self = this;
        _.each(this.settingsSelections, function (selectedID, settingID) {
            if (settingID === Constants.YEAR_FROM_ID || settingID === Constants.YEAR_TO_ID) {
                if (_.isUndefined(self.appliedSettings[Constants.YEAR_RANGE_ID])) {
                    self.appliedSettings[Constants.YEAR_RANGE_ID] = {};
                }
                self.appliedSettings[Constants.YEAR_RANGE_ID][settingID] = selectedID;
            } else {
                self.appliedSettings[settingID] = selectedID;
                if (settingID === Constants.AMOUNT_UNIT_ID) {
                    self.appliedSettings[Constants.AMOUNT_FORMAT_ID][Constants.AMOUNT_UNIT_ID] = Number(selectedID);
                }
            }
        });
        this.settingsSelections = {};
    },
	getCurrent : function() {
		return this.appliedSettings;
	},
	restoreFromSaved : function(state) {
		var self = this;
		_.each(state, function(v, k) {
			self.appliedSettings[k] = v;
		});
		this.updateUI();
	},
	applySettings : function() {
		this.updateAppliedSettings();
		this.trigger('applySettings', this.appliedSettings);
	},
	close : function() {
		this.settingsSelections = {};
		this.trigger('close');
	},
	createTranslator : function(force) {
		var self = this;
		var translateKeys = JSON.parse("{\r\n  \"amp.settings:title\": \"Settings\",\r\n  \"amp.settings:label-calendar-id\": \"Calendar\",\r\n  \"amp.settings:label-currency-code\": \"Currency\",\r\n  \"amp.settings:label-funding-type\": \"Funding Type\",\r\n  \"amp.settings:label-year-range\": \"Year Range\",\r\n  \"amp.settings:label-from\": \"From:\",\r\n  \"amp.settings:label-to\": \"To:\",\r\n  \"amp.settings:apply-button\" : \"Apply\",\r\n  \"amp.settings:cancel-button\": \"Cancel\",\r\n  \"amp.settings:all\": \"All\"\r\n}");
		if (force === true || self.translator === undefined) {
			self.translator = new Translator({
				defaultKeys : translateKeys
			});
		}
	},
	translate : function(target) {
		var element = this;
		if (target !== undefined) {
			element = target;
		}
		if (element.el !== undefined) {
			this.translator.translateDOM(element.el);
		} else {
			this.translator.translateDOM(element);
		}
	}

});
},{"../common/constants":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-settings/src/common/constants.js","amp-translate":"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-state/index.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


function StateLoadError(message, original) {
  if (!(this instanceof StateLoadError)) { return new SateLoadError(message, original); }
  this.message = message;
  this.original = original;

  this.toString = function() {
    return this.message;
  };

  return this;
}


function State() {
  'use strict';

  if (!(this instanceof State)) {
    throw new Error('State needs to be created with the `new` keyword.');
  }

  this.initialize.apply(this, arguments);
}


_.extend(State.prototype, Backbone.Events, {

  initialize: function(options) {
    this.saved = options.saved;
    // Anything that state must register itself. See `State.register`.
    this._stateRegistry = {};
    // When loading state, some things might not have registered yet.
    // It gets marked as unclaimed, and stored here.
    this._unclaimed = {};
    // use the url, if we have it
    if (options.url) {
      this.listenToURL(_(options).pick('url', 'prefix', 'autoinit'));
    }
  },

  listenToURL: function(options) {
    this._url = options.url;
    this._urlPrefixes = options.prefix || ['saved/'];

    // wrap prefixes in array to make backward compat:
    if (this._urlPrefixes.constructor !== Array){
      this._urlPrefixes = [this._urlPrefixes];
    }

    this.listenTo(this._url, 'change', this.urlMaybeLoad);
    if (options.autoinit && this._url.hash()) {
      this.urlMaybeLoad(this._url.hash());
    }  // initial state
  },

  urlMaybeLoad: function(hash) {
    var self = this;
    var matchFound = false;
    hash = hash || this._url.hash();

    // see if any prefixes match the hash.
    _.each(this._urlPrefixes, function(prefix){
      // load a state if we get the URL hash for one
      if (hash.indexOf(prefix) === 0) {
        var state_or_id = hash.split(prefix)[1];
        if (state_or_id) {
          matchFound = true;
          self[self.saved ? 'loadById' : 'load'](state_or_id, prefix);
        }
      }
    });
    if (!matchFound && hash === '') {
      self.reset();
    }
  },

  toHash: function(state_or_id) {
    if (!_(this).has('_url')) {
      console.error('Cannot generate URL hash without being initialized with URL instance');
    } else {
      return this._urlPrefixes[0] + state_or_id;
    }
  },

  loadById: function(id, matchedPrefix) {
    this.loadPromise = this.saved.load(id, matchedPrefix  );// TODO: drs: and pass matching prefix..
    this.loadPromise
      .done(_(function(stateModel) {
        this.load(stateModel.get('stateBlob'));
      }).bind(this))
      .fail(function() {
        throw new StateLoadError('Could not load state by id: ' + id);
      });
  },

  load: function(statesBlob) {
    var parsed = this.parse(statesBlob);

    var changed = false;
    _.each(parsed, function(stateToSet, id) {
      var current = this._stateRegistry[id];
      if (_.isUndefined(current)) {
        this._unclaimed[id] = stateToSet;
      } else if (!_.isEqual(current.get(), stateToSet)) {
        current.set(stateToSet);
        changed = true;
      }
    }, this);

    this.trigger('load');
    if (changed) {
      this.trigger('change');
    }
  },

  parse: function(statesBlob) {
    // break out the call to JSON.parse so that load can still be optimized
    var parsed;
    try {
      parsed = JSON.parse(statesBlob);
    } catch (e) {
      if (e instanceof SyntaxError) {
        throw new StateLoadError('Could not parse state', e);
      } else {
        throw e;
      }
    }
    return parsed;
  },

  reset: function() {
    // Restore all states to their defaults (specified at registration)
    var changed = false;
    _.each(this._stateRegistry, function(state) {
      var currentState = state.get();
      if (!_.isEqual(currentState, state.empty)) {
        // only call .set if resetting will actually change the state.
        state.set(state.empty);
        changed = true;
      }
    }, this);

    this.trigger('reset');
    if (changed) {
      this.trigger('change');
    }
  },

  
  filtersLoaded: function() {
	  var dfd = jQuery.Deferred();
	  var self = this;
	  var timer = setInterval(function() {
		  if (self._stateRegistry.filters !== undefined) {
			  clearInterval(timer);
			  dfd.resolve();
		  }
	  }, 1000);
	  return dfd.promise(); 
  },
  
  
  freeze: function(options) {
    options = options || {};
    var stateSnapshot = {};
    _.each(this._stateRegistry, function(state, id) {
      var currentState = state.get();
      stateSnapshot[id] = _.clone(currentState);  // TODO: deep clone(!!)
    });
    var statesBlob = JSON.stringify(stateSnapshot);
    if (options.toURL) {
      if (!this._url) { console.error('State cannot change URL if it does have a ref to it'); }
      this._url.hash(this._urlPrefixes[0] + encodeURIComponent(statesBlob));
    }
    this.trigger('freeze', statesBlob);
    return statesBlob;
  },

  register: function(registrable, id, options) {
    if (id in this._stateRegistry) {
      throw new Error('Attempted registration of duplicate state id ' + id);
    }

    // register the state
    this._stateRegistry[id] = {
      get: _.bind(options.get, registrable),
      set: _.bind(options.set, registrable),
      empty: options.empty
    };

    // set to the currently loaded state, or its default empty state
    if (id in this._unclaimed) {
      this._stateRegistry[id].set(this._unclaimed[id]);
      delete this._unclaimed[id];
    } else {
      this._stateRegistry[id].set(options.empty);
    }

    this.trigger('register');
  }
});


State.StateLoadError = StateLoadError;
module.exports = State;

},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js":[function(require,module,exports){
// TODO: move this up a dir, and instantiate and attach to the app


var _ = require('underscore');
var $ = require('jquery');
var Backbone = require('backbone');

function Translator(options) {
  'use strict';

  if (!(this instanceof Translator)) {
    throw new Error('Translator needs to be created with the `new` keyword.');
  }

  // this is the object that has all  the key value pairs for the widget.
  var translatorDefaults = {
    defaultKeys: {},
    availableLanguages: null,// backbone collection
    translations: {
      locales: {
        en:null
      }
    },
    ajax: $.ajax
  };

  /* Gather options */
  if (options) {
    /* Especially useful for overwriting defaultKeys, availableLanguages and translations */
    _.defaults(this, options, translatorDefaults);
  }

  this._promise = null;
  this._currentLng = 'tmp';
  this._firstGet = null;

  // TODO: add support for local storage with timestamp
  this.initTranslations = function get() {
    var self = this;


    // try web
    this._promise = this.getTranslations(self.defaultKeys)
      .fail(function(jqXHR, textStatus, errorThrown) {
        console.error('failed ', jqXHR, textStatus, errorThrown);
      });
    this.promise = this._promise.promise();
  };

  /* Use this for adding more defaultKeys or translations by module
   * if translator has already been instantiated
   */
  this.addTranslatorOptions = function(options) {
    /* force a request from API next time */
    _.defaults(this.defaultKeys, options.defaultKeys);
    this._firstGet = null;
  };


  this.getAvailableLanguages = function() {
    var deferred = $.Deferred();

    if (this.availableLanguages) {
      deferred.resolve(this.availableLanguages);
    } else {
      this._initAvailableLanguages().then(function() {
        deferred.resolve(this.availableLanguages);
      });
    }

    return deferred;
  };

  this._initAvailableLanguages = function() {
    this.availableLanguages = new Backbone.Collection([]);
    this.availableLanguages.url = '/rest/translations/languages';
    return this.availableLanguages.fetch();
  };


  // important to let the api know, so all responses are translated.
  this.setLanguage = function(lng) {
    this._currentLng = lng;
    return this._apiCall('/rest/translations/languages/' + lng, null, 'GET');
  };


  this.translateDOM = function(el) {
    var $newEl = $(el);
    /* TODO(tdk): We identified a major bug here where root immediate child
     *  template elements with translations are not being caught by this
     *  selector.
     *
     *  To workaround, we should clone, wrap, run the selector and unwrap the DOM.
     *
     *  Remember this has to work for el's around the app that are bound
     *  and not bound.
     */

    return this.getTranslations().then(function(data) {
      $.each(data, function(key, value) {
        /*if ($('[data-i18n="' + key + '"]', $newEl).length > 0) {
         console.log(key, '->', value,' $ found->', $newEl.find('[data-i18n="' + key + '"]').text());
         }*/

        // We need a way to identify controls where the placeholder needs to be translated instead of the text.
        if (key.indexOf('[placeholder]') > -1) {
          $('[data-i18n="' + key + '"]', $newEl).attr('placeholder', value);
        } else if (key.indexOf('[title]') > -1) {
          $('[data-i18n="' + key + '"]', $newEl).attr('title', value);
        } else {
          $('[data-i18n="' + key + '"]', $newEl).text(value);
        }
      });
      return $newEl;
    });
  };


  /*
   * Pass in a {"amp.gis:data-i18n-code": "base lang words", ...} object for
   * translation e.g. page title
   * */
  // TODO: don't call it a list if it's an object ?!
  this.translateList = function(list) {

    // update translateable elements in this key-value set
    var _updateList = function(list, i18nData) {
      _.each(list, function(value, key, list) {
        if (i18nData[key]) {
          list[key] = i18nData[key];
        } else {
          list[key] = key[value];
        }
      });
      return list;
    };

    return this.getTranslations().then(function(i18nData) {
      var outList = _updateList(list, i18nData);
      return outList;
    });
  };


  /*
   * Synchronously get a (already-loaded) translation
   */
  this.translateSync = function(key, alt) {
    if (this.getTranslations().state() !== 'resolved') {
      console.error('translateSync was called when getTranslations is not successfully resolved');
    }
    var translated = this.translations.locales[this._currentLng][key];
    if (translated === undefined) {
      console.warn('No translation has been loaded for', key);
      translated = alt || key;
    }
    return translated;
  };


  // Only do single request on launch.
  this.getTranslations = function() {
    // this way won't work with change languages mid way though.
    if (!this._firstGet) {
      this._firstGet = this._getTranslationsFromAPI(this.defaultKeys, this._currentLng);
    }
    return this._firstGet;
  };


  this._getTranslationsFromAPI = function(translateables, lng) {
    var self = this;
    var url = '/rest/translations/label-translations';

    return this._apiCall(url, translateables, 'POST').then(function(data) {
      //cache if we know the lng. TODO: get api to always return the lng.
      if (lng) {
        self.translations.locales[lng] = data;
      } else {
        // temp hack to do caching if API doesn't return current lng
        lng = this._currentLng;
        self.translations.locales[lng] = data;
      }

      return data;
    });
  };


  // helper to wrap api call
  this._apiCall = function(url, data, type) {
    var ajaxOptions = {
      headers: {
        // jscs:disable disallowQuotedKeysInObjects
        'Accept': 'application/json',
        'Content-Type': 'application/json'
        // jscs:enable disallowQuotedKeysInObjects
      },
      type: type,
      url: url,
      dataType: 'json'
    };
    if (data) {
      ajaxOptions.data = JSON.stringify(data);
    }

    return this.ajax(ajaxOptions);
  };

  this.initTranslations();
}

module.exports = Translator;

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/ampTemplate/node_modules/amp-url/index.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


function URL() {
  'use strict';
  if (!(this instanceof URL)) {
    throw new Error('URL needs to be created with the `new` keyword.');
  }
  if (window._ampUrler) {
    throw new Error('Another instance of URL is already managing window.location');
  } else {
    window._ampUrler = true;
  }
  this.initialize.apply(this, arguments);
}


_.extend(URL.prototype, Backbone.Events, {

  initialize: function(options) {
    options = options || {};
    this.root = options.root || window.location.host + window.location.pathname;
    _.bindAll(this, 'change');
    window.addEventListener('hashchange', this.change);  // IE 8+
  },

  hash: function(newHash, options) {
    if (!arguments.length) {
      return window.location.hash.slice(1);  // remove '#'
    } else {
      if (options.silent) { window.removeEventListener('hashchange', this.change); }  // IE 9+
      window.location.hash = newHash;
      if (options.silent) { window.addEventListener('hashchange', this.change); }
    }
  },

  full: function() {
    return '' + window.location;
  },

  change: function() {
    this.trigger('change', this.hash());
  }

});


module.exports = URL;

},{"backbone":"backbone","underscore":"underscore"}],"/home/viorel/IdeaProjects/amp/amp/TEMPLATE/reamp/tools/log/index.js":[function(require,module,exports){
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var _debug = __webpack_require__(1);

	var _debug2 = _interopRequireDefault(_debug);

	exports["default"] = function (slug) {
	  var res = {
	    log: (0, _debug2["default"])(slug),
	    err: (0, _debug2["default"])(slug),
	    warn: (0, _debug2["default"])(slug),
	    onDebug: (0, _debug2["default"])(slug)
	  };
	  res.err.log = Function.prototype.bind.call(console.error, console);
	  res.warn.log = Function.prototype.bind.call(console.warn, console);
	  res.onDebug.log = function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    for (var index in args) {
	      if ("function" == typeof args[index]) {
	        args[index]();
	        break;
	      }
	    }
	  };
	  return res;
	};

	module.exports = exports["default"];

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(2);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(3);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 3 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ }
/******/ ]);
},{}]},{},["./app/js/app.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuL2FwcC9qcy9hcHAuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2FwcC1jbGFzcy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvYmFja2JvbmUtZGFzaC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL19iYXIuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9faGVhdG1hcC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL19tdWx0aWJhci5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL19waWUuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9fdGFibGUuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9jaGFydC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL2NvbW1vbi5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL2N1c3RvbWl6ZWQvaGVhdE1hcENoYXJ0LmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9jaGFydHMvY3VzdG9taXplZC9tdWx0aUJhckNoYXJ0LmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9jaGFydHMvY3VzdG9taXplZC9waWVDaGFydC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hlY2stc3VwcG9ydC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2FtcC11c2VyLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvY2hhcnQtYWlkLXByZWRpY3RhYmlsaXR5LmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvY2hhcnQtZnVuZGluZy10eXBlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvY2hhcnQtaGVhdG1hcHMuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9jaGFydC1tb2RlbC1iYXNlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvY2hhcnQtdG9wcy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2NoYXJ0cy1jb2xsZWN0aW9uLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvZW5hYmxlZC1jaGFydHMtY29sbGVjdGlvbi5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2hlYXRtYXBzLWNvbmZpZy1jb2xsZWN0aW9uLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvc2F2ZWQtZGFzaC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL3NhdmVkLWRhc2hlcy1jb2xsZWN0aW9uLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC1haWQtcHJlZGljdGFiaWxpdHkuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2NoYXJ0LWZ1bmRpbmctdHlwZS5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvY2hhcnQtaGVhdG1hcHMuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2NoYXJ0LXRvcHMtaW5mby1tb2RhbC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvY2hhcnQtdG9wcy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvY2hhcnQtdmlldy1iYXNlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydHMuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2NvbnRyb2xzLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9kb3dubG9hZC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvZmFpbC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvZmlsdGVycy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvbWFpbi5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3Mvc2V0dGluZ3MuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL3NoYXJlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL3VnbHkvbGliLWxvYWQtaGFja3MuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvdWdseS9saWItc3JjL2NhbnZnLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL3VnbHkvbGliLXNyYy9yZ2Jjb2xvci5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy91Z2x5L3VuZGVyc2NvcmUtdHJhbnNwb3NlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL3VnbHkvdXRpbC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L25vZGVfbW9kdWxlcy9iYWJ5cGFyc2UvYmFieXBhcnNlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvbm9kZV9tb2R1bGVzL251bWVyYWwvbnVtZXJhbC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L25vZGVfbW9kdWxlcy9udmQzL2J1aWxkL252LmQzLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvaW5kZXguanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvc3JjL2NvbGxlY3Rpb25zL2FtcC1tZW51cy1jb2xsZWN0aW9uLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvc3JjL2NvbGxlY3Rpb25zL2xhbmd1YWdlLWNvbGxlY3Rpb24uanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9zcmMvbW9kZWxzL2FtcC1sYXlvdXQtbW9kZWwuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9zcmMvbW9kZWxzL2FtcC1tZW51cy1tb2RlbC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWJvaWxlcnBsYXRlL3NyYy9tb2RlbHMvc2V0dGluZ3MuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9zcmMvdmlld3MvYWJvdXQtdmlldy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWJvaWxlcnBsYXRlL3NyYy92aWV3cy9mb290ZXItdmlldy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWJvaWxlcnBsYXRlL3NyYy92aWV3cy9oZWFkZXItdmlldy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWJvaWxlcnBsYXRlL3NyYy92aWV3cy9zdWJtZW51LWNvbXBvc2l0ZXZpZXcuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9zcmMvdmlld3MvdXNlci1wcm9maWxlLXZpZXcuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvbm9kZV9tb2R1bGVzL2pxdWVyeS11aS9jb3JlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvZGF0ZXBpY2tlci5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL2RyYWdnYWJsZS5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL21vdXNlLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvd2lkZ2V0LmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9jb2xsZWN0aW9ucy9hbGwtZmlsdGVycy1jb2xsZWN0aW9uLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9saWIvanF1ZXJ5LXVpLWkxOG4uanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL2xpYi9qcXVlcnkubm91aXNsaWRlci5taW4uanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21haW4uanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21vZGVscy9iYXNlLWZpbHRlci1tb2RlbC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvbW9kZWxzL2dlbmVyaWMtZmlsdGVyLW1vZGVsLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9tb2RlbHMvb3JnLXJvbGUtZmlsdGVyLW1vZGVsLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9tb2RlbHMveWVhcnMtZmlsdGVyLW1vZGVsLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9tb2RlbHMveWVhcnMtb25seS1maWx0ZXItbW9kZWwuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3RyZWUvdHJlZS1ub2RlLW1vZGVsLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy90cmVlL3RyZWUtbm9kZS12aWV3LmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy91dGlscy9kYXRlLXV0aWxzLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy92aWV3cy9iYXNlLWZpbHRlci12aWV3LmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy92aWV3cy9maWx0ZXJzLXZpZXcuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL2dlbmVyaWMtZmlsdGVyLXZpZXcuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL3RvcC1sZXZlbC1maWx0ZXItdmlldy5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvdmlld3MveWVhcnMtZmlsdGVyLXZpZXcuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL3llYXJzLW9ubHktZmlsdGVyLXZpZXcuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1zZXR0aW5ncy9zcmMvY29sbGVjdGlvbnMvc2V0dGluZ3MtZGVmaW5pdGlvbnMtY29sbGVjdGlvbi5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLXNldHRpbmdzL3NyYy9jb21tb24vY29uZmlnLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtc2V0dGluZ3Mvc3JjL2NvbW1vbi9jb25zdGFudHMuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1zZXR0aW5ncy9zcmMvaW5kZXguanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1zZXR0aW5ncy9zcmMvbW9kZWxzL2dlbmVyYWwtc2V0dGluZ3MuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1zZXR0aW5ncy9zcmMvbW9kZWxzL3NldHRpbmdzLWRlZmluaXRpb25zLmpzIiwiL2hvbWUvdmlvcmVsL0lkZWFQcm9qZWN0cy9hbXAvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtc2V0dGluZ3Mvc3JjL3ZpZXdzL3NldHRpbmdzLXZpZXcuanMiLCIvaG9tZS92aW9yZWwvSWRlYVByb2plY3RzL2FtcC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1zdGF0ZS9pbmRleC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLXRyYW5zbGF0ZS9pbmRleC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLXVybC9pbmRleC5qcyIsIi9ob21lL3Zpb3JlbC9JZGVhUHJvamVjdHMvYW1wL2FtcC9URU1QTEFURS9yZWFtcC90b29scy9sb2cvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzViQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzRGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWxXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwdUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ovREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJyZXF1aXJlKCcuL3VnbHkvbGliLWxvYWQtaGFja3MnKTtcbnZhciBqcXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIFVzZXJNb2RlbCA9IHJlcXVpcmUoJy4vYXBwL21vZGVscy9hbXAtdXNlci5qcycpO1xudmFyIEFwcCA9IHJlcXVpcmUoJy4vYXBwL2FwcC1jbGFzcycpO1xudmFyIGFwcCA9IG5ldyBBcHAoeyBlbDogJyNhbXAtZGFzaGJvYXJkJyB9KTtcbndpbmRvdy5hcHAgPSBhcHA7ICAvLyBmb3IgZGVidWdnaW5nIGNvbnZlbmllbmNlXG5cbi8vRm9yY2UgY2FsbCB0byB0aGUgRVAgdGhhdCBzZW5kcyB0aGUgc2F2ZWQgZmlsdGVycyBpZiBhbnkuXG5hcHAuc3RhdGUuc2F2ZWQubG9hZCgpO1xuLy9hcHAucmVuZGVyKCk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBEZWZlcnJlZCA9IHJlcXVpcmUoJ2pxdWVyeScpLkRlZmVycmVkO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4vYmFja2JvbmUtZGFzaCcpO1xudmFyIHN1cHBvcnRDaGVjayA9IHJlcXVpcmUoJy4vY2hlY2stc3VwcG9ydCcpO1xudmFyIFVSTFNlcnZpY2UgPSByZXF1aXJlKCdhbXAtdXJsL2luZGV4Jyk7XG52YXIgU3RhdGUgPSByZXF1aXJlKCdhbXAtc3RhdGUvaW5kZXgnKTtcbnZhciBTdGF0ZUxvYWRFcnJvciA9IHJlcXVpcmUoJ2FtcC1zdGF0ZS9pbmRleCcpLlN0YXRlTG9hZEVycm9yO1xuXG52YXIgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ2FtcC10cmFuc2xhdGUnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCdhbXAtZmlsdGVyL3NyYy9tYWluJyk7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCdhbXAtc2V0dGluZ3Mvc3JjL2luZGV4Jyk7XG52YXIgVXNlck1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbHMvYW1wLXVzZXIuanMnKTtcbnZhciBTYXZlZERhc2hlcyA9IHJlcXVpcmUoJy4vbW9kZWxzL3NhdmVkLWRhc2hlcy1jb2xsZWN0aW9uLmpzJyk7XG52YXIgTWFpblZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL21haW4nKTtcbnZhciBGYWlsVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvZmFpbCcpO1xuXG5cbmZ1bmN0aW9uIEFwcCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFwcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FwcCBuZWVkcyB0byBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgfVxuICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuXG5fLmV4dGVuZChBcHAucHJvdG90eXBlLCBCYWNrYm9uZURhc2guRXZlbnRzLCB7XG5cdFxuICByZW5kZXJlZDogZmFsc2UsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBfaW5pdERlZmVyID0gbmV3IERlZmVycmVkKCksXG4gICAgICAgIG1pc3NpbmdGZWF0dXJlcztcbiAgICB0aGlzLmluaXRpYWxpemVkID0gX2luaXREZWZlci5wcm9taXNlKCk7XG5cbiAgICB0cnkge1xuICAgIFx0XG4gICAgXHR0aGlzLnVzZXIgPSBuZXcgVXNlck1vZGVsKClcblxuICAgICAgLy8gY2hlY2sgb3VyIHN1cHBvcnQgbGV2ZWxcbiAgICAgIHRoaXMuYnJvd3Nlcklzc3VlcyA9IHN1cHBvcnRDaGVjaygpO1xuICAgICAgXyh0aGlzLmJyb3dzZXJJc3N1ZXMpLmNoYWluKClcbiAgICAgICAgLmdyb3VwQnkoJ3NldmVyaXR5JylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oc2V2ZXJpdHlHcm91cCwgc2V2ZXJpdHkpIHtcbiAgICAgICAgICBtaXNzaW5nRmVhdHVyZXMgPSBfKHNldmVyaXR5R3JvdXApLnBsdWNrKCdmZWF0dXJlJykuam9pbignLCAnKTtcbiAgICAgICAgICBpZiAoc2V2ZXJpdHkgPT09ICdjcml0aWNhbCcpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbmFtZTogJ0luY29tcGF0aWJsZSBXZWIgQnJvd3NlcicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdEYXNoYm9hcmRzIGNhbm5vdCB3b3JrIHdpdGhvdXQgdGhlc2UgZmVhdHVyZXMsIHdoaWNoIGFyZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzdXBwb3J0ZWQgYnkgeW91ciB3ZWIgYnJvd3NlcjogJyArIG1pc3NpbmdGZWF0dXJlcyArICcuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnQW55IDxhIGhyZWY9XCJodHRwOi8vYnJvd3NlaGFwcHkuY29tL1wiPm1vZGVybiBicm93c2VyPC9hPiB3aWxsIHdvcmsuJyxcbiAgICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNldmVyaXR5ID09PSAnbWFqb3InKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydCgnTGltaXRlZCBzdXBwb3J0IGZvciBvbGQgd2ViIGJyb3dzZXJzJywgW1xuICAgICAgICAgICAgICAnWW91ciBicm93c2VyIGRvZXMgbm90IHByb3ZpZGUgc29tZSBmZWF0dXJlcyB1c2VkIGJ5IERhc2hib2FyZHM6ICcgK1xuICAgICAgICAgICAgICBtaXNzaW5nRmVhdHVyZXMgKyAnLicsXG4gICAgICAgICAgICAgICdTb21lIGZlYXR1cmVzIG1heSBub3Qgd29yayBjb3JyZWN0bHksIGhvd2V2ZXIgYW55ICcgK1xuICAgICAgICAgICAgICAnPGEgaHJlZj1cImh0dHA6Ly9icm93c2VoYXBweS5jb20vXCI+bW9kZXJuIGJyb3dzZXI8L2E+IHdpbGwgcHJvdmlkZSAnICtcbiAgICAgICAgICAgICAgJ2EgYmV0dGVyIGV4cGVyaWVuY2UuJ10pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2V2ZXJpdHkgPT09ICdtaW5vcicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhpcyBicm93c2VyIGlzIG1pc3Npbmcgc3VwcG9ydCBmb3InLCBtaXNzaW5nRmVhdHVyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIGluamVjdCBkb3dubG9hZGlmeSBpZiB3ZSBoYXZlIG5vIGRvd25sb2FkIGJ1dCBoYXZlIGZsYXNoIChJRSlcbiAgICAgIGlmICh0aGlzLmhhc0lzc3VlKCdkb3dubG9hZCcpICYmICF0aGlzLmhhc0lzc3VlKCdmbGFzaCcpKSB7XG4gICAgICAgIHZhciBzd2ZPYmogPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgICAgICAgIGRvd25sb2FkaWZ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHN3Zk9iai5zcmMgPSAnL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2NvbW1vbkpzL3N3Zm9iamVjdC0yLjIuanMnO1xuICAgICAgICBkb3dubG9hZGlmeS5zcmMgPSAnL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2NvbW1vbkpzL2Rvd25sb2FkaWZ5LTAuMi5qcyc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3dmT2JqKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZGlmeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGluaXRpYWxpemUgYXBwIHNlcnZpY2VzXG4gICAgICB0aGlzLnVybCA9IG5ldyBVUkxTZXJ2aWNlKCk7XG4gICAgICB0aGlzLnNhdmVkRGFzaGVzID0gbmV3IFNhdmVkRGFzaGVzKFtdLCB7IGFwcDogdGhpcyB9KTtcbiAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoe1xuICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICBzYXZlZDogdGhpcy5zYXZlZERhc2hlc1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIHRyeSB0byBsb2FkIGFuIGluaXRpYWwgc3RhdGUgZnJvbSB0aGUgdXJsXG4gICAgICB0cnkge1xuICAgIFx0ICB0aGlzLnN0YXRlLnVybE1heWJlTG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU3RhdGVMb2FkRXJyb3IpIHtcbiAgICAgICAgXHQgIHRoaXMucmVwb3J0KCdDb3VsZCBub3QgbG9hZCBzYXZlZCBkYXNoYm9hcmQnLCBbJ0lmIHlvdSBhcmUgdHJ5aW5nIHRvIGxvYWQgYSBzaGFyZWQgbGluaywgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgZW50aXJlIFVSTCB3YXMgY29waWVkJ10pO1xuICAgICAgICBcdCAgdGhpcy51cmwuaGFzaCgnJyk7ICAvLyBjbGVhciB0aGUgYmFkIHNhdmVkLXN0YXRlIGhhc2hcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICBcdCAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXNoYm9hcmRUcmFuc2xhdGVLZXlzID0gSlNPTi5wYXJzZShcIntcXG5cXFwiYW1wLmNvbW1vbjpmb290ZXJcXFwiOiBcXFwiRGV2ZWxvcGVkIGluIHBhcnRuZXJzaGlwIHdpdGggT0VDRCwgVU5EUCwgV0IsIEdvdmVybm1lbnQgb2YgRXRoaW9waWEgYW5kIERHXFxcIixcXG5cXG5cXFwiYW1wLmNvbW1vbjp0aXRsZVxcXCI6IFxcXCJBTVBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWRlc2t0b3BcXFwiOiBcXFwiRGVza3RvcFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtbXktZGVza3RvcFxcXCI6IFxcXCJNeSBEZXNrdG9wXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1hZGQtdGFiXFxcIjogXFxcIkFkZCBUYWJcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLXRhYi1tYW5hZ2VyXFxcIjogXFxcIlRhYiBNYW5hZ2VyXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1yZXBvcnRzXFxcIjogXFxcIlJlcG9ydHNcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWFsbC1yZXBvcnRzXFxcIjogXFxcIkFsbCBSZXBvcnRzXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1mYXYtcmVwb3J0c1xcXCI6IFxcXCJGYXZvdXJpdGUgUmVwb3J0c1xcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtcmVwb3J0LWdlbmVyYXRvclxcXCI6IFxcXCJSZXBvcnQgR2VuZXJhdG9yXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1zYWlrdVxcXCI6IFxcXCJTYWlrdVxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtZG9jdW1lbnRzXFxcIjogXFxcIkRvY3VtZW50c1xcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtZGFzaGJvYXJkc1xcXCI6IFxcXCJEYXNoYm9hcmRzXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1naXNcXFwiOiBcXFwiTmV3IEdJUyAoQkVUQSlcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWRhc2hib2FyZHNcXFwiOiBcXFwiTmV3IERhc2hib2FyZCAoQkVUQSlcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWRhc2hib2FyZC1nZW5lcmF0b3JcXFwiOiBcXFwiRGFzaGJvYXJkIEdlbmVyYXRvclxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtZG9ub3ItcHJvZmlsZVxcXCI6IFxcXCJEb25vciBQcm9maWxlXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1yZWdpb24tcHJvZmlsZVxcXCI6IFxcXCJSZWdpb24gUHJvZmlsZVxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtc2VjdG9yLXByb2ZpbGVcXFwiOiBcXFwiU2VjdG9yIFByb2ZpbGVcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWV4ZWN1dGluZy1wcm9maWxlXFxcIjogXFxcIkV4ZWN1dGluZyBBZ2VuY3kgUHJvZmlsZVxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYmVuZWZpY2lhcnktcHJvZmlsZVxcXCI6IFxcXCJCZW5lZmljaWFyeSBNaW5pc3RyeSBQcm9maWxlXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS10b29sc1xcXCI6IFxcXCJUb29sc1xcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtd29ya3NwYWNlLXNldHVwXFxcIjogXFxcIldvcmtzcGFjZSBTZXR1cFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYWR2YW5jZWQtbW9kZVxcXCI6IFxcXCJBZHZhbmNlZCBNb2RlXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1zZWFyY2hcXFwiOiBcXFwiU2VhcmNoXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1hZGRyZXNzYm9va1xcXCI6IFxcXCJBZGRyZXNzIEJvb2tcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWhlbHBcXFwiOiBcXFwiSGVscFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYW1wLWhlbHBcXFwiOiBcXFwiQU1QIEhlbHBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWdsb3NzYXJ5XFxcIjogXFxcIkdsb3NzYXJ5XFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1lbWFpbC1zdXBwb3J0LXRlYW1cXFwiOiBcXFwiRW1haWwgU3VwcG9ydCBUZWFtXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dvdXRcXFwiOiBcXFwiTG9nb3V0XFxcIixcXG5cXFwiYW1wLmNvbW1vbjpmaWx0ZXJzLWxvYWRpbmdcXFwiOiBcXFwiTG9hZGluZy4uLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6cGFnZS10aXRsZVxcXCI6XFxcIkFNUCBEYXNoYm9hcmRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpsb2FkaW5nXFxcIjogXFxcIkxvYWRpbmcuLi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRpdGxlLXByb2plY3RkYXRhXFxcIjogXFxcIlByb2plY3QgRGF0YVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6c3ViLXRpdGxlLXByb2plY3RkYXRhXFxcIjogXFxcIlZpZXcgd2hlcmUgcHJvamVjdHMgYXJlIGJlaW5nIGltcGxlbWVudGVkIHRocm91Z2hvdXQgdGhlIGNvdW50cnkuXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0aXRsZS1Db3VudHJ5XFxcIjogXFxcIkNvdW50cnlcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRpdGxlLVJlZ2lvblxcXCI6IFxcXCJSZWdpb25cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRpdGxlLVpvbmVcXFwiOiBcXFwiWm9uZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6dGl0bGUtRGlzdHJpY3RcXFwiOiBcXFwiRGlzdHJpY3RcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXJlc2V0XFxcIjogXFxcInJlc2V0IG90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtcmFkaW91aS1jb21taXRtZW50c1xcXCI6IFxcXCJDb21taXRtZW50c1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtcmFkaW91aS1kaXNidXJzZW1lbnRzXFxcIjogXFxcIkRpc2J1cnNlbWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtbm9uZS1hcHBsaWVkXFxcIjogXFxcIk5vIGZpbHRlcnMgYXBwbGllZFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2xvc2VcXFwiOiBcXFwiQ2xvc2VcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm1vZGFsLXNvcnJ5XFxcIjogXFxcIlNvcnJ5IGZvciBhbnkgaW5jb252ZW5pZW5jZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6c2hhcmUtZGFzaGJvYXJkLXRvcFxcXCI6IFxcXCJTaGFyZSBkYXNoYm9hcmRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnNoYXJlLWRhc2hib2FyZFxcXCI6IFxcXCJTaGFyZSB0aGlzIGRhc2hib2FyZCB2aWV3XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpzaGFyZS1saW5rXFxcIjogXFxcIkxpbmtcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm9mXFxcIjogXFxcIm9mXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0b29sdGlwLXByZWRpY3Qtb3RoZXJzZXJpZXNcXFwiOiBcXFwiVFJBTlNMQVRFTUVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRvdGFsXFxcIjogXFxcInRvdGFsXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZVxcXCI6IFxcXCJBTVAgVG9vbGJhclxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtZmlsdGVyc1xcXCI6IFxcXCJGaWx0ZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BEb25vckFnZW5jaWVzXFxcIjogXFxcIlRvcCBEb25vciBBZ2VuY2llc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wRG9ub3JHcm91cHNcXFwiOiBcXFwiVG9wIERvbm9yIEdyb3Vwc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wUmVnaW9uc1xcXCI6IFxcXCJUb3AgUmVnaW9uc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wU2VjdG9yc1xcXCI6IFxcXCJUb3AgU2VjdG9yc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtQWlkUHJlZGljdGFiaWxpdHlcXFwiOiBcXFwiQWlkIFByZWRpY3RhYmlsaXR5XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZVxcXCI6IFxcXCJGdW5kaW5nIFR5cGVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVJlc3BvbnNpYmxlT3JnYW5pemF0aW9uc1xcXCI6IFxcXCJSZXNwb25zaWJsZSBPcmdhbml6YXRpb25zXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1CZW5lZmljaWFyeUFnZW5jaWVzXFxcIjogXFxcIkJlbmVmaWNpYXJ5IEFnZW5jaWVzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1FeGVjdXRpbmdBZ2VuY2llc1xcXCI6IFxcXCJFeGVjdXRpbmcgQWdlbmNpZXNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUltcGxlbWVudGluZ0FnZW5jaWVzXFxcIjogXFxcIkltcGxlbWVudGluZyBBZ2VuY2llc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtUGVhY2UtYnVpbGRpbmdhbmRTdGF0ZS1idWlsZGluZ0dvYWxzXFxcIjogXFxcIlBlYWNlLWJ1aWxkaW5nIGFuZCBTdGF0ZS1idWlsZGluZyBHb2Fsc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6cHJlZGljdGFiaWxpdHktcGxhbm5lZFxcXCI6IFxcXCJQbGFubmVkXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpwcmVkaWN0YWJpbGl0eS1hY3R1YWxcXFwiOiBcXFwiQWN0dWFsXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZS1HcmFudFxcXCI6IFxcXCJHcmFudFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtRnVuZGluZ1R5cGUtTG9hblxcXCI6IFxcXCJMb2FuXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZS1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BSZWdpb25zLURpc3RyaWN0VW5kZWZpbmVkXFxcIjogXFxcIkRpc3RyaWN0OiBVXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BSZWdpb25zLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcFNlY3RvcnMtb3RoZXJzXFxcIjogXFxcIk90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wRG9ub3JBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BEb25vckdyb3Vwcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1SZXNwb25zaWJsZU9yZ2FuaXphdGlvbnMtb3RoZXJzXFxcIjogXFxcIk90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtQmVuZWZpY2lhcnlBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1FeGVjdXRpbmdBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1JbXBsZW1lbnRpbmdBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1QZWFjZS1idWlsZGluZ2FuZFN0YXRlLWJ1aWxkaW5nR29hbHMtb3RoZXJzXFxcIjpcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWVkaXRcXFwiOlxcXCJlZGl0IGZpbHRlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmRhc2hib2FyZC1zZXR0aW5nc1xcXCI6XFxcIlNldHRpbmdzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpzZXR0aW5ncy1lZGl0XFxcIjpcXFwiZWRpdCBzZXR0aW5nc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtYW1vdW50XFxcIjpcXFwiQW1vdW50XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1wcmV2aWV3XFxcIjpcXFwiUHJldmlldzpcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmRvd25sb2FkLXJlbmRlcmluZ1xcXCI6XFxcIlJlbmRlcmluZy4uLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtZG93bmxvYWQtY2hhcnRcXFwiOlxcXCJEb3dubG9hZCBjaGFydFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtZG93bmxvYWQtZGF0YVxcXCI6XFxcIkRvd25sb2FkIGRhdGFcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LW5vLWRhdGEtYXZhaWxhYmxlXFxcIjpcXFwiTm8gRGF0YSBBdmFpbGFibGVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWxvYWRpbmctc2F2ZWQtc2V0dGluZ3NcXFwiOlxcXCJMb2FkaW5nIHNhdmVkIHNldHRpbmdzLi4uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLXNob3ctc2V0dGluZ3NcXFwiOlxcXCJTaG93IGZpbHRlciBzZXR0aW5nc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1jaGFydC1sZWdlbmRzLUdyb3VwZWRcXFwiOlxcXCJHcm91cGVkXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWNoYXJ0LWxlZ2VuZHMtU3RhY2tlZFxcXCI6XFxcIlN0YWNrZWRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm9mLXRvdGFsXFxcIjogXFxcIm9mIHRvdGFsXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktYWN0dWFsLWRpc2J1cnNlbWVudHNcXFwiOiBcXFwiQWN0dWFsIERpc2J1cnNlbWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS1wbGFubmVkLWRpc2J1cnNlbWVudHNcXFwiOiBcXFwiUGxhbm5lZCBEaXNidXJzZW1lbnRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWhpZGUtZGV0YWlsc1xcXCI6IFxcXCJIaWRlIGZpbHRlciBkZXRhaWxzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpzYXZpbmctc3RhdGVcXFwiOiBcXFwiU2F2aW5nIGRhc2hib2FyZCBzdGF0ZSwgcGxlYXNlIHdhaXQuLi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmRhdGUtcmFuZ2VcXFwiOiBcXFwiRGF0ZSBSYW5nZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y3VycmVuY3lcXFwiIDogXFxcIkN1cnJlbmN5XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0eXBlXFxcIiA6IFxcXCJUeXBlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp5ZWFyXFxcIiA6IFxcXCJZZWFyXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmdHlwZS1hY3R1YWwtY29tbWl0bWVudFxcXCI6IFxcXCJBY3R1YWwgQ29tbWl0bWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1kaXNidXJzZW1lbnRcXFwiOiBcXFwiQWN0dWFsIERpc2J1cnNlbWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1leHBlbmRpdHVyZVxcXCI6IFxcXCJBY3R1YWwgRXhwZW5kaXR1cmVzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmdHlwZS1wbGFubmVkLWNvbW1pdG1lbnRcXFwiOiBcXFwiUGxhbm5lZCBDb21taXRtZW50c1xcXCIgLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLXBsYW5uZWQtZGlzYnVyc2VtZW50XFxcIjpcXHRcXFwiUGxhbm5lZCBEaXNidXJzZW1lbnRzXFxcIiAsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZnR5cGUtcGxhbm5lZC1leHBlbmRpdHVyZXNcXFwiOlxcdFxcXCJQbGFubmVkIEV4cGVuZGl0dXJlc1xcXCIsICBcXHRcXHRcXHRcXG5cXFwiYW1wLmRhc2hib2FyZDpkYXNoYm9hcmQtY2hhcnQtdG9wcy1pbmZvLW1vZGFsXFxcIjogXFxcIkNhdGVnb3J5IERldGFpbFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy10YWJsZS1wcm9qZWN0dGl0bGVcXFwiOiBcXFwiUHJvamVjdCBUaXRsZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbnVuaXRzXFxcIjogXFxcIkluIHVuaXRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLWludGhvdXNhbmRzXFxcIjogXFxcIkluIHRob3VzYW5kc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbm1pbGxpb25zXFxcIjogXFxcIkluIG1pbGxpb25zXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10aG91c2FuZFxcXCI6IFxcXCJrXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1taWxsaW9uXFxcIjogXFxcIk1cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWJpbGxpb25cXFwiOiBcXFwiQlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdHJpbGxpb25cXFwiOiBcXFwiVFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtcGV0YVxcXCI6IFxcXCJQXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1leGFcXFwiOiBcXFwiRVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtc3dhcC1heGVzXFxcIjogXFxcIlN3YXAgQXhlc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtSGVhdE1hcGJ5U2VjdG9yYW5kRG9ub3JHcm91cFxcXCI6XFxcIlNlY3RvciBGcmFnbWVudGF0aW9uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1IZWF0TWFwYnlMb2NhdGlvbmFuZERvbm9yR3JvdXBcXFwiOlxcXCJMb2NhdGlvbiBGcmFnbWVudGF0aW9uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1IZWF0TWFwYnlQcm9ncmFtYW5kRG9ub3JHcm91cFxcXCI6XFxcIlByb2dyYW0gRnJhZ21lbnRhdGlvblxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1yZXNldC1vdGhlcnNcXFwiOlxcXCJSZXNldCBPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm5lZ2F0aXZlcy12YWx1ZXNcXFwiOlxcXCJOZWdhdGl2ZSB2YWx1ZXMgYXJlIG5vdCByZXByZXNlbnRlZCBpbiB0aGlzIGNoYXJ0LlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6bmVnYXRpdmVzLXZhbHVlcy1wYXJhZ1xcXCI6XFxcIlBsZWFzZSBzd2l0Y2ggdG8gYmFyIGNoYXJ0IG9yIHRhYmxlIHZpZXcgdG8gdmlldyBhbGwgdmFsdWVzLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmRzXFxcIjpcXFwiTEVHRU5EU1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC10b3RhbHNcXFwiOlxcXCJUT1RBTFNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWxlc3MtdGhhblxcXCI6XFxcIkxlc3MgdGhhblxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYmV0d2VlblxcXCI6XFxcIkJldHdlZW5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWFuZFxcXCI6XFxcImFuZFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtbW9yZS10aGFuXFxcIjpcXFwiTW9yZSB0aGFuXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLW90aGVyc1xcXCI6XFxcIk90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6cGVyY2VudGFnZVxcXCI6IFxcXCJQZXJjZW50YWdlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWxlZ2VuZC1uLWFcXFwiOiBcXFwiTi9BXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWhlbHAtdGV4dC1sb2NhdGlvblxcXCI6XFxcIkVhY2ggY2VsbCByZXByZXNlbnRzIGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgZG9ub3IgZ3JvdXAgYW5kIGEgbG9jYXRpb24gYW5kIHJlcHJlc2VudHMgaG93IG11Y2ggdGhhdCBmdW5kZXIgY29udHJpYnV0ZXMgdG8gdGhlIHRvdGFsIGZ1bmRpbmcgcmVjZWl2ZWQgYnkgdGhhdCBsb2NhdGlvbi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtaGVscC10ZXh0LXNlY3RvclxcXCI6XFxcIkVhY2ggY2VsbCByZXByZXNlbnRzIGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgZG9ub3IgZ3JvdXAgYW5kIGEgc2VjdG9yIGFuZCByZXByZXNlbnRzIGhvdyBtdWNoIHRoYXQgZnVuZGVyIGNvbnRyaWJ1dGVzIHRvIHRoZSB0b3RhbCBmdW5kaW5nIHJlY2VpdmVkIGJ5IHRoYXQgc2VjdG9yLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1oZWxwLXRleHQtcHJvZ3JhbVxcXCI6XFxcIkVhY2ggY2VsbCByZXByZXNlbnRzIGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgZG9ub3IgZ3JvdXAgYW5kIGEgcHJvZ3JhbSBhbmQgcmVwcmVzZW50cyBob3cgbXVjaCB0aGF0IGZ1bmRlciBjb250cmlidXRlcyB0byB0aGUgdG90YWwgZnVuZGluZyByZWNlaXZlZCBieSB0aGF0IHByb2dyYW0uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b29sdGlwLXBpZS1jaGFydFt0aXRsZV1cXFwiOlxcXCJWaWV3IGRhdGEgaW4gcGllIGNoYXJ0XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b29sdGlwLWJhci1jaGFydFt0aXRsZV1cXFwiOlxcXCJWaWV3IGRhdGEgaW4gYmFyIGNoYXJ0XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b29sdGlwLXRhYmxlLWNoYXJ0W3RpdGxlXVxcXCI6XFxcIlZpZXcgZGF0YSBpbiB0YWJsZSBmb3JtYXRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvb2x0aXAtbXVsdGliYXItY2hhcnRbdGl0bGVdXFxcIjpcXFwiVmlldyBkYXRhIGluIG11bHRpYmFyIGNoYXJ0XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b29sdGlwLWRvd25sb2FkLWNoYXJ0W3RpdGxlXVxcXCI6XFxcIkRvd25sb2FkIGltYWdlIG9yIHRhYmxlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b29sdGlwLWV4cGFuZC1jaGFydFt0aXRsZV1cXFwiOlxcXCJFeHBhbmQgY2hhcnRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvb2x0aXAtY29sbGFwc2UtY2hhcnRbdGl0bGVdXFxcIjpcXFwiQ29sbGFwc2UgY2hhcnRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvb2x0aXAtaGVhdG1hcC1jaGFydFt0aXRsZV1cXFwiOlxcXCJWaWV3IGhlYXQgbWFwXFxcIlxcbn1cIik7XG4gICAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcih7XG4gICAgICAgIGRlZmF1bHRLZXlzOiBkYXNoYm9hcmRUcmFuc2xhdGVLZXlzLFxuICAgICAgICBhamF4OiBCYWNrYm9uZURhc2gud3JhcHBlZEFqYXhcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLmluaXRTZXR0aW5ncygpO1xuICAgICAgXG4gICAgICAvLyBUT0RPOiBoYW5kbGUgdHJhbnNsYXRpb25zIGxvYWQgZmFpbHVyZSAgICAgIOKAi1xuICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgRmlsdGVyKHtcbiAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgc3luYzogb3B0aW9ucy5zeW5jIHx8IEJhY2tib25lRGFzaC5zeW5jLFxuICAgICAgICAgIGNhbGxlcjogJ0RBU0hCT0FSRCdcbiAgICAgICAgfSk7XG4gICAgICAgXG4gICAgICBcblxuICAgXHQgIC8vIGluaXRpYWxpemUgYXBwIGNvbXBvbmVudHNcbiAgICAgIHRoaXMudmlldyA9IG5ldyBNYWluVmlldyh7IGFwcDogdGhpcywgZWw6IG9wdGlvbnMuZWwgfSk7ICAgICAgXG5cbiAgICAgIF9pbml0RGVmZXIucmVzb2x2ZSh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfLmRlZmVyKGZ1bmN0aW9uKCkgeyB0aHJvdyBlOyB9KTtcbiAgICAgIHRoaXMudmlldyA9IG5ldyBGYWlsVmlldyh7IGFwcDogdGhpcywgZWw6IG9wdGlvbnMuZWwsIGVycjogZX0pO1xuICAgICAgdGhpcy5lcnIgPSBlO1xuICAgICAgX2luaXREZWZlci5yZWplY3QodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogZml4IHNvbWUgcGFydHMgb2YgdGhlIGFwcCBzbyB3ZSBjYW4gbG9hZCB0cmFuc2xhdGlvbnMgYXN5bmNcbiAgICB0aGlzLnRyeUFmdGVyKHRoaXMudHJhbnNsYXRvci5wcm9taXNlLCB0aGlzLnZpZXcucmVuZGVyLCB0aGlzLnZpZXcpO1xuICAgIC8vIHRoaXMudHJ5VG8odGhpcy52aWV3LnJlbmRlciwgdGhpcy52aWV3KTtcblxuICAgIC8qIGVuc3VyZSBlbnRpcmUgcGFnZS0taGVhZGVyIGFuZCBmb290ZXIsIG5vdCBqdXN0IHRoaXMgdmlldyBpcyB0cmFuc2xhdGVkICovXG4gICAgLy8gVE9ETzogaWYgcG9zc2libGUsIG1vdmUgdGhpcyBvdXQgb2YgYXBwLWNsYXNzXG4gICAgLy8gb3IgYXQgbGVhc3QgbWFrZSBpdCBtb3JlIHRhcmdldGVkIHRoYW4gZG9jdW1lbnRcbiAgICB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKGRvY3VtZW50KTtcbiAgfSxcblxuICBoYXNJc3N1ZTogZnVuY3Rpb24oZmVhdHVyZU5hbWUpIHtcbiAgICByZXR1cm4gISFfKHRoaXMuYnJvd3Nlcklzc3VlcykuZmluZFdoZXJlKHtmZWF0dXJlOiBmZWF0dXJlTmFtZX0pO1xuICB9LFxuXG4gIHZpZXdGYWlsOiBmdW5jdGlvbih2aWV3LCBlcnIpIHtcbiAgICB2aWV3LiRlbC5odG1sKG5ldyBGYWlsVmlldyh7IGFwcDogdGhpcywgZXJyOiBlcnIgfSkucmVuZGVyKCkuZWwpO1xuICB9LFxuXG4gIHRyeVRvOiBmdW5jdGlvbihmbiwgdmlldykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh2aWV3KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfLmRlZmVyKGZ1bmN0aW9uKCkgeyB0aHJvdyBlOyB9KTtcbiAgICAgIHRoaXMudmlld0ZhaWwodmlldywgZSk7XG4gICAgfVxuICB9LFxuXG4gIHRyeUFmdGVyOiBmdW5jdGlvbihwcm9taXNlLCBmbiwgdmlldykge1xuICAgIHByb21pc2VcbiAgICAgIC5kb25lKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudHJ5VG8oZm4sIHZpZXcpO1xuICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlld0ZhaWwodmlldywgJ2ZhaWxlZCB0byBsb2FkJyk7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICByZXBvcnQ6IGZ1bmN0aW9uKHRpdGxlLCBtZXNzYWdlcykge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWRcbiAgICAgIC5kb25lKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICBhcHAubW9kYWwodGl0bGUsIHttZXNzYWdlczogbWVzc2FnZXMsIHRvbmU6ICd3YXJuaW5nJ30pO1xuICAgICAgfSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1JFUE9SVDonLCB0aXRsZSwgbWVzc2FnZXMpO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgbW9kYWw6IGZ1bmN0aW9uKHRpdGxlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8oe30pLmV4dGVuZChvcHRpb25zLCB7dG9uZTogJ3ByaW1hcnknfSk7XG4gICAgdmFyIG1vZGFsUmVhZHkgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVkXG4gICAgICAuZG9uZShmdW5jdGlvbihhcHApIHtcbiAgICAgICAgdmFyIG1vZGFsRWwgPSBhcHAudmlldy5tb2RhbCh0aXRsZSwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGFsUmVhZHkucmVzb2x2ZShtb2RhbEVsKTtcbiAgICAgIH0pXG4gICAgICAuZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdmYWlsZWQgdG8gc2hvdyBtb2RhbCBiZWNhdXNlIHRoZSBhcHAgdmlld3MgZGlkIG5vdCBpbml0aWFsaXplJywgdGl0bGUpO1xuICAgICAgICBtb2RhbFJlYWR5LnJlamVjdCgnYXBwIHZpZXdzIGRpZCBub3QgaW5pdCcpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIG1vZGFsUmVhZHkucHJvbWlzZSgpO1xuICB9LFxuICBpbml0U2V0dGluZ3M6IGZ1bmN0aW9uKCl7XG5cdHRoaXMuc2V0dGluZ3NXaWRnZXQgPSBuZXcgU2V0dGluZ3MuU2V0dGluZ3NXaWRnZXQoe1xuXHQgIFx0XHRkcmFnZ2FibGUgOiB0cnVlLFxuXHQgIFx0XHRjYWxsZXIgOiAnREFTSEJPQVJEUycsXG5cdCAgXHRcdGlzUG9wdXA6IHRydWUsXG5cdCAgXHRcdGRlZmluaXRpb25Vcmw6ICcvcmVzdC9zZXR0aW5ncy1kZWZpbml0aW9ucy9kYXNoYm9hcmRzJ1xuXHR9KTtcdFxuXHR0aGlzLmdlbmVyYWxTZXR0aW5ncyA9IG5ldyBTZXR0aW5ncy5HZW5lcmFsU2V0dGluZ3MoKTtcblx0dGhpcy5nZW5lcmFsU2V0dGluZ3MubG9hZCgpO1x0XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcDtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuXG4vLyBUT0RPOiAuLi4gLi4uIC4uLlxudmFyIElTX1BISUxTX0NPUlMgPSB3aW5kb3cgJiYgKHdpbmRvdy5sb2NhdGlvbi5ob3N0ID09PSAnbG9jYWxob3N0OjMwMDAnKTtcblxuXG52YXIgQ0FDSEUgPSBbJy9yZXN0L2Rhc2hib2FyZCddO1xuXG5cbmZ1bmN0aW9uIEluaXRFcnJvcihpbnN0YW5jZSkge1xuICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdNb2R1bGUgaW5pdGlhbGl6YXRpb24gZXJyb3InOyB9O1xufVxuXG5cbnZhciBhamF4T3B0aW9uV3JhcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IF8oe30pLmV4dGVuZChvcHRpb25zLCB7XG4gICAgLy8gbWF5YmUgdXNlIHBoaWwncyBEUkMgQ09SUyBkZXYgc2VydmVyXG4gICAgdXJsOiAoSVNfUEhJTFNfQ09SUyA/ICdodHRwOi8vbG9jYWxob3N0OjgwODAnIDogJycpICsgb3B0aW9ucy51cmwsXG4gICAgaGVhZGVyczoge1xuICAgICAgLy8ganNjczpkaXNhYmxlIGRpc2FsbG93UXVvdGVkS2V5c0luT2JqZWN0c1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIC8vIGpzY3M6ZW5hYmxlIGRpc2FsbG93UXVvdGVkS2V5c0luT2JqZWN0c1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuXG52YXIgc3luY092ZXJyaWRlID0gKGZ1bmN0aW9uKGJzKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuXG4gIGZ1bmN0aW9uIF9kb1N5bmModXJsLCBtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8oe30pLmV4dGVuZChvcHRpb25zLCB7IHVybDogdXJsIH0pO1xuICAgIG9wdGlvbnMgPSBhamF4T3B0aW9uV3JhcChvcHRpb25zKTtcbiAgICByZXR1cm4gYnMuY2FsbCh0aGlzLCBtZXRob2QsIG1vZGVsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jYWNoZVN5bmModXJsLCBtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IHVybCArICcrUE9TVDonICsgb3B0aW9ucy5kYXRhO1xuICAgIGlmIChjYWNoZVtrZXldKSB7IHJldHVybiBjYWNoZVtrZXldKCk7IH1cblxuICAgIHZhciB4aHIgPSBfZG9TeW5jKHVybCwgbWV0aG9kLCBtb2RlbCwgb3B0aW9ucyk7XG5cbiAgICBjYWNoZVtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBtYWtlIHRoZSB4aHIgcmUtY2FsbCBpdHMgY2FsbGJhY2tzXG4gICAgICByZXR1cm4geGhyXG4gICAgICAgIC5kb25lKG9wdGlvbnMuc3VjY2VzcylcbiAgICAgICAgLmFsd2F5cyhvcHRpb25zLmNvbXBsZXRlKTtcbiAgICB9O1xuXG4gICAgLy8gZG8gbm90IGNhY2hlIGZhaWxlZCByZXF1ZXN0c1xuICAgIHhoci5mYWlsKGZ1bmN0aW9uKCkgeyBkZWxldGUgY2FjaGVba2V5XTsgfSk7XG5cbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmwgfHwgXyhtb2RlbCkucmVzdWx0KCd1cmwnKSB8fCBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUudXJsLmNhbGwobW9kZWwpLFxuICAgICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnUE9TVCcgJiZcbiAgICAgIF8uc29tZShDQUNIRSwgZnVuY3Rpb24oaSkgeyByZXR1cm4gdXJsLmluZGV4T2YoaSkgPT09IDA7IH0pKSB7XG4gICAgICBjYWNoZWFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKGNhY2hlYWJsZSA/IF9jYWNoZVN5bmMgOiBfZG9TeW5jKSh1cmwsIG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpO1xuICB9O1xufSkoQmFja2JvbmUuc3luYyk7XG5cblxuLy8gbWl4ZWQgaW50byBhbGwgbW9kZWxzLCBjb2xsZWN0aW9ucyBhbmQgdmlld3MgdG8gZW5zdXJlIHdlIGhhdmUgYSBjb252ZW5pZW50XG4vLyByZWZlcmVuY2UgdG8gdGhlIGFwcCBpbnN0YW5jZSBldmVyeXdoZXJlLlxuZnVuY3Rpb24gbWl4RGFzaChDbGFzcykge1xuICByZXR1cm4gQ2xhc3MuZXh0ZW5kKHtcblxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RlZCA9IENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoIXRoaXMuYXBwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbml0RXJyb3IodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uc3RydWN0ZWQ7XG4gICAgfSxcblxuICAgIHN5bmM6IHN5bmNPdmVycmlkZVxuXG4gIH0pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gXyh7fSkuZXh0ZW5kKEJhY2tib25lLCB7XG4gIC8vIGVycm9yc1xuICBJbml0RXJyb3I6IEluaXRFcnJvcixcblxuICBNb2RlbDogbWl4RGFzaChCYWNrYm9uZS5Nb2RlbCksXG4gIENvbGxlY3Rpb246IG1peERhc2goQmFja2JvbmUuQ29sbGVjdGlvbiksXG4gIFZpZXc6IG1peERhc2goQmFja2JvbmUuVmlldyksXG5cbiAgc3luYzogc3luY092ZXJyaWRlLFxuICB3cmFwcGVkQWpheDogZnVuY3Rpb24obykgeyByZXR1cm4gQmFja2JvbmUuYWpheChhamF4T3B0aW9uV3JhcChvKSk7IH1cbn0pO1xuIiwiLypcbiAqIERyYXdpbmcgYSBiYXIgY2hhcnQgaW4gQU1QPyBQbGVhc2UgdXNlIC4vY2hhcnQuanMgaW5zdGVhZC5cbiAqL1xuXG52YXIgYmFyRGVidWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi8uLi8uLi9yZWFtcC90b29scy9sb2cnKShcImFtcDpkYXNoYm9hcmRzOmNoYXJ0czpiYXJcIik7XG5cbnZhciBudiA9IHdpbmRvdy5udjsgIC8vIG52ZDMgaXMgYSBwYWluXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcblxuXG5mdW5jdGlvbiBkYXRhVG9OdihkYXRhKSB7XG4gIHJldHVybiBkYXRhO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50Q2F0ZWdvcmllcyhkYXRhKSB7XG4gIC8vIG5vdGU6IHRoaXMgdGFrZXMgcmVndWxhciBkYXRhLCBub3QgZGF0YVRvTnYgZGF0YS5cbiAgcmV0dXJuIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIDE7ICAvLyAxIGZvciBvdGhlcnMuLi4/XG59XG5cblxuZnVuY3Rpb24gY2hhcnQob3B0aW9ucywgZGF0YSkge1xuICAvL3RoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgSSBuZWVkIHN0cmljdGx5IGVpdGhlciAzMDAgb3IgNDAwIHB4LCBhbmQgc29tZXRpbWVzLCB3aGVuIHRoZSBjaGFydCBvdmVyZmxvd3MsIGl0XG4gIC8vd2lsbCBnaXZlIG1lID40MDAgcHggaGVpZ2h0XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCA8IDQwMCA/IDMwMCA6IDQwMDtcbiAgdmFyIGNhbGN1bGF0ZWRIZWlnaHQgPSB1dGlsLmNhbGN1bGF0ZUNoYXJ0SGVpZ2h0KGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgZmFsc2UsIG9wdGlvbnMubW9kZWwpO1xuICBpZiAoY2FsY3VsYXRlZEhlaWdodCAhPT0gbnVsbCkge1xuXHQgIGhlaWdodCA9IGNhbGN1bGF0ZWRIZWlnaHQ7IFxuICB9XG4gICBcbiAgYmFyRGVidWcubG9nKFwiU2V0dGluZyBoZWlnaHQgdG9cIiwgaGVpZ2h0KTtcbiAgdmFyIF9jaGFydCA9IG52Lm1vZGVscy5kaXNjcmV0ZUJhckNoYXJ0KClcbiAgICAudmFsdWVGb3JtYXQob3B0aW9ucy5zaG9ydEZvcm1hdHRlcilcbiAgICAuc2hvd1ZhbHVlcyh0cnVlKVxuICAgIC5zaG93WUF4aXMoZmFsc2UpXG4gICAgLnNob3dYQXhpcyhmYWxzZSlcbiAgICAuaGVpZ2h0KGhlaWdodClcbiAgICAubWFyZ2luKHsgdG9wOiA1LCByaWdodDogMTAsIGJvdHRvbTogMTAsIGxlZnQ6IDEwIH0pO1xuICByZXR1cm4gX2NoYXJ0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZExlZ2VuZChzdmcsIGNoYXJ0LCBudkRhdGEsIHRyaW1MYWJlbHMsIHdpZHRoKSB7XG4gIHZhciBsZWdlbmRIZWlnaHQ7XG5cbiAgdmFyIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgIC53aWR0aCh3aWR0aCB8fCBzdmcuY2xpZW50V2lkdGgpXG4gICAgLm1hcmdpbih7bGVmdDogMjAsIHJpZ2h0OiAyMH0pXG4gICAgLnJpZ2h0QWxpZ24oZmFsc2UpXG4gICAgLmNvbG9yKHV0aWwuY2F0ZWdvcnlDb2xvdXJzKG52RGF0YVswXS52YWx1ZXMubGVuZ3RoKSlcbiAgICAua2V5KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyaW1MYWJlbHMgPyB1dGlsLmZvcm1hdFNob3J0VGV4dCgxMikoZC54KSA6IHV0aWwuZm9ybWF0U2hvcnRUZXh0KDg1KShkLngpOyB9KTtcblxuICBkMy5zZWxlY3Qoc3ZnKVxuICAgIC5kYXR1bShudkRhdGEpXG4gICAgLmFwcGVuZCgnZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kJylcbiAgICAgIC5kYXR1bShudkRhdGFbMF0udmFsdWVzKVxuICAgICAgLmNhbGwobGVnZW5kKTtcblxuICBsZWdlbmRIZWlnaHQgPSBzdmcucXVlcnlTZWxlY3RvcignLmxlZ2VuZCcpLmdldEJCb3goKS5oZWlnaHQ7XG4gIGNoYXJ0Lm1hcmdpbih7dG9wOiBsZWdlbmRIZWlnaHQgKyAxNX0pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkaXNwYXRjaE5hbWU6ICdkaXNjcmV0ZWJhcicsXG4gIGNvdW50Q2F0ZWdvcmllczogY291bnRDYXRlZ29yaWVzLFxuICBhZGRMZWdlbmQ6IGFkZExlZ2VuZCxcbiAgZGF0YVRvTnY6IGRhdGFUb052LFxuICBjaGFydDogY2hhcnRcbn07XG4iLCIvKlxuICogRHJhd2luZyBhIGJhciBjaGFydCBpbiBBTVA/IFBsZWFzZSB1c2UgLi9jaGFydC5qcyBpbnN0ZWFkLlxuICovXG5cbnZhciBiYXJEZWJ1ZyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uLy4uLy4uL3JlYW1wL3Rvb2xzL2xvZycpKFwiYW1wOmRhc2hib2FyZHM6Y2hhcnRzOmJhclwiKTtcblxudmFyIG52ID0gd2luZG93Lm52OyAgLy8gbnZkMyBpcyBhIHBhaW5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIGhlYXRNYXBDaGFydCA9IHJlcXVpcmUoJy4vY3VzdG9taXplZC9oZWF0TWFwQ2hhcnQnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5mdW5jdGlvbiBkYXRhVG9OdihkYXRhKSB7XG4gIHJldHVybiBkYXRhO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50Q2F0ZWdvcmllcyhkYXRhKSB7XG4gIC8vIG5vdGU6IHRoaXMgdGFrZXMgcmVndWxhciBkYXRhLCBub3QgZGF0YVRvTnYgZGF0YS5cbiAgcmV0dXJuIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIDE7ICAvLyAxIGZvciBvdGhlcnMuLi4/XG59XG5cblxuZnVuY3Rpb24gY2hhcnQob3B0aW9ucywgZGF0YSkge1xuICAvL3RoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgSSBuZWVkIHN0cmljdGx5IGVpdGhlciAzMDAgb3IgNDAwIHB4LCBhbmQgc29tZXRpbWVzLCB3aGVuIHRoZSBjaGFydCBvdmVyZmxvd3MsIGl0XG4gIC8vd2lsbCBnaXZlIG1lID40MDAgcHggaGVpZ2h0XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCA8IDQwMCA/IDMwMCA6IDQwMDtcbiAgdmFyIGNhbGN1bGF0ZWRIZWlnaHQgPSB1dGlsLmNhbGN1bGF0ZUNoYXJ0SGVpZ2h0KGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgZmFsc2UsIG9wdGlvbnMubW9kZWwpO1xuICBpZiAoY2FsY3VsYXRlZEhlaWdodCAhPT0gbnVsbCkge1xuXHQgIGhlaWdodCA9IGNhbGN1bGF0ZWRIZWlnaHQ7IFxuICB9XG4gICBcbiAgdmFyIF9jaGFydCA9IG52Lm1vZGVscy5oZWF0TWFwQ2hhcnQoKS5oZWlnaHQoOTAwKTtcbiAgcmV0dXJuIF9jaGFydDtcbn1cblxuXG5mdW5jdGlvbiBhZGRMZWdlbmQoc3ZnLCBjaGFydCwgbnZEYXRhLCB0cmltTGFiZWxzLCB3aWR0aCkge1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkaXNwYXRjaE5hbWU6ICdoZWF0bWFwJyxcbiAgY291bnRDYXRlZ29yaWVzOiBjb3VudENhdGVnb3JpZXMsXG4gIGFkZExlZ2VuZDogYWRkTGVnZW5kLFxuICBkYXRhVG9OdjogZGF0YVRvTnYsXG4gIGNoYXJ0OiBjaGFydFxufTtcbiIsIi8qXG4gKiBEcmF3aW5nIGEgbXVsdGliYXIgY2hhcnQgaW4gQU1QPyBQbGVhc2UgdXNlIC4vY2hhcnQuanMgaW5zdGVhZC5cbiAqL1xuXG52YXIgbXVsdGliYXJEZWJ1ZyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uLy4uLy4uL3JlYW1wL3Rvb2xzL2xvZycpKFwiYW1wOmRhc2hib2FyZHM6Y2hhcnRzOm11bHRpYmFyXCIpO1xuXG52YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxudmFyIGN1c3RvbWl6ZWRNdWx0aUJhckNoYXJ0ID0gcmVxdWlyZSgnLi9jdXN0b21pemVkL211bHRpQmFyQ2hhcnQuanMnKTtcbi8vIHZhciBkMyA9IHJlcXVpcmUoJ2QzLWJyb3dzZXJpZnknKTtcblxuXG5mdW5jdGlvbiBkYXRhVG9OdihkYXRhKSB7XG4gIHJldHVybiBkYXRhO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50Q2F0ZWdvcmllcyhkYXRhKSB7XG4gIC8vIG5vdGU6IHRoaXMgdGFrZXMgcmVndWxhciBkYXRhLCBub3QgZGF0YVRvTnYgZGF0YS5cbiAgcmV0dXJuIGRhdGEubGVuZ3RoO1xufVxuXG5cbmZ1bmN0aW9uIGNoYXJ0KG9wdGlvbnMpIHtcbiAgdmFyIG1heFZhbHVlID0gMTA7XG4gIC8vdGhpcyBjaGVjayBpcyBuZWVkZWQgYmVjYXVzZSBJIG5lZWQgc3RyaWN0bHkgZWl0aGVyIDMwMCBvciA0MDAgcHgsIGFuZCBzb21ldGltZXMsIHdoZW4gdGhlIGNoYXJ0IG92ZXJmbG93cywgaXRcbiAgLy93aWxsIGdpdmUgbWUgPjQwMCBweCBoZWlnaHRcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IDwgNDAwID8gMzAwIDogNDAwO1xuICBtdWx0aWJhckRlYnVnLmxvZyhcIlNldHRpbmcgbXVsdGliYXIgaGVpZ2h0XCIsIGhlaWdodCk7XG4gIHZhciBfY2hhcnQgPSBudi5tb2RlbHMuY3VzdG9taXplZE11bHRpQmFyQ2hhcnQoKSAgXG4gICAgLmZvcmNlWShbMCwgbWF4VmFsdWVdKSAgLy8gZW5zdXJlcyB5QXhpcyBpcyBzaG93aW5nIGF0IGxlYXN0IDAgYW5kIDEwLCBidXQgd29uJ3QgcmVzdHJpY3QgdGhlIGRvbWFpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChtZWFuaW5nIGlmIHRoZSBhcmUgdmFsdWVzIGZhbGxpbmcgb3V0c2lkZSB0aGUgcmFuZ2UgaXQgd2lsbCBzaG93IHRoZW4pLlxuICAgIC5yZWR1Y2VYVGlja3MoZmFsc2UpXG4gICAgLmhlaWdodChoZWlnaHQpXG4gICAgLm1hcmdpbih7IHRvcDogNSwgcmlnaHQ6IDEwLCBib3R0b206IDIwLCBsZWZ0OiA1MCB9KTtcblxuICBpZiAoIW9wdGlvbnMubnZDb250cm9scykge1xuICAgIF9jaGFydC5zaG93Q29udHJvbHMoZmFsc2UpO1xuICB9XG4gIFxuICBpZihvcHRpb25zLnN0YWNrZWQpe1xuXHQgIF9jaGFydC5tdWx0aWJhci5zdGFja2VkKHRydWUpOyBcbiAgfWVsc2V7XG5cdCAgX2NoYXJ0Lm11bHRpYmFyLnN0YWNrZWQoZmFsc2UpO1xuICB9XG5cbiAgX2NoYXJ0LnlBeGlzXG4gICAgLnRpY2tGb3JtYXQob3B0aW9ucy5zaG9ydEZvcm1hdHRlcilcbiAgICAuc2hvd01heE1pbihmYWxzZSk7XG5cbiAgcmV0dXJuIF9jaGFydDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlzcGF0Y2hOYW1lOiAnbXVsdGliYXInLFxuICBjb3VudENhdGVnb3JpZXM6IGNvdW50Q2F0ZWdvcmllcyxcbiAgZGF0YVRvTnY6IGRhdGFUb052LFxuICBjaGFydDogY2hhcnRcbn07XG4iLCIvKlxuICogRHJhd2luZyBhIHBpZSBjaGFydCBpbiBBTVA/IFBsZWFzZSB1c2UgLi9jaGFydC5qcyBpbnN0ZWFkLlxuICovXG5cbnZhciBudiA9IHdpbmRvdy5udjsgIC8vIG52ZDMgaXMgYSBwYWluXG4vLyB2YXIgZDMgPSByZXF1aXJlKCdkMy1icm93c2VyaWZ5Jyk7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIGN1c3RvbWl6ZWRQaWVDaGFydCA9IHJlcXVpcmUoJy4vY3VzdG9taXplZC9waWVDaGFydC5qcycpO1xuXG5cbmZ1bmN0aW9uIGRhdGFUb052KGRhdGEpIHtcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSAxKSB7XG4gICAgY29tbW9uLmZhaWwoJ1BpZSBjaGFydHMgY2FuIG9ubHkgc2hvdyBvbmUgc2VyaWVzIG9mIGRhdGEuIGdvdCcsIGRhdGEubGVuZ3RoKTtcbiAgfVxuICBpZiAoIV8uaXNBcnJheShkYXRhWzBdLnZhbHVlcykpIHtcbiAgICBjb21tb24uZmFpbCgnRGF0YSBzZXJpZXMgZGlkIG5vdCBoYXZlIGEgXCJ2YWx1ZXNcIiBhcnJheS4gSW5zdGVhZCcsIGRhdGFbMF0udmFsdWVzKTtcbiAgfVxuICByZXR1cm4gZ2V0UG9zaXRpdmVWYWx1ZXMoZGF0YVswXS52YWx1ZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGl2ZVZhbHVlcyh2YWx1ZXMpIHtcbiAgcmV0dXJuIF8uZmlsdGVyKHZhbHVlcywgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLnk+MDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvdW50Q2F0ZWdvcmllcyhkYXRhKSB7XG4gIC8vIG5vdGU6IHRoaXMgdGFrZXMgcmVndWxhciBkYXRhLCBub3QgZGF0YVRvTnYgZGF0YS5cbiAgcmV0dXJuIGdldFBvc2l0aXZlVmFsdWVzKGRhdGFbMF0udmFsdWVzKS5sZW5ndGg7XG59XG5cblxuZnVuY3Rpb24gY2hhcnQob3B0aW9ucywgZGF0YSkge1xuXHR2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPCA0MDAgPyAzMDAgOiA0MDA7XG5cdCAgdmFyIGNhbGN1bGF0ZWRIZWlnaHQgPSB1dGlsLmNhbGN1bGF0ZUNoYXJ0SGVpZ2h0KGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgZmFsc2UsIG9wdGlvbnMubW9kZWwpO1xuXHQgIGlmIChjYWxjdWxhdGVkSGVpZ2h0ICE9PSBudWxsKSB7XG5cdFx0ICBoZWlnaHQgPSBjYWxjdWxhdGVkSGVpZ2h0OyBcblx0ICB9XG5cbiAgdmFyIF9jaGFydCA9IG52Lm1vZGVscy5jdXN0b21pemVkUGllQ2hhcnQoKVxuICAgIC52YWx1ZUZvcm1hdChvcHRpb25zLnNob3J0Rm9ybWF0dGVyKVxuICAgIC5sYWJlbFR5cGUoJ3BlcmNlbnQnKVxuICAgIC5zaG93TGVnZW5kKGZhbHNlKVxuICAgIC5kb251dCh0cnVlKVxuICAgIC5oZWlnaHQoaGVpZ2h0KVxuICAgIC5tYXJnaW4oeyB0b3A6IDUsIHJpZ2h0OiA1LCBib3R0b206IDUsIGxlZnQ6IDUgfSlcbiAgICAuZG9udXRSYXRpbygwLjM1KTtcbiAgcmV0dXJuIF9jaGFydDtcbn1cblxuZnVuY3Rpb24gYWRkTGVnZW5kKHN2ZywgY2hhcnQsIG52RGF0YSwgdHJpbUxhYmVscywgd2lkdGgpIHtcblx0ICB2YXIgbGVnZW5kSGVpZ2h0O1xuXG5cdCAgdmFyIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuXHQgICAgLndpZHRoKHdpZHRoIHx8IHN2Zy5jbGllbnRXaWR0aClcblx0ICAgIC5tYXJnaW4oe2xlZnQ6IDIwLCByaWdodDogMjB9KVxuXHQgICAgLnJpZ2h0QWxpZ24oZmFsc2UpXG5cdCAgICAuY29sb3IodXRpbC5jYXRlZ29yeUNvbG91cnMobnZEYXRhLmxlbmd0aCkpXG5cdCAgICAua2V5KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyaW1MYWJlbHMgPyB1dGlsLmZvcm1hdFNob3J0VGV4dCgxMikoZC54KSA6IHV0aWwuZm9ybWF0U2hvcnRUZXh0KDg1KShkLngpOyB9KTtcblxuXHQgIGQzLnNlbGVjdChzdmcpXG5cdCAgICAuZGF0dW0obnZEYXRhKVxuXHQgICAgLmFwcGVuZCgnZycpXG5cdCAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQnKVxuXHQgICAgICAuZGF0dW0obnZEYXRhKVxuXHQgICAgICAuY2FsbChsZWdlbmQpO1xuXG5cdCAgbGVnZW5kSGVpZ2h0ID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJy5sZWdlbmQnKS5nZXRCQm94KCkuaGVpZ2h0O1xuXHQgIGNoYXJ0Lm1hcmdpbih7dG9wOiBsZWdlbmRIZWlnaHQgKyAxNX0pO1xufVxuXG5cbmZ1bmN0aW9uIHJlbW92ZUxlZ2VuZChjaGFydCkge1xuICBjaGFydC5zaG93TGVnZW5kKGZhbHNlKTtcbn1cblxuXG5mdW5jdGlvbiBub3JtYWxpemVOdlRUQXJncyhmbXRYLCBmbXRZLCByYXcpIHtcbiAgLy8gbnYgcGllIGNoYXJ0cyBkcm9wIHRoZSBzZXJpZXNOYW1lIGFzIGZpcnN0IGFyZ1xuICByZXR1cm4gW3ZvaWQgMCwgZm10WCwgZm10WSwgcmF3XTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlzcGF0Y2hOYW1lOiAncGllJyxcbiAgbm9ybWFsaXplTnZUVEFyZ3M6IG5vcm1hbGl6ZU52VFRBcmdzLFxuICBjb3VudENhdGVnb3JpZXM6IGNvdW50Q2F0ZWdvcmllcyxcbiAgYWRkTGVnZW5kOiBhZGRMZWdlbmQsXG4gIHJlbW92ZUxlZ2VuZDogcmVtb3ZlTGVnZW5kLFxuICBkYXRhVG9OdjogZGF0YVRvTnYsXG4gIGNoYXJ0OiBjaGFydFxufTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgdGFibGVUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1yZXNwb25zaXZlXFxcIj5cXG4gIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcXFwiPlxcblxcbiAgICA8JSBpZiAoXyhrZXlzKS5zb21lKCkpIHsgJT5cXG4gICAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgIDx0ZD48L3RkPlxcbiAgICAgICAgICA8JSBfKGtleXMpLmVhY2goZnVuY3Rpb24oa2V5LCBjb2xJbmRleCkgeyAlPlxcbiAgICAgICAgICAgIDx0aCBkYXRhLXNlcmllcy1pbmRleD1cXFwiPCU9IGNvbEluZGV4ICU+XFxcIj5cXG4gICAgICAgICAgICAgIDwlPSBrZXkgJT5cXG4gICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgPC90aGVhZD5cXG4gICAgPCUgfSAlPlxcblxcbiAgICA8dGJvZHk+XFxuICAgICAgPCUgXyh2YWx1ZXMpLmVhY2goZnVuY3Rpb24ocm93LCByb3dJbmRleCkgeyAlPlxcbiAgICAgICAgPHRyPlxcbiAgICAgICAgICA8dGggZGF0YS14LWluZGV4PVxcXCI8JT0gcm93SW5kZXggJT5cXFwiPlxcbiAgICAgICAgICAgIDwlPSByb3dbMF0ueCAlPlxcbiAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICA8JSBfKHJvdykuZWFjaChmdW5jdGlvbihkYXR1bSwgY29sSW5kZXgpIHsgJT5cXG4gICAgICAgICAgICA8dGQgZGF0YS14LWluZGV4PVxcXCI8JT0gcm93SW5kZXggJT5cXFwiIGRhdGEtc2VyaWVzLWluZGV4PVxcXCI8JT0gY29sSW5kZXggJT5cXFwiPlxcbiAgICAgICAgICAgICAgPCU9IG1vbmV5Rm9ybWF0KGRhdHVtLnkpICU+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgPCUgfSkgJT5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgPCUgfSkgJT5cXG4gICAgPC90Ym9keT5cXG5cXG4gIDwvdGFibGU+XFxuPC9kaXY+XFxuXCIpO1xudmFyIGhlYXRtYXBUYWJsZVRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImhlYXRtYXAtdGFibGUtcmVzcG9uc2l2ZVxcXCI+XFxuXFx0PHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZFxcXCI+XFxuXFx0XFx0PCUgaWYgKF8oa2V5cykuc29tZSgpKSB7ICU+XFxuXFx0ICAgIFxcdDx0aGVhZD5cXG5cXHQgICAgICAgIFxcdDx0cj5cXG5cXHQgICAgICAgICAgXFx0XFx0PCUgXyhrZXlzKS5lYWNoKGZ1bmN0aW9uKGtleSwgY29sSW5kZXgpIHsgJT5cXG5cXHQgICAgICAgICAgICBcXHRcXHQ8dGggZGF0YS1zZXJpZXMtaW5kZXg9XFxcIjBcXFwiPlxcblxcdCAgICAgICAgICAgICAgXFx0XFx0XFx0PCU9IGtleSAlPlxcblxcdCAgICAgICAgICAgIFxcdFxcdDwvdGg+XFxuXFx0ICAgICAgICAgIFxcdFxcdDwlIH0pOyAlPlxcblxcdCAgICAgICAgXFx0PC90cj5cXG5cXHQgICAgICBcXHQ8L3RoZWFkPlxcblxcdCAgICA8JSB9ICU+XFxuXFx0XFx0PHRib2R5PlxcblxcdFxcdFxcdDwlIF8obWF0cml4KS5lYWNoKGZ1bmN0aW9uKHJvdywgaSkgeyAlPlxcblxcdFxcdFxcdFxcdDwlIF8ocm93KS5lYWNoKGZ1bmN0aW9uKGNvbCwgaikgeyAlPlxcblxcdFxcdFxcdFxcdFxcdDx0cj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8dGQgZGF0YS14LWluZGV4PVxcXCI8JT0gaSAlPlxcXCIgZGF0YS1zZXJpZXMtaW5kZXg9XFxcIjBcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwlPSBtYXRyaXhbaV1bal0ueSAlPlxcblxcdFxcdFxcdFxcdFxcdFxcdDwvdGQ+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRkIGRhdGEteC1pbmRleD1cXFwiPCU9IGkgJT5cXFwiIGRhdGEtc2VyaWVzLWluZGV4PVxcXCIwXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8JT0gbWF0cml4W2ldW2pdLnggJT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L3RkPlxcblxcdFxcdFxcdFxcdFxcdFxcdDx0ZCBkYXRhLXgtaW5kZXg9XFxcIjwlPSBpICU+XFxcIiBkYXRhLXNlcmllcy1pbmRleD1cXFwiMFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PCU9IG1hdHJpeFtpXVtqXS52YWx1ZS5kdiAlPlxcblxcdFxcdFxcdFxcdFxcdFxcdDwvdGQ+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRkIGRhdGEteC1pbmRleD1cXFwiPCU9IGkgJT5cXFwiIGRhdGEtc2VyaWVzLWluZGV4PVxcXCIwXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8JT0gbWF0cml4W2ldW2pdLnZhbHVlLnAgJT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L3RkPlxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcblxcdFxcdFxcdFxcdFxcdDwvdHI+XFxuXFx0XFx0XFx0XFx0PCUgfSkgJT5cXG5cXHRcXHRcXHQ8JSB9KSAlPlxcblxcdFxcdDwvdGJvZHk+XFxuXFx0PC90YWJsZT5cXG48L2Rpdj5cIik7XG5cblxuZnVuY3Rpb24gZmFrZVJhd0NvbnRleHQoZSwgZGF0YSkge1xuICAvLyB0cmFuc2Zvcm0gYSB0YWJsZS1jbGljayBldmVudCBpbnRvIHNvbWV0aGluZyB0aGF0IGxvb2tzIGxpa2UgaXQgY2FtZSBmcm9tXG4gIC8vIGFuIG52ZDMgaGFuZGxlclxuICB2YXIgdCA9IGUudGFyZ2V0LFxuICAgICAgc2VyaWVzSW5kZXggPSBwYXJzZUludCh1dGlsLmRhdGEodCwgJ3Nlcmllc0luZGV4JyksIDEwKSB8fCAwLFxuICAgICAgeEluZGV4ID0gcGFyc2VJbnQodXRpbC5kYXRhKHQsICd4SW5kZXgnKSwgMTApO1xuICAvLyBUaGlzIGNoZWNrIGlzIGZvciBoZWF0bWFwcyBiZWNhdXNlIHRoZXkgZG9udCB1c2UgdGhlIHNhbWUgZGF0YSBzdHJ1Y3R1cmUuXG4gIGlmICghaXNOYU4oeEluZGV4KSkge1xuXHQgIHJldHVybiB7XG5cdCAgICBsYWJlbDogZGF0YVtzZXJpZXNJbmRleF0udmFsdWVzW3hJbmRleF0ueCB8fCB4SW5kZXgsXG5cdCAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG5cdCAgICBwb2ludEluZGV4OiB4SW5kZXgsXG5cdCAgICBwb2ludDogZGF0YVtzZXJpZXNJbmRleF0udmFsdWVzW3hJbmRleF0gfHwgeEluZGV4XG5cdCAgfTtcbiAgfSBlbHNlIHtcblx0ICByZXR1cm4ge1xuXHRcdCAgbGFiZWw6ICcnLFxuXHRcdCAgcG9pbnQ6ICcnXG5cdCAgfTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGJpbmRDbGlja0hhbmRsZXIoZWwsIGRhdGEsIG9wdGlvbnMpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGZha2VSYXcgPSBmYWtlUmF3Q29udGV4dChlLCBkYXRhKSwgIC8vIHNvIHdlIGNhbiB1c2UgdGhlIHNoYXJlZCBjb250ZXh0IHRyYW5zZm9ybWVyXG4gICAgICAgIGNvbnRleHQgPSBjb21tb24uZ2V0TmljZUNvbnRleHQoZmFrZVJhdywgZGF0YSwgZS50YXJnZXQuaW5uZXJUZXh0KTtcbiAgICBvcHRpb25zLmNsaWNrSGFuZGxlcihjb250ZXh0KTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY2hhcnRlcihkYXRhLCBvcHRpb25zKSB7XG5cdGlmIChvcHRpb25zLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuXHRcdHJldHVybiBoZWF0bWFwQ2hhcnRlcihkYXRhLCBvcHRpb25zKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gY29tbW9uQ2hhcnRlcihkYXRhLCBvcHRpb25zKTtcblx0fVx0XG59XG5cbmZ1bmN0aW9uIGNvbW1vbkNoYXJ0ZXIoZGF0YSwgb3B0aW9ucykge1xuXHR2YXIga2V5cyA9IF8oZGF0YSkucGx1Y2soJ2tleScpO1xuXG5cdHZhciB2YWx1ZXMgPSBfKGRhdGEpLmNoYWluKCkubWFwKGZ1bmN0aW9uKGRhdHVtKSB7XG5cdFx0cmV0dXJuIGRhdHVtLnZhbHVlcztcblx0fSkudHJhbnNwb3NlKCkudmFsdWUoKTtcblxuXHR2YXIgaHRtbCA9IHRhYmxlVGVtcGxhdGUoe1xuXHRcdGtleXMgOiBrZXlzLFxuXHRcdHZhbHVlcyA6IHZhbHVlcyxcblx0XHRtb25leUZvcm1hdCA6IG9wdGlvbnMuc2hvcnRGb3JtYXR0ZXJcblx0fSk7XG5cblx0dmFyIGNoYXJ0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0Y2hhcnRFbC5pbm5lckhUTUwgPSBodG1sO1xuXG5cdGJpbmRDbGlja0hhbmRsZXIoY2hhcnRFbCwgZGF0YSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGNoYXJ0RWw7XG59XG5cbmZ1bmN0aW9uIGhlYXRtYXBDaGFydGVyKGRhdGEsIG9wdGlvbnMpIHtcblx0Ly8gRm9yIEFNUC0yMzU4Mjogd2UgZG9udCB3YW50IHRoZSBuYW1lIGZyb20gXCJzdW1tYXJ5XCIgYmVjYXVzZSB0aGF0cyB0aGUgb3JpZ05hbWUgYW5kIG5vdCBhbHdheXMgdGhlIHNhbWUgbmFtZSB0aGFuIHRoZSBYIGF4aXMgY29tYm8gc2VsZWN0b3IuIFxuXHR2YXIgZmlyc3RDb2x1bW5OYW1lID0gXy5maW5kKG9wdGlvbnMubW9kZWwuZ2V0KCdoZWF0bWFwX2NvbmZpZycpLm1vZGVsc1swXS5nZXQoJ2NvbHVtbnMnKSwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLm9yaWdOYW1lID09PSBvcHRpb25zLm1vZGVsLmdldCgnc3VtbWFyeScpWzBdO1xuXHR9KS5uYW1lOyBcblx0dmFyIHNlY29uZENvbHVtbk5hbWUgPSBfLmZpbmQob3B0aW9ucy5tb2RlbC5nZXQoJ2hlYXRtYXBfY29uZmlnJykubW9kZWxzWzBdLmdldCgnY29sdW1ucycpLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0ub3JpZ05hbWUgPT09IG9wdGlvbnMubW9kZWwuZ2V0KCdzdW1tYXJ5JylbMV07XG5cdH0pLm5hbWU7XG5cdHZhciBrZXlzID0gW2ZpcnN0Q29sdW1uTmFtZSwgXG5cdCAgICAgICAgICAgIHNlY29uZENvbHVtbk5hbWUsIFxuXHQgICAgICAgICAgICB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtYW1vdW50JywgJ0Ftb3VudCcpLCBcblx0ICAgICAgICAgICAgdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOnBlcmNlbnRhZ2UnLCAnUGVyY2VudGFnZScpXTtcblxuXHR2YXIgbWF0cml4ID0gXy5tYXAob3B0aW9ucy5tb2RlbC5nZXQoXCJtYXRyaXhcIiksIGZ1bmN0aW9uKGl0ZW1ZLCBpKSB7XG5cdFx0cmV0dXJuIF8ubWFwKGl0ZW1ZLCBmdW5jdGlvbihpdGVtWCwgaikge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eSA6IG9wdGlvbnMubW9kZWwuZ2V0KFwieURhdGFTZXRcIilbaV0sXG5cdFx0XHRcdHggOiBvcHRpb25zLm1vZGVsLmdldChcInhEYXRhU2V0XCIpW2pdLFxuXHRcdFx0XHR2YWx1ZSA6IChvcHRpb25zLm1vZGVsLmdldChcIm1hdHJpeFwiKVtpXVtqXSA/IG9wdGlvbnMubW9kZWwuZ2V0KFwibWF0cml4XCIpW2ldW2pdIDoge1xuXHRcdFx0XHRcdCdkdicgOiAnJyxcblx0XHRcdFx0XHQncCcgOiAnJ1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0pXG5cdH0pO1xuXG5cdHZhciBodG1sID0gaGVhdG1hcFRhYmxlVGVtcGxhdGUoe1xuXHRcdGtleXMgOiBrZXlzLFxuXHRcdG1hdHJpeCA6IG1hdHJpeCxcblx0XHRtb25leUZvcm1hdCA6IG9wdGlvbnMuc2hvcnRGb3JtYXR0ZXJcblx0fSk7XG5cblx0dmFyIGNoYXJ0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0Y2hhcnRFbC5pbm5lckhUTUwgPSBodG1sO1xuXHRcblx0YmluZENsaWNrSGFuZGxlcihjaGFydEVsLCBkYXRhLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gY2hhcnRFbDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2hhcnRlcjogY2hhcnRlclxufTsiLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdWdseS91dGlsJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBiYXJTcGVjaWZpYyA9IHJlcXVpcmUoJy4vX2JhcicpO1xudmFyIG11bHRpYmFyU3BlY2lmaWMgPSByZXF1aXJlKCcuL19tdWx0aWJhcicpO1xudmFyIHBpZVNwZWNpZmljID0gcmVxdWlyZSgnLi9fcGllJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuL190YWJsZScpO1xudmFyIGhlYXRtYXAgPSByZXF1aXJlKCcuL19oZWF0bWFwJyk7XG52YXIgZGVmYXVsdFRUVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtcHJpbWFyeSBwYW5lbC1wb3BvdmVyXFxcIj5cXG4gIDwlIGlmICh0dC5oZWFkaW5nKSB7ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPjwlPSB0dC5oZWFkaW5nICU+PC9kaXY+XFxuICA8JSB9ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImRvbGxhelxcXCI+XFxuICAgICAgPCUgaWYgKHR0LmJvZHlUZXh0KSB7ICU+XFxuICAgICAgICA8JT0gdHQuYm9keVRleHQgJT5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgPCUgaWYgKHR0LmJvZHlMaXN0KSB7ICU+XFxuICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtdW5zdHlsZWRcXFwiPlxcbiAgICAgICAgICA8JSBfKHR0LmJvZHlMaXN0KS5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHsgJT5cXG4gICAgICAgICAgICA8bGk+PGI+PCU9IGl0ZW0uayAlPjwvYj4gPCU9IGl0ZW0udiAlPjwvbGk+XFxuICAgICAgICAgIDwlIH0pICU+XFxuICAgICAgICA8L3VsPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgPC9zcGFuPlxcbiAgPC9kaXY+XFxuICA8JSBpZiAodHQuZm9vdGVyVGV4dCkgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1mb290ZXJcXFwiPlxcbiAgICAgIDwlPSB0dC5mb290ZXJUZXh0ICU+XFxuICAgIDwvZGl2PlxcbiAgPCUgfSAlPlxcbjwvZGl2PlxcblwiKTtcblxuXG52YXIgY2hhcnRlcnMgPSB7XG4gIGJhcjogY29tbW9uLm52Q2hhcnRlcihiYXJTcGVjaWZpYyksXG4gIHBpZTogY29tbW9uLm52Q2hhcnRlcihwaWVTcGVjaWZpYyksXG4gIG11bHRpYmFyOiBjb21tb24ubnZDaGFydGVyKG11bHRpYmFyU3BlY2lmaWMpLFxuICBoZWF0bWFwOiBjb21tb24ubnZDaGFydGVyKGhlYXRtYXApLFxuICB0YWJsZTogdGFibGUuY2hhcnRlclxufTtcblxuXG5mdW5jdGlvbiBjaGFydCh0eXBlLCBkYXRhLCBvcHRpb25zKSB7XG4gIC8qXG4gICAqIEBwYXJhbSB0eXBlOiAnYmFyJyAoZGVmYXVsdCksICdwaWUnLCBvciAnbXVsdGliYXInXG4gICAqIEBwYXJhbSBkYXRhOiBbe2tleTogJ3NlcmlzTmFtZScsIHZhbHVlczogW3t4Ok5OLCB5Ok5OfV19XVxuICAgKiBAcGFyYW0gb3B0aW9uczogb3B0aW9uYWwgZXh0cmEgc3R1ZmZcbiAgICovXG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gc2V0dGluZ3MgZGVmYXVsdHNcbiAgb3B0aW9ucyA9IF8oXyhvcHRpb25zKS5jbG9uZSgpKS5kZWZhdWx0cyh7XG4gICAgaGVpZ2h0OiB2b2lkIDAsICAvLyBzaG91bGQgZmlsbCBjb250YWluZXIgaW4gbW9zdCBjYXNlcyBieSBkZWZhdWx0XG4gICAgd2lkdGg6IHZvaWQgMCxcbiAgICBudW1iZXJGb3JtYXR0ZXI6IGQzLmZvcm1hdCgnLCcpLFxuICAgIHNob3J0Rm9ybWF0dGVyOiBvcHRpb25zLm51bWJlckZvcm1hdHRlciB8fCB1dGlsLmZvcm1hdEtNQigzLCBhcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLmRlY2ltYWxTZXBhcmF0b3IpLFxuICAgIGFkZExlZ2VuZDogdHJ1ZSxcbiAgICB0cmltTGFiZWxzOiB0cnVlLFxuICAgIGdldFRUQ29udGVudDogY29tbW9uLmRlZmF1bHRHZXRUVENvbnRlbnQsXG4gICAgdHRUZW1wbGF0ZTogZGVmYXVsdFRUVGVtcGxhdGUsXG4gICAgY2xpY2tIYW5kbGVyOiBjb21tb24uZGVmYXVsdENsaWNrSGFuZGxlcixcbiAgICBudkNvbnRyb2xzOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBjaGFydGVyID0gY2hhcnRlcnNbdHlwZV0gfHwgY29tbW9uLmZhaWwoJ3VucmVjb2duaXplZCBjaGFydCB0eXBlJywgdHlwZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbDogY2hhcnRlcihkYXRhLCBvcHRpb25zKVxuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcnQ7XG4iLCJ2YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdWdseS91dGlsJyk7XG52YXIgTnVtZXJhbCA9IHJlcXVpcmUoJ251bWVyYWwnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5cbi8vIGhhY2sgbnZkMydzIGNhbGNBcHByb3hUZXh0V2lkdGggYmVjYXVzZSBpdCBpcyB0ZXJycnJycnJycnJpYmxlXG4vLyB0aGlzIHNvbHV0aW9uIGlzIGp1c3QgYXMgYmFkIDooXG4vLyBudmQzIG1ha2VzIG1lIHNvIHNhZCA6KFxuKGZ1bmN0aW9uKHVuZm9ydHVuYXRlTGliKSB7XG4gIHZhciBzYWRXYXlPZkNhbGN1bGF0aW5nVGV4dFdpZHRoID0gdW5mb3J0dW5hdGVMaWIudXRpbHMuY2FsY0FwcHJveFRleHRXaWR0aDtcbiAgdW5mb3J0dW5hdGVMaWIudXRpbHMuY2FsY0FwcHJveFRleHRXaWR0aCA9IGZ1bmN0aW9uKHN2Z1RleHRFbCkge1xuICAgIHZhciBvcmlnaW5hbFRleHQgPSBzdmdUZXh0RWwudGV4dCgpLFxuICAgICAgICBzcGFjZVBhZGRlZFRleHQgPSBvcmlnaW5hbFRleHQsXG4gICAgICAgIG51bWJlck9mRG90cyA9IChvcmlnaW5hbFRleHQubWF0Y2goL1xcLi9nKSB8fCBbXSkubGVuZ3RoLFxuICAgICAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGg7XG5cbiAgICBpZiAob3JpZ2luYWxUZXh0LnRvVXBwZXJDYXNlKCkgPT09IG9yaWdpbmFsVGV4dCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbFRleHQubGVuZ3RoIC8gNTsgaSsrKSB7IHNwYWNlUGFkZGVkVGV4dCArPSAnICc7IH1cbiAgICAgIHN2Z1RleHRFbC50ZXh0KHNwYWNlUGFkZGVkVGV4dCk7XG4gICAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGggPSBzYWRXYXlPZkNhbGN1bGF0aW5nVGV4dFdpZHRoKHN2Z1RleHRFbCk7XG4gICAgICBzdmdUZXh0RWwudGV4dChvcmlnaW5hbFRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGggPSBzYWRXYXlPZkNhbGN1bGF0aW5nVGV4dFdpZHRoKHN2Z1RleHRFbCk7XG4gICAgfVxuXG4gICAgLy8g4pmqIGRvIHlvdSBiZWxpZXZlIGluIG1hYWFhZ2ljIOKZq1xuICAgIHBvb3JseUNhbGN1bGF0ZWRXaWR0aCAtPVxuICAgICAgKHBvb3JseUNhbGN1bGF0ZWRXaWR0aCAvIHNwYWNlUGFkZGVkVGV4dC5sZW5ndGgpICogKG51bWJlck9mRG90cyAvIDMpO1xuICAgIC8vIOKZqiBtYWdpYyBtYWdpYyBtYWdpYyDimatcbiAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGggKz0gNjtcblxuICAgIHJldHVybiBwb29ybHlDYWxjdWxhdGVkV2lkdGg7XG4gIH07XG59KShudik7XG5cblxuZnVuY3Rpb24gZmFpbCgvKiBhcmd1bWVudHMgKi8pIHtcbiAgdGhyb3cge1xuICAgIG5hbWU6ICdDaGFydCBFcnJvcicsXG4gICAgbWVzc2FnZTogQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcsICcpLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyB0aGlzLm1lc3NhZ2U7IH1cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBudkNoYXJ0Q29tbW9uKG52Q2hhcnQsIG1heENhdGVnb3JpZXMpIHtcbiAgcmV0dXJuIG52Q2hhcnRcbiAgICAueChmdW5jdGlvbihkKSB7IHJldHVybiB1dGlsLmZvcm1hdFNob3J0VGV4dCgxOSkoZC54KTsgfSkgIC8vIGZpeCBvdmVyZmxvd3MgaW4gbGVnZW5kc1xuICAgIC5jb2xvcih1dGlsLmNhdGVnb3J5Q29sb3VycyhtYXhDYXRlZ29yaWVzKSk7XG59XG5cblxuZnVuY3Rpb24gZ2V0U2VjcmV0UmVuZGVyQXJlYShoZWlnaHQsIHdpZHRoKSB7XG4gIHZhciBzZWNyZXRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1cGVyLXNlY3JldC1yZW5kZXItYXJlYS1zaGgnKTtcbiAgaWYgKCFzZWNyZXRBcmVhKSB7XG4gICAgc2VjcmV0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNlY3JldEFyZWEuaWQgPSAnc3VwZXItc2VjcmV0LXJlbmRlci1hcmVhLXNoaCc7XG4gICAgc2VjcmV0QXJlYS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgc2VjcmV0QXJlYS5zdHlsZS5sZWZ0ID0gJy05OTk5ZW0nO1xuICAgIHNlY3JldEFyZWEuc3R5bGUudG9wID0gJy05OTk5ZW0nOyAgLy8gZm9yIElFIDooXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWNyZXRBcmVhKTtcbiAgfVxuICBpZiAoaGVpZ2h0KSB7IHNlY3JldEFyZWEuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JzsgfVxuICBpZiAod2lkdGgpIHsgc2VjcmV0QXJlYS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JzsgfVxuICByZXR1cm4gc2VjcmV0QXJlYTtcbn1cblxuXG5mdW5jdGlvbiBta0NoYXJ0U1ZHKGhlaWdodCwgd2lkdGgpIHtcbiAgdmFyIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2Rhc2gtY2hhcnQnKTtcbiAgLy8gcHV0IGl0IGluIHRoZSBkb20gYnV0IG91dCBvZiB0aGUgd2F5LCBzbyB3ZSBjYW4gY29tcHV0ZSBzdHlsZXMgbiBzdHVmZlxuICBnZXRTZWNyZXRSZW5kZXJBcmVhKGhlaWdodCwgd2lkdGgpLmFwcGVuZENoaWxkKHN2Zyk7XG4gIHJldHVybiBzdmc7XG59XG5cblxuZnVuY3Rpb24gbnZCb2lsZXIobnZEYXRhLCBjaGFydCwgc3ZnLCBzcGVjaWZpYywgdHJpbUxhYmVscywgYWRkTGVnZW5kLCB3aWR0aCkge1xuICBpZiAodHJpbUxhYmVscykge1xuICAgIGNoYXJ0LngoZnVuY3Rpb24oZCkgeyByZXR1cm4gdXRpbC5mb3JtYXRTaG9ydFRleHQoNTApKGQueCk7IH0pO1xuICB9XG4gIGlmIChhZGRMZWdlbmQgJiYgc3BlY2lmaWMuYWRkTGVnZW5kKSB7XG4gICAgc3BlY2lmaWMuYWRkTGVnZW5kKHN2ZywgY2hhcnQsIG52RGF0YSwgdHJpbUxhYmVscywgd2lkdGgpO1xuICB9IGVsc2UgaWYgKCFhZGRMZWdlbmQgJiYgc3BlY2lmaWMucmVtb3ZlTGVnZW5kKSB7XG4gICAgc3BlY2lmaWMucmVtb3ZlTGVnZW5kKGNoYXJ0KTtcbiAgfVxuICBkMy5zZWxlY3Qoc3ZnKVxuICAgIC5kYXR1bShudkRhdGEpXG4gICAgLmNhbGwoY2hhcnQpO1xuICBudi51dGlscy53aW5kb3dSZXNpemUoY2hhcnQudXBkYXRlKTsgIC8vIHV1dXV1Z3VnZ2dnaFxuICBudi5hZGRHcmFwaChmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJ0OyB9KTsgIC8vIHV1dXV1Z2x5IGlzIG52ZDNcbiAgcmV0dXJuIHN2Zztcbn1cblxuXG5mdW5jdGlvbiBudkNvbG9yaWZ5Q2F0ZWdvcmllcyhjaGFydCwgZGF0YSwgc3BlY2lmaWMpIHtcbiAgdmFyIG51bWJlck9mQ2F0ZWdvcmllcyA9IHNwZWNpZmljLmNvdW50Q2F0ZWdvcmllcyhkYXRhKTtcbiAgY2hhcnQuY29sb3IodXRpbC5jYXRlZ29yeUNvbG91cnMobnVtYmVyT2ZDYXRlZ29yaWVzKSk7XG4gIHJldHVybiBjaGFydDtcbn1cblxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0VFRDb250ZW50KGNvbnRleHQpIHtcbiAgcmV0dXJuIHt0dDoge1xuICAgIGhlYWRpbmc6IGNvbnRleHQueC5yYXcsXG4gICAgYm9keVRleHQ6IGNvbnRleHQueS5yYXcsXG4gICAgZm9ybWF0dGVkQW1vdW50OiBjb250ZXh0LnoucmF3XG4gIH19O1xufVxuXG5cbmZ1bmN0aW9uIGdldE5pY2VDb250ZXh0KHJhdywgZGF0YSwgZm10WSkge1xuICB2YXIgc2VyaWVzSW5kZXggPSByYXcuc2VyaWVzSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHNlcmllczoge1xuICAgICAga2V5OiBkYXRhW3Nlcmllc0luZGV4XS5rZXksXG4gICAgICBpbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICB2YWx1ZXM6IGRhdGFbc2VyaWVzSW5kZXhdLnZhbHVlc1xuICAgIH0sXG4gICAgeDoge1xuICAgICAgcmF3OiByYXcucG9pbnQueCxcbiAgICAgIGZtdDogcmF3LmxhYmVsLFxuICAgICAgaW5kZXg6IHJhdy5wb2ludEluZGV4IHx8IHJhdy5pbmRleCB8fCAwXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICByYXc6IHJhdy5wb2ludC55LFxuICAgICAgZm10OiByYXcucG9pbnQueiB8fCBmbXRZXG4gICAgfVxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIG52QmluZFRvb2x0aXAoY2hhcnQsIGRhdGEsIHNwZWNpZmljLCB0ZW1wbGF0ZSwgZ2V0VFRDb250ZW50KSB7XG4gIHZhciBudlRUSGFuZGxlciA9IGZ1bmN0aW9uKHNlcmllc05hbWUsIGZtdFgsIGZtdFksIHJhdykge1xuICAgIHJldHVybiB0ZW1wbGF0ZShnZXRUVENvbnRlbnQoZ2V0TmljZUNvbnRleHQocmF3LCBkYXRhLCBmbXRZKSkpO1xuICB9O1xuXG4gIGlmIChzcGVjaWZpYy5ub3JtYWxpemVOdlRUQXJncykgeyAvLyB3ZSBtaWdodCBoYXZlIHRvIGZpeCBudidzIGluY29uc2lzdGVudCBUVCBhcmdzXG4gICAgbnZUVEhhbmRsZXIgPSB1dGlsLnRyYW5zZm9ybUFyZ3Moc3BlY2lmaWMubm9ybWFsaXplTnZUVEFyZ3MsIG52VFRIYW5kbGVyKTtcbiAgfVxuICBjaGFydC50b29sdGlwQ29udGVudChudlRUSGFuZGxlcik7XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdENsaWNrSGFuZGxlcigvKiBjb250ZXh0ICovKSB7XG4gIC8vIGRvZXMgbm90aGluZ1xufVxuXG5cbmZ1bmN0aW9uIG52QmluZE90aGVyc0NiKGNoYXJ0LCBkYXRhLCBzcGVjaWZpYywgY2xpY2tIYW5kbGVyKSB7XG4gIGlmIChjaGFydFtzcGVjaWZpYy5kaXNwYXRjaE5hbWVdICE9PSB1bmRlZmluZWQpIHtcblx0ICBjaGFydFtzcGVjaWZpYy5kaXNwYXRjaE5hbWVdLmRpc3BhdGNoLm9uKCdlbGVtZW50Q2xpY2snLCBmdW5jdGlvbihyYXcpIHtcblx0XHQgIGNsaWNrSGFuZGxlcihnZXROaWNlQ29udGV4dChyYXcsIGRhdGEpKTtcblx0ICB9KTtcbiAgfVx0ZWxzZSB7XG5cdCAgY29uc29sZS53YXJuKFwiQ2FudCBmaW5kIFwiICsgc3BlY2lmaWMuZGlzcGF0Y2hOYW1lKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIG52Q2hhcnRlcihzcGVjaWZpYykge1xuICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBzdmcgPSBta0NoYXJ0U1ZHKG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLndpZHRoKSxcbiAgICAgICAgbnZDaGFydCA9IHNwZWNpZmljLmNoYXJ0KG9wdGlvbnMsIGRhdGEpLFxuICAgICAgICBudkRhdGEgPSBzcGVjaWZpYy5kYXRhVG9OdihkYXRhKTtcbiAgICBudkNvbG9yaWZ5Q2F0ZWdvcmllcyhudkNoYXJ0LCBkYXRhLCBzcGVjaWZpYyk7XG4gICAgbnZCaW5kVG9vbHRpcChudkNoYXJ0LCBkYXRhLCBzcGVjaWZpYywgb3B0aW9ucy50dFRlbXBsYXRlLCBvcHRpb25zLmdldFRUQ29udGVudCk7XG4gICAgbnZCb2lsZXIobnZEYXRhLCBudkNoYXJ0LCBzdmcsIHNwZWNpZmljLCBvcHRpb25zLnRyaW1MYWJlbHMsIG9wdGlvbnMuYWRkTGVnZW5kLCBvcHRpb25zLndpZHRoKTtcbiAgICBudkJpbmRPdGhlcnNDYihudkNoYXJ0LCBkYXRhLCBzcGVjaWZpYywgb3B0aW9ucy5jbGlja0hhbmRsZXIpO1xuICAgIHJldHVybiBzdmc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIpIHtcblx0dmFyIGZvcm1hdCA9IFwiXCI7XG5cdGlmIChhcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLmdyb3VwU2VwYXJhdG9yLmxlbmd0aCA+IDApIHtcblx0XHRmb3JtYXQgPSBcIjAsMFwiO1xuXHR9IGVsc2Uge1xuXHRcdGZvcm1hdCA9IFwiMFwiO1xuXHR9XG5cdGlmIChhcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLm51bWJlckZvcm1hdC5pbmRleE9mKCcuJykgPiAwKSB7XG5cdFx0dmFyIGRlY2ltYWxEaWdpdHMgPSBhcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLm51bWJlckZvcm1hdC5sZW5ndGhcblx0XHRcdC0gYXBwLmdlbmVyYWxTZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncy5udW1iZXJGb3JtYXQuaW5kZXhPZignLicpO1xuXHRcdGZvcm1hdCA9IGZvcm1hdCArIFwiLlwiICsgbmV3IEFycmF5KGRlY2ltYWxEaWdpdHMpLmpvaW4oXCIwXCIpO1xuXHR9XG5cblx0Ly8gRGVmaW5lIGEgbmV3IFwibGFuZ3VhZ2VcIiBmb3IgTnVtZXJhbCB3aGVyZSB3ZSBjYW4gY2hhbmdlIHRoZSBkZWZhdWx0XG5cdC8vIGRlbGltaXRlcnMuXG5cdHZhciBhbXBMYW5nID0ge1xuXHRcdGRlbGltaXRlcnMgOiB7XG5cdFx0XHR0aG91c2FuZHMgOiBhcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLmdyb3VwU2VwYXJhdG9yLFxuXHRcdFx0ZGVjaW1hbCA6IGFwcC5nZW5lcmFsU2V0dGluZ3MubnVtYmVyRm9ybWF0U2V0dGluZ3MuZGVjaW1hbFNlcGFyYXRvclxuXHRcdH0sXG5cdFx0YWJicmV2aWF0aW9ucyA6IHtcblx0XHRcdHRob3VzYW5kIDogYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC10aG91c2FuZCcpLFxuXHRcdFx0bWlsbGlvbiA6IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtbWlsbGlvbicpLFxuXHRcdFx0YmlsbGlvbiA6IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtYmlsbGlvbicpLFxuXHRcdFx0dHJpbGxpb24gOiBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LXRyaWxsaW9uJylcblx0XHR9LFxuXHRcdG9yZGluYWwgOiBmdW5jdGlvbihudW1iZXIpIHtcblx0XHRcdHJldHVybiBudW1iZXIgPT09IDEgPyAnc3QnIDogJ3Jkcyc7XG5cdFx0fSxcblx0XHRjdXJyZW5jeSA6IHtcblx0XHRcdHN5bWJvbCA6ICckJ1xuXHRcdH1cblx0fTtcblx0TnVtZXJhbC5sYW5ndWFnZSgnYW1wJywgYW1wTGFuZyk7XG5cdC8vIEFwcGx5IG5ldyBsYW5ndWFnZS5cblx0TnVtZXJhbC5sYW5ndWFnZSgnYW1wJyk7XG5cdC8vIEFwcGx5IHRoZSBmb3JtYXQuXG5cdHZhciBzdHJpbmdOdW1iZXIgPSBuZXcgTnVtZXJhbChudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuXHRyZXR1cm4gc3RyaW5nTnVtYmVyO1xufVxuXG52YXIgYW1wTGFuZyA9XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZhaWw6IGZhaWwsXG4gIG52Q2hhcnRDb21tb246IG52Q2hhcnRDb21tb24sXG4gIGdldE5pY2VDb250ZXh0OiBnZXROaWNlQ29udGV4dCxcbiAgZGVmYXVsdEdldFRUQ29udGVudDogZGVmYXVsdEdldFRUQ29udGVudCxcbiAgZGVmYXVsdENsaWNrSGFuZGxlcjogZGVmYXVsdENsaWNrSGFuZGxlcixcbiAgbWtDaGFydFNWRzogbWtDaGFydFNWRyxcbiAgbnZCb2lsZXI6IG52Qm9pbGVyLFxuICBudkNoYXJ0ZXI6IG52Q2hhcnRlcixcbiAgZm9ybWF0TnVtYmVyOiBmb3JtYXROdW1iZXJcbn07XG4iLCJudi5tb2RlbHMuaGVhdG1hcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxyXG4gICAgICAgICwgd2lkdGggPSA1MDBcclxuICAgICAgICAsIGhlaWdodCA9IDUwMFxyXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XHJcbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cclxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcclxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXHJcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAncmVuZGVyRW5kJylcclxuICAgICAgICA7XHJcblxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBjaGFydCBmdW5jdGlvblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XHJcblxyXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcclxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2hlYXRtYXAgaW1tZWRpYXRlJyk7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xyXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xyXG5cclxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xyXG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcclxuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXHJcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXHJcbiAgICAgICAgeDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcclxuICAgICAgICBpZDogICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXHJcblxyXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xyXG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xyXG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XHJcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xyXG4gICAgICAgIH19LFxyXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtcclxuICAgICAgICAgICAgZ2V0WT1kMy5mdW5jdG9yKF8pO1xyXG4gICAgICAgIH19XHJcbiAgICB9KTtcclxuXHJcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbn07XHJcblxyXG5udi5tb2RlbHMuaGVhdE1hcENoYXJ0ID0gZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdFxyXG5cclxuICAgIHZhciBoZWF0bWFwID0gbnYubW9kZWxzLmhlYXRtYXAoKTtcclxuXHJcbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiAyMCwgbGVmdDogMjB9XHJcbiAgICB2YXIgd2lkdGggPSBudWxsO1xyXG5cdHZhciBoZWlnaHQgPSBudWxsO1xyXG4gICAgdmFyIHNob3dMZWdlbmQgPSBmYWxzZTtcclxuICAgIHZhciBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpO1xyXG4gICAgdmFyXHRzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKCk7XHJcbiAgICB2YXIgZGVmYXVsdFN0YXRlID0gbnVsbDtcclxuICAgIHZhciBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiO1xyXG4gICAgdmFyIGR1cmF0aW9uID0gMjUwO1xyXG4gICAgdmFyIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywncmVuZGVyRW5kJyk7XHJcbiAgICB2YXIgc2hvcnRUZXh0TGVuZ3RoID0gMTc7XHJcbiAgICB2YXIgaW5uZXJNYXJnaW4gPSB7XHJcbiAgICBcdFx0dG9wIDogMTIwLFxyXG5cdFx0XHRyaWdodCA6IDAsXHJcblx0XHRcdGJvdHRvbSA6IDEwMCxcclxuXHRcdFx0bGVmdCA6IDE1MFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgaW5pdGlhbFdpZHRoID0gOTYwO1xyXG4gICAgY29uc3QgaW5pdGlhbEhlaWdodCA9IDQwMDtcclxuICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gMTAyNDtcclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XHJcblxyXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgIFx0XHRyZXR1cm4ge1xyXG4gICAgXHRcdFx0YWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWVzLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICBcclxuICAgIHZhciBzaG9ydGVuVGV4dCA9IGZ1bmN0aW9uKHRleHQsIGxlbmd0aCkge1xyXG4gICAgXHRpZiAodGV4dC5sZW5ndGggPiBsZW5ndGgpIHtcclxuICAgIFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbGVuZ3RoKSArICcuLi4nO1xyXG4gICAgXHR9XHJcbiAgICBcdHJldHVybiB0ZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gQ2hhcnQgZnVuY3Rpb25cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XHJcbiAgICBcdHZhciBfc2VsZiA9IHRoaXM7XHJcbiAgICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcclxuICAgIFx0dmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7IC8vIFRoaXMgZG9lc250IHdvcmtzIG9uIHRvcCBvZiB0aGUgZmlsZSA6KCgoXHJcblxyXG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XHJcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKGhlYXRtYXApO1xyXG5cclxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgXHQvLyBHZXQgY3VycmVuY3kgZm9yIGxhdGVyLiAgICAgICAgXHQgICAgICAgXHRcclxuICAgICAgICBcdHZhciBjdXJyZW5jeUlkID0gYXBwLnNldHRpbmdzV2lkZ2V0LmRlZmluaXRpb25zLmdldFNlbGVjdGVkT3JEZWZhdWx0Q3VycmVuY3lJZCgpO1xyXG4gICAgICAgIFx0dmFyIHNlbGVjdGVkQ3VycmVuY3kgPSBhcHAuc2V0dGluZ3NXaWRnZXQuZGVmaW5pdGlvbnMuZmluZEN1cnJlbmN5QnlJZChjdXJyZW5jeUlkKS52YWx1ZTsgICAgICAgIFx0XHJcbiAgICAgICAgXHR2YXIgbmV3U2hvcnRUZXh0TGVuZ3RoID0gIWRhdGFbMF0udmFsdWVzLm1vZGVsLmdldCgnc2hvd0Z1bGxMZWdlbmRzJykgPyBzaG9ydFRleHRMZW5ndGggOiAxMDA7XHJcbiAgICAgICAgXHRcclxuICAgICAgICBcdHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJyksIDEwKSB8fCBpbml0aWFsV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSwgMTApIHx8IGluaXRpYWxIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcclxuXHJcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcclxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvL3NldCBzdGF0ZS5kaXNhYmxlZFxyXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICBcdHZhciBjdWJlU2l6ZSA9IDMwO1xyXG4gICAgICAgIFx0dmFyIHdpZHRoID0gY29udGFpbmVyV2lkdGggLSBpbm5lck1hcmdpbi5sZWZ0IC0gaW5uZXJNYXJnaW4ucmlnaHQ7XHJcbiAgICAgICAgXHR2YXIgdG9wU2VjdGlvbkhlaWdodCA9IDE4MDtcclxuICAgICAgICBcdHZhciBsZWdlbmRTZWN0aW9uSGVpZ2h0ID0gMjA7XHJcbiAgICAgICAgXHR2YXIgaGVpZ2h0ID0gdG9wU2VjdGlvbkhlaWdodCArIChjdWJlU2l6ZSAqIGRhdGFbMF0udmFsdWVzLnkubGVuZ3RoKSArIGxlZ2VuZFNlY3Rpb25IZWlnaHQ7XHJcbiAgICAgICAgXHR2YXIgbGVnZW5kRWxlbWVudEhlaWdodCA9IDIyO1xyXG4gICAgICAgIFx0Y29uc3QgdW5kZWZpbmVkQ29sb3IgPSAnIzY2Nic7XHJcbiAgICAgICAgXHRjb25zdCBub0NvbG9yID0gJyNGRkZGRkYnO1xyXG4gICAgICAgIFx0dmFyIGNhdGVnb3JpZXMgPSBnZXRDYXRlZ29yaWVzQnlUaHJlc2hvbGQodW5kZWZpbmVkQ29sb3IsIG5vQ29sb3IsIGRhdGFbMF0udmFsdWVzLm1vZGVsKTtcclxuICAgICAgICBcdFxyXG4gICAgICAgIFx0JChjb250YWluZXJbMF0pLmNzcygnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4JykuYXR0cignY2xhc3MnLCAnZGFzaC1jaGFydCBudmQzLXN2ZyBoZWF0bWFwLWNoYXJ0Jyk7XHJcbiAgICAgICAgXHRcclxuICAgICAgICBcdHZhciBzdmcgPSBjb250YWluZXJcclxuICAgICAgICBcdFx0LmFwcGVuZChcImdcIilcclxuICAgICAgICBcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBpbm5lck1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBpbm5lck1hcmdpbi50b3AgKyBcIilcIilcclxuICAgICAgICBcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImhlYXRtYXAtbWFpbi1jb250YWluZXJcIik7XHJcbiAgICAgICAgXHRcclxuICAgICAgICBcdC8vIEFkZCBTVkcgZmlsdGVyIGZvciBjZWxsIGhpZ2hsaWdodC5cclxuICAgICAgICBcdC8vIEZvciBtb3JlIGluZm8gYWJvdXQgdGhlc2UgZmlsdGVycyBzZWU6IGh0dHA6Ly93d3cuc3ZnYmFzaWNzLmNvbS9maWx0ZXJzNC5odG1sIC8vIGh0dHA6Ly9hcGlrZS5jYS9wcm9nX3N2Z19maWx0ZXJfZmVDb2xvck1hdHJpeC5odG1sIC8vIGh0dHA6Ly9hbGlzdGFwYXJ0LmNvbS9hcnRpY2xlL2ZpbmVzc2luZy1mZWNvbG9ybWF0cml4XHJcbiAgICAgICAgXHRzdmcuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJmaWx0ZXJcIikuYXR0cihcImlkXCIsIFwiZmlsdGVyU2F0dXJhdGVcIikuYXBwZW5kKFwiZmVDb2xvck1hdHJpeFwiKS5hdHRyKFwiaW5cIiwgXCJTb3VyY2VHcmFwaGljXCIpLmF0dHIoXCJ0eXBlXCIsIFwic2F0dXJhdGVcIikuYXR0cihcInZhbHVlc1wiLCBcIjVcIik7XHJcbiAgICAgICAgXHRzdmcuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJmaWx0ZXJcIikuYXR0cihcImlkXCIsIFwiZmlsdGVyTHVtaW5hbmNlVG9BbHBoYVwiKS5hcHBlbmQoXCJmZUNvbG9yTWF0cml4XCIpLmF0dHIoXCJpblwiLCBcIlNvdXJjZUdyYXBoaWNcIikuYXR0cihcInR5cGVcIiwgXCJsdW1pbmFuY2VUb0FscGhhXCIpO1xyXG4gICAgICAgIFx0c3ZnLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwiZmlsdGVyXCIpLmF0dHIoXCJpZFwiLCBcImZpbHRlckJsdXJcIikuYXBwZW5kKFwiZmVHYXVzc2lhbkJsdXJcIikuYXR0cihcImluXCIsIFwiU291cmNlR3JhcGhpY1wiKS5hdHRyKFwic3RkRGV2aWF0aW9uXCIsIFwiMlwiKTtcclxuICAgICAgICBcdHN2Zy5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcImZpbHRlclwiKS5hdHRyKFwiaWRcIiwgXCJmaWx0ZXJEYXJrZW5cIikuYXBwZW5kKFwiZmVDb2xvck1hdHJpeFwiKS5hdHRyKFwidHlwZVwiLCBcIm1hdHJpeFwiKS5hdHRyKFwidmFsdWVzXCIsIFwiMC41IDAgMCAwIDAgMCAwLjUgMCAwIDAgMCAwIDAuNSAwIDAgMCAwIDAgMSAwXCIpO1xyXG5cclxuICAgICAgICBcdC8vIFJvd3MgY29udGFpbmVyLlxyXG4gICAgICAgIFx0dmFyIHlBeGlzTGFiZWxzQ29udGFpbmVyID0gc3ZnICAgICAgICBcdFxyXG5cdFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImhlYXRtYXAteUF4aXMtY29udGFpbmVyXCIpO1xyXG4gICAgICAgIFx0XHJcbiAgICAgICAgXHQvLyBSb3dzLlxyXG4gICAgICAgIFx0dmFyIHlBeGlzTGFiZWxzID0geUF4aXNMYWJlbHNDb250YWluZXJcclxuICAgICAgICBcdFx0LnNlbGVjdEFsbChcIi55TGFiZWxcIilcclxuICAgICAgICBcdFx0LmRhdGEoZGF0YVswXS52YWx1ZXMueSlcclxuICAgICAgICBcdFx0LmVudGVyKClcclxuICAgICAgICBcdFx0LmFwcGVuZChcInRleHRcIilcclxuICAgICAgICBcdFx0LnRleHQoZnVuY3Rpb24oZCkge1xyXG4gICAgICAgIFx0XHRcdHJldHVybiBzaG9ydGVuVGV4dChkLCBuZXdTaG9ydFRleHRMZW5ndGgpO1xyXG4gICAgICAgIFx0XHR9KVxyXG4gICAgICAgIFx0XHQuYXR0cihcInhcIiwgMClcclxuICAgICAgICBcdFx0LmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICBcdFx0XHRyZXR1cm4gaSAqIGN1YmVTaXplO1xyXG4gICAgICAgIFx0XHR9KVxyXG4gICAgICAgIFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxyXG4gICAgICAgIFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgtNixcIiArIGN1YmVTaXplIC8gMS41ICsgXCIpXCIpXHJcbiAgICAgICAgXHRcdC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwieUxhYmVsIG1vbm8gYXhpcyBudi1zZXJpZXNcIjtcclxuICAgICAgICBcdFx0fSlcclxuICAgICAgICBcdFx0LmF0dHIoJ2RhdGEtdGl0bGUnLCBmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgXHRcdFx0cmV0dXJuIGQ7XHJcbiAgICAgICAgXHRcdH0pO1xyXG4gICAgICAgIFx0XHJcbiAgICAgICAgXHRcdC8vIEZvcm1hdCBcIk90aGVyc1wiIHNwZWNpYWwgcm93IGlmIG5lZWRlZC5cclxuICAgICAgICBcdFx0aWYgKGRhdGFbMF0udmFsdWVzLnlDb3VudCA8IGRhdGFbMF0udmFsdWVzLnlUb3RhbENvdW50KSB7XHJcbiAgICAgICAgXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIFx0XHRcdHZhciBkYXRhMiA9IGRhdGE7XHJcbiAgICAgICAgXHRcdFx0dmFyIHRleHRFbGVtZW50ID0gJChjb250YWluZXJbMF0pLmZpbmQoJy55TGFiZWwnKS5sYXN0KCk7XHJcbiAgICAgICAgXHRcdFx0JCh0ZXh0RWxlbWVudCkuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICBcdFx0XHRcdHJldHVybiAkKHRleHRFbGVtZW50KS5hdHRyKCdjbGFzcycpICsgJyBsZWdlbmQtb3RoZXJzJztcclxuICAgICAgICBcdFx0XHR9KTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHJcbiAgICAgICAgXHRcdC8vIEFkZCBUb3RhbHMgc3BlY2lhbCByb3cuXHJcbiAgICAgICAgXHRcdHlBeGlzTGFiZWxzQ29udGFpbmVyLmFwcGVuZChcInRleHRcIilcclxuICAgICAgICBcdFx0XHQudGV4dChcIlRPVEFMU1wiKVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwieVwiLCAoZGF0YVswXS52YWx1ZXMueS5sZW5ndGggKiBjdWJlU2l6ZSkpXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcInlMYWJlbCBtb25vIGF4aXMgbnYtc2VyaWVzIGhlYXRtYXAtdG90YWxzXCIpXHJcbiAgICAgICAgXHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcclxuICAgICAgICBcdFx0XHQuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIilcclxuICAgICAgICAgICAgXHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC02LFwiICsgY3ViZVNpemUgLyAxLjUgKyBcIilcIilcclxuICAgICAgICAgICAgXHRcdC5hdHRyKCdkYXRhLWkxOG4nLCAnYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLXRvdGFscycpO1xyXG5cclxuICAgICAgICBcdFx0Ly8gQ29sdW1ucyBjb250YWluZXIuXHJcbiAgICAgICAgXHRcdHZhciB4QXhpc0xhYmVsc0NvbnRhaW5lciA9IHN2Z1xyXG4gICAgICAgIFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMTguNSwgLTUpXCIpXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImhlYXRtYXAteEF4aXMtY29udGFpbmVyXCIpO1xyXG5cclxuICAgICAgICBcdFx0Ly8gQ29sdW1uc1xyXG4gICAgICAgIFx0XHQvLyBOb3RpY2UgaW4gdHJhbnNmb3JtIGZ1bmN0aW9ucyB0aGUgb3JkZXIgaXMgdmVyeSBpbXBvcnRhbnQgaWYgeW91IGhhdmUgdG8gYXBwbHkgbW9yZSB0aGFuIG9uZSwgbGlrZSB0cmFuc2xhdGUgYW5kIHJvdGF0ZS5cclxuICAgICAgICBcdFx0Ly8gY3ViZVNpemUgaXMgd2hlcmUgd2UgZGVmaW5lIGhvdyBiaWcgYXJlIHRoZSBjdWJlcyBzbyBpZiB3ZSBjaGFuZ2UgaXQgaW4gdGhlIGZ1dHVyZSB0aGUgY2hhcnQgd2lsbCByZXNpemUgY29ycmVjdGx5LlxyXG4gICAgICAgIFx0XHR2YXIgeEF4aXNMYWJlbHMgPSB4QXhpc0xhYmVsc0NvbnRhaW5lclxyXG4gICAgICAgIFx0XHRcdC5zZWxlY3RBbGwoXCIueExhYmVsXCIpXHJcbiAgICAgICAgXHRcdFx0LmRhdGEoZGF0YVswXS52YWx1ZXMueClcclxuICAgICAgICBcdFx0XHQuZW50ZXIoKVxyXG4gICAgICAgIFx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXHJcbiAgICAgICAgXHRcdFx0LnRleHQoZnVuY3Rpb24oZCkge1xyXG4gICAgICAgIFx0XHRcdFx0cmV0dXJuIHNob3J0ZW5UZXh0KGQsIG5ld1Nob3J0VGV4dExlbmd0aCk7XHJcbiAgICAgICAgXHRcdFx0fSlcclxuICAgICAgICBcdFx0XHQuYXR0cihcInhcIiwgZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICAgIFx0XHRcdFx0cmV0dXJuIGkgKiBjdWJlU2l6ZTtcclxuICAgICAgICBcdFx0XHR9KVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwieVwiLCAwKVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICBcdFx0XHRcdHJldHVybiBcInJvdGF0ZSgyNzAsIFwiICsgKGN1YmVTaXplICogaSkgKyBcIiwgMClcIjtcclxuICAgICAgICBcdFx0XHR9KVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwieExhYmVsIG1vbm8gYXhpcyBudi1zZXJpZXNcIjtcclxuICAgICAgICBcdFx0XHR9KVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKCdkYXRhLXRpdGxlJywgZnVuY3Rpb24oZCkge1xyXG4gICAgICAgIFx0XHRcdFx0cmV0dXJuIGQ7XHJcbiAgICAgICAgXHRcdFx0fSk7XHJcbiAgICAgICAgXHRcdFxyXG4gICAgICAgIFx0XHQvLyBBZGQgVG90YWxzIHNwZWNpYWwgY29sdW1uLlxyXG4gICAgICAgIFx0XHR4QXhpc0xhYmVsc0NvbnRhaW5lci5hcHBlbmQoXCJ0ZXh0XCIpXHJcbiAgICAgICAgXHRcdFx0LnRleHQoXCJUT1RBTFNcIilcclxuICAgICAgICBcdFx0XHQuYXR0cihcInhcIiwgY3ViZVNpemUgKiBkYXRhWzBdLnZhbHVlcy54Lmxlbmd0aClcclxuICAgICAgICBcdFx0XHQuYXR0cihcInlcIiwgMClcclxuICAgICAgICBcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwieExhYmVsIG1vbm8gYXhpcyBudi1zZXJpZXMgaGVhdG1hcC10b3RhbHNcIilcclxuICAgICAgICBcdFx0XHQuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIilcclxuICAgICAgICAgICAgXHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICBcdFx0XHRcdHJldHVybiBcInJvdGF0ZSgyNzAsIFwiICsgKGN1YmVTaXplICogZGF0YVswXS52YWx1ZXMueC5sZW5ndGgpICsgXCIsIDApXCI7XHJcbiAgICAgICAgXHRcdFx0fSlcclxuICAgICAgICBcdFx0XHQuYXR0cignZGF0YS1pMThuJywgJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC10b3RhbHMnKTtcclxuXHJcbiAgICAgICAgXHRcdC8vIEN1YmVzXHJcbiAgICAgICAgXHRcdHZhciBjdWJlc0NvbnRhaW5lciA9IHN2Z1xyXG4gICAgXHRcdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG4gICAgXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiaGVhdG1hcC1jdWJlcy1jb250YWluZXJcIik7XHJcbiAgICAgICAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVswXS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBcdFx0XHRjcmVhdGVDdWJlKGN1YmVzQ29udGFpbmVyLCAkLmV4dGVuZChkYXRhWzBdLnZhbHVlc1tpXSwge3Rvb2x0aXA6IHNlbGVjdGVkQ3VycmVuY3kgKyAnICcgKyBkYXRhWzBdLnZhbHVlc1tpXS5hbW91bnR9KSwgY3ViZVNpemUsIG5vQ29sb3IsIGNhdGVnb3JpZXMpOyAgICAgICAgXHRcdFx0ICAgIFx0XHRcdFx0XHJcbiAgICAgICAgXHRcdH0gICAgICAgIFxyXG4gICAgICAgIFx0XHQvLyBBZGQgdG90YWwncyByb3cgaW4gdGhlIGVuZC4gICAgICAgIFx0XHRcclxuICAgICAgICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhWzBdLnZhbHVlcy54Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgXHRcdFx0Y3JlYXRlQ3ViZShjdWJlc0NvbnRhaW5lciwge3g6IGkgKyAxLCB5OiBkYXRhWzBdLnZhbHVlcy55Lmxlbmd0aCArIDEsIHZhbHVlOiBkYXRhWzBdLnZhbHVlcy54UFRvdGFsc1tpXSwgdG9vbHRpcDogc2VsZWN0ZWRDdXJyZW5jeSArICcgJyArIGRhdGFbMF0udmFsdWVzLnhUb3RhbHNbaV19LCBjdWJlU2l6ZSwgbm9Db2xvciwgY2F0ZWdvcmllcyk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0Ly8gQWRkIHRvdGFsJ3MgY29sdW1uIG9uIHRoZSByaWdodCBzaWRlLlxyXG4gICAgICAgIFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbMF0udmFsdWVzLnkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBcdFx0XHRjcmVhdGVDdWJlKGN1YmVzQ29udGFpbmVyLCB7eDogZGF0YVswXS52YWx1ZXMueC5sZW5ndGggKyAxICwgeTogaiArIDEsIHZhbHVlOiBkYXRhWzBdLnZhbHVlcy55UFRvdGFsc1tqXSwgdG9vbHRpcDogc2VsZWN0ZWRDdXJyZW5jeSArICcgJyArIGRhdGFbMF0udmFsdWVzLnlUb3RhbHNbal19LCBjdWJlU2l6ZSwgbm9Db2xvciwgY2F0ZWdvcmllcyk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0XHJcbiAgICAgICAgXHRcdC8vIEFkZCBwZXJjZW50YWdlIGxlZ2VuZHMuXHJcbiAgICAgICAgXHRcdGNyZWF0ZUxlZ2VuZHMoc3ZnLCBkYXRhLCBjdWJlU2l6ZSwgY2F0ZWdvcmllcywgbGVnZW5kRWxlbWVudEhlaWdodCk7XHJcbiAgICAgICAgXHRcdFxyXG4gICAgICAgIFx0XHRhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oc3ZnWzBdKTtcclxuICAgICAgICBcdFx0XHJcbiAgICAgICAgXHRcdC8vIFJlY2FsY3VsYXRlIG1hcmdpbnMgaWYgd2UgYXJlIHNob3dpbmcgdGhlIGZ1bGwgbGVnZW5kcy5cclxuICAgICAgICAgICAgXHRpZiAoZGF0YVswXS52YWx1ZXMubW9kZWwuZ2V0KCdzaG93RnVsbExlZ2VuZHMnKSkgeyAgICAgICAgXHRcdFxyXG4gICAgICAgICAgICBcdFx0dmFyIHRvcCA9IHN2Zy5zZWxlY3QoJy5oZWF0bWFwLXhBeGlzLWNvbnRhaW5lcicpLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0O1xyXG4gICAgICAgICAgICBcdFx0dmFyIGxlZnQgPSBzdmcuc2VsZWN0KCcuaGVhdG1hcC15QXhpcy1jb250YWluZXInKS5ub2RlKCkuZ2V0QkJveCgpLndpZHRoICsgMjU7XHJcbiAgICAgICAgICAgIFx0XHRzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGxlZnQgKyBcIixcIiArIHRvcCArIFwiKVwiKTtcclxuICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdoZWF0bWFwIGltbWVkaWF0ZScpO1xyXG4gICAgICAgIHJldHVybiBjaGFydDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0Q2F0ZWdvcmllc0J5VGhyZXNob2xkKHVuZGVmaW5lZENvbG9yLCBub0NvbG9yLCBtb2RlbCkge1xyXG4gICAgXHR2YXIgY2F0ZWdvcmllcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgXHRjYXRlZ29yaWVzLnB1c2goe21pbjogLTk5LCBtYXg6IC0xLCBjb2xvcjogdW5kZWZpbmVkQ29sb3J9KTtcclxuICAgIFx0Y2F0ZWdvcmllcy5wdXNoKHttaW46IC0xLCBtYXg6IDAsIGNvbG9yOiBub0NvbG9yfSk7XHJcbiAgICBcdHZhciBjb2xvcnMgPSBtb2RlbC5nZXQoJ2hlYXRtYXBfY29uZmlnJykubW9kZWxzWzBdLmdldCgnYW1vdW50Q29sb3JzJyk7XHJcbiAgICBcdHZhciBpID0gMjtcclxuICAgIFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gY29sb3JzKSB7XHJcbiAgICBcdCAgICBpZiAoY29sb3JzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgXHQgICAgXHRjYXRlZ29yaWVzLnB1c2goe21pbjogcGFyc2VJbnQocHJvcGVydHkpLCBjb2xvcjogY29sb3JzW3Byb3BlcnR5XSwgbWF4OiBudWxsfSk7XHJcbiAgICBcdCAgICBcdGlmIChpID4gMikge1xyXG4gICAgXHQgICAgXHRcdGNhdGVnb3JpZXNbaSAtIDFdLm1heCA9IHBhcnNlSW50KHByb3BlcnR5KTtcclxuICAgIFx0ICAgIFx0fVxyXG4gICAgXHQgICAgXHRpKys7XHJcbiAgICBcdCAgICB9XHJcbiAgICBcdH1cclxuICAgIFx0Y2F0ZWdvcmllc1tpIC0gMV0ubWF4ID0gMTAxO1xyXG4gICAgXHRyZXR1cm4gY2F0ZWdvcmllcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTGVnZW5kcyhzdmcsIGRhdGEsIGN1YmVTaXplLCBjYXRlZ29yaWVzLCBsZWdlbmRFbGVtZW50SGVpZ2h0KSB7XHJcbiAgICBcdHZhciBsZWdlbmRzQ29udGFpbmVyID0gc3ZnXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsIFwiICsgKCgoZGF0YVswXS52YWx1ZXMueS5sZW5ndGggKyAxKSAqIGN1YmVTaXplKSArIDEwKSArIFwiKVwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiaGVhdG1hcC1sZWdlbmRzLWNvbnRhaW5lclwiKTtcclxuICAgIFx0dmFyIGxlZ2VuZHNQb29sID0gW2FwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWxlc3MtdGhhblwiKSArIFwiIFwiICsgY2F0ZWdvcmllc1syXS5tYXggKyBcIiVcIixcclxuICAgIFx0ICAgICAgICAgICAgICAgICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWJldHdlZW5cIikgKyBcIiBcIiArIGNhdGVnb3JpZXNbM10ubWluICsgXCIlIFwiICsgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYW5kXCIpICsgXCIgPFwiICsgY2F0ZWdvcmllc1szXS5tYXggKyBcIiUgXCIsXHJcbiAgICBcdCAgICAgICAgICAgICAgICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWxlZ2VuZC1iZXR3ZWVuXCIpICsgXCIgXCIgKyBjYXRlZ29yaWVzWzRdLm1pbiArIFwiJSBcIiArIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWFuZFwiKSArIFwiIDxcIiArIGNhdGVnb3JpZXNbNF0ubWF4ICsgXCIlIFwiLFxyXG4gICAgXHQgICAgICAgICAgICAgICAgICAgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYmV0d2VlblwiKSArIFwiIFwiICsgY2F0ZWdvcmllc1s1XS5taW4gKyBcIiUgXCIgKyBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWxlZ2VuZC1hbmRcIikgKyBcIiA8XCIgKyBjYXRlZ29yaWVzWzVdLm1heCArIFwiJSBcIixcclxuICAgIFx0ICAgICAgICAgICAgICAgICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWJldHdlZW5cIikgKyBcIiBcIiArIGNhdGVnb3JpZXNbNl0ubWluICsgXCIlIFwiICsgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYW5kXCIpICsgXCIgPFwiICsgY2F0ZWdvcmllc1s2XS5tYXggKyBcIiUgXCIsXHJcbiAgICBcdCAgICAgICAgICAgICAgICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWxlZ2VuZC1tb3JlLXRoYW5cIikgKyBcIiBcIiArIGNhdGVnb3JpZXNbN10ubWluICsgXCIlXCJdO1xyXG4gICAgXHR2YXIgbWF4TGVnZW5kVGV4dFdpZHRoID0gMDtcclxuICAgIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRzUG9vbC5sZW5ndGg7IGkrKykge1xyXG4gICAgXHRcdHZhciBhdXhXaWR0aCA9IGNhbGN1bGF0ZVRleHRXaWR0aChsZWdlbmRzUG9vbFtpXSk7XHJcbiAgICBcdFx0aWYgKGF1eFdpZHRoID4gbWF4TGVnZW5kVGV4dFdpZHRoKSB7XHJcbiAgICBcdFx0XHRtYXhMZWdlbmRUZXh0V2lkdGggPSBhdXhXaWR0aDtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0JChcIiN0ZW1wU3BhblwiKS5yZW1vdmUoKTtcclxuICAgIFx0fVxyXG4gICAgXHRtYXhMZWdlbmRUZXh0V2lkdGggKz0gMjA7XHJcbiAgICBcdFxyXG4gICAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZHNQb29sLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBcdFx0dmFyIGxlZ2VuZHMgPSBsZWdlbmRzQ29udGFpbmVyXHJcblx0XHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgKGkgKiBtYXhMZWdlbmRUZXh0V2lkdGgpKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4TGVnZW5kVGV4dFdpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGxlZ2VuZEVsZW1lbnRIZWlnaHQpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImJvcmRlcmVkXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjYXRlZ29yaWVzW2kgKyAyXS5jb2xvcik7XHJcblx0XHRcclxuXHRcdFx0dmFyIHRleHQgPSBsZWdlbmRzQ29udGFpbmVyLmFwcGVuZChcInRleHRcIik7IFxyXG5cdFx0XHR0ZXh0LmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ0FyaWFsJylcclxuXHRcdFx0XHQuYXR0cignZm9udC1zaXplJywgJzExcHgnKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCAxNSlcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgKChpICogbWF4TGVnZW5kVGV4dFdpZHRoKSArICgobWF4TGVnZW5kVGV4dFdpZHRoIC0gY2FsY3VsYXRlVGV4dFdpZHRoKGxlZ2VuZHNQb29sW2ldKSkgLyAyKSkpXHJcblx0XHRcdFx0LnRleHQobGVnZW5kc1Bvb2xbaV0pOyAvLyBXaHkgXCJ0ZXh0XCIgaW5zdGVhZCBvZiBcImh0bWxcIiwgYmVjYXVzZSBpdCBkb2VzbnQgd29yayBvbiBJRS5cclxuICAgIFx0fVxyXG4gICAgXHRcclxuICAgIFx0bGVnZW5kc0NvbnRhaW5lci5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC50ZXh0KFwiTEVHRU5EU1wiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgLTYpXHJcblx0XHRcdC5hdHRyKFwieVwiLCAxNSlcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcInlMYWJlbCBtb25vIGF4aXMgbnYtc2VyaWVzIGhlYXRtYXAtdG90YWxzXCIpXHJcblx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcblx0XHRcdC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxyXG5cdFx0XHQuYXR0cignZGF0YS1pMThuJywgJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmRzJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1YmUoY3ViZXNDb250YWluZXIsIGRhdGEsIGN1YmVTaXplLCBub0NvbG9yLCBjYXRlZ29yaWVzKSB7XHJcbiAgICBcdHZhciBzZWxmRGF0YSA9IGRhdGE7XHJcbiAgICBcdHZhciBjdWJlID0gY3ViZXNDb250YWluZXJcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJ4XCIsICgoZGF0YS54IC0gMSkgKiBjdWJlU2l6ZSkpXHJcblx0XHRcdC5hdHRyKFwieVwiLCAoKGRhdGEueSAtIDEpICogY3ViZVNpemUpKVxyXG5cdFx0XHQuYXR0cihcInJ4XCIsIDQpXHJcblx0XHRcdC5hdHRyKFwicnlcIiwgNClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImJvcmRlcmVkXCIpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgY3ViZVNpemUpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGN1YmVTaXplKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIG5vQ29sb3IpXHJcblx0XHRcdC5hdHRyKFwiZGF0YS14XCIsIGRhdGEueCAtIDEpXHJcblx0XHRcdC5hdHRyKFwiZGF0YS15XCIsIGRhdGEueSAtIDEpO1xyXG5cdFx0XHJcblx0XHRjdWJlLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwMClcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjYWxjdWxhdGVDb2xvckZyb21DYXRlZ29yaWVzKGRhdGEudmFsdWUsIGNhdGVnb3JpZXMsIG5vQ29sb3IpKTtcclxuXHRcdFxyXG5cdFx0dmFyIHRleHQgPSBjdWJlc0NvbnRhaW5lci5hcHBlbmQoXCJ0ZXh0XCIpOyBcclxuXHRcdHRleHQuYXR0cignZm9udC1mYW1pbHknLCAnQXJpYWwnKVxyXG5cdFx0XHQuYXR0cignZm9udC1zaXplJywgJzExcHgnKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgKChkYXRhLnkgLSAxKSAqIGN1YmVTaXplKSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsICgoZGF0YS55IC0gMSkgKiBjdWJlU2l6ZSkgKyAxOSlcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImhlYXRtYXAtY2VsbFwiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gVGhlIFwib2Zmc2V0c1wiIHdlIGFkZCBvbiBlYWNoIHJldHVybiBjYWxsIGFyZSB0aWVkIHRvIHRoZSBjdXJyZW50IGZvbnQgZmFtaWx5IGFuZCBzaXplLCBzbyBpZiB3ZSBjaGFuZ2UgdGhlbSB3ZSBtaWdodCBuZWVkIHRvIGNoYW5nZSB0aGUgb2Zmc2V0cyB0b28uXHJcblx0XHRcdFx0dmFyIGQgPSBkYXRhO1xyXG5cdFx0XHRcdHZhciBhdXhWYWwgPSBkLnZhbHVlO1xyXG5cdFx0XHRcdGlmIChhdXhWYWwgPiAwICYmIGF1eFZhbCA8IDEpIHtcclxuXHRcdFx0XHRcdHJldHVybiAoKGQueCAtIDEpICogY3ViZVNpemUpICsgNDtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGF1eFZhbCA8IDEwKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKChkLnggLSAxKSAqIGN1YmVTaXplKSArIDg7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChhdXhWYWwgPT0gMTAwKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKChkLnggLSAxKSAqIGN1YmVTaXplKSArIDE7XHRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuICgoZC54IC0gMSkgKiBjdWJlU2l6ZSkgKyA1O1xyXG5cdFx0XHRcdH1cdFx0XHRcdFx0XHJcblx0XHRcdH0pLnRleHQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gQ2FudCB1c2UgXCJodG1sXCIgZnVuY3Rpb24gb24gSUUuXHJcblx0XHRcdFx0dmFyIGQgPSBkYXRhO1xyXG5cdFx0XHRcdHZhciBhdXhWYWwgPSBkLnZhbHVlO1xyXG5cdFx0XHRcdGlmIChhdXhWYWwgPiAtMSkge1xyXG5cdFx0XHRcdFx0aWYgKGF1eFZhbCA+IDAgJiYgYXV4VmFsIDwgMSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJzwxJSc7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gYXV4VmFsICsgJyUnO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1eFZhbCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLW4tYVwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKG9iaikge1x0XHRcdFx0XHJcblx0XHRcdFx0Ly8gUmVtb3ZlIGFsbCBmaWx0ZXJzIGFwcGxpZWQuXHJcblx0XHRcdFx0JCgkKGN1YmVzQ29udGFpbmVyWzBdKS5maW5kKFwicmVjdFwiKSkucmVtb3ZlQXR0cihcImZpbHRlclwiKTtcclxuXHRcdFx0XHQvLyBBcHBseSBcImRhcmtlblwiIHRvIHRoZSByb3cgYW5kIGNvbHVtbi5cdFx0XHJcblx0XHRcdFx0JCgkKGN1YmVzQ29udGFpbmVyWzBdKS5maW5kKFwiW2RhdGEteD0nXCIrIChzZWxmRGF0YS54IC0gMSkgKyBcIiddXCIpKS5hdHRyKFwiZmlsdGVyXCIsIFwidXJsKCNmaWx0ZXJEYXJrZW4pXCIpO1xyXG5cdFx0XHRcdCQoJChjdWJlc0NvbnRhaW5lclswXSkuZmluZChcIltkYXRhLXk9J1wiKyAoc2VsZkRhdGEueSAtIDEpICsgXCInXVwiKSkuYXR0cihcImZpbHRlclwiLCBcInVybCgjZmlsdGVyRGFya2VuKVwiKTtcclxuXHRcdFx0XHQvLyBIaWdobGlnaHQgdGhpcyBjZWxsLlxyXG5cdFx0XHRcdCQoJChjdWJlc0NvbnRhaW5lclswXSkuZmluZChcIltkYXRhLXk9J1wiKyAoc2VsZkRhdGEueSAtIDEpICsgXCInXVwiICsgXCJbZGF0YS14PSdcIisgKHNlbGZEYXRhLnggLSAxKSArIFwiJ11cIikpLnJlbW92ZUF0dHIoXCJmaWx0ZXJcIik7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHJcblx0XHRpZiAoZGF0YS50b29sdGlwKSB7XHJcblx0XHRcdHRleHQuYXR0cignZGF0YS10aXRsZScsIGRhdGEudG9vbHRpcClcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwibnYtc2VyaWVzIGhlYXRtYXAtY2VsbFwiKTtcclxuXHRcdH1cclxuICAgIH1cclxuICAgICAgIFxyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JGcm9tQ2F0ZWdvcmllcyh2YWx1ZSwgY2F0ZWdvcmllcywgbm9Db2xvcikge1xyXG4gICAgXHR2YXIgY29sb3IgPSBub0NvbG9yO1xyXG4gICAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIFx0XHRpZiAoKHZhbHVlID49IGNhdGVnb3JpZXNbaV0ubWluKSAmJiAodmFsdWUgPCBjYXRlZ29yaWVzW2ldLm1heCkpIHtcclxuICAgIFx0XHRcdGNvbG9yID0gY2F0ZWdvcmllc1tpXS5jb2xvcjtcclxuICAgIFx0XHRcdGJyZWFrO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgXHRyZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVRleHRXaWR0aCh0ZXh0KSB7XHJcbiAgICBcdCQoXCJib2R5XCIpLmFwcGVuZChcIjxzcGFuIGlkPSd0ZW1wU3BhbicgY2xhc3M9J2ludmlzaWJsZSc+XCIgKyB0ZXh0ICsgXCI8L3NwYW4+XCIpO1xyXG4gICAgXHR2YXIgYXV4V2lkdGggPSAkKFwiI3RlbXBTcGFuXCIpLndpZHRoKCk7XHJcbiAgICBcdCQoXCIjdGVtcFNwYW5cIikucmVtb3ZlKCk7XHJcbiAgICBcdHJldHVybiBhdXhXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcclxuICAgIGNoYXJ0LmxlZ2VuZCA9IHt9O1xyXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcclxuICAgIGNoYXJ0LmhlYXRtYXAgPSBoZWF0bWFwO1xyXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xyXG4gICAgY2hhcnQuc2hvcnRUZXh0TGVuZ3RoID0gZnVuY3Rpb24oXykge1xyXG4gICAgICAgIHJldHVybiBzaG9ydFRleHRMZW5ndGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHVzZSBPYmplY3QgZ2V0L3NldCBmdW5jdGlvbmFsaXR5IHRvIG1hcCBiZXR3ZWVuIHZhcnMgYW5kIGNoYXJ0IGZ1bmN0aW9uc1xyXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7ICAgIFx0XHJcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xyXG4gICAgICAgIG5vRGF0YTogICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxyXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgICBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxyXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcclxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xyXG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XHJcbiAgICAgICAgfX0sXHJcbiAgICAgICAgY29sb3I6IHt9LFxyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XHJcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xyXG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xyXG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcclxuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xyXG4gICAgICAgIH19LFxyXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiB7fVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XHJcbiAgICAgICAgaGVpZ2h0ID0gXztcclxuICAgICAgICByZXR1cm4gY2hhcnQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgaGVhdG1hcCk7XHJcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbn07IiwiXHJcbm52Lm1vZGVscy5jdXN0b21pemVkTXVsdGlCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICB2YXIgbXVsdGliYXIgPSBudi5tb2RlbHMubXVsdGlCYXIoKVxyXG4gICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcclxuICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXHJcbiAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxyXG4gICAgLCBjb250cm9scyA9IG52Lm1vZGVscy5sZWdlbmQoKSAvL3RoaXMgaXNuJ3QgZXhwb3NlZCBieSBkZWZhdWx0IDooXHJcbiAgICA7XHJcblxyXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDUwLCBsZWZ0OiA2MH1cclxuICAgICwgd2lkdGggPSBudWxsXHJcbiAgICAsIGhlaWdodCA9IG51bGxcclxuICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxyXG4gICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXHJcbiAgICAsIHNob3dMZWdlbmQgPSB0cnVlXHJcbiAgICAsIHNob3dYQXhpcyA9IHRydWVcclxuICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxyXG4gICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxyXG4gICAgLCByZWR1Y2VYVGlja3MgPSB0cnVlIC8vIGlmIGZhbHNlIGEgdGljayB3aWxsIHNob3cgZm9yIGV2ZXJ5IGRhdGEgcG9pbnRcclxuICAgICwgc3RhZ2dlckxhYmVscyA9IGZhbHNlXHJcbiAgICAsIHJvdGF0ZUxhYmVscyA9IDBcclxuICAgICwgdG9vbHRpcHMgPSB0cnVlXHJcbiAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XHJcbiAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcclxuICAgICAgICAnPHA+JyArICB5ICsgJyBvbiAnICsgeCArICc8L3A+J1xyXG4gICAgfVxyXG4gICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxyXG4gICAgLCB5IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC55U2NhbGUoKVxyXG4gICAgLCBzdGF0ZSA9IHsgc3RhY2tlZDogZmFsc2UgfVxyXG4gICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXHJcbiAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcclxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxyXG4gICAgLCBjb250cm9sV2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNob3dDb250cm9scyA/IDMwMCA6IDAgfSAvKkluY3JlYXNlZCBmcm9tIDE4MCBpbiBvcmlnaW5hbCBmaWxlLiovXHJcbiAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxyXG4gICAgO1xyXG5cclxuICBtdWx0aWJhclxyXG4gICAgLnN0YWNrZWQoZmFsc2UpXHJcbiAgO1xyXG4gIHhBeGlzXHJcbiAgICAub3JpZW50KCdib3R0b20nKVxyXG4gICAgLnRpY2tQYWRkaW5nKDcpXHJcbiAgICAuaGlnaGxpZ2h0WmVybyh0cnVlKVxyXG4gICAgLnNob3dNYXhNaW4oZmFsc2UpXHJcbiAgICAudGlja0Zvcm1hdChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pXHJcbiAgO1xyXG4gIHlBeGlzXHJcbiAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcclxuICAgIC50aWNrRm9ybWF0KGQzLmZvcm1hdCgnLC4xZicpKVxyXG4gIDtcclxuXHJcbiAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xyXG4gICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcclxuICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxyXG4gICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKG11bHRpYmFyLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcclxuICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXHJcbiAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xyXG5cclxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xyXG4gIH07XHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cclxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcclxuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcclxuICAgICAgICB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXHJcbiAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxyXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxyXG4gICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcclxuXHJcbiAgICAgIHRyeXtcclxuICAgICAgICBpZihkYXRhWzBdLnZhbHVlc1swXS54Lmxlbmd0aCA+IDQpe1xyXG4gICAgICAgIFx0Ly9tYXJnaW4uYm90dG9tICs9IDEzMDtcclxuICAgICAgICBcdG1hcmdpbi5ib3R0b20gPSAxMzA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9Y2F0Y2goZSl7fVxyXG5cclxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xyXG4gICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xyXG5cclxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcclxuICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XHJcblxyXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xyXG4gICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XHJcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcclxuICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXHJcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxyXG5cclxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xyXG5cclxuICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXHJcbiAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxyXG4gICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcclxuXHJcbiAgICAgICAgbm9EYXRhVGV4dFxyXG4gICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcclxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hhcnQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIFNldHVwIFNjYWxlc1xyXG5cclxuICAgICAgeCA9IG11bHRpYmFyLnhTY2FsZSgpO1xyXG4gICAgICB5ID0gbXVsdGliYXIueVNjYWxlKCk7XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XHJcblxyXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aUJhcldpdGhMZWdlbmQnKS5kYXRhKFtkYXRhXSk7XHJcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LW11bHRpQmFyV2l0aExlZ2VuZCcpLmFwcGVuZCgnZycpO1xyXG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XHJcblxyXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XHJcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcclxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XHJcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XHJcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgLy8gTGVnZW5kXHJcblxyXG4gICAgICBpZiAoc2hvd0xlZ2VuZCkge1xyXG4gICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCAtIGNvbnRyb2xXaWR0aCgpKTtcclxuXHJcbiAgICAgICAgaWYgKG11bHRpYmFyLmJhckNvbG9yKCkpXHJcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcclxuICAgICAgICAgICAgc2VyaWVzLmNvbG9yID0gZDMucmdiKCcjY2NjJykuZGFya2VyKGkgKiAxLjUpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxyXG4gICAgICAgICAgLmRhdHVtKGRhdGEpXHJcbiAgICAgICAgICAuY2FsbChsZWdlbmQpO1xyXG5cclxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XHJcbiAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xyXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXHJcbiAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxyXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGNvbnRyb2xXaWR0aCgpICsgJywnICsgKC1tYXJnaW4udG9wKSArJyknKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBDb250cm9sc1xyXG5cclxuICAgICAgdmFyIGdyb3VwZWRMZWdlbmRUcm4gPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWNoYXJ0LWxlZ2VuZHMtR3JvdXBlZFwiLFwiR3JvdXBlZFwiKTtcclxuICAgICAgdmFyIHN0YWNrZWRMZWdlbmRUcm4gPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWNoYXJ0LWxlZ2VuZHMtU3RhY2tlZFwiLFwiU3RhY2tlZFwiKTtcclxuICAgICAgaWYgKHNob3dDb250cm9scykge1xyXG4gICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXHJcbiAgICAgICAgICB7IGtleTogZ3JvdXBlZExlZ2VuZFRybiwgZGlzYWJsZWQ6IG11bHRpYmFyLnN0YWNrZWQoKSB9LFxyXG4gICAgICAgICAgeyBrZXk6IHN0YWNrZWRMZWdlbmRUcm4sIGRpc2FibGVkOiAhbXVsdGliYXIuc3RhY2tlZCgpIH1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBjb250cm9scy53aWR0aChjb250cm9sV2lkdGgoKSkuY29sb3IoWycjNDQ0JywgJyM0NDQnLCAnIzQ0NCddKTtcclxuICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXHJcbiAgICAgICAgICAuZGF0dW0oY29udHJvbHNEYXRhKVxyXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxyXG4gICAgICAgICAgLmNhbGwoY29udHJvbHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcclxuXHJcbiAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcclxuICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcclxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcclxuXHJcbiAgICAgIG11bHRpYmFyXHJcbiAgICAgICAgLmRpc2FibGVkKGRhdGEubWFwKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLmRpc2FibGVkIH0pKVxyXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcclxuICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcclxuICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcclxuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSlcclxuXHJcblxyXG4gICAgICB2YXIgYmFyc1dyYXAgPSBnLnNlbGVjdCgnLm52LWJhcnNXcmFwJylcclxuICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXHJcblxyXG4gICAgICBiYXJzV3JhcC50cmFuc2l0aW9uKCkuY2FsbChtdWx0aWJhcik7XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIFNldHVwIEF4ZXNcclxuXHJcbiAgICAgIGlmIChzaG93WEF4aXMpIHtcclxuICAgICAgICB4QXhpc1xyXG4gICAgICAgICAgLnNjYWxlKHgpXHJcbiAgICAgICAgICAudGlja3MoIGF2YWlsYWJsZVdpZHRoIC8gMTAwIClcclxuICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcclxuXHJcbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxyXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcclxuICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgLmNhbGwoeEF4aXMpO1xyXG5cclxuICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3QoJy5udi14Lm52LWF4aXMgPiBnJykuc2VsZWN0QWxsKCdnJyk7XHJcblxyXG4gICAgICAgIHhUaWNrc1xyXG4gICAgICAgICAgLnNlbGVjdEFsbCgnbGluZSwgdGV4dCcpXHJcbiAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgaWYoZGF0YVswXS52YWx1ZXNbMF0ueC5sZW5ndGggPiA0KXtcclxuICAgICAgICAgICAgZy5zZWxlY3RBbGwoXCIubnYteC5udi1heGlzIC5udi13cmFwIGcgZyB0ZXh0XCIpXHJcbiAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcclxuICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIFwiLS44ZW1cIilcclxuICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLjE1ZW1cIilcclxuICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtNjUpXCIgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9Y2F0Y2goZSl7fVxyXG5cclxuICAgICAgICBpZiAoc3RhZ2dlckxhYmVscykge1xyXG4gICAgICAgICAgdmFyIGdldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciBzdGFnZ2VyVXAgPSA1LCBzdGFnZ2VyRG93biA9IDE3OyAgLy9waXhlbHMgdG8gc3RhZ2dlciBieVxyXG4gICAgICAgICAgLy8gSXNzdWUgIzE0MFxyXG4gICAgICAgICAgeFRpY2tzXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikge1xyXG4gICAgICAgICAgICAgIHJldHVybiAgZ2V0VHJhbnNsYXRlKDAsIChqICUgMiA9PSAwID8gc3RhZ2dlclVwIDogc3RhZ2dlckRvd24pKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmFyIHRvdGFsSW5CZXR3ZWVuVGlja3MgPSBkMy5zZWxlY3RBbGwoXCIubnYteC5udi1heGlzIC5udi13cmFwIGcgZyB0ZXh0XCIpWzBdLmxlbmd0aDtcclxuICAgICAgICAgIGcuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtYXhpc01heE1pbiB0ZXh0XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsaSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc2xhdGUoMCwgKGkgPT09IDAgfHwgdG90YWxJbkJldHdlZW5UaWNrcyAlIDIgIT09IDApID8gc3RhZ2dlckRvd24gOiBzdGFnZ2VyVXApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZWR1Y2VYVGlja3MpXHJcbiAgICAgICAgICB4VGlja3NcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaSAlIE1hdGguY2VpbChkYXRhWzBdLnZhbHVlcy5sZW5ndGggLyAoYXZhaWxhYmxlV2lkdGggLyAxMDApKSAhPT0gMDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCwgbGluZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApO1xyXG5cclxuICAgICAgICBpZihyb3RhdGVMYWJlbHMpXHJcbiAgICAgICAgICB4VGlja3NcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnLnRpY2sgdGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKCcgKyByb3RhdGVMYWJlbHMgKyAnIDAsMCknKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcm90YXRlTGFiZWxzID4gMCA/ICdzdGFydCcgOiAnZW5kJyk7XHJcblxyXG4gICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4gdGV4dCcpXHJcbiAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGlmIChzaG93WUF4aXMpIHtcclxuICAgICAgICB5QXhpc1xyXG4gICAgICAgICAgLnNjYWxlKHkpXHJcbiAgICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodCAvIDM2IClcclxuICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcclxuXHJcbiAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgIC5jYWxsKHlBeGlzKTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuXHJcbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XHJcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XHJcbiAgICAgICAgaWYgKCFkLmRpc2FibGVkKSByZXR1cm47XHJcbiAgICAgICAgY29udHJvbHNEYXRhID0gY29udHJvbHNEYXRhLm1hcChmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgICBzLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChkLmtleSkge1xyXG4gICAgICAgICAgY2FzZSBncm91cGVkTGVnZW5kVHJuOlxyXG4gICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIHN0YWNrZWRMZWdlbmRUcm46XHJcbiAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuc3RhY2tlZCA9IG11bHRpYmFyLnN0YWNrZWQoKTtcclxuICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XHJcblxyXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSlcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxyXG4gICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xyXG4gICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlLnN0YWNrZWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGUuc3RhY2tlZCk7XHJcbiAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gZS5zdGFja2VkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH1cclxuXHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIG11bHRpYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XHJcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcclxuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xyXG4gIH0pO1xyXG5cclxuICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XHJcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcclxuICB9KTtcclxuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcclxuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xyXG4gIGNoYXJ0Lm11bHRpYmFyID0gbXVsdGliYXI7XHJcbiAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xyXG4gIGNoYXJ0LmNvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgY2hhcnQueEF4aXMgPSB4QXhpcztcclxuICBjaGFydC55QXhpcyA9IHlBeGlzO1xyXG5cclxuICBkMy5yZWJpbmQoY2hhcnQsIG11bHRpYmFyLCAneCcsICd5JywgJ3hEb21haW4nLCAneURvbWFpbicsICd4UmFuZ2UnLCAneVJhbmdlJywgJ2ZvcmNlWCcsICdmb3JjZVknLCAnY2xpcEVkZ2UnLFxyXG4gICAgJ2lkJywgJ3N0YWNrZWQnLCAnc3RhY2tPZmZzZXQnLCAnZGVsYXknLCAnYmFyQ29sb3InLCdncm91cFNwYWNpbmcnKTtcclxuXHJcbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xyXG5cclxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XHJcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xyXG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xyXG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcclxuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XHJcbiAgICB3aWR0aCA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xyXG4gICAgaGVpZ2h0ID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xyXG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcclxuICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuc2hvd0NvbnRyb2xzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0NvbnRyb2xzO1xyXG4gICAgc2hvd0NvbnRyb2xzID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0xlZ2VuZDtcclxuICAgIHNob3dMZWdlbmQgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dYQXhpcztcclxuICAgIHNob3dYQXhpcyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd1lBeGlzO1xyXG4gICAgc2hvd1lBeGlzID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJpZ2h0QWxpZ25ZQXhpcztcclxuICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XHJcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnJlZHVjZVhUaWNrcz0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmVkdWNlWFRpY2tzO1xyXG4gICAgcmVkdWNlWFRpY2tzID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5yb3RhdGVMYWJlbHMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByb3RhdGVMYWJlbHM7XHJcbiAgICByb3RhdGVMYWJlbHMgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH1cclxuXHJcbiAgY2hhcnQuc3RhZ2dlckxhYmVscyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YWdnZXJMYWJlbHM7XHJcbiAgICBzdGFnZ2VyTGFiZWxzID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC50b29sdGlwID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcclxuICAgIHRvb2x0aXAgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnRvb2x0aXBzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcHM7XHJcbiAgICB0b29sdGlwcyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQudG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwO1xyXG4gICAgdG9vbHRpcCA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuc3RhdGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGF0ZTtcclxuICAgIHN0YXRlID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5kZWZhdWx0U3RhdGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZhdWx0U3RhdGU7XHJcbiAgICBkZWZhdWx0U3RhdGUgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0Lm5vRGF0YSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcclxuICAgIG5vRGF0YSA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHJcbiAgcmV0dXJuIGNoYXJ0O1xyXG59IiwiXHJcbm52Lm1vZGVscy5jdXN0b21pemVkUGllQ2hhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICB2YXIgcGllID0gbnYubW9kZWxzLnBpZSgpO1xyXG4gICAgdmFyIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKS5tYXJnaW4oe3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH0pO1xyXG5cclxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDIwLCBsZWZ0OiAyMH1cclxuICAgIC8vdmFyIGxlZ2VuZE1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogMjAsIGxlZnQ6IDIwfVxyXG4gICAgICAgICwgd2lkdGggPSBudWxsXHJcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXHJcbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxyXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxyXG4gICAgICAgICwgdG9vbHRpcHMgPSB0cnVlXHJcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB5LCBlLCBncmFwaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxoMyBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICdcclxuICAgICAgICAgICAgICAgICsgZS5jb2xvciArICdcIj4nICsga2V5ICsgJzwvaDM+J1xyXG4gICAgICAgICAgICAgICAgKyAnPHA+JyArICB5ICsgJzwvcD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxyXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxyXG4gICAgICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxyXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcclxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywncmVuZGVyRW5kJylcclxuICAgICAgICA7XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgdG9vbHRpcExhYmVsID0gcGllLngoKShlLnBvaW50KTtcclxuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCAob2Zmc2V0RWxlbWVudCAmJiBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQpIHx8IDAgKSxcclxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIChvZmZzZXRFbGVtZW50ICYmIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wKSB8fCAwKSxcclxuICAgICAgICAgICAgeSA9IHBpZS52YWx1ZUZvcm1hdCgpKHBpZS55KCkoZS5wb2ludCkpLFxyXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcCh0b29sdGlwTGFiZWwsIHksIGUsIGNoYXJ0KVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICduJyA6ICdzJywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoKTtcclxuXHJcbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBDaGFydCBmdW5jdGlvblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcclxuICAgIFx0XHJcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcclxuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMocGllKTtcclxuXHJcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJyksIDEwKSB8fCA5NjApXHJcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcclxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSwgMTApIHx8IDQwMClcclxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tXHJcbiAgICAgICAgICAgICAgICA7XHJcblxyXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5jYWxsKGNoYXJ0KTsgfTtcclxuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcclxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IHN0YXRlLmRpc2FibGVkXHJcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cclxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcclxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtcGllQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XHJcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXBpZUNoYXJ0JykuYXBwZW5kKCdnJyk7XHJcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBoZWlnaHRPZmZzZXQgPSAkKCQoY29udGFpbmVyWzBdKVswXSkuZmluZChcIi5sZWdlbmQubnZkMy1zdmdcIilbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllV3JhcCcpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgaGVpZ2h0T2Zmc2V0ICsgJyknKTtcclxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExlZ2VuZFxyXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKCBhdmFpbGFibGVXaWR0aCApLmtleShwaWUueCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy93cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxyXG4gICAgICAgICAgICBwaWUud2lkdGgoYXZhaWxhYmxlV2lkdGgpLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgcGllV3JhcCA9IGcuc2VsZWN0KCcubnYtcGllV3JhcCcpLmRhdHVtKFtkYXRhXSk7XHJcbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24ocGllV3JhcCkuY2FsbChwaWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXHJcbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBwaWUuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgncGllQ2hhcnQgaW1tZWRpYXRlJyk7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHBpZS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xyXG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXHJcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XHJcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xyXG4gICAgY2hhcnQucGllID0gcGllO1xyXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xyXG5cclxuICAgIC8vIHVzZSBPYmplY3QgZ2V0L3NldCBmdW5jdGlvbmFsaXR5IHRvIG1hcCBiZXR3ZWVuIHZhcnMgYW5kIGNoYXJ0IGZ1bmN0aW9uc1xyXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7ICAgIFx0XHJcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xyXG4gICAgICAgIG5vRGF0YTogICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxyXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcclxuICAgICAgICB0b29sdGlwczogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgICAgICAgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxyXG4gICAgICAgIHNob3dMZWdlbmQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sICAgICBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcclxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sICAgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcclxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXHJcbiAgICAgICAgY29sb3I6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XHJcbiAgICAgICAgICAgIGNvbG9yID0gXztcclxuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcclxuICAgICAgICAgICAgcGllLmNvbG9yKGNvbG9yKTtcclxuICAgICAgICB9fSxcclxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xyXG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XHJcbiAgICAgICAgfX0sXHJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcclxuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XHJcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XHJcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xyXG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XHJcbiAgICAgICAgfX0sXHJcbiAgICAgICAgLypsZWdlbmRNYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxlZ2VuZE1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xyXG4gICAgICAgIFx0bGVnZW5kTWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IGxlZ2VuZE1hcmdpbi50b3A7XHJcbiAgICAgICAgXHRsZWdlbmRNYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbGVnZW5kTWFyZ2luLnJpZ2h0O1xyXG4gICAgICAgIFx0bGVnZW5kTWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IGxlZ2VuZE1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgXHRsZWdlbmRNYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbGVnZW5kTWFyZ2luLmxlZnQ7XHJcbiAgICAgICAgfX0sKi9cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgcGllKTtcclxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcclxuICAgIHJldHVybiBjaGFydDtcclxufTsiLCJmdW5jdGlvbiBxdWVyeXNlbGVjdG9yKCkge1xuICByZXR1cm4gISFkb2N1bWVudC5xdWVyeVNlbGVjdG9yOyAgLy8gZmFpbHMgb24gb29vb29vb29vb2xkIElFXG59XG5cblxuZnVuY3Rpb24gc3ZnKCkge1xuICB0cnkge1xuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3czLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG5cbmZ1bmN0aW9uIGNhbnZhcygpIHtcbiAgcmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcbn1cblxuXG5mdW5jdGlvbiBjYW52YXNUZXh0KCkge1xuICBpZiAoIWNhbnZhcygpKSB7IHJldHVybiBmYWxzZTsgfVxuICB2YXIgdGV4dEZuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKS5maWxsVGV4dDtcbiAgcmV0dXJuICh0eXBlb2YgdGV4dEZuID09PSAnZnVuY3Rpb24nKTtcbn1cblxuXG52YXIgaXNJRSA9IChmdW5jdGlvbigpIHtcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQwMTg2MS8xMjk5Njk1XG4gIC8vIE1hZ2ljLiBEbyBub3QgdG91Y2guXG4gIHZhciB5ZXNJdElzID0gISEoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCwgdGVtLFxuICAgIE0gPSB1YS5tYXRjaCgvKG9wZXJhfGNocm9tZXxzYWZhcml8ZmlyZWZveHxtc2llfHRyaWRlbnQoPz1cXC8pKVxcLz9cXHMqKFxcZCspL2kpIHx8IFtdO1xuICAgIGlmICgvdHJpZGVudC9pLnRlc3QoTVsxXSkpIHtcbiAgICAgIHRlbSA9ICAvXFxicnZbIDpdKyhcXGQrKS9nLmV4ZWModWEpIHx8IFtdO1xuICAgICAgcmV0dXJuICdNU0lFICcgKyAodGVtWzFdIHx8ICcnKTtcbiAgICB9XG4gICAgaWYgKE1bMV0gPT09ICdDaHJvbWUnKSB7XG4gICAgICB0ZW0gPSB1YS5tYXRjaCgvXFxiT1BSXFwvKFxcZCspLyk7XG4gICAgICBpZiAoISF0ZW0pIHsgcmV0dXJuICdPcGVyYSAnICsgdGVtWzFdOyB9XG4gICAgfVxuICAgIE0gPSBNWzJdID8gW01bMV0sIE1bMl1dIDogW25hdmlnYXRvci5hcHBOYW1lLCBuYXZpZ2F0b3IuYXBwVmVyc2lvbiwgJy0/J107XG4gICAgaWYgKCh0ZW0gPSAhIXVhLm1hdGNoKC92ZXJzaW9uXFwvKFxcZCspL2kpKSkgeyBNLnNwbGljZSgxLCAxLCB0ZW1bMV0pOyB9XG4gICAgcmV0dXJuIE0uam9pbignICcpO1xuICB9KSgpLm1hdGNoKC9eTVNJRS8pO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIHllc0l0SXM7IH07XG59KSgpO1xuXG5cbmZ1bmN0aW9uIGRhdGFVUkxIcmVmKCkge1xuICAvLyBJIGRvbid0IGtub3cgaG93IHRvIGZlYXR1cmUtZGV0ZWN0IHRoaXMgOihcbiAgLy8gd2Ugd2lsbCBiZSBvcHRpbWlzaXRpYyBhbiBvbmx5IHNheSBcIm5vXCIgaWYgd2Ugc2VlIElFLlxuICByZXR1cm4gIWlzSUUoKTtcbn1cblxuXG5mdW5jdGlvbiBmbGFzaCgpIHtcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAwOTU0NjcvMTI5OTY5NVxuICAvLyBncm9zcy4uLlxuICB0cnkge1xuICAgIHJldHVybiAhIShuZXcgQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2gnKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5taW1lVHlwZXMgJiZcbiAgICAgIG5hdmlnYXRvci5taW1lVHlwZXNbJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ10gIT09IHZvaWQgMCAmJlxuICAgICAgbmF2aWdhdG9yLm1pbWVUeXBlc1snYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXS5lbmFibGVkUGx1Z2luO1xuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1pc3NpbmdGZWF0dXJlcyA9IFtdOyAgLy8gYW4gZW1wdHkgYXJyYXkgd2lsbCBjYXN0IHRvIGJvb2wgZmFsc2UuIGhhbmR5IVxuXG4gIGlmICghcXVlcnlzZWxlY3RvcigpKSB7XG4gICAgbWlzc2luZ0ZlYXR1cmVzLnB1c2goe1xuICAgICAgZmVhdHVyZTogJ3F1ZXJ5U2VsZWN0b3InLFxuICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCdcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghc3ZnKCkpIHtcbiAgICBtaXNzaW5nRmVhdHVyZXMucHVzaCh7XG4gICAgICBmZWF0dXJlOiAnU1ZHJyxcbiAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWNhbnZhc1RleHQoKSkge1xuICAgIG1pc3NpbmdGZWF0dXJlcy5wdXNoKHtcbiAgICAgIGZlYXR1cmU6ICdjYW52YXMnLFxuICAgICAgc2V2ZXJpdHk6ICdtYWpvcidcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghZGF0YVVSTEhyZWYoKSkge1xuICAgIG1pc3NpbmdGZWF0dXJlcy5wdXNoKHtcbiAgICAgIGZlYXR1cmU6ICdkb3dubG9hZCcsXG4gICAgICBzZXZlcml0eTogZmxhc2goKSA/ICdtaW5vcicgOiAnbWFqb3InXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWZsYXNoKCkpIHtcbiAgICBtaXNzaW5nRmVhdHVyZXMucHVzaCh7XG4gICAgICBmZWF0dXJlOiAnZmxhc2gnLFxuICAgICAgc2V2ZXJpdHk6IGlzSUUoKSA/ICdtYWpvcicgOiAnbWlub3InXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbWlzc2luZ0ZlYXR1cmVzO1xufTtcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgdXJsOiAnL3Jlc3Qvc2VjdXJpdHkvbGF5b3V0JyxcblxuICAvKioqKioqKioqKioqXG4gICAqIGVtYWlsIGlzIG51bGwgZnJvbSBzZXJ2ZXIgd2hlbiBub3QgbG9nZ2VkIGluIG9yIHdoZW4gd29ya3NwYWNlIG5vdCBzZXQgeWV0LlxuICAgKiBCZWZvcmUgaXQgaXMgZmV0Y2hlZCwgZGVmYXVsdCB0byB1bmRlZmluZWQuXG4gICAqL1xuICBkZWZhdWx0czoge1xuICAgIGVtYWlsOiB1bmRlZmluZWRcbiAgfSxcbiAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNhY2hlID0gZmFsc2U7XG4gICAgcmV0dXJuIEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBDaGFydE1vZGVsID0gcmVxdWlyZSgnLi9jaGFydC1tb2RlbC1iYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydE1vZGVsLmV4dGVuZCh7XG5cdFxuXG5cdGRlZmF1bHRzIDoge1xuXHRcdHRpdGxlIDogJycsXG5cdFx0c2hvd1BsYW5uZWREaXNidXJzZW1lbnRzOiB0cnVlLFxuXHRcdHNob3dBY3R1YWxEaXNidXJzZW1lbnRzOiB0cnVlLFxuXHRcdGNoYXJ0VHlwZTogJ2FpZFByZWRpY3RhYmlsaXR5J1xuXHR9LFxuXG4gIF9wcmVwYXJlVHJhbnNsYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByZWRpY3RhYmlsaXR5QmFzZUxhbmd1YWdlID0ge307XG5cbiAgICAvKiBQcmVwYXJlIHRoZSB0cmFuc2xhdGlvbnMgZm9yIHRoZSBjaGFydCAqL1xuICAgIHByZWRpY3RhYmlsaXR5QmFzZUxhbmd1YWdlWydhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS1wbGFubmVkLWRpc2J1cnNlbWVudHMnXSA9ICdQbGFubmVkIERpc2J1cnNlbWVudHMnO1xuICAgIHByZWRpY3RhYmlsaXR5QmFzZUxhbmd1YWdlWydhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS1hY3R1YWwtZGlzYnVyc2VtZW50cyddID0gJ0FjdHVhbCBEaXNidXJzZW1lbnRzJztcblxuICAgIHRoaXMubG9jYWxpemVkUHJlZGljdGFiaWxpdHkgPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZUxpc3QocHJlZGljdGFiaWxpdHlCYXNlTGFuZ3VhZ2UpLnRoZW4oXG4gICAgICBmdW5jdGlvbihsb2NhbGl6ZWRQcmVkaWN0YWJpbGl0eUxpc3QpIHtcbiAgICAgICAgc2VsZi5sb2NhbGl6ZWRQcmVkaWN0YWJpbGl0eUxpc3QgPSBsb2NhbGl6ZWRQcmVkaWN0YWJpbGl0eUxpc3Q7XG4gICAgICB9KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNldCgndGl0bGUnLCBkYXRhLnRpdGxlKTtcdFxuXHRpZighXy5pc1VuZGVmaW5lZChkYXRhLnNob3dQbGFubmVkRGlzYnVyc2VtZW50cykpe1xuXHRcdHRoaXMuc2V0KCdzaG93UGxhbm5lZERpc2J1cnNlbWVudHMnLCBkYXRhLnNob3dQbGFubmVkRGlzYnVyc2VtZW50cyk7XG5cdH1cblx0aWYoIV8uaXNVbmRlZmluZWQoZGF0YS5zaG93QWN0dWFsRGlzYnVyc2VtZW50cykpe1xuXHRcdHRoaXMuc2V0KCdzaG93QWN0dWFsRGlzYnVyc2VtZW50cycsIGRhdGEuc2hvd0FjdHVhbERpc2J1cnNlbWVudHMpO1xuXHR9XHRcblx0XG4gICAgZnVuY3Rpb24gcGljayh3aGljaCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBkLnllYXIsXG4gICAgICAgICAgeTogZFt3aGljaF1bJ2Ftb3VudCddLFxuICAgICAgICAgIHo6IGRbd2hpY2hdWydmb3JtYXR0ZWRBbW91bnQnXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gICAgLyogcmV0dXJucyBmcm9tIG1hcCgpIGxpa2UgW3thbXAuZ2lzOnRpdGxlLVJlZ2lvbjogJ1JlZ2lvbid9LCAuLi4gXSovXG5cbiAgICBkYXRhLnByb2Nlc3NlZCA9IFtcbiAgICAgIHtcbiAgICAgICAga2V5OiB0aGlzLmxvY2FsaXplZFByZWRpY3RhYmlsaXR5TGlzdFsnYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktcGxhbm5lZC1kaXNidXJzZW1lbnRzJ10sXG4gICAgICAgIG9yaWdpbmFsS2V5OiAncGxhbm5lZCcsXG4gICAgICAgIHZhbHVlczogXyhkYXRhLnllYXJzKS5tYXAocGljaygncGxhbm5lZCBkaXNidXJzZW1lbnRzJykpLFxuICAgICAgICBkaXNhYmxlZDogIXRoaXMuZ2V0KCdzaG93UGxhbm5lZERpc2J1cnNlbWVudHMnKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiB0aGlzLmxvY2FsaXplZFByZWRpY3RhYmlsaXR5TGlzdFsnYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktYWN0dWFsLWRpc2J1cnNlbWVudHMnXSxcbiAgICAgICAgb3JpZ2luYWxLZXk6ICdhY3R1YWwnLFxuICAgICAgICB2YWx1ZXM6IF8oZGF0YS55ZWFycykubWFwKHBpY2soJ2FjdHVhbCBkaXNidXJzZW1lbnRzJykpLFxuICAgICAgICBkaXNhYmxlZDogIXRoaXMuZ2V0KCdzaG93QWN0dWFsRGlzYnVyc2VtZW50cycpXG4gICAgICB9XG4gICAgXTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIENoYXJ0TW9kZWwgPSByZXF1aXJlKCcuL2NoYXJ0LW1vZGVsLWJhc2UnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jaGFydHMvY29tbW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRNb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgdHlwZWQ6IHRydWUsXG4gICAgbGltaXQ6IDMsXG4gICAgdGl0bGU6ICcnLFxuICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgIHNlcmllc1RvRXhjbHVkZTogW10sXG4gICAgeWVhclRvdGFsczp7fSxcbiAgICBjaGFydFR5cGU6ICdmdW5kaW5nVHlwZSdcbiAgfSxcblxuICBfcHJlcGFyZVRyYW5zbGF0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmdHlwZUJhc2VMYW5ndWFnZSA9IHt9O1xuXG4gICAgLyogUHJlcGFyZSB0aGUgdHJhbnNsYXRpb25zIGZvciB0aGUgY2hhcnQgKi9cbiAgICB2YXIgY2hhcnROYW1lID0gWydhbXAuZGFzaGJvYXJkOmNoYXJ0LScsIHRoaXMuZ2V0KCduYW1lJykucmVwbGFjZSgvIC9nLCAnJyksICctJ10uam9pbignJyk7XG5cbiAgICAvKlxuICAgICAqIFRPRE86IGxvYWQgYWxsIHRoZSBsb2NhbGl6YXRpb25zIGluIHRoaXMgY2hhcnQncyBuYW1lc3BhY2UgdG8gdGhpcyBhcnJheVxuICAgICAqIGZyb20gaW5pdGlhbC10cmFuc2xhdGlvbi1yZXF1ZXN0Lmpzb24gLS0gRm9yIG5vdyBqdXN0IGhhcmRjb2RlIHRoZSB0d28gc29ydHMuXG4gICAgICovXG4gICAgaWYgKHRoaXMuZ2V0KCduYW1lJykgPT09ICdGdW5kaW5nIFR5cGUnKSB7XG4gICAgICBmdHlwZUJhc2VMYW5ndWFnZVtjaGFydE5hbWUgKyAnR3JhbnQnXSA9ICdHcmFudCc7XG4gICAgICBmdHlwZUJhc2VMYW5ndWFnZVtjaGFydE5hbWUgKyAnTG9hbiddID0gJ0xvYW4nO1xuICAgICAgZnR5cGVCYXNlTGFuZ3VhZ2VbY2hhcnROYW1lICsgJ290aGVycyddID0gJ090aGVycyc7XG4gICAgfVxuXG4gICAgdGhpcy5sb2NhbGl6ZWRGVHlwZSA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlTGlzdChmdHlwZUJhc2VMYW5ndWFnZSkudGhlbihcbiAgICAgIGZ1bmN0aW9uKGxvY2FsaXplZEtleVZhbCkge1xuICAgICAgICBzZWxmLmxvY2FsaXplZExvb2t1cCA9IGxvY2FsaXplZEtleVZhbDtcbiAgICAgIH0pO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuc2V0KCd0aXRsZScsIGRhdGEudGl0bGUpO1xuXHRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHllYXJzO1xuICAgIGlmIChkYXRhLnZhbHVlcy5sZW5ndGggPiAwICYmICFpc05hTihwYXJzZUludCgoZGF0YS52YWx1ZXMpWzBdLlllYXIsIDEwKSkpIHtcbiAgICAgIHllYXJzID0gXy5zb3J0QnkoZGF0YS52YWx1ZXMsIGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gcGFyc2VJbnQob2JqLlllYXIsIDEwKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHllYXJzID0gXyhkYXRhLnZhbHVlcykuc29ydEJ5KCdZZWFyJyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJ0TmFtZSA9IFsnYW1wLmRhc2hib2FyZDpjaGFydC0nLCB0aGlzLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywgJycpLCAnLSddLmpvaW4oJycpO1xuICAgIHZhciBsb2NhbGl6ZWRPdGhlcnMgPSBzZWxmLmxvY2FsaXplZExvb2t1cFtjaGFydE5hbWUgKyAnb3RoZXJzJ107XG5cbiAgICAvLyByZWZvcm1hdCB0aGUgZGF0YSBmb3IgbnZkM1xuICAgIGRhdGEucHJvY2Vzc2VkID0gXyh5ZWFycylcbiAgICAgIC5jaGFpbigpXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKHNlcmllcywgeWVhcikge1xuICAgICAgICBzZXJpZXMucHVzaC5hcHBseShzZXJpZXMsIF8oeWVhci52YWx1ZXMpLnBsdWNrKCd0eXBlJykpO1xuICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgfSwgW10pXG4gICAgICAudW5pcSgpXG4gICAgICAubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGNsZWFuTmFtZSA9IHMucmVwbGFjZSgvWyA6Ll0vZywgJycpO1xuICAgICAgICB2YXIgbG9jYWxpemVkTmFtZSA9IHM7XG4gICAgICAgIGlmIChzZWxmLmxvY2FsaXplZExvb2t1cFtjaGFydE5hbWUgKyBjbGVhbk5hbWVdKSB7XG4gICAgICAgICAgbG9jYWxpemVkTmFtZSA9IHNlbGYubG9jYWxpemVkTG9va3VwW2NoYXJ0TmFtZSArIGNsZWFuTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IGxvY2FsaXplZE5hbWUsXG4gICAgICAgICAgdmFsdWVzOiBfKHllYXJzKS5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICAgICAgdmFyIHllYXJWYWx1ZSA9IF8oeS52YWx1ZXMpLmZpbmRXaGVyZSh7dHlwZTogc30pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogeS5ZZWFyLFxuICAgICAgICAgICAgICB5OiB5ZWFyVmFsdWUgJiYgeWVhclZhbHVlLmFtb3VudCB8fCAwLFxuICAgICAgICAgICAgICB6OiB5ZWFyVmFsdWUgJiYgeWVhclZhbHVlLmZvcm1hdHRlZEFtb3VudCB8fCAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkaXNhYmxlZDogKF8uaW5kZXhPZihzZWxmLmdldCgnc2VyaWVzVG9FeGNsdWRlJyksbG9jYWxpemVkTmFtZSkgIT0gLTEpXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICAgLnZhbHVlKCk7XG4gICAgXG4gXG5cdFxuICAgIC8vIGdyb3VwIHNtYWxsZXN0IGNvbnRyaWJ1dG9ycyBhcyBcIm90aGVyXCJzXG4gICAgaWYgKHRoaXMuZ2V0KCdsaW1pdCcpIDwgZGF0YS5wcm9jZXNzZWQubGVuZ3RoKSB7XG4gICAgXHQvLyBTdW1tYXJpemUgZWFjaCBmdW5kaW5nIHR5cGUgYW5kIHNvcnQgYnkgdG90YWwgZGVzY2VuZGluZywgY3JlYXRlIGEgbmV3IGFycmF5IG9ubHkgd2l0aCBmdW5kaW5nIHR5cGVzIG5hbWVzLlxuICAgIFx0dmFyIG90aGVyc05hbWVzID0gXyhkYXRhLnByb2Nlc3NlZClcblx0ICAgICAgICAuY2hhaW4oKVxuXHQgICAgICAgIC5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7XG5cdCAgICAgICAgXHRyZXR1cm4ge1xuXHQgICAgICAgIFx0XHRrZXk6IHNlcmllcy5rZXksXG5cdFx0ICAgICAgICBcdHRvdGFsOiBfKHNlcmllcy52YWx1ZXMpLnJlZHVjZShmdW5jdGlvbih0LCB2KSB7IHJldHVybiB0ICsgdi55OyB9LCAwKVxuXHRcdCAgICAgICAgfTtcblx0ICAgICAgICB9KVxuXHQgICAgICAgIC5zb3J0QnkoJ3RvdGFsJylcblx0ICAgICAgICAucmV2ZXJzZSgpXG5cdCAgICAgICAgLnJlc3QodGhpcy5nZXQoJ2xpbWl0JykpXG5cdCAgICAgICAgLnBsdWNrKCdrZXknKVxuXHQgICAgICAgIC52YWx1ZSgpO1xuXG4gICAgXHQvLyBDcmVhdGUgYSBuZXcgYXJyYXkgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBidXQgb25seSB3aXRoIHRoZSBmdW5kaW5nIHR5cGVzIGZyb20gJ090aGVycycgY2F0ZWdvcnkuXG4gICAgXHR2YXIgb3RoZXJzU2VyaWVzVmFsdWVzID0gXyhkYXRhLnByb2Nlc3NlZCkuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gXyhvdGhlcnNOYW1lcykuY29udGFpbnMoc2VyaWVzLmtleSk7IH0pXG4gICAgXHR2YXIgc29ydGVkT3RoZXJzU2VyaWVzVmFsdWVzID0gW107XG4gICAgXHRcbiAgICBcdC8vIFNvcnQgJ290aGVyc1Nlcmllc1ZhbHVlcycgYnkgdGhlIHZhbHVlcyBmcm9tICdvdGhlcnNOYW1lcycgXG4gICAgXHQvLyAoaWYgd2UgZG9udCBkbyB0aGlzIHN0ZXAgdGhlbiB3ZSB3aWxsICdleHRyYWN0JyB0aGUgd3JvbmcgZnVuZGluZyB0eXBlIHdoZW4gY2xpY2tpbmcgJ090aGVycycpLlxuICAgIFx0b3RoZXJzTmFtZXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG4gICAgXHRcdG90aGVyc1Nlcmllc1ZhbHVlcyA9IG90aGVyc1Nlcmllc1ZhbHVlcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgIFx0ICAgICAgICBpZighZm91bmQgJiYgaXRlbS5rZXkgPT09IGtleSkge1xuICAgIFx0ICAgICAgICBcdHNvcnRlZE90aGVyc1Nlcmllc1ZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgIFx0ICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgIFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIFx0ICAgICAgICB9IGVsc2UgXG4gICAgXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBcdCAgICB9KVxuICAgIFx0fSk7XG4gICAgXHRcbiAgICBcdC8vIFN1bW1hcml6ZSBhbGwgZnVuZGluZyB0eXBlcyAoZnJvbSAnT3RoZXJzJykgYnkgeWVhci5cbiAgICBcdG90aGVyc1Nlcmllc1ZhbHVlcyA9IF8oc29ydGVkT3RoZXJzU2VyaWVzVmFsdWVzKVxuXHQgICAgXHQuY2hhaW4oKVxuXHQgICAgXHQubWFwKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLnZhbHVlczsgfSlcblx0ICAgICAgICAudHJhbnNwb3NlKClcblx0ICAgICAgICAubWFwKGZ1bmN0aW9uKG90aGVyc1llYXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgXHR4OiBvdGhlcnNZZWFyWzBdLngsXG5cdCAgICAgICAgICAgIFx0eTogXyhvdGhlcnNZZWFyKS5yZWR1Y2UoZnVuY3Rpb24odCwgcykgeyByZXR1cm4gdCArIHMueTsgfSwgMCksXG5cdCAgICAgICAgICAgIFx0ejogJydcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KVxuXHQgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgICAgIFx0cmV0dXJuIHtcblx0ICAgICAgICBcdFx0eDogaXRlbS54LFxuXHQgICAgICAgIFx0XHR5OiBpdGVtLnksXG5cdCAgICAgICAgXHRcdHo6IGNvbW1vbi5mb3JtYXROdW1iZXIoaXRlbS55IC8qKiBwYXJzZUZsb2F0KGFwcC5nZW5lcmFsU2V0dGluZ3MubnVtYmVyRGl2aWRlcikqLylcblx0ICAgICAgICBcdH07XG5cdCAgICAgICAgfSlcblx0ICAgICAgICAudmFsdWUoKVxuXHQgICAgXG5cdCAgICB2YXIgb3RoZXJzU2VyaWVzID0geyBcblx0ICAgICAgICBrZXk6IGxvY2FsaXplZE90aGVycyxcblx0ICAgICAgICBjb2xvcjogJyM3NzcnLFxuXHQgICAgICAgIHNwZWNpYWw6ICdvdGhlcnMnLFxuXHQgICAgICAgIGRpc2FibGVkOiAoXy5pbmRleE9mKHNlbGYuZ2V0KCdzZXJpZXNUb0V4Y2x1ZGUnKSwgbG9jYWxpemVkT3RoZXJzKSAhPSAtMSksXG5cdCAgICAgICAgdmFsdWVzOiBvdGhlcnNTZXJpZXNWYWx1ZXNcblx0ICAgIH07XG4gICAgXHQgICAgXHQvLyBSZW1vdmUgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSB0aGUgZnVuZGluZyB0eXBlcyB3ZSBncm91cGVkIGluICdPdGhlcnMnIChjYW50IHVzZSBzbGljZSBiZWNhdXNlIHRoZSBzb3J0aW5nIGluICdkYXRhLnByb2Nlc3NlZCcgaXMgZGlmZmVyZW50KS5cbiAgICBcdGRhdGEucHJvY2Vzc2VkID0gXyhkYXRhLnByb2Nlc3NlZCkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gIV8ob3RoZXJzTmFtZXMpLmNvbnRhaW5zKGl0ZW0ua2V5KX0pO1xuICAgIFx0ZGF0YS5wcm9jZXNzZWQucHVzaChvdGhlcnNTZXJpZXMpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgeWVhclRvdGFscyA9IHt9O1xuXHRfLmVhY2goZGF0YS5wcm9jZXNzZWQsIGZ1bmN0aW9uKGQpe1xuXHRcdF8uZWFjaChkLnZhbHVlcywgZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0eWVhclRvdGFsc1t2YWx1ZS54XSA9ICh5ZWFyVG90YWxzW3ZhbHVlLnhdIHx8IDApICsgdmFsdWUueTtcblx0XHR9KTsgICAgXHRcdFxuXHR9KTtcblx0XG5cdHRoaXMuc2V0KCd5ZWFyVG90YWxzJywgeWVhclRvdGFscyk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG59KTtcbiIsInZhciBwYXJhbSA9IHJlcXVpcmUoJ2pxdWVyeScpLnBhcmFtO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQ2hhcnRNb2RlbCA9IHJlcXVpcmUoJy4vY2hhcnQtbW9kZWwtYmFzZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NoYXJ0cy9jb21tb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydE1vZGVsLmV4dGVuZCh7XG5cblx0ZGVmYXVsdHM6IHtcblx0ICAgIHhMaW1pdDogMzAsIC8vVGhpcyBpcyB0aGUgbWF4IG51bWJlciBvZiBlbGVtZW50cyB3ZSB3aWxsIHNlZSBpbiB0aGUgeCBheGlzLlxuXHQgICAgeUxpbWl0OiAxMCwgLy9UaGlzIGlzIHRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIHdlIHdpbGwgc2VlIGluIHRoZSB5IGF4aXMuICBcblx0ICAgIG9yaWdpbmFsWUxpbWl0OiAxMCwgLy9UaGlzIGlzIHRoZSBvcmlnaW5hbCBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB0aGUgeSBheGlzICh1c2VkIHRvIHJldmVydCBcIm90aGVyc1wiKS5cblx0ICAgIHRpdGxlOiAnJyxcblx0ICAgIG5hbWU6ICcnLFxuXHQgICAgYmlnTjogMCxcblx0ICAgIGFsdGVybmF0aXZlQ29udGFpbmVyQ2xhc3M6ICdoZWF0bWFwLWNoYXJ0LXdyYXAnLFxuXHQgICAgdmFsdWVzOiBbXSxcblx0ICAgIGNoYXJ0VHlwZTogJ2ZyYWdtZW50YXRpb24nLFxuXHQgICAgc3dhcEF4ZXM6IGZhbHNlLFxuXHQgICAgaGVhdG1hcF90eXBlOiBudWxsLFxuXHQgICAgc2hvd1Jlc2V0QnV0dG9uOiBmYWxzZSxcblx0ICAgIHNob3dGdWxsTGVnZW5kczogZmFsc2Vcblx0fSxcblxuXHRfcHJlcGFyZVRyYW5zbGF0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRvcEJhc2VMYW5ndWFnZSA9IHt9O1xuXG5cdCAgICAvKiBQcmVwYXJlIHRoZSB0cmFuc2xhdGlvbnMgZm9yIHRoZSBjaGFydCAqL1xuXHQgICAgdmFyIGNoYXJ0TmFtZSA9IFsnYW1wLmRhc2hib2FyZDpjaGFydC0nLCB0aGlzLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywgJycpLCAnLSddLmpvaW4oJycpO1xuXHRcblx0ICAgIHRoaXMubG9jYWxpemVkVG9wQ2hhcnQgPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZUxpc3QodG9wQmFzZUxhbmd1YWdlKVxuXHQgICAgXHQuZG9uZShfKGZ1bmN0aW9uKGxvY2FsaXplZFRvcENoYXJ0S2V5VmFsKSB7XG5cdCAgICBcdFx0dGhpcy5sb2NhbGl6ZWRMb29rdXAgPSBsb2NhbGl6ZWRUb3BDaGFydEtleVZhbDtcblx0ICAgIFx0fSkuYmluZCh0aGlzKSk7XG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYudmFsdWVzID0gbmV3IEFycmF5KCk7XG5cdFx0aWYgKF8uaXNVbmRlZmluZWQoZGF0YS54RGF0YVNldCkgfHwgXy5pc1VuZGVmaW5lZChkYXRhLnlEYXRhU2V0KSkge1xuXHRcdFx0Ly8gVGhlIEVQIGZvciBoZWF0bWFwcyBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgb3RoZXIgY2hhcnRzIGJlY2F1c2UgaXQgcmV0dXJucyBhbiBlbXB0eSBvYmplY3QsIHNvIHdlIHNldCBleHBsaWNpdGx5IHNvbWUgZmllbGRzIHRvIGVtcHR5IHZhbHVlLiBcblx0XHRcdGRhdGEueURhdGFTZXQgPSBbXTtcblx0XHRcdGRhdGEueERhdGFTZXQgPSBbXTtcblx0XHRcdGRhdGEubWF0cml4ID0gW107XG5cdFx0XHRkYXRhLnhUb3RhbHMgPSAwO1xuXHRcdFx0ZGF0YS55VG90YWxzID0gMDtcblx0XHRcdGRhdGEueENvdW50ID0gMDtcblx0XHRcdGRhdGEueUNvdW50ID0gMDtcblx0XHRcdGRhdGEueFRvdGFsQ291bnQgPSAwO1xuXHRcdFx0ZGF0YS55VG90YWxDb3VudCA9IDA7XG5cdFx0fVx0XHRcblx0XHRzZWxmLnZhbHVlcy54ID0gZGF0YS54RGF0YVNldDtcblx0XHRzZWxmLnZhbHVlcy55ID0gZGF0YS55RGF0YVNldDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEueURhdGFTZXQubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS54RGF0YVNldC5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAoZGF0YS5tYXRyaXhbaV0gIT09IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBkYXRhLm1hdHJpeFtpXVtqXSAhPT0gbnVsbCA/IGRhdGEubWF0cml4W2ldW2pdIDoge3A6IC0xLCBhbW91bnQ6ICcwJ307XG5cdFx0XHRcdFx0dmFyIHJvdyA9IHt5OiBpICsgMSwgeDogaiArIDEsIHZhbHVlOiB2YWx1ZS5wLCBhbW91bnQ6IHZhbHVlLmR2LyosIHluYW1lOiBkYXRhLnlEYXRhU2V0W2ldLCB4bmFtZTogZGF0YS54RGF0YVNldFtpXSovfTsgLy9uYW1lIGlzIGZvciB0b29sdGlwXG5cdFx0XHRcdFx0c2VsZi52YWx1ZXMucHVzaChyb3cpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYudmFsdWVzLnB1c2goe3k6IGkgKyAxLCB4OiBqICsgMSwgdmFsdWU6IC0xLCBhbW91bnQ6IFwiMFwifSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XHRcdFxuXHRcdC8vIE5vcm1hbGl6ZSB2YWx1ZXMuXG5cdFx0c2VsZi52YWx1ZXMgPSB0aGlzLm5vcm1hbGl6ZVZhbHVlcyhzZWxmLnZhbHVlcyk7XG5cdFx0XG5cdFx0Ly8gQWRkIHRvdGFscyBkYXRhLlxuXHRcdHNlbGYudmFsdWVzLnhQVG90YWxzID0gdGhpcy5ub3JtYWxpemVWYWx1ZXMoZGF0YS54UFRvdGFscyk7XG5cdFx0c2VsZi52YWx1ZXMueVBUb3RhbHMgPSB0aGlzLm5vcm1hbGl6ZVZhbHVlcyhkYXRhLnlQVG90YWxzKTtcblx0XHRzZWxmLnZhbHVlcy54VG90YWxzID0gZGF0YS54VG90YWxzO1xuXHRcdHNlbGYudmFsdWVzLnlUb3RhbHMgPSBkYXRhLnlUb3RhbHM7XG5cdFx0c2VsZi52YWx1ZXMueENvdW50ID0gZGF0YS54Q291bnQ7XG5cdFx0c2VsZi52YWx1ZXMueUNvdW50ID0gZGF0YS55Q291bnQ7XG5cdFx0c2VsZi52YWx1ZXMueFRvdGFsQ291bnQgPSBkYXRhLnhUb3RhbENvdW50O1xuXHRcdHNlbGYudmFsdWVzLnlUb3RhbENvdW50ID0gZGF0YS55VG90YWxDb3VudDtcdFxuXHRcdHNlbGYudmFsdWVzLm1vZGVsID0gdGhpcztcblxuXHRcdGlmICghdGhpcy5sb2NhbGl6ZWRMb29rdXApIHtcblx0XHRcdC8vIHdlIGNhbid0IHByb2NlZGUgaWYgd2UgZG9uJ3QgaGF2ZSB0cmFuc2xhdGlvbnMgeWV0IDooXG5cdFx0XHQvLyB0aGlzIGNvZGUgc2hvdWxkIG5vdyBiZSB1bnJlYWNoYWJsZSwgYnV0IHknbmV2ZXIga25vdy4uLlxuXHRcdFx0dGhpcy5hcHAucmVwb3J0KCdMb2FkaW5nIGVycm9yJywgWydUcmFuc2xhdGlvbnMgZm9yIHRoZSBhcHBsaWNhdGlvbiB3ZXJlIG5vdCBsb2FkZWQgYmVmb3JlIHJlbmRlcmluZyddKTtcblx0XHR9XG5cdFx0dmFyIGNoYXJ0TmFtZSA9IFsnYW1wLmRhc2hib2FyZDpjaGFydC0nLCB0aGlzLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywgJycpLCAnLSddLmpvaW4oJycpO1xuXG5cdFx0ZGF0YS5wcm9jZXNzZWQgPSBbe3ZhbHVlczogdGhpcy52YWx1ZXN9XTtcblx0XHRkYXRhLnZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdFxuXHRcdGlmIChkYXRhLnlDb3VudCA+IHRoaXMuZ2V0KCdvcmlnaW5hbFlMaW1pdCcpICsgMSkge1xuXHRcdFx0dGhpcy5zZXQoJ3Nob3dSZXNldEJ1dHRvbicsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldCgnc2hvd1Jlc2V0QnV0dG9uJywgZmFsc2UpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblx0XG5cdG5vcm1hbGl6ZVZhbHVlczogZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0aWYgKF8uaXNVbmRlZmluZWQodmFsdWVzKSA9PT0gZmFsc2UpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBhdXhWYWx1ZSA9IHZhbHVlc1tpXS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWVzW2ldLnZhbHVlIDogdmFsdWVzW2ldO1xuXHRcdFx0XHRpZiAoYXV4VmFsdWUgPiAwICYmIGF1eFZhbHVlIDwgMSkge1xuXHRcdFx0XHRcdC8vRG8gbm90aGluZztcblx0XHRcdFx0fSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1eFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1eFZhbHVlID0gLTk5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ldLnZhbHVlID0gTWF0aC5mbG9vcihhdXhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSBNYXRoLmZsb29yKGF1eFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0ZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0b3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwgeyB1cmw6IHRoaXMudXJsIH0pO1xuXHRcdFxuXHRcdC8vIFByb2Nlc3MgcGFyYW1zIGZyb20gaGVhdC1tYXAvY29uZmlncywgaW4gdGhhdCBFUCB3ZSBoYXZlIGRlZmluZWQgZWFjaCBoZWF0bWFwLlxuXHRcdHZhciBjb25maWdzID0gdGhpcy5nZXQoJ2hlYXRtYXBfY29uZmlnJykubW9kZWxzWzBdO1xuXHRcdHZhciB0aGlzQ2hhcnQgPSBfLmZpbmQoY29uZmlncy5nZXQoJ2NoYXJ0cycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0ubmFtZSA9PT0gc2VsZi5nZXQoJ25hbWUnKX0pO1xuXHRcdHZhciB4Q29sdW1uID0gc2VsZi5nZXQoJ3hBeGlzQ29sdW1uJykgIT09ICcnID8gc2VsZi5nZXQoJ3hBeGlzQ29sdW1uJykgOiBjb25maWdzLmdldCgnY29sdW1ucycpW3RoaXNDaGFydC54Q29sdW1uc1swXV0ub3JpZ05hbWU7IC8vIEZpcnN0IGNvbHVtbiBpcyBkZWZhdWx0LlxuXHRcdHZhciB5Q29sdW1uID0gY29uZmlncy5nZXQoJ2NvbHVtbnMnKVt0aGlzQ2hhcnQueUNvbHVtbnNbMF1dLm9yaWdOYW1lOyAvLyBGaXJzdCBjb2x1bW4gaXMgZGVmYXVsdC5cblx0XHRcblx0XHQvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHN3aXRjaCBheGlzLlxuXHRcdGlmIChzZWxmLmdldCgnc3dhcEF4ZXMnKSA9PT0gdHJ1ZSkge1xuXHRcdFx0dmFyIGF1eEF4aXMgPSB5Q29sdW1uO1xuXHRcdFx0eUNvbHVtbiA9IHhDb2x1bW47XG5cdFx0XHR4Q29sdW1uID0gYXV4QXhpcztcblx0XHR9XHRcdFxuXHRcdHZhciBwYXJhbXNGb3JIZWF0TWFwID0ge3hDb3VudDogc2VsZi5nZXQoJ3hMaW1pdCcpLCB4Q29sdW1uOiB4Q29sdW1uLCB5Q29sdW1uOiB5Q29sdW1uLCB5Q291bnQ6IHNlbGYuZ2V0KCd5TGltaXQnKX07XHRcdFxuXHRcdHZhciBmaWx0ZXJPYmplY3QgPSBKU09OLnBhcnNlKG9wdGlvbnMuZGF0YSk7XHRcdFxuXHRcdHBhcmFtc0ZvckhlYXRNYXAuZmlsdGVycyA9IChmaWx0ZXJPYmplY3QgJiYgZmlsdGVyT2JqZWN0LmZpbHRlcnMpID8gZmlsdGVyT2JqZWN0LmZpbHRlcnMgOiB7fTsgXG5cdFx0b3B0aW9ucy5kYXRhID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zRm9ySGVhdE1hcCk7XG5cblx0XHRyZXR1cm4gQ2hhcnRNb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0fVxufSk7IiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLk1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHt9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuICAgIHRoaXMuX3ByZXBhcmVUcmFuc2xhdGlvbnMoKTsgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgaW1wbGVtZW50YXRpb24gaW50byBoZXJlXG4gIH0sXG5cbiAgaGFzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8odGhpcy5nZXQoJ3Byb2Nlc3NlZCcpKVxuICAgICAgLmNoYWluKClcbiAgICAgIC5wbHVjaygndmFsdWVzJylcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJiYgdHJ1ZSB8fCByZXN1bHQ7XG4gICAgICB9LCBmYWxzZSlcbiAgICAgIC52YWx1ZSgpO1xuICB9LFxuXG4gIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKG9wdGlvbnMuZGF0YSk7XG4gICAgZGF0YS5zZXR0aW5ncyA9IHRoaXMuYXBwLnNldHRpbmdzV2lkZ2V0LnRvQVBJRm9ybWF0KCk7XG5cbiAgICBpZiAodGhpcy5nZXQoJ2FkanR5cGUnKSkge1xuICAgICAgLy8gVE9ETyBhZGp0eXBlIGhhcmQtY29kaW5nIGtleSBmb3Igbm93LCBzaG91bGQgZ2V0IGZyb20gc2V0dGluZ3MuLi5cbiAgICAgIGRhdGEuc2V0dGluZ3MgPSBfKHt9KS5leHRlbmQoZGF0YS5zZXR0aW5ncywgeydmdW5kaW5nLXR5cGUnOiB0aGlzLmdldCgnYWRqdHlwZScpfSk7XG4gICAgfVxuICAgIF8uZGVmYXVsdHMoZGF0YS5zZXR0aW5ncyx7ICdjdXJyZW5jeS1jb2RlJzogdGhpcy5hcHAuc2V0dGluZ3NXaWRnZXQuZGVmaW5pdGlvbnMuZ2V0RGVmYXVsdEN1cnJlbmN5SWQoKX0pO1xuICAgIG9wdGlvbnMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIHJldHVybiBCYWNrYm9uZURhc2guTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgcGFyYW0gPSByZXF1aXJlKCdqcXVlcnknKS5wYXJhbTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIENoYXJ0TW9kZWwgPSByZXF1aXJlKCcuL2NoYXJ0LW1vZGVsLWJhc2UnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jaGFydHMvY29tbW9uJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICBsaW1pdDogNSxcbiAgICB0aXRsZTogJycsXG4gICAgYmlnTjogMCxcbiAgICBjaGFydFR5cGU6ICd0b3AnXG4gIH0sXG5cbiAgX3ByZXBhcmVUcmFuc2xhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3BCYXNlTGFuZ3VhZ2UgPSB7fTtcblxuICAgIC8qIFByZXBhcmUgdGhlIHRyYW5zbGF0aW9ucyBmb3IgdGhlIGNoYXJ0ICovXG4gICAgdmFyIGNoYXJ0TmFtZSA9IFsnYW1wLmRhc2hib2FyZDpjaGFydC0nLCB0aGlzLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywgJycpLCAnLSddLmpvaW4oJycpO1xuXG4gICAgLypcbiAgICAgKiBUT0RPOiBsb2FkIGFsbCB0aGUgbG9jYWxpemF0aW9ucyBpbiB0aGlzIGNoYXJ0J3MgbmFtZXNwYWNlIHRvIHRoaXMgYXJyYXlcbiAgICAgKiBmcm9tIGluaXRpYWwtdHJhbnNsYXRpb24tcmVxdWVzdC5qc29uIC0tIEZvciBub3cganVzdCBoYXJkY29kZSB0aGUgdHdvIHNvcnRzLlxuICAgICAqL1xuICAgIGlmICh0aGlzLmdldCgnbmFtZScpID09PSAnVG9wIFJlZ2lvbnMnKSB7XG4gICAgICB0b3BCYXNlTGFuZ3VhZ2VbY2hhcnROYW1lICsgJ0Rpc3RyaWN0VW5kZWZpbmVkJ10gPSAnRGlzdHJpY3RzOiBVbmRlZmluZWQnO1xuICAgIH1cbiAgICB0b3BCYXNlTGFuZ3VhZ2VbY2hhcnROYW1lICsgJ290aGVycyddID0gJ090aGVycyc7XG5cbiAgICB0aGlzLmxvY2FsaXplZFRvcENoYXJ0ID0gdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVMaXN0KHRvcEJhc2VMYW5ndWFnZSlcbiAgICAgIC5kb25lKF8oZnVuY3Rpb24obG9jYWxpemVkVG9wQ2hhcnRLZXlWYWwpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6ZWRMb29rdXAgPSBsb2NhbGl6ZWRUb3BDaGFydEtleVZhbDtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuc2V0KCd0aXRsZScsIGRhdGEudGl0bGUpO1xuXHQgIFxuICAgIGlmICghdGhpcy5sb2NhbGl6ZWRMb29rdXApIHtcbiAgICAgIC8vIHdlIGNhbid0IHByb2NlZGUgaWYgd2UgZG9uJ3QgaGF2ZSB0cmFuc2xhdGlvbnMgeWV0IDooXG4gICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIG5vdyBiZSB1bnJlYWNoYWJsZSwgYnV0IHknbmV2ZXIga25vdy4uLlxuICAgICAgdGhpcy5hcHAucmVwb3J0KCdMb2FkaW5nIGVycm9yJywgW1xuICAgICAgJ1RyYW5zbGF0aW9ucyBmb3IgdGhlIGFwcGxpY2F0aW9uIHdlcmUgbm90IGxvYWRlZCBiZWZvcmUgcmVuZGVyaW5nJ10pO1xuICAgIH1cblxuICAgIHZhciBjaGFydE5hbWUgPSBbJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtJywgdGhpcy5nZXQoJ25hbWUnKS5yZXBsYWNlKC8gL2csICcnKSwgJy0nXS5qb2luKCcnKTtcbiAgICB0aGlzLmxvY2FsaXplZE90aGVycyA9IHRoaXMubG9jYWxpemVkTG9va3VwW2NoYXJ0TmFtZSArICdvdGhlcnMnXTtcbiAgICBpZiAodGhpcy5sb2NhbGl6ZWRPdGhlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgIFx0Y29uc29sZS5lcnJvcignbWlzc2luZyB0cmFuc2xhdGlvbiBpbiAuanNvbiBmaWxlOiAnICsgY2hhcnROYW1lICsgJ290aGVycycpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBfKGRhdGEudmFsdWVzLnNsaWNlKCkpLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgY2xlYW5OYW1lID0gdi5uYW1lLnJlcGxhY2UoL1sgOi5dL2csICcnKTtcbiAgICAgIHZhciBsb2NhbGl6ZWROYW1lID0gdi5uYW1lO1xuICAgICAgaWYgKHRoaXMubG9jYWxpemVkTG9va3VwW2NoYXJ0TmFtZSArIGNsZWFuTmFtZV0pIHtcbiAgICAgICAgbG9jYWxpemVkTmFtZSA9IHRoaXMubG9jYWxpemVkTG9va3VwW2NoYXJ0TmFtZSArIGNsZWFuTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxvY2FsaXplZE5hbWUsXG4gICAgICAgIHk6IHYuYW1vdW50LFxuICAgICAgICB6OiB2LmZvcm1hdHRlZEFtb3VudCxcbiAgICAgICAgaWQ6IHYuaWRcbiAgICAgIH07XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBhbnkgZHVwbGljYXRlIGtleXMuLi4gbnZkMyBwdWtlcyBvbiB0aG9zZVxuICAgIGlmIChfKF8odmFsdWVzKS5wbHVjaygneCcpKS51bmlxKCkubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5hcHAucmVwb3J0KCdEYXRhIEVycm9yJyxcbiAgICAgICAgWydUaGUgZGF0YSBmb3IgJyArIHRoaXMuZ2V0KCduYW1lJykgKyAnIHdhcyBpbmNvbnNpc3RlbnQgZHVlIHRvIGR1cGxpY2F0ZSBrZXlzJyxcbiAgICAgICAgJ1RoZSBjaGFydCB3aWxsIGJlIHNob3duLCBidXQgaXQgbWF5IGhhdmUgZXJyb3JzIG9yIG90aGVyIGlzc3VlcyBhcyBhIHJlc3VsdC4nXSk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubWF4TGltaXQgPiB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgXHR2YXIgb3RoZXIgPSB7XG4gICAgXHRcdFx0eDogdGhpcy5sb2NhbGl6ZWRPdGhlcnMsXG4gICAgXHRcdFx0eTogZGF0YS50b3RhbCAtICAvLyB0b3RhbCBtaW51cyB0aGUgc3VtIG9mIHdoYXQgd2UgaGF2ZVxuICAgICAgICAgICAgICAgIF8uY2hhaW4odmFsdWVzKS5wbHVjaygneScpLnJlZHVjZShmdW5jdGlvbihsLCByKSB7IHJldHVybiBsICsgcjsgfSwgMCkudmFsdWUoKSxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM3NzcnLFxuICAgICAgICAgICAgICAgIHNwZWNpYWw6ICdvdGhlcnMnXG4gICAgICAgIH07XG4gICAgICAgIC8vQU1QLTE4NzQwOiBXZSBjaGFuZ2VkIHRoZSBFUCB0byBzZW5kIHJhdyBudW1iZXJzIGV4cHJlc3NlZCBpbiB1bml0cyBzbyB3ZSBuZWVkIHRvIGFwcGx5IHRoZSBHUyBoZXJlLlxuICAgIFx0b3RoZXIueiA9IGNvbW1vbi5mb3JtYXROdW1iZXIob3RoZXIueSAvIGFwcC5nZW5lcmFsU2V0dGluZ3MubnVtYmVyRGl2aWRlcik7XG4gICAgICAgIHZhbHVlcy5wdXNoKG90aGVyKTtcbiAgICB9XG5cbiAgICBkYXRhLnByb2Nlc3NlZCA9IFt7dmFsdWVzOiB2YWx1ZXN9XTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKFxuICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgIHsgdXJsOiB0aGlzLnVybCArICc/JyArIHBhcmFtKHRoaXMucGljaygnbGltaXQnKSkgfSk7XG4gICAgcmV0dXJuIENoYXJ0TW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgfVxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxuXHJcbnZhciBFbmFibGVkQ2hhcnRNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XHJcblxyXG59KTtcclxuXHJcbnZhciBFbmFibGVkQ2hhcnRzQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuXHRtb2RlbCA6IEVuYWJsZWRDaGFydE1vZGVsLFxyXG5cdHVybCA6ICcvcmVzdC9jb21tb24vZm0nLFxyXG5cdGZldGNoRGF0YSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IHtcclxuXHRcdFx0XCJkZXRhaWwtbW9kdWxlc1wiIDogWyBcIkRBU0hCT0FSRFNcIiBdXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5mZXRjaCh7XHJcblx0XHRcdHR5cGUgOiAnUE9TVCcsXHJcblx0XHRcdGFzeW5jIDogZmFsc2UsXHJcblx0XHRcdHByb2Nlc3NEYXRhIDogZmFsc2UsXHJcblx0XHRcdG1pbWVUeXBlIDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG5cdFx0XHR0cmFkaXRpb25hbCA6IHRydWUsXHJcblx0XHRcdGhlYWRlcnMgOiB7XHJcblx0XHRcdFx0J0NvbnRlbnQtVHlwZScgOiAnYXBwbGljYXRpb24vanNvbicsXHJcblx0XHRcdFx0J0NhY2hlLUNvbnRyb2wnIDogJ25vLWNhY2hlJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRkYXRhIDogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSwgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZHVlIHRvXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBpbmNvbXBhdGliaWxpdGllcyB3aXRoIEplcnNleVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2hlbiByZWNlaXZpbmcgdGhlIHBhcmFtcy5cclxuXHRcdFx0ZXJyb3IgOiBmdW5jdGlvbihjb2xsZWN0aW9uLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ2Vycm9yIGxvYWRpbmcgY2hhcnRzLicpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzdWNjZXNzIDogZnVuY3Rpb24oY29sbGVjdGlvbiwgcmVzcG9uc2UpIHtcclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVuYWJsZWRDaGFydHNDb2xsZWN0aW9uOyIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxudmFyIEhlYXRtYXBzQ29uZmlnTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xyXG5cclxufSk7XHJcblxyXG52YXIgSGVhdG1hcHNDb25maWdDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xyXG5cdG1vZGVsIDogSGVhdG1hcHNDb25maWdNb2RlbCxcclxuXHR1cmwgOiAnL3Jlc3QvZGFzaGJvYXJkL2hlYXQtbWFwL2NvbmZpZ3MnLFxyXG5cdGZldGNoRGF0YSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5mZXRjaCh7XHJcblx0XHRcdHR5cGUgOiAnR0VUJyxcclxuXHRcdFx0YXN5bmMgOiBmYWxzZSxcclxuXHRcdFx0cHJvY2Vzc0RhdGEgOiBmYWxzZSxcclxuXHRcdFx0bWltZVR5cGUgOiAnYXBwbGljYXRpb24vanNvbicsXHJcblx0XHRcdHRyYWRpdGlvbmFsIDogdHJ1ZSxcclxuXHRcdFx0aGVhZGVycyA6IHtcclxuXHRcdFx0XHQnQ29udGVudC1UeXBlJyA6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuXHRcdFx0XHQnQ2FjaGUtQ29udHJvbCcgOiAnbm8tY2FjaGUnXHJcblx0XHRcdH0sXHJcblx0XHRcdGRhdGEgOiBKU09OLnN0cmluZ2lmeSgpLCAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBkdWUgdG9cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGluY29tcGF0aWJpbGl0aWVzIHdpdGggSmVyc2V5XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB3aGVuIHJlY2VpdmluZyB0aGUgcGFyYW1zLlxyXG5cdFx0XHRlcnJvciA6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcignZXJyb3IgbG9hZGluZyBoZWF0bWFwIGNvbmZpZ3MuJyk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHN1Y2Nlc3MgOiBmdW5jdGlvbihjb2xsZWN0aW9uLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZWF0bWFwc0NvbmZpZ0NvbGxlY3Rpb247IiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbnZhciBBUElfSURfS0VZID0gJ21hcElkJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5Nb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgbmFtZTogdW5kZWZpbmVkLFxuICAgIGRlc2NyaXB0aW9uOiB1bmRlZmluZWQsXG4gICAgc3RhdGVCbG9iOiB1bmRlZmluZWRcbiAgfSxcblxuICAvLyBwYXJzZSBhbmQgdG9KU09OIG1hcCB0aGUgaWQgZmllbGQgdG8gbWFwSWQgZm9yIHRoZSBBUEkuXG4gIHBhcnNlOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoXyhvYmopLmhhcyhBUElfSURfS0VZKSkge1xuICAgICAgb2JqLmlkID0gb2JqW0FQSV9JRF9LRVldO1xuICAgICAgZGVsZXRlIG9ialtBUElfSURfS0VZXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybDtcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0gQmFja2JvbmVEYXNoLk1vZGVsLnByb3RvdHlwZS50b0pTT04uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoXyhjb3B5KS5oYXMoJ2lkJykpIHtcbiAgICAgIGNvcHlbQVBJX0lEX0tFWV0gPSBjb3B5LmlkO1xuICAgICAgZGVsZXRlIGNvcHkuaWQ7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbn0sIHtcbiAgZnJvbUlkOiBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyh7IGlkOiBpZCB9LCBvcHRpb25zKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBEZWZlcnJlZCA9IHJlcXVpcmUoJ2pxdWVyeScpLkRlZmVycmVkO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBTYXZlZENoYXJ0ID0gcmVxdWlyZSgnLi9zYXZlZC1kYXNoJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIHVybDogJy9yZXN0L2Rhc2hib2FyZC9zYXZlZC1jaGFydHMnLFxuXG4gIG1vZGVsOiBTYXZlZENoYXJ0LFxuICB0aW1lcjogdW5kZWZpbmVkLFxuICBpbml0aWFsaXplZE9uY2U6IGZhbHNlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gIH0sXG5cbiAgbG9hZDogZnVuY3Rpb24oc3RhdGVJZCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdGlmIChzZWxmLmluaXRpYWxpemVkT25jZSAhPT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdHNlbGYuaW5pdGlhbGl6ZWRPbmNlID0gdHJ1ZTtcblx0IFxuICAgIHZhciBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHZhciBsb2FkZWQgPSB0aGlzLmdldChzdGF0ZUlkKTtcbiAgICBpZiAobG9hZGVkKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKGxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWwuZnJvbUlkKHN0YXRlSWQsIHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICAgIHRoaXMuYWRkKG1vZGVsKTsgIC8vIHNldHMgdXAgY29sbGVjdGlvbiBzbyB0aGUgbW9kZWwgY2FuIGZpbmQgYSBVUkxcbiAgICAgIG1vZGVsLmZldGNoKCkuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG1vZGVsKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBTVAtMTk4MDMgYW5kIEFNUC0yMDIwNjogSGVyZSB3ZSB3YWl0IHVudGlsIHRoZSBmaWx0ZXIgd2lkZ2V0IGhhcyBiZWVuIGxvYWRlZCB0byB0cmlnZ2VyIHRoZSAnYXBwbHknIGV2ZW50IGFuZCBmb3JjZSBlYWNoIGNoYXJ0IHRvIHJlZHJhdyB3aXRoIHRoZSBzYXZlZCBmaWx0ZXJzLlxuXHQgICAgICAvLyBUcmllZCB0byBkbyBzb21ldGhpbmcgc2ltaWxhciBiZWZvcmUgd2UgcmVhY2ggdGhpcyBzdGFnZSAoaWU6IGluIGFwcC1jbGFzcy5qcywgY2hhcnQtdmlldy1iYXNlLmpzLCBjaGFydHMuanMsIGV0YykgYnV0IHdpdGhvdXQgbHVjayBiZWNhdXNlIHRoZSByZW5kZXIgaXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkuXG5cdCAgICAgIC8vIFRPRE86IFdlIG5lZWQgbW9yZSB0aW1lIHRvIGV2YWx1YXRlIGEgc29sdXRpb24gdXNpbmcgdGhpcy5hcHAuZmlsdGVyLmxvYWRlZCBwcm9taXNlIGJ1dCB0aGF0IGRpZG50IHdvcmsgY29uc2lzdGVudGx5IG9uIElFLiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc2VsZi50aW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFx0ICBzZWxmLnRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0ICAgIFx0ICBpZiAodGhpcy5hcHAgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFwcC5maWx0ZXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFwcC5maWx0ZXIuZmluaXNoZWRGaXJzdExvYWQgPT09IHRydWUpIHtcblx0XHQgICAgXHRcdCAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcblx0XHQgICAgXHRcdCAgdGhpcy5hcHAuZmlsdGVyLnRyaWdnZXIoJ2FwcGx5Jyk7XHRcdFx0ICAgIFx0XHQgIFxuXHRcdCAgICBcdFx0ICAvLyBPbmx5IG1ha2UgMSByZW5kZXIgY2FsbCB0byB0aGUgbWFpbiBhcHAgdmlldywgdGhpcyB3aWxsIHByZXZlbnQgb3RoZXIgYnVncyAoaWU6IHRoZSBkb3VibGUgYW5kIHRyaXBsZSBjaGFydCByZW5kZXJpbmcpLlxuXHRcdCAgICBcdFx0ICBpZiAodGhpcy5hcHAucmVuZGVyZWQgPT09IGZhbHNlKSB7XG5cdFx0ICAgIFx0XHRcdCAgdGhpcy5hcHAucmVuZGVyZWQgPSB0cnVlO1xuXHRcdCAgICBcdFx0XHQgIGFwcC5yZW5kZXIoKTtcblx0XHQgICAgXHRcdCAgfVxuXHRcdCAgICBcdCAgfVxuXHRcdCAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdGYWlsZWQgdG8gbG9hZCBzYXZlZCBkYXNoYm9hcmQnLCBbJ0NvdWxkIG5vdCByZXRyaWV2ZSB0aGUgc2F2ZWQgc3RhdGUuJ10pO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgfVxufSk7IiwidmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciBDaGFydFZpZXdCYXNlID0gcmVxdWlyZSgnLi9jaGFydC12aWV3LWJhc2UnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRWaWV3QmFzZS5leHRlbmQoe1xuXG4gIHVpRGVmYXVsdHM6IHtcbiAgICBiaWc6IGZhbHNlLFxuICAgIHZpZXc6ICdtdWx0aWJhcicsXG4gICAgc2hvd1RvdGFsOiB0cnVlLFxuICAgIHNob3dNZWFzdXJlc1NlbGVjdG9yOiB0cnVlLFxuICAgIHNob3dUb3BMZWdlbmRzOiB0cnVlLFxuICAgIHNob3dDb21tb25DaGFydEFyZWE6IHRydWVcbiAgfSxcbiAgZXZlbnRzOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LENoYXJ0Vmlld0Jhc2UucHJvdG90eXBlLmV2ZW50cyx7XG4gICAgICAgICAgJ2NsaWNrIC5udi1zZXJpZXMnIDogJ2NoYW5nZUNoYXJ0Q29sdW1ucydcbiAgICAgIH0pO1xuICB9LCAgXG4gIGNoYW5nZUNoYXJ0Q29sdW1uczogZnVuY3Rpb24oZSl7XG5cdCAgdmFyIGtleSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5maW5kKCcubnYtbGVnZW5kLXRleHQnKS50ZXh0KCk7XG5cdCAgdmFyIHBsYW5uZWREaXNidXJzZW1lbnRUcm4gPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktcGxhbm5lZC1kaXNidXJzZW1lbnRzXCIsXCJQbGFubmVkIERpc2J1cnNlbWVudHNcIik7XG5cdCAgdmFyIGFjdHVhbERpc2J1cnNlbWVudFRybiA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS1hY3R1YWwtZGlzYnVyc2VtZW50c1wiLFwiQWN0dWFsIERpc2J1cnNlbWVudHNcIik7XG5cdCAgaWYoa2V5ID09IHBsYW5uZWREaXNidXJzZW1lbnRUcm4pe1xuXHRcdCAgdGhpcy5tb2RlbC5zZXQoJ3Nob3dQbGFubmVkRGlzYnVyc2VtZW50cycsICF0aGlzLm1vZGVsLmdldCgnc2hvd1BsYW5uZWREaXNidXJzZW1lbnRzJykpO1x0XG5cdCAgfWVsc2UgaWYoa2V5ID09IGFjdHVhbERpc2J1cnNlbWVudFRybil7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc2hvd0FjdHVhbERpc2J1cnNlbWVudHMnLCAhdGhpcy5tb2RlbC5nZXQoJ3Nob3dBY3R1YWxEaXNidXJzZW1lbnRzJykpO1x0XG5cdCAgfVx0XG4gIH0sXG4gIGNoYXJ0Vmlld3M6IFtcbiAgICAnbXVsdGliYXInLFxuICAgICd0YWJsZSdcbiAgXSxcblxuICBjaGFydE9wdGlvbnM6IHtcbiAgICBudkNvbnRyb2xzOiBmYWxzZVxuICB9LFxuXG4gIGRvd25sb2FkQ2hhcnRPcHRpb25zOiB7XG4gICAgbnZDb250cm9sczogZmFsc2UsXG4gICAgdHJpbUxhYmVsczogZmFsc2VcbiAgfSxcblxuICBnZXRUVENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgYXBwID0gdGhpcy5hcHA7XG4gICAgdmFyIG9mID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpvZicsJ29mJyk7XG4gICAgdmFyIHRvdGFsID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDp0b3RhbCcsJ3RvdGFsJyk7XG4gICAgdmFyIHVuaXRzID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhhcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckRpdmlkZXJEZXNjcmlwdGlvbik7XG5cbiAgICAvLyBJTVBPUlRBTlQ6IFdlIGFzc3VtZSB0aGlzIGNoYXJ0IHdpbGwgQUxXQVlTIHNob3cgMiBkYXRhIHNlcmllcy5cbiAgICAvKiBtb2RpZnkgdG8gYmUgbGlrZSBjaGFydC1mdW5kaW5nLXR5cGUgaWYgYWRkaW5nIG1vcmUgc2VyaWVzICovXG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgaWYgKGNvbnRleHQuZGF0YVswXS5kaXNhYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgaW5kZXggPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IGNvbnRleHQuc2VyaWVzLmluZGV4O1xuICAgIH1cblxuICAgIHZhciBoZWFkZXIgPSBjb250ZXh0LngucmF3ICsgJyAnICtcbiAgICAgICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS0nICtcbiAgICAgICAgICBjb250ZXh0LmRhdGFbaW5kZXhdLm9yaWdpbmFsS2V5ICsgJy0nICsgdGhpcy5tb2RlbC5nZXQoJ21lYXN1cmUnKSwgJycpO1xuXG4gICAgdmFyIG90aGVyU2VyaWVzID0gY29udGV4dC5kYXRhWzEgLSBpbmRleF07ICAvLyBXQVJOSU5HOiBhc3N1bWVzIG9ubHkgMiBzZXJpZXNcbiAgICB2YXIgb3RoZXJIZXJlID0gb3RoZXJTZXJpZXMudmFsdWVzW2NvbnRleHQueC5pbmRleF07XG4gICAgdmFyIGxpbmUyQW1vdW50ID0gMDtcbiAgICBpZiAob3RoZXJIZXJlLnkgPiAwKSB7XG4gICAgICBsaW5lMkFtb3VudCA9IGNvbnRleHQueS5yYXcgLyBvdGhlckhlcmUueTtcbiAgICB9XG4gICAgdmFyIGxpbmUyID0gJzxiPicgKyBkMy5mb3JtYXQoJyUnKShsaW5lMkFtb3VudCkgK1xuICAgICAgICAnPC9iPiZuYnNwPHNwYW4+JyArIG9mICsgJzwvc3Bhbj4mbmJzcCcgKyBjb250ZXh0LngucmF3ICtcbiAgICAgICAgJyZuYnNwPHNwYW4+JyArIHRvdGFsICsgJzwvc3Bhbj4nO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVuY3lOYW1lID0gYXBwLnNldHRpbmdzV2lkZ2V0LmRlZmluaXRpb25zLmZpbmRDdXJyZW5jeUJ5SWQoc2VsZi5tb2RlbC5nZXQoJ2N1cnJlbmN5JykpLnZhbHVlOyBcbiAgICByZXR1cm4ge3R0OiB7XG4gICAgICBoZWFkaW5nOiBoZWFkZXIsXG4gICAgICBib2R5VGV4dDogJzxiPicgKyBjb250ZXh0LnkuZm10ICsgJzwvYj4gJyArIGN1cnJlbmN5TmFtZSArICcgKCcgKyB1bml0cyArICcpJyxcbiAgICAgIGZvb3RlclRleHQ6IGxpbmUyXG4gICAgfX07XG4gIH1cblxufSk7XG4iLCJ2YXIgZDMgPSByZXF1aXJlKCdkMycpO1xudmFyIENoYXJ0Vmlld0Jhc2UgPSByZXF1aXJlKCcuL2NoYXJ0LXZpZXctYmFzZScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydFZpZXdCYXNlLmV4dGVuZCh7XG5cbiAgdWlEZWZhdWx0czoge1xuICAgIGJpZzogdHJ1ZSxcbiAgICBhZGp0eXBlOiAnRkFLRScsXG4gICAgdmlldzogJ211bHRpYmFyJyxcbiAgICBzaG93VG90YWw6IHRydWUsXG4gICAgc2hvd01lYXN1cmVzU2VsZWN0b3I6IHRydWUsXG4gICAgc2hvd1RvcExlZ2VuZHM6IHRydWUsXG4gICAgc2hvd0NvbW1vbkNoYXJ0QXJlYTogdHJ1ZVxuICB9LFxuICBldmVudHM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe30sQ2hhcnRWaWV3QmFzZS5wcm90b3R5cGUuZXZlbnRzLHtcbiAgICAgICAgICAnY2xpY2sgLm52LXNlcmllcycgOiAnY2hhbmdlQ2hhcnRDb2x1bW5zJ1xuICAgICAgfSk7XG4gIH0sICAgXG4gIGNoYW5nZUNoYXJ0Q29sdW1uczogZnVuY3Rpb24oZSl7XHQgIFxuXHQgIHZhciBrZXkgPSAkKGUuY3VycmVudFRhcmdldCkuZmluZCgnLm52LWxlZ2VuZC10ZXh0JykudGV4dCgpO1x0IFxuXHQgIHZhciBzdGFja2VkTGVnZW5kVHJuID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1jaGFydC1sZWdlbmRzLVN0YWNrZWRcIixcIlN0YWNrZWRcIik7XG5cdCAgdmFyIGdyb3VwZWRMZWdlbmRUcm4gPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWNoYXJ0LWxlZ2VuZHMtR3JvdXBlZFwiLFwiR3JvdXBlZFwiKTtcblx0ICBpZihrZXkgPT0gc3RhY2tlZExlZ2VuZFRybiB8fCBrZXkgPT0gZ3JvdXBlZExlZ2VuZFRybil7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc3RhY2tlZCcsIChrZXkgPT0gc3RhY2tlZExlZ2VuZFRybiApKTtcdFxuXHQgIH1lbHNle1xuXHRcdCAgdmFyIHNlcmllc1RvRXhjbHVkZSA9IHRoaXMubW9kZWwuZ2V0KCdzZXJpZXNUb0V4Y2x1ZGUnKSA/IHRoaXMubW9kZWwuZ2V0KCdzZXJpZXNUb0V4Y2x1ZGUnKSA6IFtdO1xuXHRcdCAgdmFyIGluZGV4T2ZLZXlJbkV4Y2x1c2lvbkxpc3QgPSBfLmluZGV4T2Yoc2VyaWVzVG9FeGNsdWRlLCBrZXkpO1xuXHRcdCAgaWYoJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoJ2NsYXNzJykuaW5kZXhPZignZGlzYWJsZWQnKSAhPSAtMSl7XG5cdFx0XHQgIGlmKGluZGV4T2ZLZXlJbkV4Y2x1c2lvbkxpc3QgPT0gLTEpe1xuXHRcdFx0XHQgIHNlcmllc1RvRXhjbHVkZS5wdXNoKGtleSk7XG5cdFx0XHQgIH1cdFx0XHQgIFxuXHRcdCAgfWVsc2V7XG5cdFx0XHQgIGlmKGluZGV4T2ZLZXlJbkV4Y2x1c2lvbkxpc3QgIT0gLTEpe1xuXHRcdFx0XHQgIHNlcmllc1RvRXhjbHVkZS5zcGxpY2UoaW5kZXhPZktleUluRXhjbHVzaW9uTGlzdCwgMSk7XG5cdFx0XHQgIH1cblx0XHQgIH1cblx0XHQgIHRoaXMubW9kZWwuc2V0KCdzZXJpZXNUb0V4Y2x1ZGUnLHNlcmllc1RvRXhjbHVkZSk7XG5cdCAgfVx0IFxuICB9LFxuICBjaGFydFZpZXdzOiBbXG4gICAgJ211bHRpYmFyJyxcbiAgICAndGFibGUnXG4gIF0sXG5cbiAgZG93bmxvYWRDaGFydE9wdGlvbnM6IHtcbiAgICB0cmltTGFiZWxzOiBmYWxzZVxuICB9LFxuXG4gIGdldFRUQ29udGVudDogZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBhcHAgPSB0aGlzLmFwcDtcbiAgICB2YXIgb2YgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOm9mJywnb2YnKTtcbiAgICB2YXIgdG90YWwgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOnRvdGFsJywndG90YWwnKTtcbiAgICB2YXIgdW5pdHMgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKGFwcC5nZW5lcmFsU2V0dGluZ3MubnVtYmVyRGl2aWRlckRlc2NyaXB0aW9uKTtcblxuICAgIHZhciBhY3RpdmVUb29sdGlwVGl0bGVzID0gXy5maWx0ZXIoY29udGV4dC5kYXRhLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgIHJldHVybiBzZXJpZXMuZGlzYWJsZWQgIT09IHRydWU7XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIHRvdGFsRm9yWWVhciA9IHRoaXMubW9kZWwuZ2V0KCd5ZWFyVG90YWxzJykgPyB0aGlzLm1vZGVsLmdldCgneWVhclRvdGFscycpW2NvbnRleHQueC5yYXcgXSA6IG51bGw7XG4gICAgdmFyIGQzRm9ybWF0VG90YWwgPSAnJywgdG90YWxTcGFuID0gJyc7XG4gICAgaWYodG90YWxGb3JZZWFyICYmIHRvdGFsRm9yWWVhciAhPSAwKXtcbiAgICBcdGQzRm9ybWF0VG90YWwgPSBkMy5mb3JtYXQoJyUnKShjb250ZXh0LnkucmF3IC8gdG90YWxGb3JZZWFyKTtcbiAgICAgICAgdG90YWxTcGFuID0gJyZuYnNwPHNwYW4+JyArIHRvdGFsICsgJzwvc3Bhbj4nO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbmN5TmFtZSA9ICBhcHAuc2V0dGluZ3NXaWRnZXQuZGVmaW5pdGlvbnMuZmluZEN1cnJlbmN5QnlJZChzZWxmLm1vZGVsLmdldCgnY3VycmVuY3knKSkudmFsdWU7ICBcbiAgICByZXR1cm4ge3R0OiB7XG4gICAgICBoZWFkaW5nOiBjb250ZXh0LngucmF3ICsgJyAnICsgYWN0aXZlVG9vbHRpcFRpdGxlc1tjb250ZXh0LnNlcmllcy5pbmRleF0ua2V5LFxuICAgICAgYm9keVRleHQ6ICc8Yj4nICsgY29udGV4dC55LmZtdCArICc8L2I+ICcgKyBjdXJyZW5jeU5hbWUgKyAnICgnICsgdW5pdHMgKyAnKScsXG4gICAgICBmb290ZXJUZXh0OiAnPGI+JyArIGQzRm9ybWF0VG90YWwgKyAnPC9iPiZuYnNwPHNwYW4+JyArIG9mICsgJzwvc3Bhbj4mbmJzcCcgKyBjb250ZXh0LngucmF3ICsgdG90YWxTcGFuXG4gICAgfX07XG4gIH0sXG5cbiAgY2hhcnRDbGlja0hhbmRsZXI6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAvLyBjbGlja2luZyBvbiB0aGUgXCJvdGhlcnNcIiBiYXIgbG9hZHMgZml2ZSBtb3JlLlxuICAgIGlmIChjb250ZXh0LmRhdGFbY29udGV4dC5zZXJpZXMuaW5kZXhdLnNwZWNpYWwgPT09ICdvdGhlcnMnKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCgnbGltaXQnLCB0aGlzLm1vZGVsLmdldCgnbGltaXQnKSArIDEpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG52YXIgQ2hhcnRWaWV3QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnQtdmlldy1iYXNlJyk7XG52YXIgTW9kYWxWaWV3ID0gcmVxdWlyZSgnLi9jaGFydC10b3BzLWluZm8tbW9kYWwnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0Vmlld0Jhc2UuZXh0ZW5kKHtcblxuICB1aURlZmF1bHRzOiB7XG5cdGFkanR5cGU6ICdGQUtFJyxcblx0eEF4aXNDb2x1bW46ICcnLFxuICAgIHNob3dUb3RhbDogZmFsc2UsXG4gICAgc2hvd01lYXN1cmVzU2VsZWN0b3I6IHRydWUsXG4gICAgc2hvd1RvcExlZ2VuZHM6IGZhbHNlLFxuICAgIHNob3dDb21tb25DaGFydEFyZWE6IGZhbHNlLFxuICAgIGRpc2FibGVSZXNpemU6IHRydWVcbiAgfSxcbiAgXG4gIGNoYXJ0Vmlld3M6IFtcbiAgICAnaGVhdG1hcCcsXG4gICAgJ3RhYmxlJyAgICBcbiAgXSxcbiAgXG4gIG1vZGFsVmlldzogdW5kZWZpbmVkLFxuICBcbiAgY2hhcnRDbGlja0hhbmRsZXIgOiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdCAgaWYgKGNvbnRleHQueS5mbXQgPT09IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1vdGhlcnMnKSkge1xuXHRcdCAgdGhpcy5tb2RlbC5zZXQoJ3lMaW1pdCcsIHRoaXMubW9kZWwuZ2V0KCd5TGltaXQnKSArIDEwKTtcblx0XHQgIHRoaXMudXBkYXRlRGF0YSgpO1xuXHQgIH1cbiAgfSxcbiAgXG4gIGRvd25sb2FkQ2hhcnRPcHRpb25zOiB7XG4gICAgdHJpbUxhYmVsczogZmFsc2VcbiAgfVxuXG59KTsiLCJcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XHJcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8c2NyaXB0IHR5cGU9XFxcInRleHQvamF2YXNjcmlwdFxcXCI+XFxyXFxuXFx0ZnVuY3Rpb24gb3BlblByZXZpZXdBY3Rpdml0eShpZCkge1xcclxcblxcdFxcdHdpbmRvdy5vcGVuKCcvYWltL3ZpZXdBY3Rpdml0eVByZXZpZXcuZG9+cHVibGljPXRydWV+cGFnZUlkPTJ+YWN0aXZpdHlJZD0nICsgaWQsICdfYmxhbmsnKTtcXHJcXG5cXHR9XFxyXFxuPC9zY3JpcHQ+XFxyXFxuXFxyXFxuPGRpdiBjbGFzcz0nY2hhcnQtdG9wcy1pbmZvLWNhdGVnb3J5Jz5cXHJcXG5cXHQ8c3Bhbj5cXHJcXG5cXHRcXHQ8Yj48JT0gKGNvbnRleHQueC5mbXQgfHwgY29udGV4dC54LnJhdykgJT48L2I+IC0gPCU9IG1vZGVsLmdldCgnYWRqdHlwZScpJT4gLSAgXFx0XFx0XFxyXFxuXFx0XFx0PHNwYW4gZGF0YS1pMThuPVxcXCI8JT0gYXBwLmdlbmVyYWxTZXR0aW5ncy5udW1iZXJEaXZpZGVyRGVzY3JpcHRpb24gJT5cXFwiPjwvc3Bhbj5cXHJcXG5cXHRcXHQ8JT0gbW9kZWwuZ2V0KCdjdXJyZW5jeScpICU+XFxyXFxuXFx0PC9zcGFuPlxcclxcbjwvZGl2PlxcclxcbjxkaXYgY2xhc3M9XFxcImNoYXJ0LXRvcHMtaW5mby1jb250YWluZXJcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNoYXJ0LXRvcHMtaW5mby1jb250ZW50XFxcIj5cXHJcXG5cXHRcXHQ8JSBpZihlcnJvcikgeyAlPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcclxcblxcdFxcdFxcdFxcdDxzdHJvbmc+PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmVycm9yXFxcIj5FcnJvcjwvc3Bhbj48L3N0cm9uZz5cXHJcXG5cXHRcXHRcXHRcXHQ8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZXJyb3ItZGV0YWlsXFxcIj5UaGUgQWlkIE1hbmFnZW1lbnQgUGxhdGZvcm0gaGFzIHRlbXBvcmFyaWx5IGVuY291bnRlcmVkIGFuIGlzc3VlLiBXZSBhcG9sb2dpemUgZm9yIGFueSBpbmNvbnZlbmllbmNlLjwvc3Bhbj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8JSB9IGVsc2UgaWYodmFsdWVzID09PSB1bmRlZmluZWQpIHsgJT5cXHJcXG5cXHRcXHRcXHQ8aW1nIGFsdD1cXFwiXFxcIiBzcmM9XFxcIi9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvYnVpbGQvaW1nL2xvYWRpbmctaWNvbi5naWZcXFwiPlxcclxcblxcdFxcdFxcdDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1yZW5kZXJpbmdcXFwiPlJlbmRlcmluZy4uLjwvc3Bhbj5cXHJcXG5cXHRcXHQ8JSB9IGVsc2UgeyAlPlxcclxcblxcdFxcdFxcdDwlIHZhciByb3dDbGFzcyA9ICcnOyAlPlxcclxcblxcdFxcdFxcdDx0YWJsZT5cXHJcXG5cXHRcXHRcXHRcXHQ8dHI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PHRoPjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLXRhYmxlLXByb2plY3R0aXRsZVxcXCI+UHJvamVjdCBUaXRsZTwvc3Bhbj48L3RoPlxcclxcblxcdFxcdFxcdFxcdFxcdDx0aD48c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy10YWJsZS1hbW91bnRcXFwiPkFtb3VudDwvc3Bhbj48L3RoPlxcclxcblxcdFxcdFxcdFxcdDwvdHI+XFx0XFx0XFx0XFxyXFxuXFx0XFx0XFx0PCUgXyh2YWx1ZXMpLmVhY2goZnVuY3Rpb24ocm93LCBpKSB7ICU+XFxyXFxuICAgICAgICAgIFxcdFxcdDwlIFxcdGlmIChpICUgMiA9PT0gMCkgcm93Q2xhc3MgPSAnb2RkX3Jvdyc7XFxyXFxuICAgIFxcdFxcdFxcdFxcdGVsc2Ugcm93Q2xhc3MgPSAnJzsgJT5cXHJcXG4gICAgXFx0XFx0XFx0PHRyIGNsYXNzPVxcXCI8JT1yb3dDbGFzcyU+XFxcIj5cXHJcXG4gICAgXFx0XFx0XFx0XFx0PHRkPlxcclxcbiAgICBcXHRcXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz0ncG9pbnRlcicgb25jbGljaz0nb3BlblByZXZpZXdBY3Rpdml0eSg8JT1yb3cuaWQlPiknPjwlPXJvdy5uYW1lJT48L3NwYW4+XFxyXFxuICAgIFxcdFxcdFxcdFxcdDwvdGQ+XFxyXFxuICAgIFxcdFxcdFxcdFxcdDx0ZD48JT1yb3cuZm9ybWF0dGVkQW1vdW50JT48L3RkPlxcclxcbiAgICBcXHRcXHRcXHQ8L3RyPlxcclxcbiAgICAgICAgXFx0PCUgfSkgJT5cXHJcXG4gICAgICAgIFxcdDwvdGFibGU+XFxyXFxuXFx0XFx0PCUgfSAlPlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdFx0dGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcclxuXHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcclxuXHRcdHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG5cdFx0dGhpcy5udW1iZXJEaXZpZGVyID0gYXBwLmdlbmVyYWxTZXR0aW5ncy5udW1iZXJEaXZpZGVyO1x0XHRcdFxyXG5cdH0sXHJcblxyXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLiRlbC5odG1sKHRlbXBsYXRlKHtcclxuXHRcdFx0ZXJyb3I6IHVuZGVmaW5lZCxcclxuXHRcdFx0bW9kZWw6IHRoaXMubW9kZWwsXHJcblx0XHRcdGNvbnRleHQ6IHRoaXMuY29udGV4dCxcclxuXHRcdFx0dmFsdWVzOiB1bmRlZmluZWQsXHJcblx0XHRcdG51bWJlckRpdmlkZXI6IHRoaXMubnVtYmVyRGl2aWRlclxyXG5cdFx0fSkpO1xyXG5cdFx0YXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoXCIuZGFzaC1zZXR0aW5ncy1tb2RhbFwiKSk7XHJcblx0XHRcclxuXHRcdC8vVE9ETzogbW92ZSB0aGlzIGNvZGUgdG8gYSBuZXcgbW9kZWwgc28gdGhlIEFQSSBjYWxsIGlzIG1hZGUgYXV0b21hdGljYWxseS5cclxuICAgIFx0dmFyIGNvbmZpZyA9IHRoaXMuYXBwLmZpbHRlci5zZXJpYWxpemUoKTtcclxuICAgIFx0Y29uZmlnLnNldHRpbmdzID0gdGhpcy5hcHAuc2V0dGluZ3NXaWRnZXQudG9BUElGb3JtYXQoKTtcclxuICAgIFx0Y29uZmlnLnNldHRpbmdzWydmdW5kaW5nLXR5cGUnXSA9IHRoaXMubW9kZWwuZ2V0KCdhZGp0eXBlJyk7XHJcbiAgICBcdCQuYWpheCh7XHJcbiAgICBcdFx0bWV0aG9kOiAnUE9TVCcsXHJcbiAgICBcdFx0dXJsOiBzZWxmLm1vZGVsLnVybCArICcvJyArIHRoaXMuY29udGV4dC5kYXRhWzBdLnZhbHVlc1t0aGlzLmNvbnRleHQueC5pbmRleF0uaWQsXHJcbiAgICBcdFx0ZGF0YVR5cGU6ICdqc29uJyxcclxuICAgIFx0XHRjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgXHRcdHByb2Nlc3NEYXRhOiBmYWxzZSxcclxuICAgIFx0XHRkYXRhOiBKU09OLnN0cmluZ2lmeShjb25maWcpXHJcbiAgICBcdH0pLmRvbmUoZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgXHRcdC8vVE9ETzogQ2FuIHdlIGF2b2lkIHJlLWNhbGxpbmcgdGhlIHRlbXBsYXRlIGJ5IGJpbmRpbmcgdGhlIGNoYW5nZXMgaW4gdGhlICd2YWx1ZXMnIGZpZWxkPyBcclxuICAgIFx0XHRzZWxmLiRlbC5odG1sKHRlbXBsYXRlKHtcclxuXHRcdFx0XHRlcnJvcjogdW5kZWZpbmVkLFxyXG4gICAgXHRcdFx0bW9kZWw6IHNlbGYubW9kZWwsXHJcbiAgICBcdFx0XHRjb250ZXh0OiBzZWxmLmNvbnRleHQsXHJcbiAgICBcdFx0XHR2YWx1ZXM6IGRhdGEudmFsdWVzLFxyXG4gICAgXHRcdFx0bnVtYmVyRGl2aWRlcjogc2VsZi5udW1iZXJEaXZpZGVyXHJcbiAgICBcdFx0fSkpO1xyXG4gICAgXHRcdGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKFwiLmRhc2gtc2V0dGluZ3MtbW9kYWxcIikpO1xyXG4gICAgXHR9KS5mYWlsKGZ1bmN0aW9uKHhociwgZXJyKSB7XHJcblx0XHRcdHZhciBtc2cgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpLmVycm9yO1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgR2V0dGluZyBjaGFydC10b3BzLWluZm8tbW9kYWwgZnJvbSBFUFwiLCBtc2cpO1xyXG5cdFx0XHRzZWxmLiRlbC5odG1sKHRlbXBsYXRlKHtcclxuXHRcdFx0XHRtb2RlbDogc2VsZi5tb2RlbCxcclxuXHRcdFx0XHRjb250ZXh0OiBzZWxmLmNvbnRleHQsXHJcblx0XHRcdFx0ZXJyb3I6IGVycixcclxuXHRcdFx0XHRudW1iZXJEaXZpZGVyOiBzZWxmLm51bWJlckRpdmlkZXJcclxuXHRcdFx0fSkpO1xyXG5cdFx0fSk7XHJcbiAgICBcdFxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcbn0pOyIsInZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG52YXIgQ2hhcnRWaWV3QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnQtdmlldy1iYXNlJyk7XG52YXIgTW9kYWxWaWV3ID0gcmVxdWlyZSgnLi9jaGFydC10b3BzLWluZm8tbW9kYWwnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0Vmlld0Jhc2UuZXh0ZW5kKHtcblxuICB1aURlZmF1bHRzOiB7XG4gICAgYWRqdHlwZTogJ0ZBS0UnLFxuICAgIHNob3dUb3RhbDogdHJ1ZSxcbiAgICBzaG93TWVhc3VyZXNTZWxlY3RvcjogdHJ1ZSxcbiAgICBzaG93VG9wTGVnZW5kczogdHJ1ZSxcbiAgICBzaG93Q29tbW9uQ2hhcnRBcmVhOiB0cnVlICAgIFxuICB9LFxuICBcbiAgY2hhcnRWaWV3czogW1xuXHQnYmFyJyxcbiAgICAncGllJyxcbiAgICAndGFibGUnICAgIFxuICBdLFxuICBcbiAgbW9kYWxWaWV3OiB1bmRlZmluZWQsXG4gIFxuICAvL0RvbnQgdHJ5IHRvIGNhbGwgaW5pdGlhbGl6ZSBoZXJlIGJlY2F1c2UgaXQgdGhyb3dzIGEgJ01vZHVsZSBpbml0aWFsaXphdGlvbiBlcnJvcicgOigoXG4gIC8qaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgIHRoaXMubW9kYWxWaWV3ID0gbmV3IE1vZGFsVmlldyh7IGFwcDogb3B0aW9ucy5hcHAsIGNvbGxlY3Rpb246IHRoaXMubW9kZWwuY29sbGVjdGlvbiB9KTtcbiAgfSwqL1xuXG4gIGRvd25sb2FkQ2hhcnRPcHRpb25zOiB7XG4gICAgdHJpbUxhYmVsczogZmFsc2VcbiAgfSxcblxuICBnZXRUVENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0dmFyIG9mVG90YWwgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpvZi10b3RhbFwiLFwib2YgdG90YWxcIik7XG5cdHZhciB1bml0cyA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoYXBwLmdlbmVyYWxTZXR0aW5ncy5udW1iZXJEaXZpZGVyRGVzY3JpcHRpb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVuY3lOYW1lID0gIGFwcC5zZXR0aW5nc1dpZGdldC5kZWZpbml0aW9ucy5maW5kQ3VycmVuY3lCeUlkKHNlbGYubW9kZWwuZ2V0KCdjdXJyZW5jeScpKS52YWx1ZTtcbiAgICB2YXIgcGVyY2VudGFnZSA9IGNvbnRleHQueS5yYXcgPiAwID9cbiAgICAgICAgZDMuZm9ybWF0KCclJykoY29udGV4dC55LnJhdyAvIHRoaXMubW9kZWwuZ2V0KCd0b3RhbFBvc2l0aXZlJykpICsgJzwvYj4mbmJzcDxzcGFuPicgKyBvZlRvdGFsOlxuICAgICAgICBcIlwiO1xuICAgIHJldHVybiB7dHQ6IHtcbiAgICAgIGhlYWRpbmc6IGNvbnRleHQueC5yYXcsXG4gICAgICBib2R5VGV4dDogJzxiPicgKyBjb250ZXh0LnkuZm10ICsgJzwvYj4gJyArIGN1cnJlbmN5TmFtZSArICcgKCcgKyB1bml0cyArICcpJyxcbiAgICAgIGZvb3RlclRleHQ6ICc8Yj4nICsgcGVyY2VudGFnZSArICc8L3NwYW4+J1xuICAgIH19O1xuICB9LFxuXG4gIGNoYXJ0Q2xpY2tIYW5kbGVyOiBmdW5jdGlvbihjb250ZXh0KSB7XHQgIFxuICAgIC8vIGNsaWNraW5nIG9uIHRoZSBcIm90aGVyc1wiIGJhciBsb2FkcyBmaXZlIG1vcmUuXG4gICAgaWYgKGNvbnRleHQuZGF0YVtjb250ZXh0LnNlcmllcy5pbmRleF1cbiAgICAgICAgICAgICAgIC52YWx1ZXNbY29udGV4dC54LmluZGV4XS5zcGVjaWFsID09PSAnb3RoZXJzJykge1xuICAgICAgdGhpcy5tb2RlbC5zZXQoJ2xpbWl0JywgdGhpcy5tb2RlbC5nZXQoJ2xpbWl0JykgKyA1KTsgICAgICBcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ2JpZycsIHRydWUpOyAgICAgIFxuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlbC5nZXQoJ3Nob3dDYXRlZ29yaWVzSW5mbycpID09PSB0cnVlKSB7ICAgIFx0XG4gICAgXHR0aGlzLm1vZGFsVmlldyA9IG5ldyBNb2RhbFZpZXcoeyBhcHA6IGFwcCwgY29udGV4dDogY29udGV4dCwgbW9kZWw6IHRoaXMubW9kZWwgfSk7XG4gICAgXHR0aGlzLm9wZW5JbmZvV2luZG93KCk7ICAgIFx0ICAgIFx0XG4gICAgfVxuICB9LFxuICBcbiAgb3BlbkluZm9XaW5kb3c6IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBzcGVjaWFsQ2xhc3MgPSAnZGFzaC1zZXR0aW5ncy1tb2RhbCc7XG5cdCAgdGhpcy5hcHAubW9kYWwoJ0NhdGVnb3J5IERldGFpbCcsIHtcblx0XHQgIHNwZWNpYWxDbGFzczogc3BlY2lhbENsYXNzLFxuXHQgICAgICBib2R5RWw6IHRoaXMubW9kYWxWaWV3LnJlbmRlcigpLmVsLFxuXHQgICAgICBpMThuVGl0bGU6ICdhbXAuZGFzaGJvYXJkOmRhc2hib2FyZC1jaGFydC10b3BzLWluZm8tbW9kYWwnXG5cdCAgfSk7XHQgICAgXG5cdCAgLy8gVHJhbnNsYXRlIG1vZGFsIHBvcHVwLlxuXHQgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKFwiLlwiICsgc3BlY2lhbENsYXNzKSk7XG4gIH1cblxufSk7XG4iLCJcbnZhciBEZWZlcnJlZCA9IHJlcXVpcmUoJ2pxdWVyeScpLkRlZmVycmVkO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIGdldENoYXJ0ID0gcmVxdWlyZSgnLi4vY2hhcnRzL2NoYXJ0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIERvd25sb2FkVmlldyA9IHJlcXVpcmUoJy4vZG93bmxvYWQnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTIgPCUgaWYgKCFtb2RlbC5nZXQoJ2JpZycpKSB7ICU+Y29sLW1kLTY8JSB9IGVsc2UgeyAlPiBiaWctY2hhcnQtPCU9IG1vZGVsLmdldCgnYmlnTicpJT4gPCUgfSAlPlxcXCI+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbCBwYW5lbC1jaGFydFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmcgZml4LXRpdGxlLWhlaWdodFxcXCI+XFxuICAgICAgPCUgaWYgKG1vZGVsLmdldCgnc2hvd1RvdGFsJykgPT09IHRydWUpIHsgJT5cXG5cXHQgICAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0IGJpZy1udW1iZXJcXFwiPlxcblxcdCAgICAgICAgPGIgY2xhc3M9XFxcImNoYXJ0LXRvdGFsXFxcIj48L2I+XFxuXFx0ICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY2hhcnQtY3VycmVuY3lcXFwiPjwvc3Bhbj5cXG5cXHQgICAgICA8L2Rpdj5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY2hhcnQtdGl0bGVcXFwiPlxcblxcdCAgICAgIDxoMiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtPCU9IG1vZGVsLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywnJykgJT5cXFwiPjwlPSBtb2RlbC5nZXQoJ3RpdGxlJykgJT48L2gyPlxcblxcdCAgICAgIDwlIGlmIChtb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHsgJT5cXG5cXHQgICAgICBcXHQ8JSB2YXIgaGVscF9pY29uX3RleHQgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtaGVscC10ZXh0LScgKyBtb2RlbC5nZXQoJ2hlYXRtYXBfdHlwZScpKTslPlxcblxcdCAgICAgIFxcdDxpbWcgc3JjPVxcXCIvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2J1aWxkL2ltZy9xdWVzdGlvbm1hcmsxLnBuZ1xcXCIgY2xhc3M9XFxcInF1ZXN0aW9uX21hcmsgbnYtc2VyaWVzXFxcIiBkYXRhLXRpdGxlPVxcXCI8JT0gaGVscF9pY29uX3RleHQgJT5cXFwiPlxcblxcdCAgICAgIDwlIH0gJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFx0XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNoYXJ0LWNvbnRhaW5lclxcXCI+XFxuICAgICAgICA8aDMgY2xhc3M9XFxcImRhc2gtY2hhcnQtZGlhZ25vc3RpYyB0ZXh0LWNlbnRlclxcXCI+PC9oMz5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRhc2gtY2hhcnQtd3JhcCA8JT0gKG1vZGVsLmdldCgnYWx0ZXJuYXRpdmVDb250YWluZXJDbGFzcycpICE9PSB1bmRlZmluZWQgPyBtb2RlbC5nZXQoJ2FsdGVybmF0aXZlQ29udGFpbmVyQ2xhc3MnKSA6ICcnKSU+XFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmsgYnRuLXhzIHB1bGwtcmlnaHQgcmVzZXRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1yZXNldFxcXCI+cmVzZXQgb3RoZXJzPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtd2FybmluZyBuZWdhdGl2ZS12YWx1ZXMtbWVzc2FnZVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcbiAgICAgICAgICA8c3Ryb25nIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpuZWdhdGl2ZXMtdmFsdWVzXFxcIj5OZWdhdGl2ZSB2YWx1ZXMgYXJlIG5vdCByZXByZXNlbnRlZCBpbiB0aGlzIGNoYXJ0Ljwvc3Ryb25nPjxicj5cXG4gICAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOm5lZ2F0aXZlcy12YWx1ZXMtcGFyYWdcXFwiPlBsZWFzZSBzd2l0Y2ggdG8gYmFyIGNoYXJ0IG9yIHRhYmxlIHZpZXcgdG8gdmlldyBhbGwgdmFsdWVzLjwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWZvb3RlciBjbGVhcmZpeFxcXCI+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8JSBfKHZpZXdzKS5lYWNoKGZ1bmN0aW9uKHZpZXcpIHsgJT5cXG4gICAgICAgICAgICA8YnV0dG9uIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b29sdGlwLTwlPSB2aWV3ICU+LWNoYXJ0W3RpdGxlXVxcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIHRpdGxlPVxcXCJWaWV3IGRhdGEgaW4gPCU9IHZpZXcgJT4gY2hhcnRcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgZGF0YS12aWV3PVxcXCI8JT0gdmlldyAlPlxcXCJcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImNoYXJ0LXZpZXcgYnRuIGJ0bi1zbSBidG4tPCU9ICh2aWV3ID09PSBtb2RlbC5nZXQoJ3ZpZXcnKSkgPyAncHJpbWFyeScgOiAnZGVmYXVsdCcgJT5cXFwiPlxcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tPCU9IHtcXG4gICAgICAgICAgICAgICAgYmFyOiAnc2lnbmFsJyxcXG4gICAgICAgICAgICAgICAgbXVsdGliYXI6ICdzaWduYWwnLFxcbiAgICAgICAgICAgICAgICBoZWF0bWFwOiAnc3RhdHMnLFxcbiAgICAgICAgICAgICAgICBwaWU6ICdhZGp1c3QnLFxcbiAgICAgICAgICAgICAgICB0YWJsZTogJ3RoLWxpc3QnXFxuICAgICAgICAgICAgICB9W3ZpZXddICU+XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDwlIH0pICU+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cFxcXCI+XFxuICAgICAgICAgIDxhIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b29sdGlwLWRvd25sb2FkLWNoYXJ0W3RpdGxlXVxcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIHRpdGxlPVxcXCJEb3dubG9hZCBpbWFnZSBvciB0YWJsZVxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBkb3dubG9hZFxcXCJcXG4gICAgICAgICAgICBkb3dubG9hZD1cXFwiQU1QIDwlPSBtb2RlbC5nZXQoJ3RpdGxlJykgJT4gLSA8JT0gKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSAlPi5wbmdcXFwiXFxuICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNsb3VkLWRvd25sb2FkXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgPGJ1dHRvbiBkYXRhLWkxOG49XFxcIjwlPSBtb2RlbC5nZXQoJ2JpZycpID8gJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9vbHRpcC1jb2xsYXBzZS1jaGFydFt0aXRsZV0nIDogJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9vbHRpcC1leHBhbmQtY2hhcnRbdGl0bGVdJyAlPlxcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIHRpdGxlPVxcXCI8JT0gbW9kZWwuZ2V0KCdiaWcnKSA/ICdDb2xsYXBzZSBjaGFydCcgOiAnRXhwYW5kIGNoYXJ0JyAlPlxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tPCU9IG1vZGVsLmdldCgnYmlnJykgPyAncHJpbWFyeScgOiAnZGVmYXVsdCcgJT4gZXhwYW5kIGhpZGRlbi14cyBoaWRkZW4tc21cXFwiIDwlPSBtb2RlbC5nZXQoJ2Rpc2FibGVSZXNpemUnKSA/ICdkaXNhYmxlZCcgOiAnJyU+PlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWZ1bGxzY3JlZW5cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICA8L2Rpdj48IS0tIGJ1dHRvbnMgaW4gLnB1bGwtcmlnaHQgLS0+XFxuXFxuICAgICAgPCUgaWYgKG1vZGVsLmdldCgnYWRqdHlwZScpICYmIG1vZGVsLmdldCgnc2hvd01lYXN1cmVzU2VsZWN0b3InKSA9PT0gdHJ1ZSkgeyAlPlxcbiAgICAgICAgPGZvcm0gY2xhc3M9XFxcImZvcm0taW5saW5lIGRhc2gtZm9ybSBkYXNoLWFkai10eXBlXFxcIiByb2xlPVxcXCJmb3JtXFxcIj5cXG4gICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGxpa2UtYnRuLXNtIGZ0eXBlLW9wdGlvbnNcXFwiPlxcbiAgICAgICAgICAgIDxvcHRpb24+Li4uPC9vcHRpb24+XFxuICAgICAgICAgICAgPCEtLSBnZXRzIHBvcHVsYXRlZCBhZnRlciBzZXR0aW5ncyBsb2FkIC0tPlxcbiAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImNoZWF0LWxpbmVoZWlnaHRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvZm9ybT5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgXFxuICAgICAgPCUgaWYgKG1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykgeyAlPlxcblxcdFxcdDxmb3JtIGNsYXNzPVxcXCJmb3JtLWlubGluZSBkYXNoLWZvcm0gZGFzaC14YXhpcy1vcHRpb25zXFxcIiByb2xlPVxcXCJmb3JtXFxcIj5cXG4gICAgICAgIFxcdDxzZWxlY3QgY2xhc3M9XFxcImZvcm0tY29udHJvbCBsaWtlLWJ0bi1zbSB4YXhpcy1vcHRpb25zXFxcIj5cXG4gICAgICAgICAgICBcXHQ8b3B0aW9uPi4uLjwvb3B0aW9uPlxcbiAgICAgICAgICAgIFxcdDwhLS0gZ2V0cyBwb3B1bGF0ZWQgYWZ0ZXIgc2V0dGluZ3MgbG9hZCAtLT5cXG4gICAgICAgICAgXFx0PC9zZWxlY3Q+XFxuICAgICAgICAgIFxcdDxzcGFuIGNsYXNzPVxcXCJjaGVhdC1saW5laGVpZ2h0XFxcIj48L3NwYW4+XFxuICAgICAgICA8L2Zvcm0+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRlZmF1bHQgaGVhdG1hcC1zd2l0Y2hcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1zd2FwLWF4ZXNcXFwiPlN3YXAgQXhlczwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcblxcdCA8JSB9ICU+XFxuXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJleHBvcnQtbW9kYWxcXFwiPjwvZGl2PlxcbjwvZGl2PlwiKTtcblxuXG52YXIgYWRqT3B0VGVtcGxhdGUgPSBfLnRlbXBsYXRlKCc8b3B0aW9uIHZhbHVlPVwiPCU9b3B0LmlkJT5cIiAnICtcbiAgJzwlPSBjdXJyZW50ID8gc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiIDogXFwnXFwnICU+PjwlPW9wdC5uYW1lJT48L29wdGlvbj4nKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgdWlEZWZhdWx0czoge1xuICAgIGJpZzogZmFsc2UsXG4gICAgdmlldzogJ2JhcidcbiAgfSxcblxuICBldmVudHM6IHtcbiAgICAnY2hhbmdlIC5kYXNoLWFkai10eXBlIHNlbGVjdCc6ICdjaGFuZ2VBZGpUeXBlJyxcbiAgICAnY2hhbmdlIC5kYXNoLXhheGlzLW9wdGlvbnMgc2VsZWN0JzogJ2NoYW5nZVhBeGlzJyxcbiAgICAnY2xpY2sgLnJlc2V0JzogJ3Jlc2V0TGltaXQnLFxuICAgICdjbGljayAuY2hhcnQtdmlldyc6ICdjaGFuZ2VDaGFydFZpZXcnLFxuICAgICdjbGljayAuZG93bmxvYWQnOiAnZG93bmxvYWQnLFxuICAgICdjbGljayAuZXhwYW5kJzogJ2JpZycsXG4gICAgJ2NsaWNrIC5yZXRyeSc6ICdyZW5kZXInLFxuICAgICdjbGljayAuaGVhdG1hcC1zd2l0Y2gnOiAnaGVhdG1hcFN3aXRjaEF4aXMnXG4gIH0sXG5cbiAgY2hhcnRWaWV3czogW1xuICAgICdiYXInLFxuICAgICdwaWUnLFxuICAgICdoZWF0bWFwJyxcbiAgICAndGFibGUnICAgIFxuICBdLCAgXG4gIFxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLm1vZGVsLnNldCh0aGlzLnVpRGVmYXVsdHMpO1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZVdhaXQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuICAgIHRoaXMuc2hvd0NoYXJ0UHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHRoaXMucmVuZGVyZWRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICBpZiAodGhpcy5hcHAuc2F2ZWREYXNoZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhIGJpdCBza2V0Y2guLi4uXG4gICAgXHQgIHRoaXMuYXBwLnN0YXRlLmxvYWRQcm9taXNlLmFsd2F5cyh0aGlzLl9zdGF0ZVdhaXQucmVzb2x2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdGVXYWl0LnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuYXBwLmZpbHRlciwgJ2FwcGx5JywgdGhpcy51cGRhdGVEYXRhKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuYXBwLnNldHRpbmdzV2lkZ2V0LCAnYXBwbHlTZXR0aW5ncycsIHRoaXMudXBkYXRlRGF0YSk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOmFkanR5cGUnLCB0aGlzLnJlbmRlcik7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnhBeGlzQ29sdW1uJywgdGhpcy5yZW5kZXIpO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTpsaW1pdCcsIHRoaXMudXBkYXRlRGF0YSk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnZpZXcnLCB0aGlzLnJlbmRlcik7XG5cbiAgICB0aGlzLmFwcC5zdGF0ZS5yZWdpc3Rlcih0aGlzLCAnY2hhcnQ6JyArIHRoaXMubW9kZWwudXJsLCB7XG4gICAgICBnZXQ6IF8ucGFydGlhbChfKHRoaXMubW9kZWwucGljaykuYmluZCh0aGlzLm1vZGVsKSwgJ2xpbWl0JywgJ2FkanR5cGUnLCAneEF4aXNDb2x1bW4nLCAndmlldycsICdiaWcnLCdzdGFja2VkJywnc2hvd1BsYW5uZWREaXNidXJzZW1lbnRzJywnc2hvd0FjdHVhbERpc2J1cnNlbWVudHMnLCdzZXJpZXNUb0V4Y2x1ZGUnLCAneExpbWl0JywgJ3lMaW1pdCcsICdzd2FwQXhlcycpLFxuICAgICAgc2V0OiBfKHRoaXMubW9kZWwuc2V0KS5iaW5kKHRoaXMubW9kZWwpLFxuICAgICAgZW1wdHk6IG51bGxcbiAgICB9KTtcblxuICAgIF8uYmluZEFsbCh0aGlzLCAnc2hvd0NoYXJ0JywgJ2ZhaWxMb2FkaW5nJywnaGlkZUV4cG9ydEluUHVibGljVmlldycsJ2V4dHJhY3ROdW1iZXJGb3JtYXRTZXR0aW5ncycpO1xuICAgIGlmICh0aGlzLmdldFRUQ29udGVudCkgeyBfLmJpbmRBbGwodGhpcywgJ2dldFRUQ29udGVudCcpOyB9XG4gICAgaWYgKHRoaXMuY2hhcnRDbGlja0hhbmRsZXIpIHsgXy5iaW5kQWxsKHRoaXMsICdjaGFydENsaWNrSGFuZGxlcicpOyB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLnJlbmRlcmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHZhciByZW5kZXJPcHRpb25zID0ge1xuICAgICAgdmlld3M6IHRoaXMuY2hhcnRWaWV3cyxcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnRFbCxcbiAgICAgIHV0aWw6IHV0aWxcbiAgICB9O1xuICAgIC8vIFdlIG5lZWQgdG8gYmUgc3VyZSBhbGwgZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiBsb2FkZWQgYmVmb3JlIHByb2Nlc3NpbmcgZWFjaCBjaGFydCAoc3BlY2lhbGx5IHRoZSB0ZW1wbGF0ZXMpLlxuICAgICQud2hlbih0aGlzLl9zdGF0ZVdhaXQsIHRoaXMuYXBwLmZpbHRlci5sb2FkZWQsIHRoaXMuYXBwLnRyYW5zbGF0b3IucHJvbWlzZSwgdGhpcy5hcHAuc2V0dGluZ3NXaWRnZXQuZGVmaW5pdGlvbnMubG9hZGVkLCB0aGlzLmFwcC5nZW5lcmFsU2V0dGluZ3MubG9hZGVkKS5kb25lKGZ1bmN0aW9uKCkge1xuICAgIFx0XG4gICAgXHRzZWxmLmV4dHJhY3ROdW1iZXJGb3JtYXRTZXR0aW5ncygpO1xuICAgIFx0c2VsZi4kZWwuaHRtbCh0ZW1wbGF0ZShyZW5kZXJPcHRpb25zKSk7XG4gICAgXHRzZWxmLmhpZGVFeHBvcnRJblB1YmxpY1ZpZXcoKTtcbiAgICBcdHNlbGYubWVzc2FnZSA9IHNlbGYuJCgnLmRhc2gtY2hhcnQtZGlhZ25vc3RpYycpO1xuICAgIFx0c2VsZi5jaGFydENvbnRhaW5lciA9IHNlbGYuJCgnLmRhc2gtY2hhcnQtd3JhcCcpO1xuXHRcblx0ICAgIGlmIChzZWxmLm1vZGVsLmdldCgnYWRqdHlwZScpICE9PSB2b2lkIDApIHsgIC8vIHRoaXMgY2hhcnQgaGFzIGFkaiBzZXR0aW5nc1xuXHQgICAgXHRzZWxmLnJlbmRlcmVkID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgYWRqU2V0dGluZ3MgPSBzZWxmLmFwcC5zZXR0aW5nc1dpZGdldC5kZWZpbml0aW9ucy5nZXRGdW5kaW5nVHlwZVNldHRpbmcoKTsgXHQgICAgICAgIFx0XG5cdCAgICAgICAgaWYgKCFhZGpTZXR0aW5ncykgeyBcblx0ICAgICAgICBcdHNlbGYuYXBwLnJlcG9ydCgnQ291bGQgbm90IGZpbmQgRnVuZGluZyBUeXBlIHNldHRpbmdzJyk7IFxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgXHRpZiAoc2VsZi5tb2RlbC5nZXQoJ2FkanR5cGUnKSA9PT0gJ0ZBS0UnKSB7XG5cdCAgICAgICAgXHRcdHNlbGYubW9kZWwuc2V0KCdhZGp0eXBlJywgYWRqU2V0dGluZ3MuZ2V0KCd2YWx1ZScpLmRlZmF1bHRJZCk7XG5cdCAgICAgICAgXHR9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNlbGYuJCgnLmZ0eXBlLW9wdGlvbnMnKS5odG1sKFxuXHQgICAgICAgICAgXyhhZGpTZXR0aW5ncy5nZXQoJ3ZhbHVlJykub3B0aW9ucykubWFwKGZ1bmN0aW9uKG9wdCkge1xuXHQgICAgICAgICAgICByZXR1cm4gYWRqT3B0VGVtcGxhdGUoe1xuXHQgICAgICAgICAgICAgIG9wdDogb3B0LFxuXHQgICAgICAgICAgICAgIGN1cnJlbnQ6IChvcHQuaWQgPT09IHNlbGYubW9kZWwuZ2V0KCdhZGp0eXBlJykpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfSwgc2VsZilcblx0ICAgICAgICApO1xuXHQgICAgICBcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdHNlbGYucmVuZGVyZWQgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgXG5cdCAgICAvLyBGb3IgaGVhdG1hcHMgYWRkIHNvbWUgZXh0cmEgY29tYm9zLlxuXHQgICAgaWYgKHNlbGYubW9kZWwuZ2V0KCdjaGFydFR5cGUnKSA9PT0gJ2ZyYWdtZW50YXRpb24nKSB7XG5cdCAgICBcdHZhciBoZWF0TWFwQ29uZmlncyA9IHNlbGYubW9kZWwuZ2V0KCdoZWF0bWFwX2NvbmZpZycpLm1vZGVsc1swXTtcblx0ICAgIFx0dmFyIHRoaXNIZWF0TWFwQ2hhcnQgPSBfLmZpbmQoaGVhdE1hcENvbmZpZ3MuZ2V0KCdjaGFydHMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLm5hbWUgPT09IHNlbGYubW9kZWwuZ2V0KCduYW1lJyl9KTtcblx0ICAgIFx0c2VsZi4kKCcueGF4aXMtb3B0aW9ucycpLmh0bWwoXG5cdCAgICBcdFx0Xyh0aGlzSGVhdE1hcENoYXJ0LnhDb2x1bW5zKS5tYXAoZnVuY3Rpb24oY29sSWQpIHtcblx0ICAgIFx0XHRcdHZhciBpdGVtID0gXy5maW5kKGhlYXRNYXBDb25maWdzLmdldCgnY29sdW1ucycpLCBmdW5jdGlvbihpdGVtLCBpKSB7IHJldHVybiBpID09PSBjb2xJZH0pO1xuXHQgICAgXHRcdFx0dmFyIG9wdCA9IHtpZDogaXRlbS5vcmlnTmFtZSwgbmFtZTogaXRlbS5uYW1lLCBzZWxlY3RlZDogZmFsc2UsIHZhbHVlOiBpdGVtLm9yaWdOYW1lfTtcblx0ICAgIFx0XHRcdHJldHVybiBhZGpPcHRUZW1wbGF0ZSh7XG5cdCAgICBcdFx0XHRcdG9wdDogb3B0LFxuXHQgICAgXHQgICAgICAgICAgICBjdXJyZW50OiAob3B0LmlkID09PSBzZWxmLm1vZGVsLmdldCgneEF4aXNDb2x1bW4nKSlcblx0ICAgIFx0ICAgICAgICB9KTtcblx0ICAgIFx0ICAgIH0sIHNlbGYpXG5cdCAgICBcdCk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHNlbGYuX3N0YXRlV2FpdC5zdGF0ZSgpICE9PSAncGVuZGluZycpIHtcblx0ICAgIFx0c2VsZi51cGRhdGVEYXRhKCk7XG5cdCAgICB9XG5cblx0ICAgIHNlbGYuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKHNlbGYuJGVsKTtcbiAgICAgICAgc2VsZi4kZWwuZmluZCgnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXScpLnRvb2x0aXAoKTtcblx0ICAgIHNlbGYucmVuZGVyZWRQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB1cGRhdGVEYXRhOiBmdW5jdGlvbigpIHtcblx0aWYodGhpcy5hcHAucmVuZGVyZWQgIT09IHRydWUpIHsgcmV0dXJuOyB9ICBcbiAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHsgcmV0dXJuOyB9ICAvLyBzaG9ydC1jaXJjdWl0IG9uIGVhcmx5IGZpbHRlcnMgYXBwbHkgZXZlbnRcbiAgICBpZiAodGhpcy5fc3RhdGVXYWl0LnN0YXRlKCkgPT09ICdwZW5kaW5nJykgeyAgLy8gc2hvcnQtY2lyY3VpdCB1bnRpbCB3ZSBoYXZlIHN0YXRlXG4gICAgICB0aGlzLm1lc3NhZ2UuaHRtbCgnTG9hZGluZy4uLicpLmF0dHIoJ2RhdGEtaTE4bicsICdhbXAuZGFzaGJvYXJkOmNoYXJ0LWxvYWRpbmctc2F2ZWQtc2V0dGluZ3MnKTtcbiAgICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKCcuY2hhcnQtY29udGFpbmVyJykpO1xuICAgICAgLy90aGlzLm1lc3NhZ2UuZmFkZUluKDEwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zaG93Q2hhcnRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7IC8vIFdlIG5lZWQgdG8gcmVpbml0aWFsaXplIHRoaXMgcHJvbWlzZS5cbiAgICB0aGlzLmNoYXJ0Q29udGFpbmVyLmVtcHR5KCk7XG4gICAgdGhpcy5tZXNzYWdlLmh0bWwoJzxzcGFuIGRhdGEtaTE4bj1cImFtcC5kYXNoYm9hcmQ6bG9hZGluZ1wiPkxvYWRpbmcuLi48L3NwYW4+JykuZmFkZUluKDEwMCk7XG5cbiAgICB0aGlzLmFwcC50cmFuc2xhdG9yLmdldFRyYW5zbGF0aW9ucygpXG4gICAgICAuZG9uZShfKGZ1bmN0aW9uKCkgeyAgLy8gZGVmZXIgaGVyZSB0byBwcmV2ZW50IGEgcmFjZSB3aXRoIHRyYW5zbGF0aW9ucyBsb2FkaW5nXG5cbiAgICBcdGlmICh0aGlzLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuICAgIFx0XHQvLyBXZSBuZWVkIHRoaXMgZm9yIEFNUC0yNTU5OS5cbiAgICBcdFx0dGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00odGhpcy5lbCk7XG4gICAgXHR9XG5cbiAgICAgICAgdGhpcy5tb2RlbC5mZXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1BPU1QnLCAgLy8gVE9ETzogbW92ZSBmZXRjaCBvcHRpb25zIHRvIG1vZGVsP1xuICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHRoaXMuYXBwLmZpbHRlci5zZXJpYWxpemUoKSlcbiAgICAgICAgfSlcbiAgICAgICAgLmFsd2F5cyhfKGZ1bmN0aW9uKCkgeyAgfSkuYmluZCh0aGlzKSlcbiAgICAgICAgLmRvbmUodGhpcy5zaG93Q2hhcnQpXG4gICAgICAgIC5mYWlsKHRoaXMuZmFpbExvYWRpbmcpO1xuICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYXBwLnJlcG9ydCgnQ291bGQgbm90IGxvYWQgdHJhbnNsYXRpb25zJywgW1xuICAgICAgICAgICdSZWZyZXNoaW5nIHRoZSBwYWdlIG1heSBmaXggdGhlIGlzc3VlLiddKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gIH0sXG5cbiAgc2hvd0NoYXJ0OiBmdW5jdGlvbigpIHtcblx0ICB0aGlzLnNob3dOZWdhdGl2ZUFsZXJ0KCk7XG5cdCAgXG4gICAgLy8gVE9ETzogd2h5IGFyZSB3ZSB0cmlnZ2VyaW5nIHR3aWNlIG9uIGxvYWQ/Pz9cbiAgICBpZiAoIXRoaXMubW9kZWwuaGFzRGF0YSgpKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UuaHRtbCgnTm8gRGF0YSBBdmFpbGFibGUnKS5hdHRyKCdkYXRhLWkxOG4nLCdhbXAuZGFzaGJvYXJkOmNoYXJ0LW5vLWRhdGEtYXZhaWxhYmxlJyk7XG4gICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oJCgnLmNoYXJ0LWNvbnRhaW5lcicpKTtcbiAgICAgIHRoaXMucmVzZXROdW1iZXJzKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAgICBcbiAgICB2YXIgY2hhcnQgPSBnZXRDaGFydCh0aGlzLm1vZGVsLmdldCgndmlldycpLCB0aGlzLm1vZGVsLmdldCgncHJvY2Vzc2VkJyksIHRoaXMuZ2V0Q2hhcnRPcHRpb25zKCksIHRoaXMubW9kZWwpO1xuICAgIHRoaXMuY2hhcnRDb250YWluZXIuaHRtbChjaGFydC5lbCk7XG5cbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpICE9PSAnZnJhZ21lbnRhdGlvbicpIHtcbiAgICBcdHRoaXMucmVuZGVyTnVtYmVycygpO1xuICAgIFx0dGhpcy5maXhUaXRsZVdpZHRoKCk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgIT09ICdmcmFnbWVudGF0aW9uJykge1xuXHQgICAgdmFyIGxpbWl0ID0gdGhpcy5tb2RlbC5nZXQoJ2xpbWl0Jyk7XG5cdCAgICBpZiAobGltaXQpIHtcblx0ICAgICAgdGhpcy4kKCcucmVzZXQnKVtsaW1pdCA9PT0gdGhpcy5tb2RlbC5kZWZhdWx0cy5saW1pdCA/ICdoaWRlJyA6ICdzaG93J10oKTtcblx0ICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Nob3dSZXNldEJ1dHRvbicpKSB7XG4gICAgICAgIFx0dGhpcy4kKCcucmVzZXQnKS5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIFx0dGhpcy4kKCcucmVzZXQnKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlLnN0b3AoKS5mYWRlT3V0KDIwMCk7XG4gICAgXG4gICAgdGhpcy5iZWF1dGlmeUxlZ2VuZHModGhpcyk7XG4gICAgXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCd2aWV3JykgPT09ICdoZWF0bWFwJykge1xuICAgIFx0dGhpcy5oYW5kbGVIZWF0bWFwQ2xpY2tzKCk7XG4gICAgfVxuICAgICAgICBcbiAgICB0aGlzLnNob3dDaGFydFByb21pc2UucmVzb2x2ZSgpO1xuICB9LFxuICBcbiAgaGFuZGxlSGVhdG1hcENsaWNrczogZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciBvdGhlcnMgPSB0aGlzLiQoXCIubGVnZW5kLW90aGVyc1wiKTtcblx0ICBpZiAob3RoZXJzKSB7XG5cdFx0ICAkKG90aGVycykub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHQgIHNlbGYubW9kZWwuc2V0KCd5TGltaXQnLCBzZWxmLm1vZGVsLmdldCgneUxpbWl0JykgKyBzZWxmLm1vZGVsLmdldCgnb3JpZ2luYWxZTGltaXQnKSk7XG5cdFx0XHQgIHNlbGYudXBkYXRlRGF0YSgpO1xuXHRcdCAgfSk7XG5cdCAgfVxuICB9LFxuICBcbiAgc2hvd05lZ2F0aXZlQWxlcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMubW9kZWwuZ2V0KCd2aWV3JykgPT09ICdwaWUnICYmIF8uZmluZCh0aGlzLm1vZGVsLmdldCgncHJvY2Vzc2VkJylbMF0udmFsdWVzLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLnkgPCAwO30pKSB7XG4gICAgICB0aGlzLiQoJy5uZWdhdGl2ZS12YWx1ZXMtbWVzc2FnZScpLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kKCcubmVnYXRpdmUtdmFsdWVzLW1lc3NhZ2UnKS5oaWRlKCk7XG4gICAgfVxuICB9LFxuXG4gIGdldENoYXJ0T3B0aW9uczogZnVuY3Rpb24oKSB7XHQgIFxuICAgIHZhciBjbyA9IF8oXyh0aGlzLmNoYXJ0T3B0aW9ucykuY2xvbmUoKSB8fCB7fSkuZGVmYXVsdHMoe1xuICAgICAgdHJpbUxhYmVsczogIXRoaXMubW9kZWwuZ2V0KCdiaWcnKSxcbiAgICAgIGdldFRUQ29udGVudDogdGhpcy5nZXRUVENvbnRlbnQsXG4gICAgICBjbGlja0hhbmRsZXI6IHRoaXMuY2hhcnRDbGlja0hhbmRsZXIsXG4gICAgICB3aWR0aDogdGhpcy4kKCcucGFuZWwtYm9keScpLndpZHRoKCksXG4gICAgICBoZWlnaHQ6IHRoaXMuJCgnLnBhbmVsLWJvZHknKS5oZWlnaHQoKVxuICAgICAgXG4gICAgfSk7XG4gICAgaWYodGhpcy5tb2RlbC5nZXQoJ3ZpZXcnKSA9PSAnbXVsdGliYXInKXtcbiAgXHQgIGNvLnN0YWNrZWQgPSB0aGlzLm1vZGVsLmdldCgnc3RhY2tlZCcpO1xuICBcdH1cbiAgICBjby5tb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgcmV0dXJuIGNvO1xuICB9LFxuXG4gIGZhaWxMb2FkaW5nOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lc3NhZ2UuaHRtbCgnRmFpbGVkIHRvIGxvYWQgZGF0YSA8c21hbGw+JyArIGFyZ3VtZW50c1syXSArXG4gICAgICAnIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicmV0cnkgYnRuIGJ0bi13YXJuaW5nIGJ0bi1zbVwiPicgK1xuICAgICAgJzxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZWZyZXNoXCI+PC9zcGFuPiBSZXRyeTwvYnV0dG9uPjwvc21hbGw+Jykuc2hvdygpO1xuICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCBsb2FkaW5nIGNoYXJ0IDooJywgYXJndW1lbnRzKTtcbiAgfSxcblxuICByZW5kZXJOdW1iZXJzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3RvdGFsJykpIHtcbiAgICBcdHRoaXMuJCgnLmNoYXJ0LXRvdGFsJykuaHRtbCh1dGlsLnRyYW5zbGF0ZUxhbmd1YWdlKHRoaXMubW9kZWwuZ2V0KCdzdW1hcml6ZWRUb3RhbCcpKSk7IC8vIHRoaXMgc2hhbGwgdXNlIHRoZSBmb3JtYXQgZnJvbSB0aGUgc2VydmVyIGFuZCB0cmFuc2xhdGUgaXQgaW4gdGhlIGZyb250IGVuZFxuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICB2YXIgY3VycmVuY3lOYW1lID0gYXBwLnNldHRpbmdzV2lkZ2V0LmRlZmluaXRpb25zLmZpbmRDdXJyZW5jeUJ5SWQoc2VsZi5tb2RlbC5nZXQoJ2N1cnJlbmN5JykpLnZhbHVlOyAgICBcdFxuICAgIHRoaXMuJCgnLmNoYXJ0LWN1cnJlbmN5JykuaHRtbChjdXJyZW5jeU5hbWUpO1xuICB9LFxuXG4gIHJlc2V0TnVtYmVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kKCcuY2hhcnQtdG90YWwnKS5odG1sKCcnKTtcbiAgICB0aGlzLiQoJy5jaGFydC1jdXJyZW5jeScpLmh0bWwoJycpO1xuICB9LFxuICBcbiAgZml4VGl0bGVXaWR0aDogZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGVsZW1lbnRzU3BhY2UgPSAxMDtcblx0ICB2YXIgbWF4X2xpbmVzX29uX3RpdGxlID0gMjtcblx0ICB2YXIgY2hhcnNUb1JlbW92ZSA9IDU7XG5cdCAgdmFyIHRpdGxlID0gdGhpcy4kKFwiLmNoYXJ0LXRpdGxlIGgyXCIpO1xuXHQgIHZhciB0aXRsZVdpZHRoID0gJCh0aXRsZSkud2lkdGgoKTtcblx0ICB2YXIgY29udGFpbmVyV2lkdGggPSB0aGlzLiQoXCIucGFuZWwtaGVhZGluZ1wiKS53aWR0aCgpO1xuXHQgIHZhciBhbW91bnRXaWR0aCA9IHRoaXMuJChcIi5iaWctbnVtYmVyXCIpLndpZHRoKCk7XG5cdCAgaWYgKGNvbnRhaW5lcldpZHRoIDwgdGl0bGVXaWR0aCArIGFtb3VudFdpZHRoKSB7XG5cdFx0ICAkKHRpdGxlKS5jc3MoJ3dpZHRoJywgKGNvbnRhaW5lcldpZHRoIC0gYW1vdW50V2lkdGggLSBlbGVtZW50c1NwYWNlKSArICdweCcpO1xuXHRcdCAgd2hpbGUgKHRoaXMuY2FsY3VsYXRlVGV4dExpbmVzKHRpdGxlKSA+IG1heF9saW5lc19vbl90aXRsZSkge1xuXHRcdFx0ICAkKHRpdGxlKS5odG1sKCQodGl0bGUpLmh0bWwoKS5zdWJzdHJpbmcoMCwgJCh0aXRsZSkuaHRtbCgpLmxlbmd0aCAtIGNoYXJzVG9SZW1vdmUpICsgJy4uLicpO1xuXHRcdFx0ICAkKHRpdGxlKS5hdHRyKCdkYXRhLXRpdGxlJywgdGhpcy5tb2RlbC5nZXQoJ3RpdGxlJykpO1xuXHRcdFx0ICB0aGlzLmFkZFNpbXBsZVRvb2x0aXAodGl0bGUpO1xuXHRcdCAgfVxuXHQgIH1cbiAgfSxcbiAgXG4gIGNhbGN1bGF0ZVRleHRMaW5lczogZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgdmFyIGxpbmVIZWlnaHQgPSAyNDtcblx0ICB2YXIgbGluZXMgPSBNYXRoLmZsb29yKCQob2JqZWN0KS5oZWlnaHQoKSAvIGxpbmVIZWlnaHQpO1xuXHQgIHJldHVybiBsaW5lcztcbiAgfSxcblxuICByZXNldExpbWl0OiBmdW5jdGlvbigpIHtcblx0ICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHtcblx0XHQgIHRoaXMubW9kZWwuc2V0KCd5TGltaXQnLCB0aGlzLm1vZGVsLmdldCgnb3JpZ2luYWxZTGltaXQnKSk7XG5cdFx0ICB0aGlzLnVwZGF0ZURhdGEoKTtcblx0ICB9IGVsc2Uge1xuXHRcdCAgdGhpcy5tb2RlbC5zZXQoJ2xpbWl0JywgdGhpcy5tb2RlbC5kZWZhdWx0cy5saW1pdCk7XG5cdCAgfVxuICB9LFxuXG4gIGNoYW5nZUFkalR5cGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbmV3VHlwZSA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICB0aGlzLm1vZGVsLnNldCgnYWRqdHlwZScsIG5ld1R5cGUpO1xuICB9LFxuICBcbiAgY2hhbmdlWEF4aXM6IGZ1bmN0aW9uKGUpIHtcblx0ICB2YXIgbmV3VHlwZSA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcblx0ICB0aGlzLm1vZGVsLnNldCgneEF4aXNDb2x1bW4nLCBuZXdUeXBlKTtcbiAgfSwgIFxuXG4gIGNoYW5nZUNoYXJ0VmlldzogZnVuY3Rpb24oZSkge1xuICAgIHZhciB2aWV3ID0gdXRpbC5kYXRhKGUuY3VycmVudFRhcmdldCwgJ3ZpZXcnKTtcbiAgICB0aGlzLm1vZGVsLnNldCgndmlldycsIHZpZXcpO1xuICAgIHRoaXMuaGlkZUV4cG9ydEluUHVibGljVmlldygpO1xuICB9LFxuICBoaWRlRXhwb3J0SW5QdWJsaWNWaWV3OiBmdW5jdGlvbigpe1xuXHQgIHZhciBlZGl0YWJsZURhdGFFeHBvcnRTZXR0aW5nID0gdGhpcy5hcHAuZ2VuZXJhbFNldHRpbmdzLmdldCgnaGlkZS1lZGl0YWJsZS1leHBvcnQtZm9ybWF0cy1wdWJsaWMtdmlldycpO1xuXHQgIGlmKHRoaXMubW9kZWwuZ2V0KCd2aWV3JykgPT09ICd0YWJsZScgJiYgZWRpdGFibGVEYXRhRXhwb3J0U2V0dGluZyA9PSB0cnVlICYmIHRoaXMuYXBwLnVzZXIuZ2V0KCdsb2dnZWQnKSA9PSBmYWxzZSApe1xuXHRcdCAgdGhpcy4kZWwuZmluZCgnLmRvd25sb2FkJykuaGlkZSgpO1xuXHQgIH1lbHNle1xuXHRcdCAgdGhpcy4kZWwuZmluZCgnLmRvd25sb2FkJykuc2hvdygpO1xuXHQgIH0gIFxuICB9LCAgXG4gIGJpZzogZnVuY3Rpb24oKSB7XG4gICAgLy8gdG9nZ2xlIGJpZy9zbWFsbCBjaGFydHMgb24gbGFyZ2Ugc2NyZWVuc1xuICAgIHRoaXMubW9kZWwuc2V0KCdiaWcnLCAhdGhpcy5tb2RlbC5nZXQoJ2JpZycpKTtcbiAgfSxcbiAgc2V0Q2xlYXI6IGZ1bmN0aW9uKHNob3VsZEJyZWFrKSB7XG4gICAgLy8gbGF5b3V0IGhpbnRzLCBzaG91bGQgb25seSBiZSBjYWxsZWQgYnkgLi9jaGFydHMuanNcbiAgICB0aGlzLiRlbFtzaG91bGRCcmVhayA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnY2xlYXJmaXgnKTtcbiAgfSxcblxuICBkb3dubG9hZDogZnVuY3Rpb24oKSB7ICAgICBcblx0dmFyIGNoYXJ0T3B0aW9ucyA9IF8odGhpcy5nZXRDaGFydE9wdGlvbnMoKSkub21pdCgnaGVpZ2h0JywgJ3dpZHRoJyk7XHRcbiAgICB2YXIgZG93bmxvYWRWaWV3ID0gbmV3IERvd25sb2FkVmlldyh7XG4gICAgICBhcHA6IHRoaXMuYXBwLFxuICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBjaGFydE9wdGlvbnM6IGNoYXJ0T3B0aW9uc1xuICAgIH0pO1xuICAgIHZhciBzcGVjaWFsQ2xhc3MgPSAnZGFzaC1kb3dubG9hZC1tb2RhbCc7XG4gICAgdGhpcy5hcHAubW9kYWwoJ0Rvd25sb2FkIGNoYXJ0Jywge1xuICAgICAgYm9keUVsOiBkb3dubG9hZFZpZXcucmVuZGVyKCkuZWwsXG4gICAgICBzcGVjaWFsQ2xhc3M6IHNwZWNpYWxDbGFzcyxcbiAgICAgIGkxOG5UaXRsZTogJ2FtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtZG93bmxvYWQtY2hhcnQnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gVHJhbnNsYXRlIG1vZGFsIHBvcHVwLlx0XG4gICBcdGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKFwiLlwiICsgc3BlY2lhbENsYXNzKSk7XG4gIH0sXG4gIFxuICBoZWF0bWFwU3dpdGNoQXhpczogZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLm1vZGVsLmdldCgnc3dhcEF4ZXMnKSA9PT0gdHJ1ZSkge1xuXHRcdCAgdGhpcy5tb2RlbC5zZXQoJ3N3YXBBeGVzJywgZmFsc2UpO1xuXHQgIH0gZWxzZSB7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc3dhcEF4ZXMnLCB0cnVlKTtcblx0ICB9ICBcblx0ICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgfSxcblxuICAvL0FNUC0xODYzMDogSGVyZSB3ZSBzZXR1cCBhIHNpbXBsZSB0b29sdGlwIGZvciBlYWNoIGxlZ2VuZCBlbGVtZW50LlxuICBiZWF1dGlmeUxlZ2VuZHMgOiBmdW5jdGlvbihzZWxmKSB7XHQgIFxuXHQgIHZhciBoYXNWYWx1ZXMgPSBmYWxzZTtcblx0ICB2YXIgaGFzUHJvY2Vzc2VkID0gZmFsc2U7XG5cdCAgaWYoc2VsZi5tb2RlbCAhPT0gdW5kZWZpbmVkICYmIHNlbGYubW9kZWwuZ2V0KCd2YWx1ZXMnKSAhPT0gdW5kZWZpbmVkICYmIHNlbGYubW9kZWwuZ2V0KCd2YWx1ZXMnKS5sZW5ndGggPiAwKSB7XG5cdFx0ICBoYXNWYWx1ZXMgPSB0cnVlO1xuXHQgIH1cblx0ICBpZihzZWxmLm1vZGVsICE9PSB1bmRlZmluZWQgJiYgc2VsZi5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpICE9PSB1bmRlZmluZWQgJiYgc2VsZi5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpLmxlbmd0aCA+IDEpIHtcblx0XHQgIGhhc1Byb2Nlc3NlZCA9IHRydWU7XG5cdCAgfVxuXHQgIFxuXHQgIC8vIEl0ZXJhdGUgdGhlIGxpc3Qgb2YgbGVnZW5kIGVsZW1lbnRzIGluIERPTSAob25seSBmb3IgdGhpcyBjaGFydCkgYW5kIHNldCBhIGRhdGEgZWxlbWVudCBjYWxsZWQgJ2RhdGEtdGl0bGUnIHRoYXRcblx0ICAvLyB3aWxsIGJlIHRoZW4gdXNlZCB3aGVuIGEgaG92ZXIgZXZlbnQgaXMgZmlyZWQuXG5cdCAgJCh0aGlzLiRlbCkuZmluZChcIi5udi1zZXJpZXNcIikuZWFjaChmdW5jdGlvbihpLCBlbGVtKSB7XG5cdFx0ICAvLyBIZWF0bWFwcyBkb250IG5lZWQgYSBzcGVjaWFsIHJlcHJvY2Vzc2luZy5cblx0XHQgIGlmIChzZWxmLm1vZGVsLmdldCgndmlldycpICE9PSAnaGVhdG1hcCcpIHtcblx0XHRcdCAgaWYoaGFzVmFsdWVzICYmICFoYXNQcm9jZXNzZWQpIHtcblx0XHRcdFx0ICAvLyBUb3AgY2hhcnRzLlxuXHRcdFx0XHQgIGlmKHNlbGYubW9kZWwuZ2V0KCd2YWx1ZXMnKVtpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ICAkKGVsZW0pLmRhdGEoJ2RhdGEtdGl0bGUnLCBzZWxmLm1vZGVsLmdldCgndmFsdWVzJylbaV0ubmFtZSk7XG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHQvLyBUaGlzIHRoZSBsYXN0IGxlZ2VuZCBcIk90aGVyc1wiIChkb2VzbnQgY29tZSBpbiB0aGUgZGF0YSkuXG5cdFx0XHQgICAgXHQkKGVsZW0pLmRhdGEoJ2RhdGEtdGl0bGUnLCBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZS1vdGhlcnNcIiwgXCJPdGhlcnNcIikpO1xuXHRcdFx0XHQgIH1cblx0XHRcdCAgfSBlbHNlIGlmKGhhc1Byb2Nlc3NlZCkge1xuXHRcdFx0XHQgIC8vIEFpZCBQcmVkaWN0YWJpbGl0eSBjaGFydHMgYW5kIEZ1bmRpbmcgVHlwZSBjaGFydHMuXG5cdFx0XHRcdCAgaWYoc2VsZi5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQgIC8vIFRoZSBleHRyYSBjaGVjayBpcyBmb3IgRlQgY2hhcnRzIHRoYXQgaGF2ZSBtb3JlIGxlZ2VuZHMgKGdyb3VwZWQsIHN0YWNrZWQsIGV0YykuXG5cdFx0XHRcdFx0ICAkKGVsZW0pLmRhdGEoJ2RhdGEtdGl0bGUnLCBzZWxmLm1vZGVsLmdldCgncHJvY2Vzc2VkJylbaV0ua2V5KTtcblx0XHRcdFx0ICB9XG5cdFx0XHQgIH1cblx0XHQgIH1cblx0ICAgIFxuXHRcdCAgLy8gTm93IGJpbmQgTlYgdG9vbHRpcCBtZWNoYW5pc20gdG8gaG92ZXIgZXZlbnQgZm9yIGVhY2ggbGVnZW5kLlxuXHRcdCAgc2VsZi5hZGRTaW1wbGVUb29sdGlwKGVsZW0pO1xuXHQgIH0pO1xuICB9LFxuICBcbiAgYWRkU2ltcGxlVG9vbHRpcDogZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgaWYgKCQob2JqZWN0KS5kYXRhKCdkYXRhLXRpdGxlJykgfHwgJChvYmplY3QpLmRhdGEoJ3RpdGxlJykpIHtcblx0XHQgICQob2JqZWN0KS5ob3ZlcihmdW5jdGlvbigpIHtcblx0XHRcdCAgdmFyIHRpdGxlID0gJChvYmplY3QpLmRhdGEoJ2RhdGEtdGl0bGUnKSA/ICQob2JqZWN0KS5kYXRhKCdkYXRhLXRpdGxlJykgOiAkKG9iamVjdCkuZGF0YSgndGl0bGUnKTtcblx0XHRcdCAgdmFyIG9mZnNldCA9ICQob2JqZWN0KS5vZmZzZXQoKTtcblx0ICAgIFx0ICBudi50b29sdGlwLnNob3coW29mZnNldC5sZWZ0LCBvZmZzZXQudG9wXSwgXCI8ZGl2IGNsYXNzPSdwYW5lbCBwYW5lbC1wcmltYXJ5IHBhbmVsLXBvcG92ZXInPjxkaXYgY2xhc3M9J3BhbmVsLWhlYWRpbmcnPlwiICsgdGl0bGUgKyBcIjwvZGl2PjwvZGl2PlwiKTtcblx0XHQgIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICBudi50b29sdGlwLmNsZWFudXAoKTtcblx0XHQgIH0pO1xuXHQgIH1cbiAgfSxcbiAgZXh0cmFjdE51bWJlckZvcm1hdFNldHRpbmdzOiBmdW5jdGlvbihzZXR0aW5ncykge1xuXHRcdCAgdmFyIG51bWJlckZvcm1hdCA9IHt9OyBcblx0ICAgICAgbnVtYmVyRm9ybWF0Lm51bWJlckZvcm1hdCA9IHRoaXMuYXBwLmdlbmVyYWxTZXR0aW5ncy5nZXQoJ251bWJlci1mb3JtYXQnKSB8fCAnIywjLiMnO1xuXG5cdFx0ICAvLyBJZiB0aGUgZm9ybWF0IHBhdHRlcm4gZG9lc250IGhhdmUgdGhvdXNhbmRzIGdyb3VwaW5nIHRoZW4gaWdub3JlICdudW1iZXItZ3JvdXAtc2VwYXJhdG9yJyBwYXJhbSBvciBpdCB3aWxsIFxuXHRcdCAgLy8gYmUgdXNlZCBieSBKUyB0byBncm91cCBieSB0aG91c2FuZHMgKGllOiBpbiB0aGUgJ090aGVycycgY29sdW1ucykuXG5cdFx0ICBpZihudW1iZXJGb3JtYXQubnVtYmVyRm9ybWF0LmluZGV4T2YoJywnKSAhPT0gLTEpIHtcdFx0XHQgIFx0XHQgIFxuXHRcdFx0ICBudW1iZXJGb3JtYXQuZ3JvdXBTZXBhcmF0b3IgPSB0aGlzLmFwcC5nZW5lcmFsU2V0dGluZ3MuZ2V0KCdudW1iZXItZ3JvdXAtc2VwYXJhdG9yJykgfHwgJywnO1xuXHRcdCAgfSBlbHNlIHtcblx0XHRcdCAgbnVtYmVyRm9ybWF0Lmdyb3VwU2VwYXJhdG9yID0gJyc7XG5cdFx0ICB9XG5cdFx0ICBcdFx0XHQgIFxuXHRcdCAgbnVtYmVyRm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgPSB0aGlzLmFwcC5nZW5lcmFsU2V0dGluZ3MuZ2V0KCdudW1iZXItZGVjaW1hbC1zZXBhcmF0b3InKSB8fCAnLic7XG5cdFx0ICB0aGlzLmFwcC5nZW5lcmFsU2V0dGluZ3MubnVtYmVyRm9ybWF0U2V0dGluZ3MgPSBudW1iZXJGb3JtYXQ7XHRcdFxuXHRcdCAgXG5cdFx0ICB0aGlzLmFwcC5nZW5lcmFsU2V0dGluZ3MubnVtYmVyRGl2aWRlciA9IHRoaXMuYXBwLmdlbmVyYWxTZXR0aW5ncy5nZXQoJ251bWJlci1kaXZpZGVyJyk7XHRcdCAgXG5cdFx0ICBpZiAodGhpcy5hcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckRpdmlkZXIgPT09IDEpIHtcblx0XHRcdCAgdGhpcy5hcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckRpdmlkZXJEZXNjcmlwdGlvbiA9ICdhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvcHMtaW51bml0cyc7XG5cdFx0ICB9IGVsc2UgaWYodGhpcy5hcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckRpdmlkZXIgPT09IDEwMDApIHtcblx0XHRcdCAgdGhpcy5hcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckRpdmlkZXJEZXNjcmlwdGlvbiA9ICdhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvcHMtaW50aG91c2FuZHMnO1xuXHRcdCAgfSBlbHNlIGlmKHRoaXMuYXBwLmdlbmVyYWxTZXR0aW5ncy5udW1iZXJEaXZpZGVyID09PSAxMDAwMDAwKSB7XG5cdFx0XHQgIHRoaXMuYXBwLmdlbmVyYWxTZXR0aW5ncy5udW1iZXJEaXZpZGVyRGVzY3JpcHRpb24gPSAnYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLWlubWlsbGlvbnMnO1xuXHRcdCAgfWVsc2UgaWYodGhpcy5hcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckRpdmlkZXIgPT09IDEwMDAwMDAwMDApIHtcblx0XHRcdCAgdGhpcy5hcHAuZ2VuZXJhbFNldHRpbmdzLm51bWJlckRpdmlkZXJEZXNjcmlwdGlvbiA9ICdhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvcHMtaW5iaWxsaW9ucyc7XG5cdFx0ICB9XG5cdCAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcblxudmFyIFRvcHMgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhcnQtdG9wcycpO1xudmFyIFByZWRpY3RhYmlsaXR5ID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LWFpZC1wcmVkaWN0YWJpbGl0eScpO1xudmFyIEZ1bmRpbmdUeXBlID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LWZ1bmRpbmctdHlwZScpO1xudmFyIEhlYXRNYXBDaGFydCA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydC1oZWF0bWFwcycpO1xuXG52YXIgVG9wc0NoYXJ0VmlldyA9IHJlcXVpcmUoJy4vY2hhcnQtdG9wcycpO1xudmFyIEhlYXRNYXBDaGFydFZpZXcgPSByZXF1aXJlKCcuL2NoYXJ0LWhlYXRtYXBzJyk7XG52YXIgUHJlZGljdGFiaWxpdHlDaGFydFZpZXcgPSByZXF1aXJlKCcuL2NoYXJ0LWFpZC1wcmVkaWN0YWJpbGl0eScpO1xudmFyIEZ1bmRpbmdUeXBlQ2hhcnRWaWV3ID0gcmVxdWlyZSgnLi9jaGFydC1mdW5kaW5nLXR5cGUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAncm93JyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLmNoYXJ0Vmlld3MgPSB0aGlzLmNvbGxlY3Rpb24ubWFwKGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgICB2YXIgQ2hhcnRWaWV3ID0gY2hhcnQgaW5zdGFuY2VvZiBUb3BzID8gVG9wc0NoYXJ0Vmlld1xuICAgICAgICAgICAgICAgICAgICA6IGNoYXJ0IGluc3RhbmNlb2YgUHJlZGljdGFiaWxpdHkgPyBQcmVkaWN0YWJpbGl0eUNoYXJ0Vmlld1xuICAgICAgICAgICAgICAgICAgICA6IGNoYXJ0IGluc3RhbmNlb2YgRnVuZGluZ1R5cGUgPyBGdW5kaW5nVHlwZUNoYXJ0Vmlld1xuICAgICAgICAgICAgICAgICAgICA6IGNoYXJ0IGluc3RhbmNlb2YgSGVhdE1hcENoYXJ0ID8gSGVhdE1hcENoYXJ0Vmlld1xuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICByZXR1cm4gbmV3IENoYXJ0Vmlldyh7IG1vZGVsOiBjaGFydCwgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLmFwcC5maWx0ZXIsICdhcHBseScsIHRoaXMuYXBwbHlGaWx0ZXIpO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAnY2hhbmdlOmJpZycsIHRoaXMuaW5qZWN0QnJlYWtzKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ2NoYW5nZTpiaWdOJywgdGhpcy5yZWRyYXdDb250YWluZXIpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbChfKHRoaXMuY2hhcnRWaWV3cykubWFwKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIHJldHVybiB2aWV3LnJlbmRlcigpLmVsO1xuICAgIH0pKTtcbiAgICB0aGlzLmluamVjdEJyZWFrcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluamVjdEJyZWFrczogZnVuY3Rpb24oY2hhcnRNb2RlbCkge1xuICAgIF8odGhpcy5jaGFydFZpZXdzKS5yZWR1Y2UoZnVuY3Rpb24oYnJlYWtBZnRlciwgdGhpc1ZpZXcpIHtcbiAgICAgIHRoaXNWaWV3LnNldENsZWFyKGJyZWFrQWZ0ZXIpO1xuICAgICAgaWYgKCFicmVha0FmdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzVmlldy5tb2RlbC5nZXQoJ2JpZycpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIGlmIChjaGFydE1vZGVsKSB7XG4gICAgICB2YXIgY2hhcnRWaWV3ID0gXyh0aGlzLmNoYXJ0Vmlld3MpLmZpbmQoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5tb2RlbCA9PT0gY2hhcnRNb2RlbDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGNoYXJ0VmlldykgeyBjaGFydFZpZXcucmVuZGVyKCk7IH1cbiAgICB9XG4gIH0sXG4gIFxuICByZWRyYXdDb250YWluZXI6IGZ1bmN0aW9uKGNoYXJ0TW9kZWwpIHtcblx0ICBpZiAoY2hhcnRNb2RlbCkge1xuXHRcdCAgdmFyIGNoYXJ0VmlldyA9IF8odGhpcy5jaGFydFZpZXdzKS5maW5kKGZ1bmN0aW9uKHYpIHtcblx0XHRcdCAgcmV0dXJuIHYubW9kZWwgPT09IGNoYXJ0TW9kZWw7XG5cdCAgICAgIH0pO1xuXHQgICAgICBpZiAoY2hhcnRWaWV3KSB7IFxuXHQgICAgXHQgIGNoYXJ0Vmlldy5yZW5kZXIoKTsgXG5cdCAgICAgIH1cblx0ICB9IFxuICB9XG5cbn0pO1xuIiwidmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBGaWx0ZXJzID0gcmVxdWlyZSgnLi9maWx0ZXJzJyk7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuL3NldHRpbmdzJyk7XG52YXIgU2hhcmUgPSByZXF1aXJlKCcuL3NoYXJlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ3JvdycsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7ICAgIFxuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoeyBhcHA6IHRoaXMuYXBwIH0pO1xuICAgIHRoaXMuZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICB0aGlzLnNoYXJlID0gbmV3IFNoYXJlKHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwoW1xuICAgICAgdGhpcy5maWx0ZXJzLnJlbmRlcigpLmVsLFxuICAgICAgdGhpcy5zZXR0aW5ncy5yZW5kZXIoKS5lbCxcbiAgICAgIHRoaXMuc2hhcmUucmVuZGVyKCkuZWxcbiAgICBdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGJhYnkgPSByZXF1aXJlKCdiYWJ5cGFyc2UnKTtcbnZhciBjYW52ZyA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvbGliLWxvYWQtaGFja3MnKS5jYW52ZztcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdWdseS91dGlsJyk7XG5cblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIGdldENoYXJ0ID0gcmVxdWlyZSgnLi4vY2hhcnRzL2NoYXJ0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxoNCBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtcHJldmlld1xcXCI+UHJldmlldzo8L2g0PlxcblxcbjwhLS0gVGhpcyAnbW9kYWwnIGRpdiBmaXhlcyBBTVAtMTk1MjU6IEluIEZGIHdoZW4gdGhlIGNoYXJ0IGlzIGRyYXduIChmb3IgbGVzcyB0aGFuIGEgc2Vjb25kKSBpbiAnc3ZnLXdyYXAnLCBzb21ldGltZXMgdGhlIG1vdXNlIGN1cnNvciBpcyBvdmVyIG9uZSBvZiB0aGUgYmFycyBhbmQgdHJpZ2dlcnMgdGhlIHRvb2x0aXAsXFxudGhhdCBwcm9jZXNzIGlzIG5vdCBmdWxseSBwZXJmb3JtZWQgdGh1cyByZXN1bHRpbmcgaW4gaW5jb21wbGV0ZSBodG1sIHdoaWNoIGlzIHJlamVjdGVkIGJ5IHRoZSBicm93c2VyIDooICAtLT5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1wcmV2aWV3LWFyZWFcXFwiPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInByZXZpZXctYXJlYVxcXCI+XFxuXFx0PGRpdiBjbGFzcz1cXFwic3ZnLXdyYXAgaGlkZGVuXFxcIj5cXG4gIFxcdDwvZGl2PlxcbiAgXFx0PGRpdiBjbGFzcz1cXFwiY2FudmFzLXdyYXAgaGlkZGVuXFxcIj5cXG4gIFxcdDwvZGl2PlxcbiAgXFx0PGRpdiBjbGFzcz1cXFwidGFibGUtd3JhcCBoaWRkZW5cXFwiPlxcbiAgXFx0PC9kaXY+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcbiAgPGEgY2xhc3M9XFxcImJ0biBidG4tc3VjY2VzcyBkb3dubG9hZC1jaGFydCBkaXNhYmxlZFxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWRvd25sb2FkXFxcIj48L3NwYW4+XFxuICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1yZW5kZXJpbmdcXFwiIGNsYXNzPVxcXCJ3b3JkXFxcIj5SZW5kZXJpbmcuLi48L3NwYW4+XFxuICA8L2E+XFxuPC9kaXY+XFxuXCIpO1xuXG52YXIgcHJldmlvdXNYTGltaXQgPSBudWxsO1xudmFyIHByZXZpb3VzWUxpbWl0ID0gbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdmFyIHZhbHVlc0xlbmd0aCA9IHRoaXMubW9kZWwuZ2V0KCd2YWx1ZXMnKSA/IHRoaXMubW9kZWwuZ2V0KCd2YWx1ZXMnKS5sZW5ndGggOiAwO1xuICAgIHZhciBoZWlnaHQgPSB1dGlsLmNhbGN1bGF0ZUNoYXJ0SGVpZ2h0KHZhbHVlc0xlbmd0aCwgdHJ1ZSk7XG4gICAgdGhpcy5kYXNoQ2hhcnRPcHRpb25zID0gXyh7fSkuZXh0ZW5kKG9wdGlvbnMuY2hhcnRPcHRpb25zLCB7XG4gICAgICBoZWlnaHQ6IGhlaWdodCwgLy80NTAsICAvLyBzeW5jIHdpdGggY3NzISEhXG4gICAgICB3aWR0aDogJCgnLmNvbnRhaW5lcicpLndpZHRoKCksXHQvLyBzeW5jIHdpdGggY3NzISEhXG4gICAgICB0cmltTGFiZWxzOiBmYWxzZSxcbiAgICAgIG52Q29udHJvbHM6IGZhbHNlICAgICAgXG4gICAgfSk7XG4gICAgXG4gICAgLy8gSGVhdG1hcHMgZXhwb3J0IG5lZWQgdG8gc2hvdyBhbGwgZGF0YSBhdCBvbmNlIHNvIHdlIGZvcmNlIHRoZSB4L3kgbGltaXRzIGFuZCByZS1yZW5kZXIgdGhlIGNoYXJ0LlxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuXHQgICAgcHJldmlvdXNYTGltaXQgPSB0aGlzLm1vZGVsLmdldCgneExpbWl0Jyk7XG5cdCAgICBwcmV2aW91c1lMaW1pdCA9IHRoaXMubW9kZWwuZ2V0KCd5TGltaXQnKTtcblx0ICAgIHRoaXMubW9kZWwuc2V0KCd5TGltaXQnLCAtMSk7XG5cdCAgICB0aGlzLm1vZGVsLnNldCgneExpbWl0JywgLTEpO1xuXHQgICAgdGhpcy5tb2RlbC5zZXQoJ3Nob3dGdWxsTGVnZW5kcycsIHRydWUpO1xuXHQgICAgdmFyIGNoYXJ0ID0gXy5maW5kKHRoaXMuYXBwLnZpZXcuY2hhcnRzLmNoYXJ0Vmlld3MsIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5tb2RlbC5nZXQoJ25hbWUnKSA9PT0gc2VsZi5tb2RlbC5nZXQoJ25hbWUnKX0pO1xuXHQgICAgY2hhcnQucmVuZGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpOyAgIFxuICAgIHRoaXMuY2hhcnQgPSBfLmZpbmQoc2VsZi5hcHAudmlldy5jaGFydHMuY2hhcnRWaWV3cywgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLm1vZGVsLmdldCgnbmFtZScpID09PSBzZWxmLm1vZGVsLmdldCgnbmFtZScpfSk7XG4gICAgXG5cdC8vIEhlcmUgd2Ugd2lsbCBkZWZpbmUgYW4gaW50ZXJ2YWwgdGhhdCB3aWxsIGNoZWNrIHBlcmlvZGljYWxseSBpZiB0aGUgYm9vdHN0cmFwIG1vZGFsIGlzIGZ1bGx5IHJlbmRlcmVkLlxuXHQvLyBJbiB0aGF0IG1vbWVudCB0aGUgaW50ZXJ2YWwgaXMgZmluaXNoZWQgYW5kIHRoZSBjaGFydCBpcyByZW5kZXJlZC5cblx0dmFyIHJlbmRlcmVkID0gZmFsc2U7IC8vIFRoaXMgZmxhZyBpcyB1c2VkIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIHJlbmRlciBwcm9jZXNzIHR3aWNlIGluIGNhc2UgdGhlIGJyb3dzZXIgbWVzcyB1cCB0aGUgaW50ZXJ2YWwuXHQgICAgXHRcblx0dmFyIGludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHRcdGlmICgkKCcuZGFzaC1kb3dubG9hZC1tb2RhbCcpLmNsb3Nlc3QoJy5pbicpLmxlbmd0aCA+IDApIHtcblx0XHRcdHdpbmRvdy5jbGVhckludGVydmFsKGludGVydmFsKTtcblx0XHRcdC8vIFdhaXQgZm9yIHRoZSBjaGFydCBpbiB0aGUgZGFzaGJvYXJkIHBhZ2UgdG8gYmUgZnVsbHkgcmVuZGVyZWQsIHRoaXMgaGFzIGltcGFjdCBvbmx5IG9uIGhlYXRtYXAgY2hhcnRzLCBvbiB0aGUgcmVzdCBpcyB0cmFuc3BhcmVudC5cblx0XHRcdCQud2hlbihzZWxmLmNoYXJ0LnJlbmRlcmVkUHJvbWlzZSwgc2VsZi5jaGFydC5zaG93Q2hhcnRQcm9taXNlKS5kb25lKGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdGlmIChzZWxmLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuXHQgICAgXHRcdFx0Ly8gV2UgYWRkIGFuIGV2ZW50IGZvciBoZWF0bWFwcyB0byByZS1kcmF3IHRoZSBvcmlnaW5hbCBjaGFydC5cblx0ICAgIFx0XHQgICAgJCgnLmRhc2gtZG93bmxvYWQtbW9kYWwnKS5jbG9zZXN0KCcuaW4nKS5vbignaGlkZS5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdCAgICBcdHNlbGYubW9kZWwuc2V0KCd5TGltaXQnLCBwcmV2aW91c1lMaW1pdCk7XG5cdCAgICBcdFx0ICAgIFx0c2VsZi5tb2RlbC5zZXQoJ3hMaW1pdCcsIHByZXZpb3VzWExpbWl0KTtcblx0ICAgIFx0XHQgICAgXHRzZWxmLm1vZGVsLnNldCgnc2hvd0Z1bGxMZWdlbmRzJywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0c2VsZi5jaGFydC5yZW5kZXIoKTtcblx0ICAgIFx0XHQgICAgfSk7XG5cdCAgICBcdFx0fVxuXHRcdFx0ICAgIGlmIChzZWxmLm1vZGVsLmdldCgndmlldycpID09PSAndGFibGUnKSB7XG5cdFx0XHQgICAgXHRzZWxmLnJlbmRlckNTVihzZWxmLiQoJy5wcmV2aWV3LWFyZWEgLnRhYmxlLXdyYXAnKS5yZW1vdmVDbGFzcygnaGlkZGVuJykpO1xuXHRcdFx0ICAgIH0gZWxzZSB7XG5cdFx0XHQgICAgICAgIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuXHRcdFx0ICAgICAgICBpZiAocmVuZGVyZWQgPT09IGZhbHNlKSB7XG5cdFx0XHQgICAgICAgIFx0cmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0ICAgICAgICBcdHNlbGYucmVuZGVyQ2hhcnQoc2VsZi4kKCcucHJldmlldy1hcmVhIC5zdmctd3JhcCcpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKSxcblx0XHRcdCAgICAgICAgXHRcdHNlbGYuJCgnLnByZXZpZXctYXJlYSAuY2FudmFzLXdyYXAnKSwgc2VsZi5jaGFydCk7XG5cdFx0XHQgICAgICAgIH1cblx0XHRcdCAgICB9XG5cdFx0XHR9KTtcblx0XHR9XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJDaGFydDogZnVuY3Rpb24oc3ZnQ29udGFpbmVyLCBjYW52YXNDb250YWluZXIsIGNoYXJ0KSB7XG5cdHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoXyh0aGlzLmFwcC5icm93c2VySXNzdWVzKS5maW5kV2hlcmUoe2ZlYXR1cmU6ICdjYW52YXMnfSkpIHtcbiAgICAgIHRoaXMuYXBwLnZpZXdGYWlsKHRoaXMsICdDaGFydCBleHBvcnQgcmVxdWlyZXMgYSBtb2Rlcm4gd2ViIGJyb3dzZXInKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHNlbGYubW9kZWwuZ2V0KCdjaGFydFR5cGUnKSA9PT0gJ2ZyYWdtZW50YXRpb24nKSB7XG4gICAgXHR2YXIgc3ZnID0gJCgkKCQoY2hhcnQpWzBdLmVsKS5maW5kKFwic3ZnXCIpKVswXS5nZXRCQm94KCk7XG5cdCAgICB0aGlzLmRhc2hDaGFydE9wdGlvbnMuaGVpZ2h0ID0gc3ZnLmhlaWdodCArIDEwMDtcblx0ICAgIHRoaXMuZGFzaENoYXJ0T3B0aW9ucy53aWR0aCA9IHN2Zy53aWR0aCArIDgwO1xuICAgIH1cbiAgICAgICAgXG4gICAgdmFyIHZpZXcgPSB0aGlzLm1vZGVsLmdldCgndmlldycpLFxuICAgICAgICBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgY2hhcnRFbCA9IGdldENoYXJ0KHZpZXcsIGRhdGEsXG4gICAgICAgICAgXyh7fSkuZXh0ZW5kKHRoaXMuZGFzaENoYXJ0T3B0aW9ucywgeyBoZWlnaHQ6IHRoaXMuZGFzaENoYXJ0T3B0aW9ucy5oZWlnaHQgLSA0MiB9KSkuZWw7XG5cbiAgICBzdmdDb250YWluZXIuaHRtbChjaGFydEVsKTtcblxuICAgIHRoaXMucHJlcGFyZUNhbnZhcyhjYW52YXMsIHRoaXMuZGFzaENoYXJ0T3B0aW9ucy5oZWlnaHQsIHRoaXMuZGFzaENoYXJ0T3B0aW9ucy53aWR0aCk7XG5cbiAgICB0aGlzLmNoYXJ0VG9DYW52YXMoY2hhcnRFbCwgY2FudmFzLCBmdW5jdGlvbigpIHtcbiAgICAgIHN2Z0NvbnRhaW5lci5oaWRlKCk7XG4gICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICBjYW52YXNDb250YWluZXIuaHRtbChpbWcpO1xuICAgICAgJChjYW52YXNDb250YWluZXIpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICQoJy5tb2RhbC1wcmV2aWV3LWFyZWEnKS5yZW1vdmUoKTtcbiAgICAgIHRoaXMubWFrZURvd25sb2FkYWJsZShpbWcuc3JjLCAnY2hhcnQnLCAnLnBuZycpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNjYWxlIHRoZSBtb2RhbCBjb3JyZWN0bHkgZm9yIGhlYXRtYXBzLlxuICAgIGlmIChzZWxmLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuICAgIFx0dmFyIG1vZGFsID0gJCgnLmRhc2gtZG93bmxvYWQtbW9kYWwnKS5jbG9zZXN0KCcuaW4nKS5maW5kKCcuZGFzaC1kb3dubG9hZC1tb2RhbCcpO1xuICAgIFx0aWYgKCQoc3ZnQ29udGFpbmVyKS53aWR0aCgpID4gJChtb2RhbCkud2lkdGgoKSkge1xuICAgIFx0XHQkKG1vZGFsKS5maW5kKCcucHJldmlldy1hcmVhJykuY3NzKCdtYXgtd2lkdGgnLCc5MCUnKTtcbiAgICAgICAgXHQkKG1vZGFsKS5jbG9zZXN0KCcuaW4nKS5maW5kKCcucHJldmlldy1hcmVhJykuY3NzKCdvdmVyZmxvdycsJ2F1dG8nKTtcbiAgICBcdH1cbiAgICBcdGlmICgkKHN2Z0NvbnRhaW5lcikuaGVpZ2h0KCkgPiAkKHdpbmRvdykuaGVpZ2h0KCkpIHtcbiAgICBcdFx0JChtb2RhbCkuZmluZCgnLnByZXZpZXctYXJlYScpLmNzcygnbWF4LWhlaWdodCcsICgkKHdpbmRvdykuaGVpZ2h0KCkgLSAyNzApICsgJ3B4Jyk7XG4gICAgICAgIFx0JChtb2RhbCkuY2xvc2VzdCgnLmluJykuZmluZCgnLnByZXZpZXctYXJlYScpLmNzcygnb3ZlcmZsb3cnLCdhdXRvJyk7XG4gICAgXHR9XG4gICAgfVxuICB9LFxuXG4gIHByZXBhcmVDYW52YXM6IGZ1bmN0aW9uKGNhbnZhcywgaCwgdykge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciBjdXJyZW5jeSA9IGFwcC5zZXR0aW5nc1dpZGdldC5kZWZpbml0aW9ucy5maW5kQ3VycmVuY3lCeUlkKHNlbGYubW9kZWwuZ2V0KCdjdXJyZW5jeScpKTtcbiAgICB2YXIgY3VycmVuY3lOYW1lID0gY3VycmVuY3kgIT09IHVuZGVmaW5lZCA/IGN1cnJlbmN5LnZhbHVlIDogJyc7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgIFx0bW9uZXlDb250ZXh0ID0gKHRoaXMubW9kZWwuZ2V0KCdzdW1hcml6ZWRUb3RhbCcpICE9PSB1bmRlZmluZWQgPyAnOiAnICsgdXRpbC50cmFuc2xhdGVMYW5ndWFnZSh0aGlzLm1vZGVsLmdldCgnc3VtYXJpemVkVG90YWwnKSkgKyAnICc6ICcgJykgKyBjdXJyZW5jeU5hbWUsXG4gICAgICAgIGFkalR5cGUgPSB0aGlzLm1vZGVsLmdldCgnYWRqdHlwZScpOyAgICBcbiAgICBpZiAoYWRqVHlwZSkge1xuICAgICAgICB2YXIgdHJuQWRqVHlwZSA9IHRoaXMuY2hhcnQuJGVsLmZpbmQoJy5mdHlwZS1vcHRpb25zIG9wdGlvbjpzZWxlY3RlZCcpLnRleHQoKTtcbiAgICAgICAgbW9uZXlDb250ZXh0ID0gdHJuQWRqVHlwZSArIG1vbmV5Q29udGV4dDtcbiAgICB9XG5cbiAgICAvLyBzaXplIHRoZSBjYW52YXNcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHcpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGgpO1xuXG4gICAgLy8gbWFrZSB0aGUgYmFja2dyb3VuZCBvcGFxdWUgd2hpdGVcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3QoMCwgMCwgdywgaCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgLy8gQWRkIHRoZSBjaGFydCB0aXRsZVxuICAgIGN0eC5maWxsU3R5bGUgPSAnIzE2M2Y2Nic7XG4gICAgY3R4LmZvbnQgPSAnYm9sZCAyMnB4IFwiT3BlbiBTYW5zXCInO1xuICAgIGN0eC5maWxsVGV4dCh0aGlzLm1vZGVsLmdldCgndGl0bGUnKS50b1VwcGVyQ2FzZSgpLCAxMCwgMTAgKyAyMik7XG4gICAgLy8gd2hhdCBtb25leSBhcmUgd2UgdGFsa2luZyBhYm91dD9cbiAgICBjdHguZmlsbFN0eWxlID0gJyMzMzMnO1xuICAgIGlmIChzZWxmLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuICAgIFx0Y3R4LmZvbnQgPSAnbm9ybWFsIDE0cHggXCJPcGVuIFNhbnNcIic7XG4gICAgXHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIFx0Y3R4LmZpbGxUZXh0KHRybkFkalR5cGUsIDEwLCA1MCk7XHQgICAgXG4gICAgfSBlbHNlIHsgICAgXG4gICAgXHRjdHgudGV4dEFsaWduID0gJ3JpZ2h0Jztcblx0ICAgIGN0eC5maWxsVGV4dChtb25leUNvbnRleHQsIHcgLSAxMCwgMTAgKyAyMik7XG5cdCAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnOyAgLy8gcmVzZXQgaXRcbiAgICB9ICAgIFxuICAgIC8vIHJlc2V0IGZvbnQgdG8gc29tZXRoaW5nIG5vcm1hbCAobnZkMyB1c2VzIGNzcyB1Z2guLi4pXG4gICAgY3R4LmZvbnQgPSAnbm9ybWFsIDEycHggXCJzYW5zLXNlcmlmXCInO1xuICAgIFxuICAgICQoJy5tb2RhbC5pbiAubW9kYWwtZGlhbG9nJykud2lkdGgodyArIDYwKTtcbiAgfSxcblxuICBjaGFydFRvQ2FudmFzOiBmdW5jdGlvbihzdmcsIGNhbnZhcywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0aWYgKHRoaXMubW9kZWwuZ2V0KCdjaGFydFR5cGUnKSA9PT0gJ2ZyYWdtZW50YXRpb24nKSB7XG5cdFx0Ly8gVGhpcyBpcyB3aGF0IGFwcGxpZXMgdGhlIG5lY2Vzc2FyeSBzdHlsZXMgdG8gdGhlIGNoYXJ0wrRzIFNWRy5cblx0XHR2YXIgY3NzID0gXCJyZWN0LmJvcmRlcmVkIHtzdHJva2U6ICNFNkU2RTY7c3Ryb2tlLXdpZHRoOiAycHg7fSB0ZXh0Lm1vbm8ge2ZvbnQtc2l6ZTogOXB0O2ZvbnQtZmFtaWx5OiBBcmlhbDtmaWxsOiAjMDAwO31cIjtcblx0ICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0ICAgIHMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG5cdCAgICBzLmlubmVySFRNTCA9IFwiPCFbQ0RBVEFbXFxuXCIgKyBjc3MgKyBcIlxcbl1dPlwiO1xuXHQgICAgc3ZnLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGVmc1wiKVswXS5hcHBlbmRDaGlsZChzKTtcblx0fVxuXHRcbiAgICB2YXIgYm91bmRDQiA9IF8oY2IpLmJpbmQodGhpcyk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFwcC50cnlUbyhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FudmcoY2FudmFzLCBzdmcucGFyZW50Tm9kZS5pbm5lckhUTUwsIHsgLy8gbm90ZTogc3ZnLm91dGVySFRNTCBicmVha3MgSUVcbiAgICAgICAgICBvZmZzZXRZOiAoKHNlbGYubW9kZWwuZ2V0KCdjaGFydFR5cGUnKSAhPT0gJ2ZyYWdtZW50YXRpb24nKSA/IDQyIDogNjUpLFxuICAgICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWUsXG4gICAgICAgICAgaWdub3JlQ2xlYXI6IHRydWUsXG4gICAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgICAgcmVuZGVyQ2FsbGJhY2s6IGJvdW5kQ0JcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LmJpbmQodGhpcyksIDE1MDApOyAgLy8gd2UgaGF2ZSB0byB3YWl0IGZvciBzdHVwaWQgbnZkMy4uLlxuICB9LFxuXG4gIHJlbmRlckNTVjogZnVuY3Rpb24oY3N2Q29udGFpbmVyKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIGN1cnJlbmN5TmFtZSA9IGFwcC5zZXR0aW5nc1dpZGdldC5kZWZpbml0aW9ucy5maW5kQ3VycmVuY3lCeUlkKHNlbGYubW9kZWwuZ2V0KCdjdXJyZW5jeScpKS52YWx1ZTtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdwcm9jZXNzZWQnKSxcbiAgICAgICAgY3VycmVuY3kgPSBjdXJyZW5jeU5hbWUsXG4gICAgICAgIGFkanR5cGUgPSB0aGlzLm1vZGVsLmdldCgnYWRqdHlwZScpIHx8IGZhbHNlLFxuICAgICAgICBjc3ZUcmFuc2Zvcm1lZCxcbiAgICAgICAgaGVhZGVyUm93LFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgcHJldmlldztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5cyA9IF8oZGF0YSkucGx1Y2soJ2tleScpO1xuICAgIFxuICAgIGlmIChzZWxmLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgIT09ICdmcmFnbWVudGF0aW9uJykge1xuXHQgICAgLy8gdGFibGUgb2YgYWxsIHRoZSBkYXRhXG5cdCAgICBjc3ZUcmFuc2Zvcm1lZCA9IF8oZGF0YSlcblx0ICAgICAgLmNoYWluKClcblx0ICAgICAgLnBsdWNrKCd2YWx1ZXMnKVxuXHQgICAgICAudHJhbnNwb3NlKClcblx0ICAgICAgLm1hcChmdW5jdGlvbihyb3cpIHtcblx0ICAgICAgICByZXR1cm4gXyhyb3cpLnJlZHVjZShmdW5jdGlvbihjc3ZSb3csIGNlbGwpIHtcblx0ICAgICAgICAgIGNzdlJvdy5wdXNoKGNlbGwueSk7XG5cdCAgICAgICAgICByZXR1cm4gY3N2Um93O1xuXHQgICAgICAgIH0sIFtyb3dbMF0ueF0pO1xuXHQgICAgICB9KVxuXHQgICAgICAubWFwKGZ1bmN0aW9uKHJvdykge1xuXHQgICAgICAgIHJvdy5wdXNoKGN1cnJlbmN5IHx8ICcnKTtcblx0ICAgICAgICBpZiAoYWRqdHlwZSkge1xuXHRcdFx0XHR2YXIgdHJuQWRqVHlwZSA9IHNlbGYuY2hhcnQuJGVsLmZpbmQoJy5mdHlwZS1vcHRpb25zIG9wdGlvbjpzZWxlY3RlZCcpLnRleHQoKTtcblx0ICAgICAgICAgICAgcm93LnB1c2godHJuQWRqVHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByb3c7XG5cdCAgICAgIH0pXG5cdCAgICAgIC52YWx1ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNzdlRyYW5zZm9ybWVkID0gXy5tYXAoc2VsZi5tb2RlbC5nZXQoXCJtYXRyaXhcIiksIGZ1bmN0aW9uKGl0ZW1ZLCBpKSB7XG5cdFx0XHRyZXR1cm4gXy5tYXAoaXRlbVksIGZ1bmN0aW9uKGl0ZW1YLCBqKSB7XG5cdFx0XHRcdHJldHVybiBbc2VsZi5tb2RlbC5nZXQoXCJ5RGF0YVNldFwiKVtpXSxcblx0XHRcdFx0XHRzZWxmLm1vZGVsLmdldChcInhEYXRhU2V0XCIpW2pdLFxuXHRcdFx0XHRcdHNlbGYubW9kZWwuZ2V0KFwibWF0cml4XCIpW2ldW2pdID8gc2VsZi5tb2RlbC5nZXQoXCJtYXRyaXhcIilbaV1bal0uZHYgOiAnJyxcblx0XHRcdFx0XHRzZWxmLm1vZGVsLmdldChcIm1hdHJpeFwiKVtpXVtqXSA/IHNlbGYubW9kZWwuZ2V0KFwibWF0cml4XCIpW2ldW2pdLnAgOiAnJ1xuXHRcdFx0XHRdXG5cdFx0XHR9KVxuXHRcdH0pO1xuXHQgICAgY3N2VHJhbnNmb3JtZWQgPSBbXS5jb25jYXQuYXBwbHkoW10sIGNzdlRyYW5zZm9ybWVkKTtcblx0ICAgIGNzdlRyYW5zZm9ybWVkID0gXy5lYWNoKGNzdlRyYW5zZm9ybWVkLCBmdW5jdGlvbihpdGVtKSB7IFxuXHQgICAgICAgIGl0ZW0ucHVzaChjdXJyZW5jeSk7XG5cdCAgICAgICAgaWYgKGFkanR5cGUpIHtcblx0XHRcdFx0dmFyIHRybkFkalR5cGUgPSBzZWxmLmNoYXJ0LiRlbC5maW5kKCcuZnR5cGUtb3B0aW9ucyBvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCk7XG5cdCAgICAgICAgICAgIGl0ZW0ucHVzaCh0cm5BZGpUeXBlKTtcblx0ICAgICAgICB9XHQgICAgICAgIFxuXHQgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcHJlcGVuZCBhIGhlYWRlciByb3dcbiAgICBoZWFkZXJSb3cgPSBbXTtcbiAgICB2YXIgYW1vdW50VHJuID0gdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmRvd25sb2FkLWFtb3VudCcsICdBbW91bnQnKTtcbiAgICB2YXIgY3VycmVuY3lUcm4gPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y3VycmVuY3knLCAnQ3VycmVuY3knKTtcbiAgICB2YXIgcGVyY2VudGFnZVRybiA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpwZXJjZW50YWdlJywgJ1BlcmNlbnRhZ2UnKTtcbiAgICB2YXIgdHlwZVRybiA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDp0eXBlJywgJ1R5cGUnKTtcbiAgICB2YXIgeWVhclRybiA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDp5ZWFyJywgJ1llYXInKTtcblxuXHRpZiAodGhpcy5tb2RlbC51cmwuaW5kZXhPZignL3RvcHMnKSA+IC0xKSB7XG5cdCAgICBoZWFkZXJSb3cucHVzaCh0aGlzLm1vZGVsLmdldCgndGl0bGUnKSk7XG5cdCAgICBoZWFkZXJSb3cucHVzaChhbW91bnRUcm4pO1xuXHQgICAgaGVhZGVyUm93LnB1c2goY3VycmVuY3lUcm4pO1xuXHQgICAgaGVhZGVyUm93LnB1c2godHlwZVRybik7XG5cdH0gZWxzZSBpZiAodGhpcy5tb2RlbC51cmwuaW5kZXhPZignL2FpZC1wcmVkaWN0YWJpbGl0eScpID4gLTEpIHtcblx0ICAgIGhlYWRlclJvdy5wdXNoKHllYXJUcm4pO1xuXHQgICAgXy5lYWNoKGtleXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgIFx0aGVhZGVyUm93LnB1c2goaXRlbSk7XG5cdCAgICB9KTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKGN1cnJlbmN5VHJuKTtcblx0fSBlbHNlIGlmICh0aGlzLm1vZGVsLnVybC5pbmRleE9mKCcvZnR5cGUnKSA+IC0xKSB7XG5cdFx0aGVhZGVyUm93LnB1c2goeWVhclRybik7XG5cdCAgICBfLmVhY2goa2V5cywgZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgXHRoZWFkZXJSb3cucHVzaChpdGVtKTtcblx0ICAgIH0pO1xuXHQgICAgaGVhZGVyUm93LnB1c2goY3VycmVuY3lUcm4pO1xuXHQgICAgaGVhZGVyUm93LnB1c2godHlwZVRybik7XG5cdH0gZWxzZSBpZiAodGhpcy5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHtcblx0XHQvLyBGb3IgQU1QLTIzNTgyOiB3ZSBkb250IHdhbnQgdGhlIG5hbWUgZnJvbSBcInN1bW1hcnlcIiBiZWNhdXNlIHRoYXRzIHRoZSBvcmlnTmFtZSBhbmQgbm90IGFsd2F5cyB0aGUgc2FtZSBuYW1lIHRoYW4gdGhlIFggYXhpcyBjb21ibyBzZWxlY3Rvci4gXG5cdFx0dmFyIGZpcnN0Q29sdW1uTmFtZSA9IF8uZmluZChzZWxmLm1vZGVsLmdldCgnaGVhdG1hcF9jb25maWcnKS5tb2RlbHNbMF0uZ2V0KCdjb2x1bW5zJyksIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLm9yaWdOYW1lID09PSBzZWxmLm1vZGVsLmdldCgnc3VtbWFyeScpWzBdO1xuXHRcdH0pLm5hbWU7IFxuXHRcdHZhciBzZWNvbmRDb2x1bW5OYW1lID0gXy5maW5kKHNlbGYubW9kZWwuZ2V0KCdoZWF0bWFwX2NvbmZpZycpLm1vZGVsc1swXS5nZXQoJ2NvbHVtbnMnKSwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0ub3JpZ05hbWUgPT09IHNlbGYubW9kZWwuZ2V0KCdzdW1tYXJ5JylbMV07XG5cdFx0fSkubmFtZTtcblx0XHRoZWFkZXJSb3cucHVzaChmaXJzdENvbHVtbk5hbWUpO1xuXHRcdGhlYWRlclJvdy5wdXNoKHNlY29uZENvbHVtbk5hbWUpO1xuXHQgICAgaGVhZGVyUm93LnB1c2goYW1vdW50VHJuKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKHBlcmNlbnRhZ2VUcm4pO1xuXHQgICAgaGVhZGVyUm93LnB1c2goY3VycmVuY3lUcm4pO1xuXHQgICAgaGVhZGVyUm93LnB1c2godHlwZVRybik7XG5cdH1cblxuICAgIGNzdlRyYW5zZm9ybWVkLnVuc2hpZnQoaGVhZGVyUm93KTtcbiAgICAvKiBBZGQgc2VwPSwgZm9yIGF1dG9tYXRpYyBFeGNlbCBzdXBwb3J0IGF0IHRoZSB2ZXJ5IHRvcCBvZiB0aGUgZmlsZSB3b3JrcyBidXQgYnJlYWtzIEJPTSB1bmljb2RlLlxuICAgICAqIExldCB1cyB1c2UgdGFiLWRlbGltaXRlZCBpbnN0ZWFkLlxuICAgICAqICBUaGlzIHdlYnNpdGUgc2hvd3MgYSBjc3Ygd2l0aCBUYWItZGVsaW1pdGVkLCB1dGYxNmxlIHdpdGggYSBCT00gaGFzIGJlc3QgRXhjZWwgc3VwcG9ydCAodmlhIFN0YWNrT3ZlcmZsb3cpOlxuICAgICAqICBodHRwOi8vd2lraS5zY24uc2FwLmNvbS93aWtpL2Rpc3BsYXkvQUJBUC9DU1YrdGVzdHMrb2YrZW5jb2RpbmcrYW5kK2NvbHVtbitzZXBhcmF0b3JcbiAgICAgKi9cblxuICAgIHRleHRDb250ZW50ID0gYmFieS51bnBhcnNlKGNzdlRyYW5zZm9ybWVkLCB7XG4gICAgICBkZWxpbWl0ZXI6ICc7JyxcbiAgICAgIGVuY29kaW5nOiAndXRmLTE2JyxcbiAgICBcdHF1b3RlczogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgcHJldmlldy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2Nzdi1wcmV2aWV3Jyk7XG4gICAgcHJldmlldy52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIGNzdkNvbnRhaW5lci5odG1sKHByZXZpZXcpO1xuXG4gICAgaWYgKCF0aGlzLmFwcC5oYXNJc3N1ZSgnZG93bmxvYWQnKSkge1xuICAgICAgdGV4dENvbnRlbnQgPSB1dGlsLnRleHRBc0RhdGFVUkwodGV4dENvbnRlbnQpO1xuICAgIH1cblxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KF8oZnVuY3Rpb24oKSB7ICAvLyBzdHVwaWQgYm9vdHN0cmFwIG1vZGFscy4uLlxuICAgICAgLy8gdGhpcyBzZXRUaW1lb3V0IGlzIG5lZWRlZCBmb3IgdGhlIGZsYXNoIGZhbGxiYWNrIDooXG4gICAgICB0aGlzLm1ha2VEb3dubG9hZGFibGUodGV4dENvbnRlbnQsICdkYXRhJywgJy5jc3YnKTtcbiAgICB9KS5iaW5kKHRoaXMpLCAxMDApO1xuICB9LFxuXG4gIG1ha2VEb3dubG9hZGFibGU6IGZ1bmN0aW9uKHN0dWZmLCB3aGF0LCBleHQpIHtcblx0dmFyIG1lc3NhZ2VLZXkgPSBbJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtJywgdGhpcy5tb2RlbC5nZXQoJ25hbWUnKS5yZXBsYWNlKC8gL2csICcnKV0uam9pbignJylcblx0dmFyIHRyYW5zbGF0ZWROYW1lID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhtZXNzYWdlS2V5LCB0aGlzLm1vZGVsLmdldCgnbmFtZScpKTtcbiAgICB2YXIgZmlsZU5hbWUgPSB0cmFuc2xhdGVkTmFtZSArIGV4dCxcbiAgICAgICAgZGxCdXR0b24gPSB0aGlzLiQoJy5kb3dubG9hZC1jaGFydCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgIGRsQnV0dG9uLmZpbmQoJy53b3JkJykudGV4dCgnRG93bmxvYWQgJyArIHdoYXQpLmF0dHIoJ2RhdGEtaTE4bicsICdhbXAuZGFzaGJvYXJkOmRvd25sb2FkLWRvd25sb2FkLScgKyB3aGF0KTtcbiAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oZGxCdXR0b24pO1xuXG4gICAgaWYgKHRoaXMuYXBwLmhhc0lzc3VlKCdkb3dubG9hZCcpKSB7XG4gICAgICBpZiAodGhpcy5hcHAuaGFzSXNzdWUoJ2ZsYXNoJykpIHtcbiAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdZb3VyIGJyb3dzZXIgaXMgbWlzc2luZyBmZWF0dXJlcyB0byBpbml0aWF0ZSB0aGUgZG93bmxvYWQnLCBbXG4gICAgICAgICAgJ1lvdSBtaWdodCBiZSBhYmxlIHRvIHNhdmUgdGhpcyBjaGFydCBtYW51YWxseSBieSByaWdodC1jbGlja2luZyB0aGUgJyArXG4gICAgICAgICAgJ3ByZXZpZXcgYW5kIHNlbGVjdGluZyBcIlNhdmUgUGljdHVyZSBBcy4uLiddKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJhZCBicm93c2VyLCBidXQgaGFzIGZsYXNoISBmYWxsYmFjayB0byBkb3dubG9hZGlmeVxuICAgICAgICB0aGlzLmFwcC50cnlUbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB3aW5kb3cuRG93bmxvYWRpZnkuY3JlYXRlKGRsQnV0dG9uWzBdLCB7XG4gICAgICAgICAgICBzd2Y6ICcvVEVNUExBVEUvYW1wVGVtcGxhdGUvY29tbW9uTWVkaWEvZG93bmxvYWRpZnkuc3dmJyxcbiAgICAgICAgICAgIGRvd25sb2FkSW1hZ2U6ICcvVEVNUExBVEUvYW1wVGVtcGxhdGUvY29tbW9uTWVkaWEvZG93bmxvYWQtYnV0dG9uLXN0YXRlcy5wbmc/cmV2PTQnLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB3aWR0aDogMTc2LFxuICAgICAgICAgICAgaGVpZ2h0OiAzNCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGRhdGE6IHN0dWZmXG4gICAgICAgICAgICAgIC5yZXBsYWNlKCdkYXRhOnRleHQvcGxhaW47YmFzZTY0LC8vJywgJycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsJywgJycpLFxuICAgICAgICAgICAgZGF0YVR5cGU6IGV4dCA9PT0gJy5jc3YnID8gJ3N0cmluZycgOiAnYmFzZTY0JyxcbiAgICAgICAgICAgIGFwcGVuZDogdHJ1ZSxcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aGlzLmFwcC5yZXBvcnQoJ0NvdWxkIG5vdCBkb3dubG9hZCB0aGUgZmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJCgnLmRvd25sb2FkLWNoYXJ0JylcbiAgICAgICAgLmF0dHIoJ2hyZWYnLCBzdHVmZilcbiAgICAgICAgLmF0dHIoJ2Rvd25sb2FkJywgZmlsZU5hbWUpO1xuICAgIH1cblxuICAgIC8vIEFNUC0xOTgxM1xuICAgIGlmIChleHQuaW5kZXhPZignY3N2JykgIT09IC0xKSB7XG4gICAgXHQkKCcubW9kYWwtcHJldmlldy1hcmVhJykucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gIDxoZWFkZXIgY2xhc3M9XFxcInNwYWNlZCB0ZXh0LWNlbnRlclxcXCI+XFxuICAgIDxoMj5cXG4gICAgICBUaGUgYXBwbGljYXRpb24gZW5jb3VudGVyZWQgYW5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidGV4dC1kYW5nZXJcXFwiPmVycm9yPC9zcGFuPlxcbiAgICAgIDxzbWFsbD46KDwvc21hbGw+XFxuICAgIDwvaDI+XFxuICAgIDxwPjwlPSBlcnIgJT48L3A+XFxuICA8L2hlYWRlcj5cXG48L2Rpdj5cXG5cIik7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMuZXJyID0gb3B0aW9ucy5lcnI7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKHsgZXJyOiB0aGlzLmVyciB9KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG5cbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbC14cy0xMiBjb2wtbWQtNVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBwdWxsLXJpZ2h0IHNob3ctZmlsdGVyc1xcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1lZGl0XFxcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1lZGl0XFxcIj5FZGl0IGZpbHRlcnM8L3NwYW4+XFxuICAgICAgPC9idXR0b24+XFxuICAgICAgPGgzIGNsYXNzPVxcXCJpbmxpbmUtaGVhZGluZ1xcXCIgZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnRpdGxlLWZpbHRlcnNcXFwiPkZpbHRlcnM8L2gzPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImFwcGxpZWQtZmlsdGVyc1xcXCI+XFxuICAgICAgICA8ZW0gZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOmZpbHRlcnMtbG9hZGluZ1xcXCI+TG9hZGluZy4uLjwvZW0+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBpZD1cXFwiZmlsdGVyLXBvcHVwXFxcIj48L2Rpdj5cXG5cIik7XG52YXIgc3VtbWFyeVRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjwlIGlmICghY291bnRBcHBsaWVkKSB7ICU+XFxuICA8ZW0gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtbm9uZS1hcHBsaWVkXFxcIj5ObyBmaWx0ZXJzIGFwcGxpZWQ8L2VtPlxcbjwlIH0gZWxzZSB7ICU+XFxuICA8c3Bhbj5cXG4gICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBzaG93LWZpbHRlci1kZXRhaWxzXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1leWUtb3BlblxcXCI+PC9zcGFuPlxcbiAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLXNob3ctc2V0dGluZ3NcXFwiPlNob3cgZmlsdGVyIHNldHRpbmdzPC9zcGFuPlxcbiAgICAgICg8Yj48JT0gY291bnRBcHBsaWVkICU+PC9iPilcXG4gICAgPC9idXR0b24+XFxuICA8L3NwYW4+XFxuPCUgfSAlPlxcblwiKTtcbnZhciBkZXRhaWxzVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdj5cXG4gIDxoNCBjbGFzcz1cXFwiaW5saW5lLWhlYWRpbmdcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWFjdGl2ZVxcXCI+QWN0aXZlIEZpbHRlcnM8L2g0PlxcbiAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0IGhpZGUtZmlsdGVyLWRldGFpbHNcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1leWUtY2xvc2VcXFwiPjwvc3Bhbj5cXG4gICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtaGlkZS1kZXRhaWxzXFxcIj5IaWRlIGZpbHRlciBkZXRhaWxzPC9zcGFuPlxcbiAgPC9idXR0b24+XFxuPC9kaXY+XFxuPCUgXyhhcHBsaWVkKS5lYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyAlPlxcbiAgPGg1PlxcbiAgICA8YSBocmVmPVxcXCIjZmlsdGVyLWRldGFpbC08JT0gZmlsdGVyLmlkICU+XFxcIiBkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIj48JT0gZmlsdGVyLm5hbWUgJT48L2E+XFxuICAgICg8JT0gZmlsdGVyLmRldGFpbC5sZW5ndGggJT4pXFxuICA8L2g1PlxcbiAgPHVsIGlkPVxcXCJmaWx0ZXItZGV0YWlsLTwlPSBmaWx0ZXIuaWQgJT5cXFwiIGNsYXNzPVxcXCJjb2xsYXBzZVxcXCI+XFxuICAgIDwlIF8oZmlsdGVyLmRldGFpbCkuZWFjaChmdW5jdGlvbihkZXRhaWwpIHsgJT5cXG4gICAgICA8bGk+PCU9IGRldGFpbCAlPjwvbGk+XFxuICAgIDwlIH0pICU+XFxuICA8L3VsPlxcbjwlIH0pICU+XCIpO1xudmFyIGZpbHRlcnNWaWV3TG9nID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vLi4vLi4vcmVhbXAvdG9vbHMvbG9nJykoJ2FtcDpkYXNoYm9hcmRzOmZpbHRlcnM6dmlldycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLnNob3ctZmlsdGVycyc6ICdzaG93RmlsdGVyJyxcbiAgICAnY2xpY2sgLnNob3ctZmlsdGVyLWRldGFpbHMnOiAnc2hvd0ZpbHRlckRldGFpbHMnLFxuICAgICdjbGljayAuaGlkZS1maWx0ZXItZGV0YWlscyc6ICdoaWRlRmlsdGVyRGV0YWlscydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZpbmlzaGVkRmlyc3RMb2FkID0gZmFsc2U7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuYXBwLmZpbHRlciwgJ2NhbmNlbCcsIHRoaXMuaGlkZUZpbHRlcik7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmFwcC5maWx0ZXIsICdhcHBseScsIHRoaXMuYXBwbHlGaWx0ZXIpO1xuICAgIHRoaXMuYXBwLmdlbmVyYWxTZXR0aW5ncy5sb2FkKCkuZG9uZShfKGZ1bmN0aW9uKCkgeyAgICAgXG4gICAgICB0aGlzLmFwcC5maWx0ZXIubG9hZGVkLmRvbmUoXyhmdW5jdGlvbigpIHsgICAgICAgIFxuICAgICAgICB0aGlzLmFwcC5zdGF0ZS5yZWdpc3Rlcih0aGlzLCAnZmlsdGVycycsIHtcbiAgICAgICAgICAgIGdldDogXyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHAuZmlsdGVyLnNlcmlhbGl6ZSgpOyAgICAgICAgICAgIFxuICAgICAgICAgIH0pLmJpbmQodGhpcyksXG4gICAgICAgICAgc2V0OiBfKGZ1bmN0aW9uKHN0YXRlKSB7ICAgICAgICBcdFxuICAgICAgICAgICAgaWYgKF8uaXNFbXB0eShzdGF0ZSkpeyAgICAgICAgICAgIFxuICAgICAgICAgICAgXHRzZWxmLmFwcC5maWx0ZXIuZXh0cmFjdERhdGVzKHNlbGYuYXBwLmdlbmVyYWxTZXR0aW5ncywgc3RhdGUsICdkYXNoYm9hcmQtZGVmYXVsdC1taW4tZGF0ZScsICdkYXNoYm9hcmQtZGVmYXVsdC1tYXgtZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHAuZmlsdGVyLmRlc2VyaWFsaXplKHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLmZpbHRlci5maW5pc2hlZEZpcnN0TG9hZCA9IHRydWU7XG4gICAgICAgICAgfSkuYmluZCh0aGlzKSxcbiAgICAgICAgICBlbXB0eToge31cbiAgICAgICAgfSk7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpO1xuICAgIHRoaXMuYXBwLmZpbHRlci5zZXRFbGVtZW50KHRoaXMuZWwucXVlcnlTZWxlY3RvcignI2ZpbHRlci1wb3B1cCcpKTtcbiAgICB0aGlzLmhpZGVGaWx0ZXIoKTtcbiAgICB0aGlzLmFwcC5maWx0ZXIubG9hZGVkXG4gICAgICAuZG9uZShfKHRoaXMucmVuZGVyQXBwbGllZCkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJCgnLmFwcGxpZWQtZmlsdGVycycpLmh0bWwoJzxzdHJvbmcgY2xhc3M9XCJ0ZXh0LWRhbmdlciBmaWx0ZXJzLWVyclwiPicgK1xuICAgICAgICAgICdGYWlsZWQgdG8gbG9hZCBmaWx0ZXJzPC9zdHJvbmc+IDxhIGhyZWY9XCJcIiBjbGFzcz1cImJ0biBidG4td2FybmluZyBidG4tc21cIj4nICtcbiAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2hcIj48L3NwYW4+IFJlZnJlc2ggcGFnZTwvYT4nKTtcbiAgICAgICAgdGhpcy4kKCdidXR0b24nKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlckFwcGxpZWQ6IGZ1bmN0aW9uKCkge1x0ICBcbiAgICB2YXIgZmlsdGVyT2JqZWN0ID0gdGhpcy5hcHAuZmlsdGVyLnNlcmlhbGl6ZVRvTW9kZWxzKCk7XG4gICAgdmFyIGNvdW50QXBwbGllZCA9IF8oZmlsdGVyT2JqZWN0LmZpbHRlcnMpLmtleXMoKS5sZW5ndGg7XG4gICAgdGhpcy4kKCcuYXBwbGllZC1maWx0ZXJzJykuaHRtbChzdW1tYXJ5VGVtcGxhdGUoeyBjb3VudEFwcGxpZWQ6IGNvdW50QXBwbGllZCB9KSk7XG4gICAgdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00odGhpcy5lbCk7XG4gIH0sXG5cbiAgc2hvd0ZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHAuZmlsdGVyLnNob3dGaWx0ZXJzKCk7XG4gICAgdGhpcy4kKCcjZmlsdGVyLXBvcHVwJykuc2hvdygpO1xuICB9LFxuXG4gIGhpZGVGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJCgnI2ZpbHRlci1wb3B1cCcpLmhpZGUoKTtcbiAgfSxcblxuICBhcHBseUZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gdG9kbzogYWN0dWFsbHkgZG8gYW4gZWZmZWN0IGZvciBjaGFuZ2VkIGZpbHRlcnMuLi5cbiAgICB0aGlzLmhpZGVGaWx0ZXIoKTtcbiAgICB0aGlzLnJlbmRlckFwcGxpZWQoKTtcbiAgfSxcblxuICBzaG93RmlsdGVyRGV0YWlsczogZnVuY3Rpb24oKSB7XG5cdHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmlsdGVyT2JqZWN0ID0gdGhpcy5hcHAuZmlsdGVyLnNlcmlhbGl6ZVRvTW9kZWxzKCk7IFxuICAgIHZhciBhcHBsaWVkID0gXyhmaWx0ZXJPYmplY3QuZmlsdGVycykubWFwKGZ1bmN0aW9uKGZpbHRlciwga2V5KSB7XG4gICAgICB2YXIgZmlsdGVyRmllbGQgPSBmaWx0ZXJPYmplY3QuZmlsdGVyc1trZXldO1xuICAgICAgaWYoZmlsdGVyRmllbGQubW9kZWxUeXBlID09PSAnWUVBUi1TSU5HTEUtVkFMVUUnIHx8IGZpbHRlckZpZWxkLm1vZGVsVHlwZSA9PT0gJ0RBVEUtUkFOR0UtVkFMVUVTJyl7XG4gICAgXHQgIHJldHVybiBzZWxmLmdldEFwcGxpZWREYXRlT2JqZWN0KGZpbHRlck9iamVjdCxrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICBcdCAgcmV0dXJuIHtcbiAgICBcdCAgICAgICAgbmFtZTogZmlsdGVyLmZpbHRlck5hbWUgfHwga2V5LFxuICAgIFx0ICAgICAgICBpZDoga2V5LnJlcGxhY2UoL1teXFx3XS9nLCAnJyksIC8vIHJlbW92ZSBhbnl0aGluZyBub24tYWxwaGFudW1cbiAgICBcdCAgICAgICAgZGV0YWlsOiBfKGZpbHRlcikubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgXHQgICAgICAgICAgaWYgKHZhbHVlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIFx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldCgnbmFtZScpO1xuICAgIFx0ICAgICAgICAgIH0gZWxzZSB7XG4gICAgXHQgICAgICAgICAgICAvLyBUbyBmaXggcHJvYmxlbSB3aXRoIGRhdGVzLlxuICAgIFx0ICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBrZXkgJiYgdmFsdWUgIT09IGZpbHRlci5maWx0ZXJOYW1lKSB7XG4gICAgXHQgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBcdCAgICAgICAgICAgIH1cbiAgICBcdCAgICAgICAgICB9XG4gICAgXHQgICAgICAgIH0pXG4gICAgXHQgICAgICB9OyAgXG4gICAgICB9XG4gICAgICBcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLiQoJy5hcHBsaWVkLWZpbHRlcnMnKS5odG1sKGRldGFpbHNUZW1wbGF0ZSh7IGFwcGxpZWQ6IGFwcGxpZWQgfSkpO1xuICAgIHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKHRoaXMuZWwpO1xuICB9LFxuICBnZXRBcHBsaWVkRGF0ZU9iamVjdDogZnVuY3Rpb24oZmlsdGVyT2JqZWN0LCBmaWx0ZXJLZXkpe1xuXHQgIHZhciBmaWx0ZXJGaWVsZCA9IGZpbHRlck9iamVjdC5maWx0ZXJzW2ZpbHRlcktleV07XG5cdCAgdmFyIGRhdGVSYW5nZVRleHQgPSAnJztcblx0ICBpZihmaWx0ZXJLZXkgPT09ICdkYXRlJykge1xuXHRcdCAgZGF0ZVJhbmdlVGV4dCA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmRhdGUtcmFuZ2VcIiwgXCJEYXRlIFJhbmdlXCIpO1xuXHQgIH0gZWxzZSBpZihmaWx0ZXJLZXkgPT09ICdjb21wdXRlZC15ZWFyJykge1xuXHRcdCAgZGF0ZVJhbmdlVGV4dCA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNvbXB1dGVkWWVhclwiLCBcIkNvbXB1dGVkIFllYXJcIik7XG5cdCAgfSBlbHNlIHtcblx0XHQgIGRhdGVSYW5nZVRleHQgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpcIiArIGZpbHRlcktleS5yZXBsYWNlKC9bXlxcd10vZywgJy0nKSwgZmlsdGVyS2V5KTtcblx0ICB9XG5cdCAgdmFyIGRldGFpbCA9IGZpbHRlckZpZWxkLm1vZGVsVHlwZSA9PT0gJ1lFQVItU0lOR0xFLVZBTFVFJz8gZmlsdGVyRmllbGQueWVhcjogdGhpcy5hcHAuZmlsdGVyLmZvcm1hdERhdGUoZmlsdGVyRmllbGQuc3RhcnQpICsgJyZtZGFzaDsnICsgdGhpcy5hcHAuZmlsdGVyLmZvcm1hdERhdGUoZmlsdGVyRmllbGQuZW5kKVxuXHQgIHJldHVybiB7XG5cdFx0ICBpZDogZmlsdGVyS2V5LnJlcGxhY2UoL1teXFx3XS9nLCAnLScpLFxuXHRcdCAgbmFtZTogZGF0ZVJhbmdlVGV4dCxcblx0XHQgIGRldGFpbDogW2RldGFpbF1cblx0XHR9O1x0ICBcbiAgfSxcbiAgaGlkZUZpbHRlckRldGFpbHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVuZGVyQXBwbGllZCgpO1xuICB9XG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG52YXIgU3RhdGVMb2FkRXJyb3IgPSByZXF1aXJlKCdhbXAtc3RhdGUvaW5kZXgnKS5TdGF0ZUxvYWRFcnJvcjtcblxudmFyIENvbnRyb2xzID0gcmVxdWlyZSgnLi9jb250cm9scycpO1xudmFyIENoYXJ0c1ZpZXcgPSByZXF1aXJlKCcuL2NoYXJ0cycpO1xudmFyIENoYXJ0cyA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydHMtY29sbGVjdGlvbicpO1xudmFyIGJvaWxlcnBsYXRlID0gcmVxdWlyZSgnYW1wLWJvaWxlcnBsYXRlJyk7XG52YXIgSGVhdE1hcENoYXJ0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LWhlYXRtYXBzJyk7XG52YXIgVG9wc0NoYXJ0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LXRvcHMnKTtcbnZhciBQcmVkaWN0YWJpbGl0eUNoYXJ0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LWFpZC1wcmVkaWN0YWJpbGl0eScpO1xudmFyIEZ1bmRpbmdUeXBlQ2hhcnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhcnQtZnVuZGluZy10eXBlJyk7XG5cbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbjwvZGl2PlxcblwiKTtcbnZhciBtb2RhbFRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcIm1vZGFsIGZhZGVcXFwiIGlkPVxcXCI8JT0gbS5pZCAlPlxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJkaWFsb2dcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwibXlNb2RhbExhYmVsXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2cgPCU9IG0uc3BlY2lhbENsYXNzICU+XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtaGVhZGVyXFxcIj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPjxzcGFuIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9zcGFuPjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjbG9zZVxcXCIgY2xhc3M9XFxcInNyLW9ubHlcXFwiPkNsb3NlPC9zcGFuPjwvYnV0dG9uPlxcbiAgICAgICAgPGg0IGNsYXNzPVxcXCJtb2RhbC10aXRsZSB0ZXh0LTwlPSBtLnRvbmUgJT5cXFwiIGRhdGEtaTE4bj1cXFwiPCU9IG0uaTE4blRpdGxlICU+XFxcIj48JT0gbS50aXRsZSAlPjwvaDQ+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxuICAgICAgICA8JSBpZiAobS5jb250ZW50KSB7ICU+XFxuICAgICAgICAgIDwlPSBtLmNvbnRlbnQgJT5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwlIGlmIChtLm1lc3NhZ2VzKSB7ICU+XFxuICAgICAgICAgIDwlIF8obS5tZXNzYWdlcykuZWFjaChmdW5jdGlvbihtZXNzYWdlKSB7ICU+XFxuICAgICAgICAgICAgPHA+PCU9IG1lc3NhZ2UgJT48L3A+XFxuICAgICAgICAgIDwlIH0pICU+XFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgPC9kaXY+ICAgICAgXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCIpO1xuXG52YXIgRW5hYmxlZENoYXJ0c0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9tb2RlbHMvZW5hYmxlZC1jaGFydHMtY29sbGVjdGlvbicpO1xudmFyIEhlYXRtYXBzQ29uZmlnQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL21vZGVscy9oZWF0bWFwcy1jb25maWctY29sbGVjdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgYWxyZWFkeSBkbyBvdGhlciBmZXRjaGVzIG9uIGluaXQgc28uLi5cbiAgICB0aGlzLmFwcC51c2VyLmZldGNoKCk7XG4gICAgdGhpcy5jb250cm9scyA9IG5ldyBDb250cm9scyh7IGFwcDogdGhpcy5hcHAgfSk7XG5cbiAgICAvLyBBTVAtMTk1NDU6IFdlIGluc3RhbnRpYXRlIHRoZSBjb2xsZWN0aW9uIG9mIGVuYWJsZWQgY2hhcnRzIChmcm9tIEZNKSBhbmQgdXNlIGl0IHRvIGVuYWJsZSBvciBub3QgZWFjaCBjaGFydC5cbiAgICB2YXIgZW5hYmxlZENoYXJ0c0ZNID0gbmV3IEVuYWJsZWRDaGFydHNDb2xsZWN0aW9uKCk7XG4gICAgZW5hYmxlZENoYXJ0c0ZNLmZldGNoRGF0YSgpO1xuICAgIFxuICAgIC8vIEdldCBjb25maWcgb2YgYWxsIGhlYXRtYXBzIGZyb20gYmFja2VuZC5cbiAgICB2YXIgaGVhdG1hcHNDb25maWdzID0gbmV3IEhlYXRtYXBzQ29uZmlnQ29sbGVjdGlvbigpO1xuICAgIGhlYXRtYXBzQ29uZmlncy5mZXRjaERhdGEoKTtcbiAgICBcbiAgICBpZihlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnZXJyb3InKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoZSBzYW1lIGVuZHBvaW50IHdpbGwgc2VuZCBhbiBlcnJvciBpZiAnREFTSEJPQVJEUycgaXMgbm90IGFjdGl2ZSBpbiB0aGUgRmVhdHVyZSBNYW5hZ2VyLlxuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSAnLyc7XG4gICAgfVxuICAgIFxuICAgIHZhciBjb2wgPSBbXTtcbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1RvcCBEb25vcnMnfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBUb3BzQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ1RvcCBEb25vciBBZ2VuY2llcycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG4gIFx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvZG8nIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdUb3AgRG9ub3IgR3JvdXAnfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBUb3BzQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ1RvcCBEb25vciBHcm91cHMnLCBiaWc6IGZhbHNlLCB2aWV3OiAnYmFyJyB9LFxuICBcdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL2RnJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnVG9wIFJlZ2lvbnMnfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBUb3BzQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ1RvcCBSZWdpb25zJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvcmUnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdUb3AgU2VjdG9ycyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnVG9wIFNlY3RvcnMnLCBiaWc6IGZhbHNlLCB2aWV3OiAnYmFyJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9wcycgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ0FpZCBQcmVkaWN0YWJpbGl0eSd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFByZWRpY3RhYmlsaXR5Q2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ0FpZCBQcmVkaWN0YWJpbGl0eScgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL2FpZC1wcmVkaWN0YWJpbGl0eScgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ0Z1bmRpbmcgVHlwZSd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IEZ1bmRpbmdUeXBlQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ0Z1bmRpbmcgVHlwZScgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL2Z0eXBlJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnUmVzcG9uc2libGUgT3JnYW5pemF0aW9ucyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnUmVzcG9uc2libGUgT3JnYW5pemF0aW9ucycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG5cdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL3JvJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnQmVuZWZpY2lhcnkgQWdlbmNpZXMnfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBUb3BzQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ0JlbmVmaWNpYXJ5IEFnZW5jaWVzJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvYmEnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdFeGVjdXRpbmcgQWdlbmNpZXMnfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBUb3BzQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ0V4ZWN1dGluZyBBZ2VuY2llcycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG5cdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL2VhJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnSW1wbGVtZW50aW5nIEFnZW5jaWVzJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgVG9wc0NoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdJbXBsZW1lbnRpbmcgQWdlbmNpZXMnLCBiaWc6IGZhbHNlLCB2aWV3OiAnYmFyJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9pYScgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1BlYWNlLWJ1aWxkaW5nIGFuZCBTdGF0ZS1idWlsZGluZyBHb2Fscyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgICBcdFx0XHR7IG5hbWU6ICdQZWFjZS1idWlsZGluZyBhbmQgU3RhdGUtYnVpbGRpbmcgR29hbHMnLCBiaWc6IHRydWUsIHNob3dDYXRlZ29yaWVzSW5mbzogdHJ1ZSwgdmlldzogJ3BpZScgfSxcbiAgICBcdFx0XHR7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL25kZCcgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1NlY3RvciBGcmFnbWVudGF0aW9uJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgSGVhdE1hcENoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdIZWF0TWFwIGJ5IFNlY3RvciBhbmQgRG9ub3IgR3JvdXAnLCB0aXRsZTogJ1NlY3RvciBGcmFnbWVudGF0aW9uJywgYmlnOiB0cnVlLCB2aWV3OiAnaGVhdG1hcCcsIGhlYXRtYXBfY29uZmlnOiBoZWF0bWFwc0NvbmZpZ3MsIGhlYXRtYXBfdHlwZTogJ3NlY3RvcicgfSxcbiAgXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvaGVhdC1tYXAvc2VjJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnTG9jYXRpb24gRnJhZ21lbnRhdGlvbid9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IEhlYXRNYXBDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnSGVhdE1hcCBieSBMb2NhdGlvbiBhbmQgRG9ub3IgR3JvdXAnLCB0aXRsZTogJ0xvY2F0aW9uIEZyYWdtZW50YXRpb24nLCBiaWc6IHRydWUsIHZpZXc6ICdoZWF0bWFwJywgaGVhdG1hcF9jb25maWc6IGhlYXRtYXBzQ29uZmlncywgaGVhdG1hcF90eXBlOiAnbG9jYXRpb24nIH0sXG4gIFx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL2hlYXQtbWFwL2xvYycgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1Byb2dyYW0gRnJhZ21lbnRhdGlvbid9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IEhlYXRNYXBDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnSGVhdE1hcCBieSBQcm9ncmFtIGFuZCBEb25vciBHcm91cCcsIHRpdGxlOiAnUHJvZ3JhbSBGcmFnbWVudGF0aW9uJywgYmlnOiB0cnVlLCB2aWV3OiAnaGVhdG1hcCcsIGhlYXRtYXBfY29uZmlnOiBoZWF0bWFwc0NvbmZpZ3MsIGhlYXRtYXBfdHlwZTogJ3Byb2dyYW0nIH0sXG4gIFx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL2hlYXQtbWFwL3ByZycgfSkpO1xuICAgIH1cbiAgICAgICBcbiAgICB2YXIgY2hhcnRzQ29sbGVjdGlvbiA9IG5ldyBDaGFydHMoY29sLCB7IGFwcDogdGhpcy5hcHAgfSk7XG4gICAgdGhpcy5jaGFydHMgPSBuZXcgQ2hhcnRzVmlldyh7XG4gICAgICBhcHA6IHRoaXMuYXBwLFxuICAgICAgY29sbGVjdGlvbjogY2hhcnRzQ29sbGVjdGlvblxuICAgIH0pO1xuICAgIFxuICAgIC8vYXV0by1yZW5kZXJzIHRoZSBsYXlvdXRcbiAgICB0aGlzLmhlYWRlcldpZGdldCA9IG5ldyBib2lsZXJwbGF0ZS5sYXlvdXQoXG4gICAgICB7XG4gICAgICAgIGNhbGxlcjogJ0RBU0hCT0FSRCdcblx0ICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoKSk7XG4gICAgdGhpcy4kKCcuY29udGFpbmVyJykuaHRtbChbXG4gICAgICB0aGlzLmNvbnRyb2xzLnJlbmRlcigpLmVsLFxuICAgICAgdGhpcy5jaGFydHMucmVuZGVyKCkuZWwsXG4gICAgXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbW9kYWw6IGZ1bmN0aW9uKHRpdGxlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8oe1xuICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgaWQ6IF8udW5pcXVlSWQoJ21vZGFsJylcbiAgICB9KS5leHRlbmQob3B0aW9ucyk7XG4gICAgdGhpcy4kZWwucGFyZW50KCkuYXBwZW5kKG1vZGFsVGVtcGxhdGUoe206IG9wdGlvbnN9KSk7XG4gICAgdmFyIHRoaXNNb2RhbCA9IHRoaXMuJGVsLnBhcmVudCgpLmZpbmQoJyMnICsgb3B0aW9ucy5pZCk7XG4gICAgaWYgKG9wdGlvbnMuYm9keUVsKSB7IHRoaXNNb2RhbC5maW5kKCcubW9kYWwtYm9keScpLmh0bWwob3B0aW9ucy5ib2R5RWwpOyB9XG4gICAgdGhpc01vZGFsLm1vZGFsKCk7XG4gICAgcmV0dXJuIHRoaXNNb2RhbFswXTsgIC8vIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnRcbiAgfVxuXG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbC14cy0xMiBjb2wtc20tNiBjb2wtbWQtM1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbiAgICAgIDxoMyBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZGFzaGJvYXJkLXNldHRpbmdzXFxcIiBjbGFzcz1cXFwiaW5saW5lLWhlYWRpbmdcXFwiIHN0eWxlPVxcXCJtYXgtd2lkdGg6IDUwcHg7b3ZlcmZsb3cteDogdmlzaWJsZVxcXCI+U2V0dGluZ3M8L2gzPlxcbiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBwdWxsLXJpZ2h0IGRhc2gtc2V0dGluZ3MtYnV0dG9uXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWVkaXRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpzZXR0aW5ncy1lZGl0XFxcIj5lZGl0IHNldHRpbmdzPC9zcGFuPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgaWQ9XFxcImFtcC1zZXR0aW5nc1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjwvZGl2PlxcblwiKTtcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5kYXNoLXNldHRpbmdzLWJ1dHRvbic6ICdlZGl0U2V0dGluZ3MnXG4gIH0sXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwOyAgICBcbiAgICB0aGlzLmFwcC5zZXR0aW5nc1dpZGdldC5kZWZpbml0aW9ucy5sb2FkZWQuZG9uZShfKGZ1bmN0aW9uKCkge1xuICAgICB0aGlzLmFwcC5zdGF0ZS5yZWdpc3Rlcih0aGlzLCAnc2V0dGluZ3MnLCB7XG4gICAgICAgIGdldDogdGhpcy5hcHAuc2V0dGluZ3NXaWRnZXQudG9BUElGb3JtYXQsXG4gICAgICAgIHNldDogdGhpcy5hcHAuc2V0dGluZ3NXaWRnZXQucmVzdG9yZUZyb21TYXZlZFxuICAgICAgfSk7XG4gICAgfSkuYmluZCh0aGlzKSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTsgXG4gICAgdGhpcy5hcHAuc2V0dGluZ3NXaWRnZXQuc2V0RWxlbWVudCh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJyNhbXAtc2V0dGluZ3MnKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVkaXRTZXR0aW5nczogZnVuY3Rpb24oKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dGhpcy5hcHAuc2V0dGluZ3NXaWRnZXQuc2hvdygpO1xuXHR0aGlzLiQoJyNhbXAtc2V0dGluZ3MnKS5zaG93KCk7XG5cdHRoaXMuYXBwLnNldHRpbmdzV2lkZ2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuJCgnI2FtcC1zZXR0aW5ncycpLmhpZGUoKTtcblx0fSk7XG5cdFxuXHR0aGlzLmFwcC5zZXR0aW5nc1dpZGdldC5vbignYXBwbHlTZXR0aW5ncycsIGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuJCgnI2FtcC1zZXR0aW5ncycpLmhpZGUoKTtcblx0fSk7XHRcbiB9XG5cbn0pO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwiY29sLXhzLTEyIGNvbC1zbS02IGNvbC1tZC00XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInBhbmVsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgICAgPGgzIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpzaGFyZS1kYXNoYm9hcmQtdG9wXFxcIiBjbGFzcz1cXFwiaW5saW5lLWhlYWRpbmdcXFwiPlNoYXJlPC9oMz5cXG4gICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRlZmF1bHQgcHVsbC1yaWdodCBkYXNoLXNoYXJlLWJ1dHRvblxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1saW5rXFxcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6c2hhcmUtbGlua1xcXCI+bGluazwvc3Bhbj5cXG4gICAgICA8L2J1dHRvbj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cXG48ZGl2IGNsYXNzPVxcXCJkYXNoLXNoYXJlLW1vZGFsIG1vZGFsIGZhZGVcXFwiIGlkPVxcXCI8JT0gZGV0YWlscy5pZCAlPlxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJkaWFsb2dcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwibXlNb2RhbExhYmVsXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbCBwYW5lbC1wcmltYXJ5XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nIGZpeC10aXRsZS1oZWlnaHRcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+PHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L3NwYW4+PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNsb3NlXFxcIiBjbGFzcz1cXFwic3Itb25seVxcXCI+Q2xvc2U8L3NwYW4+PC9idXR0b24+XFxuICAgICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6c2hhcmUtZGFzaGJvYXJkXFxcIj5TaGFyZSB0aGlzIGRhc2hib2FyZCB2aWV3PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbiAgICAgICAgPGZvcm0gcm9sZT1cXFwiZm9ybVxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6c2hhcmUtbGlua1xcXCIgZm9yPVxcXCJkYXNoLXNoYXJlLXVybFxcXCI+TGluazwvbGFiZWw+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ1cmxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJkYXNoLXNoYXJlLXVybFxcXCIgLz5cXG4gICAgICAgIDwvZm9ybT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1mb290ZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2xvc2U8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIik7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuZGFzaC1zaGFyZS1idXR0b24nOiAnc2hhcmUnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKHsgZGV0YWlsczoge30gfSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNoYXJlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2F2aW5nID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6c2F2aW5nLXN0YXRlXCIsXCJTYXZpbmcgZGFzaGJvYXJkIHN0YXRlLCBwbGVhc2Ugd2FpdC4uLlwiKTtcblx0ICBcbiAgICB0aGlzLiQoJyNkYXNoLXNoYXJlLXVybCcpXG4gICAgICAuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKVxuICAgICAgLnZhbChzYXZpbmcpO1xuXG4gICAgdmFyIHN0YXRlQmxvYiA9IHRoaXMuYXBwLnN0YXRlLmZyZWV6ZSgpO1xuXG4gICAgdGhpcy5saXN0ZW5Ub09uY2UodGhpcy5hcHAuc2F2ZWREYXNoZXMsICdyZXF1ZXN0JywgZnVuY3Rpb24obW9kZWwsIHhocikge1xuICAgICAgLy8gdGhpcyBoYXMgdG8gYmUgc2V0IHVwIGJlZm9yZSAuY3JlYXRlLCBzbyB3ZSBkb24ndCBtaXNzIGl0XG4gICAgICB4aHJcbiAgICAgICAgLmRvbmUoXyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaWQgPSBtb2RlbC5nZXQoJ2lkJyk7XG4gICAgICAgICAgdGhpcy5hcHAudXJsLmhhc2godGhpcy5hcHAuc3RhdGUudG9IYXNoKGlkKSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICAgICAgdGhpcy4kKCcjZGFzaC1zaGFyZS11cmwnKVxuICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgIC52YWwodGhpcy5hcHAudXJsLmZ1bGwoKSk7XG4gICAgICAgIH0pLmJpbmQodGhpcykpXG4gICAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy4kKCcjZGFzaC1zaGFyZS11cmwnKS52YWwoJ0Vycm9yOiBjb3VsZCBub3Qgc2F2ZSBkYXNoYm9hcmQgZm9yIHNoYXJpbmcuJyk7XG4gICAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hcHAuc2F2ZWREYXNoZXMuY3JlYXRlKHsgIC8vIGNyZWF0ZSBkb2VzIFBPU1RcbiAgICAgIHRpdGxlOiAnRGFzaGJvYXJkJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnU2F2ZWQgZGFzaGJvYXJkJyxcbiAgICAgIHN0YXRlQmxvYjogc3RhdGVCbG9iXG4gICAgfSwgeyBhcHA6IHRoaXMuYXBwIH0pO1xuXG4gICAgdGhpcy4kKCcuZGFzaC1zaGFyZS1tb2RhbCcpLm1vZGFsKCk7XG4gIH1cblxufSk7XG4iLCIvLyBudmQzIGdvZXMgZ2xvYmFsIHNpZ2guLi4gbWFrZSBzdXJlIGQzIGlzIGFscmVhZHkgZ2xvYmFsXG4vKiBUT0RPOiBpbiB0aGlzIHZlcnNpb24gb2YgbnZkMyB2MS43LjEsIG1haW4gaXMgbm90IHNwZWNpZmllZCBpbiBwYWNrYWdlLmpzb24sXG4gaWYgd2UgZXZlciB1cGdyYWRlIHRvIDEuOCssIGNoYW5nZSB0aGlzIGJhY2sgdG8ganVzdCByZXF1aXJlKG52ZDMpICovXG5yZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvbnZkMy9idWlsZC9udi5kMycpO1xuXG4vLyBsb2FkIHVuZGVyc2NvcmUgbWl4aW5zXG5yZXF1aXJlKCcuL3VuZGVyc2NvcmUtdHJhbnNwb3NlJyk7XG5cbi8vIGxvYWQgY2Fudmcgc3R1ZmZcbndpbmRvdy5SR0JDb2xvciA9IHJlcXVpcmUoJy4vbGliLXNyYy9yZ2Jjb2xvcicpO1xucmVxdWlyZSgnLi9saWItc3JjL2NhbnZnJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhbnZnOiB3aW5kb3cuY2Fudmdcbn07XG4iLCIvKlxuICogY2FudmcuanMgLSBKYXZhc2NyaXB0IFNWRyBwYXJzZXIgYW5kIHJlbmRlcmVyIG9uIENhbnZhc1xuICogTUlUIExpY2Vuc2VkIFxuICogR2FiZSBMZXJuZXIgKGdhYmVsZXJuZXJAZ21haWwuY29tKVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2NhbnZnL1xuICpcbiAqIFJlcXVpcmVzOiByZ2Jjb2xvci5qcyAtIGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXG4gKi9cbihmdW5jdGlvbigpe1xuICAgIC8vIGNhbnZnKHRhcmdldCwgcylcbiAgICAvLyBlbXB0eSBwYXJhbWV0ZXJzOiByZXBsYWNlIGFsbCAnc3ZnJyBlbGVtZW50cyBvbiBwYWdlIHdpdGggJ2NhbnZhcycgZWxlbWVudHNcbiAgICAvLyB0YXJnZXQ6IGNhbnZhcyBlbGVtZW50IG9yIHRoZSBpZCBvZiBhIGNhbnZhcyBlbGVtZW50XG4gICAgLy8gczogc3ZnIHN0cmluZywgdXJsIHRvIHN2ZyBmaWxlLCBvciB4bWwgZG9jdW1lbnRcbiAgICAvLyBvcHRzOiBvcHRpb25hbCBoYXNoIG9mIG9wdGlvbnNcbiAgICAvLyAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSA9PiBpZ25vcmUgbW91c2UgZXZlbnRzXG4gICAgLy8gICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlID0+IGlnbm9yZSBhbmltYXRpb25zXG4gICAgLy8gICAgICAgaWdub3JlRGltZW5zaW9uczogdHJ1ZSA9PiBkb2VzIG5vdCB0cnkgdG8gcmVzaXplIGNhbnZhc1xuICAgIC8vICAgICAgIGlnbm9yZUNsZWFyOiB0cnVlID0+IGRvZXMgbm90IGNsZWFyIGNhbnZhc1xuICAgIC8vICAgICAgIG9mZnNldFg6IGludCA9PiBkcmF3cyBhdCBhIHggb2Zmc2V0XG4gICAgLy8gICAgICAgb2Zmc2V0WTogaW50ID0+IGRyYXdzIGF0IGEgeSBvZmZzZXRcbiAgICAvLyAgICAgICBzY2FsZVdpZHRoOiBpbnQgPT4gc2NhbGVzIGhvcml6b250YWxseSB0byB3aWR0aFxuICAgIC8vICAgICAgIHNjYWxlSGVpZ2h0OiBpbnQgPT4gc2NhbGVzIHZlcnRpY2FsbHkgdG8gaGVpZ2h0XG4gICAgLy8gICAgICAgcmVuZGVyQ2FsbGJhY2s6IGZ1bmN0aW9uID0+IHdpbGwgY2FsbCB0aGUgZnVuY3Rpb24gYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciBpcyBjb21wbGV0ZWRcbiAgICAvLyAgICAgICBmb3JjZVJlZHJhdzogZnVuY3Rpb24gPT4gd2lsbCBjYWxsIHRoZSBmdW5jdGlvbiBvbiBldmVyeSBmcmFtZSwgaWYgaXQgcmV0dXJucyB0cnVlLCB3aWxsIHJlZHJhd1xuICAgIHRoaXMuY2FudmcgPSBmdW5jdGlvbiAodGFyZ2V0LCBzLCBvcHRzKSB7XG4gICAgICAgIC8vIG5vIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsICYmIHMgPT0gbnVsbCAmJiBvcHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzdmdUYWdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3ZnJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c3ZnVGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdmdUYWcgPSBzdmdUYWdzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IHN2Z1RhZy5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IHN2Z1RhZy5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgc3ZnVGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGMsIHN2Z1RhZyk7XG4gICAgICAgICAgICAgICAgc3ZnVGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3ZnVGFnKTtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHN2Z1RhZyk7XG4gICAgICAgICAgICAgICAgY2FudmcoYywgZGl2LmlubmVySFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHN0b3JlIGNsYXNzIG9uIGNhbnZhc1xuICAgICAgICBpZiAodGFyZ2V0LnN2ZyAhPSBudWxsKSB0YXJnZXQuc3ZnLnN0b3AoKTtcbiAgICAgICAgdmFyIHN2ZyA9IGJ1aWxkKG9wdHMgfHwge30pO1xuICAgICAgICAvLyBvbiBpLmUuIDggZm9yIGZsYXNoIGNhbnZhcywgd2UgY2FuJ3QgYXNzaWduIHRoZSBwcm9wZXJ0eSBzbyBjaGVjayBmb3IgaXRcbiAgICAgICAgaWYgKCEodGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgdGFyZ2V0LmNoaWxkTm9kZXNbMF0ubm9kZU5hbWUgPT0gJ09CSkVDVCcpKSB0YXJnZXQuc3ZnID0gc3ZnO1xuICAgICAgICBcbiAgICAgICAgdmFyIGN0eCA9IHRhcmdldC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAodHlwZW9mKHMuZG9jdW1lbnRFbGVtZW50KSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gbG9hZCBmcm9tIHhtbCBkb2NcbiAgICAgICAgICAgIHN2Zy5sb2FkWG1sRG9jKGN0eCwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocy5zdWJzdHIoMCwxKSA9PSAnPCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgZnJvbSB4bWwgc3RyaW5nXG4gICAgICAgICAgICBzdmcubG9hZFhtbChjdHgsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbG9hZCBmcm9tIHVybFxuICAgICAgICAgICAgc3ZnLmxvYWQoY3R4LCBzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkKG9wdHMpIHtcbiAgICAgICAgdmFyIHN2ZyA9IHsgb3B0czogb3B0cyB9O1xuICAgICAgICBcbiAgICAgICAgc3ZnLkZSQU1FUkFURSA9IDMwO1xuICAgICAgICBzdmcuTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XG4gICAgICAgIFxuICAgICAgICBzdmcubG9nID0gZnVuY3Rpb24obXNnKSB7fTtcbiAgICAgICAgaWYgKHN2Zy5vcHRzWydsb2cnXSA9PSB0cnVlICYmIHR5cGVvZihjb25zb2xlKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3ZnLmxvZyA9IGZ1bmN0aW9uKG1zZykgeyBjb25zb2xlLmxvZyhtc2cpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gZ2xvYmFsc1xuICAgICAgICBzdmcuaW5pdCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgdmFyIHVuaXF1ZUlkID0gMDtcbiAgICAgICAgICAgIHN2Zy5VbmlxdWVJZCA9IGZ1bmN0aW9uICgpIHsgdW5pcXVlSWQrKzsgcmV0dXJuICdjYW52ZycgKyB1bmlxdWVJZDsgfTtcbiAgICAgICAgICAgIHN2Zy5EZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICAgICAgc3ZnLlN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgc3ZnLkFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHN2Zy5JbWFnZXMgPSBbXTtcbiAgICAgICAgICAgIHN2Zy5jdHggPSBjdHg7XG4gICAgICAgICAgICBzdmcuVmlld1BvcnQgPSBuZXcgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdQb3J0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuQ2xlYXIgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMgPSBbXTsgfVxuICAgICAgICAgICAgICAgIHRoaXMuU2V0Q3VycmVudCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHsgdGhpcy52aWV3UG9ydHMucHVzaCh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7IH1cbiAgICAgICAgICAgICAgICB0aGlzLlJlbW92ZUN1cnJlbnQgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMucG9wKCk7IH1cbiAgICAgICAgICAgICAgICB0aGlzLkN1cnJlbnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1BvcnRzW3RoaXMudmlld1BvcnRzLmxlbmd0aCAtIDFdOyB9XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkud2lkdGg7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkuaGVpZ2h0OyB9XG4gICAgICAgICAgICAgICAgdGhpcy5Db21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgIT0gbnVsbCAmJiB0eXBlb2YoZCkgPT0gJ251bWJlcicpIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA9PSAneCcpIHJldHVybiB0aGlzLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkID09ICd5JykgcmV0dXJuIHRoaXMuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53aWR0aCgpLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0KCksIDIpKSAvIE1hdGguc3FydCgyKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuaW5pdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gaW1hZ2VzIGxvYWRlZFxuICAgICAgICBzdmcuSW1hZ2VzTG9hZGVkID0gZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN2Zy5JbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN2Zy5JbWFnZXNbaV0ubG9hZGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaW1cbiAgICAgICAgc3ZnLnRyaW0gPSBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTsgfVxuICAgICAgICBcbiAgICAgICAgLy8gY29tcHJlc3Mgc3BhY2VzXG4gICAgICAgIHN2Zy5jb21wcmVzc1NwYWNlcyA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvW1xcc1xcclxcdFxcbl0rL2dtLCcgJyk7IH1cbiAgICAgICAgXG4gICAgICAgIC8vIGFqYXhcbiAgICAgICAgc3ZnLmFqYXggPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHZhciBBSkFYO1xuICAgICAgICAgICAgaWYod2luZG93LlhNTEh0dHBSZXF1ZXN0KXtBSkFYPW5ldyBYTUxIdHRwUmVxdWVzdCgpO31cbiAgICAgICAgICAgIGVsc2V7QUpBWD1uZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTt9XG4gICAgICAgICAgICBpZihBSkFYKXtcbiAgICAgICAgICAgICAgIEFKQVgub3BlbignR0VUJyx1cmwsZmFsc2UpO1xuICAgICAgICAgICAgICAgQUpBWC5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgcmV0dXJuIEFKQVgucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICAvLyBwYXJzZSB4bWxcbiAgICAgICAgc3ZnLnBhcnNlWG1sID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKFdpbmRvd3MpICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZihXaW5kb3dzLkRhdGEpICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZihXaW5kb3dzLkRhdGEuWG1sKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciB4bWxEb2MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sTG9hZFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucHJvaGliaXREdGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB4bWxEb2MubG9hZFhtbCh4bWwsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LkRPTVBhcnNlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHhtbCA9IHhtbC5yZXBsYWNlKC88IURPQ1RZUEUgc3ZnW14+XSo+LywgJycpO1xuICAgICAgICAgICAgICAgIHZhciB4bWxEb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgICAgICAgICAgIHhtbERvYy5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgeG1sRG9jLmxvYWRYTUwoeG1sKTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHhtbERvYztcbiAgICAgICAgICAgIH0gICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN2Zy5Qcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9ICAgXG4gICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAhPSBudWxsICYmIHRoaXMudmFsdWUgIT09ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbnVtZXJpY2FsIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5udW1WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnZhbHVlICsgJycpLm1hdGNoKC8lJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBuIC8gMTAwLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLnZhbHVlT3JEZWZhdWx0ID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5udW1WYWx1ZU9yRGVmYXVsdCA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29sb3IgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIC8vIGF1Z21lbnQgdGhlIGN1cnJlbnQgY29sb3IgdmFsdWUgd2l0aCB0aGUgb3BhY2l0eVxuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuYWRkT3BhY2l0eSA9IGZ1bmN0aW9uKG9wYWNpdHlQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGFjaXR5UHJvcC52YWx1ZSAhPSBudWxsICYmIG9wYWNpdHlQcm9wLnZhbHVlICE9ICcnICYmIHR5cGVvZih0aGlzLnZhbHVlKT09J3N0cmluZycpIHsgLy8gY2FuIG9ubHkgYWRkIG9wYWNpdHkgdG8gY29sb3JzLCBub3QgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IG5ldyBSR0JDb2xvcih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvci5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gJ3JnYmEoJyArIGNvbG9yLnIgKyAnLCAnICsgY29sb3IuZyArICcsICcgKyBjb2xvci5iICsgJywgJyArIG9wYWNpdHlQcm9wLm51bVZhbHVlKCkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuUHJvcGVydHkodGhpcy5uYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBkZWZpbml0aW9uIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGRlZmluaXRpb24gZnJvbSB0aGUgZGVmaW5pdGlvbnMgdGFibGVcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldERlZmluaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnZhbHVlLm1hdGNoKC8jKFteXFwpJ1wiXSspLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7IG5hbWUgPSBuYW1lWzFdOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgeyBuYW1lID0gdGhpcy52YWx1ZTsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ZnLkRlZmluaXRpb25zW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmlzVXJsRGVmaW5pdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5pbmRleE9mKCd1cmwoJykgPT0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldEZpbGxTdHlsZURlZmluaXRpb24gPSBmdW5jdGlvbihlLCBvcGFjaXR5UHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmICE9IG51bGwgJiYgZGVmLmNyZWF0ZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmLmNyZWF0ZUdyYWRpZW50KHN2Zy5jdHgsIGUsIG9wYWNpdHlQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmICE9IG51bGwgJiYgZGVmLmNyZWF0ZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHQgPSBkZWYuYXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB0Lmhhc1ZhbHVlKCkpIHsgZGVmLmF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScsIHRydWUpLnZhbHVlID0gcHQudmFsdWU7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWYuY3JlYXRlUGF0dGVybihzdmcuY3R4LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBsZW5ndGggZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0RFBJID0gZnVuY3Rpb24odmlld1BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDk2LjA7IC8vIFRPRE86IGNvbXB1dGU/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0RU0gPSBmdW5jdGlvbih2aWV3UG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW0gPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZvbnRTaXplJywgc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb250U2l6ZS5oYXNWYWx1ZSgpKSBlbSA9IGZvbnRTaXplLnRvUGl4ZWxzKHZpZXdQb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRVbml0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMudmFsdWUrJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1swLTlcXC5cXC1dL2csJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbGVuZ3RoIGFzIHBpeGVsc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9QaXhlbHMgPSBmdW5jdGlvbih2aWV3UG9ydCwgcHJvY2Vzc1BlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMudmFsdWUrJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9lbSQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RU0odmlld1BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvZXgkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldEVNKHZpZXdQb3J0KSAvIDIuMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL3B4JC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvcHQkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCkgKiAoMS4wIC8gNzIuMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9wYyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIDE1O1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvY20kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCkgLyAyLjU0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvbW0kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCkgLyAyNS40O1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvaW4kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC8lJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogc3ZnLlZpZXdQb3J0LkNvbXB1dGVTaXplKHZpZXdQb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm51bVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzUGVyY2VudCAmJiBuIDwgMS4wKSByZXR1cm4gbiAqIHN2Zy5WaWV3UG9ydC5Db21wdXRlU2l6ZSh2aWV3UG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGltZSBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB0aW1lIGFzIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMudmFsdWUrJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9zJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL21zJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYW5nbGUgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgYW5nbGUgYXMgcmFkaWFuc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9SYWRpYW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnZhbHVlKycnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvZGVnJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9ncmFkJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAyMDAuMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9yYWQkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gdGV4dCBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB0ZXh0IGJhc2VsaW5lXG4gICAgICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZU1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICdiYXNlbGluZSc6ICdhbHBoYWJldGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWJlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICdtaWRkbGUnOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NlbnRyYWwnOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgICAgICAnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxuICAgICAgICAgICAgICAgICAgICAnYWxwaGFiZXRpYyc6ICdhbHBoYWJldGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ2hhbmdpbmcnOiAnaGFuZ2luZycsXG4gICAgICAgICAgICAgICAgICAgICdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9UZXh0QmFzZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRCYXNlbGluZU1hcHBpbmdbdGhpcy52YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyBmb250c1xuICAgICAgICBzdmcuRm9udCA9IG5ldyAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLlN0eWxlcyA9ICdub3JtYWx8aXRhbGljfG9ibGlxdWV8aW5oZXJpdCc7XG4gICAgICAgICAgICB0aGlzLlZhcmlhbnRzID0gJ25vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQnO1xuICAgICAgICAgICAgdGhpcy5XZWlnaHRzID0gJ25vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwfGluaGVyaXQnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLkNyZWF0ZUZvbnQgPSBmdW5jdGlvbihmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gaW5oZXJpdCAhPSBudWxsID8gdGhpcy5QYXJzZShpbmhlcml0KSA6IHRoaXMuQ3JlYXRlRm9udCgnJywgJycsICcnLCAnJywgJycsIHN2Zy5jdHguZm9udCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHkgfHwgZi5mb250RmFtaWx5LCBcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IGZvbnRTaXplIHx8IGYuZm9udFNpemUsIFxuICAgICAgICAgICAgICAgICAgICBmb250U3R5bGU6IGZvbnRTdHlsZSB8fCBmLmZvbnRTdHlsZSwgXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQgfHwgZi5mb250V2VpZ2h0LCBcbiAgICAgICAgICAgICAgICAgICAgZm9udFZhcmlhbnQ6IGZvbnRWYXJpYW50IHx8IGYuZm9udFZhcmlhbnQsXG4gICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbdGhpcy5mb250U3R5bGUsIHRoaXMuZm9udFZhcmlhbnQsIHRoaXMuZm9udFdlaWdodCwgdGhpcy5mb250U2l6ZSwgdGhpcy5mb250RmFtaWx5XS5qb2luKCcgJykgfSBcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLlBhcnNlID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHZhciBmID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXMocyB8fCAnJykpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IHsgZm9udFNpemU6IGZhbHNlLCBmb250U3R5bGU6IGZhbHNlLCBmb250V2VpZ2h0OiBmYWxzZSwgZm9udFZhcmlhbnQ6IGZhbHNlIH1cbiAgICAgICAgICAgICAgICB2YXIgZmYgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldC5mb250U3R5bGUgJiYgdGhhdC5TdHlsZXMuaW5kZXhPZihkW2ldKSAhPSAtMSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFN0eWxlID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNldC5mb250VmFyaWFudCAmJiB0aGF0LlZhcmlhbnRzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRWYXJpYW50ID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHNldC5mb250VmFyaWFudCA9IHRydWU7ICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZXQuZm9udFdlaWdodCAmJiB0aGF0LldlaWdodHMuaW5kZXhPZihkW2ldKSAhPSAtMSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFdlaWdodCA9IGRbaV07IHNldC5mb250U3R5bGUgPSBzZXQuZm9udFZhcmlhbnQgPSBzZXQuZm9udFdlaWdodCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNldC5mb250U2l6ZSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFNpemUgPSBkW2ldLnNwbGl0KCcvJylbMF07IHNldC5mb250U3R5bGUgPSBzZXQuZm9udFZhcmlhbnQgPSBzZXQuZm9udFdlaWdodCA9IHNldC5mb250U2l6ZSA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IGlmIChkW2ldICE9ICdpbmhlcml0JykgZmYgKz0gZFtpXTsgfVxuICAgICAgICAgICAgICAgIH0gaWYgKGZmICE9ICcnKSBmLmZvbnRGYW1pbHkgPSBmZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBwb2ludHMgYW5kIHBhdGhzXG4gICAgICAgIHN2Zy5Ub051bWJlckFycmF5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgdmFyIGEgPSBzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXMoKHMgfHwgJycpLnJlcGxhY2UoLywvZywgJyAnKSkpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBwYXJzZUZsb2F0KGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0gICAgICAgXG4gICAgICAgIHN2Zy5Qb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9ICAgXG4gICAgICAgICAgICBzdmcuUG9pbnQucHJvdG90eXBlLmFuZ2xlVG8gPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIocC55IC0gdGhpcy55LCBwLnggLSB0aGlzLngpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcuUG9pbnQucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHZhciB4cCA9IHRoaXMueCAqIHZbMF0gKyB0aGlzLnkgKiB2WzJdICsgdls0XTtcbiAgICAgICAgICAgICAgICB2YXIgeXAgPSB0aGlzLnggKiB2WzFdICsgdGhpcy55ICogdlszXSArIHZbNV07XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geHA7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgc3ZnLkNyZWF0ZVBvaW50ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgdmFyIGEgPSBzdmcuVG9OdW1iZXJBcnJheShzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3ZnLlBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5DcmVhdGVQYXRoID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgdmFyIGEgPSBzdmcuVG9OdW1iZXJBcnJheShzKTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobmV3IHN2Zy5Qb2ludChhW2ldLCBhW2krMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBib3VuZGluZyBib3hcbiAgICAgICAgc3ZnLkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHsgLy8gcGFzcyBpbiBpbml0aWFsIHBvaW50cyBpZiB5b3Ugd2FudFxuICAgICAgICAgICAgdGhpcy54MSA9IE51bWJlci5OYU47XG4gICAgICAgICAgICB0aGlzLnkxID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIHRoaXMueDIgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgdGhpcy55MiA9IE51bWJlci5OYU47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMueCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54MTsgfVxuICAgICAgICAgICAgdGhpcy55ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkxOyB9XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLngyIC0gdGhpcy54MTsgfVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7ICAgIFxuICAgICAgICAgICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkWCA9IGZ1bmN0aW9uKHgpIHsgdGhpcy5hZGRQb2ludCh4LCBudWxsKTsgfVxuICAgICAgICAgICAgdGhpcy5hZGRZID0gZnVuY3Rpb24oeSkgeyB0aGlzLmFkZFBvaW50KG51bGwsIHkpOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkQm91bmRpbmdCb3ggPSBmdW5jdGlvbihiYikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoYmIueDEsIGJiLnkxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KGJiLngyLCBiYi55Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNwMXggPSBwMHggKyAyLzMgKiAocDF4IC0gcDB4KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcbiAgICAgICAgICAgICAgICB2YXIgY3AxeSA9IHAweSArIDIvMyAqIChwMXkgLSBwMHkpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuICAgICAgICAgICAgICAgIHZhciBjcDJ4ID0gY3AxeCArIDEvMyAqIChwMnggLSBwMHgpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICAgICAgICAgIHZhciBjcDJ5ID0gY3AxeSArIDEvMyAqIChwMnkgLSBwMHkpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksIGNwMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hZGRCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBodHRwOi8vYmxvZy5oYWNrZXJzLWNhZmUubmV0LzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcbiAgICAgICAgICAgICAgICB2YXIgcDAgPSBbcDB4LCBwMHldLCBwMSA9IFtwMXgsIHAxeV0sIHAyID0gW3AyeCwgcDJ5XSwgcDMgPSBbcDN4LCBwM3ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQocDBbMF0sIHAwWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KHAzWzBdLCBwM1sxXSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8PTE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKHQpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMS10LCAzKSAqIHAwW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICArIDMgKiBNYXRoLnBvdygxLXQsIDIpICogdCAqIHAxW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICArIDMgKiAoMS10KSAqIE1hdGgucG93KHQsIDIpICogcDJbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICsgTWF0aC5wb3codCwgMykgKiBwM1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDApIHRoaXMuYWRkWChmKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB0aGlzLmFkZFkoZih0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIyYWMgPCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB0aGlzLmFkZFgoZih0MSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkgdGhpcy5hZGRZKGYodDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDApIHRoaXMuYWRkWChmKHQyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB0aGlzLmFkZFkoZih0MikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlzUG9pbnRJbkJveCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMueDEgPD0geCAmJiB4IDw9IHRoaXMueDIgJiYgdGhpcy55MSA8PSB5ICYmIHkgPD0gdGhpcy55Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdHJhbnNmb3Jtc1xuICAgICAgICBzdmcuVHJhbnNmb3JtID0gZnVuY3Rpb24odikgeyAgIFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5UeXBlID0ge31cbiAgICAgICAgXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGVcbiAgICAgICAgICAgIHRoaXMuVHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gc3ZnLkNyZWF0ZVBvaW50KHMpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnAueCB8fCAwLjAsIHRoaXMucC55IHx8IDAuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC0xLjAgKiB0aGlzLnAueCB8fCAwLjAsIC0xLjAgKiB0aGlzLnAueSB8fCAwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgdGhpcy5wLnggfHwgMC4wLCB0aGlzLnAueSB8fCAwLjBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJvdGF0ZVxuICAgICAgICAgICAgdGhpcy5UeXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5nbGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdhbmdsZScsIGFbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY3ggPSBhWzFdIHx8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jeSA9IGFbMl0gfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5jeCwgdGhpcy5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5hbmdsZS50b1JhZGlhbnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMuY3gsIC10aGlzLmN5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5jeCwgdGhpcy5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLTEuMCAqIHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC10aGlzLmN4LCAtdGhpcy5jeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuYW5nbGUudG9SYWRpYW5zKCk7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHRoaXMucC54IHx8IDAuMCwgdGhpcy5wLnkgfHwgMC4wXSk7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0oW01hdGguY29zKGEpLCBNYXRoLnNpbihhKSwgLU1hdGguc2luKGEpLCBNYXRoLmNvcyhhKSwgMCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICBwLmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCAtdGhpcy5wLnggfHwgMC4wLCAtdGhpcy5wLnkgfHwgMC4wXSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuVHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBzdmcuQ3JlYXRlUG9pbnQocyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUodGhpcy5wLnggfHwgMS4wLCB0aGlzLnAueSB8fCB0aGlzLnAueCB8fCAxLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEuMCAvIHRoaXMucC54IHx8IDEuMCwgMS4wIC8gdGhpcy5wLnkgfHwgdGhpcy5wLnggfHwgMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0oW3RoaXMucC54IHx8IDAuMCwgMCwgMCwgdGhpcy5wLnkgfHwgMC4wLCAwLCAwXSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLlR5cGUubWF0cml4ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHRoaXMubSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybSh0aGlzLm1bMF0sIHRoaXMubVsxXSwgdGhpcy5tWzJdLCB0aGlzLm1bM10sIHRoaXMubVs0XSwgdGhpcy5tWzVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5tWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMubVsyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLm1bNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5tWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMubVszXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLm1bNV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXQgPSAxIC8gKGEqKGUqaS1mKmgpLWIqKGQqaS1mKmcpK2MqKGQqaC1lKmcpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldCooZSppLWYqaCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXQqKGYqZy1kKmkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0KihjKmgtYippKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldCooYSppLWMqZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXQqKGIqZi1jKmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0KihjKmQtYSpmKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBseVRyYW5zZm9ybSh0aGlzLm0pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuVHlwZS5Ta2V3QmFzZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2UgPSB0aGF0LlR5cGUubWF0cml4O1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZShzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnYW5nbGUnLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuVHlwZS5Ta2V3QmFzZS5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLm1hdHJpeDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5UeXBlLnNrZXdYID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZSA9IHRoYXQuVHlwZS5Ta2V3QmFzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2Uocyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tID0gWzEsIDAsIE1hdGgudGFuKHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuVHlwZS5za2V3WC5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLlNrZXdCYXNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLlR5cGUuc2tld1kgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlID0gdGhhdC5UeXBlLlNrZXdCYXNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZShzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm0gPSBbMSwgTWF0aC50YW4odGhpcy5hbmdsZS50b1JhZGlhbnMoKSksIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5UeXBlLnNrZXdZLnByb3RvdHlwZSA9IG5ldyB0aGlzLlR5cGUuU2tld0Jhc2U7XG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtc1tpXS5hcHBseShjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT10aGlzLnRyYW5zZm9ybXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXNbaV0udW5hcHBseShjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXNbaV0uYXBwbHlUb1BvaW50KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXModikpLnJlcGxhY2UoL1xcKShbYS16QS1aXSkvZywgJykgJDEnKS5yZXBsYWNlKC9cXCkoXFxzPyxcXHM/KS9nLCcpICcpLnNwbGl0KC9cXHMoPz1bYS16XSkvKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzdmcudHJpbShkYXRhW2ldLnNwbGl0KCcoJylbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBzID0gZGF0YVtpXS5zcGxpdCgnKCcpWzFdLnJlcGxhY2UoJyknLCcnKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IHRoaXMuVHlwZVt0eXBlXShzKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgICAgIHN2Zy5Bc3BlY3RSYXRpbyA9IGZ1bmN0aW9uKGN0eCwgYXNwZWN0UmF0aW8sIHdpZHRoLCBkZXNpcmVkV2lkdGgsIGhlaWdodCwgZGVzaXJlZEhlaWdodCwgbWluWCwgbWluWSwgcmVmWCwgcmVmWSkge1xuICAgICAgICAgICAgLy8gYXNwZWN0IHJhdGlvIC0gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gc3ZnLmNvbXByZXNzU3BhY2VzKGFzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW8ucmVwbGFjZSgvXmRlZmVyXFxzLywnJyk7IC8vIGlnbm9yZSBkZWZlclxuICAgICAgICAgICAgdmFyIGFsaWduID0gYXNwZWN0UmF0aW8uc3BsaXQoJyAnKVswXSB8fCAneE1pZFlNaWQnO1xuICAgICAgICAgICAgdmFyIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW8uc3BsaXQoJyAnKVsxXSB8fCAnbWVldCc7ICAgICAgICAgICAgICAgICAgXG4gICAgXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSB3aWR0aCAvIGRlc2lyZWRXaWR0aDtcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSBoZWlnaHQgLyBkZXNpcmVkSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgdmFyIHNjYWxlTWF4ID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgaWYgKG1lZXRPclNsaWNlID09ICdtZWV0JykgeyBkZXNpcmVkV2lkdGggKj0gc2NhbGVNaW47IGRlc2lyZWRIZWlnaHQgKj0gc2NhbGVNaW47IH1cbiAgICAgICAgICAgIGlmIChtZWV0T3JTbGljZSA9PSAnc2xpY2UnKSB7IGRlc2lyZWRXaWR0aCAqPSBzY2FsZU1heDsgZGVzaXJlZEhlaWdodCAqPSBzY2FsZU1heDsgfSAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVmWCA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlgnLCByZWZYKTtcbiAgICAgICAgICAgIHJlZlkgPSBuZXcgc3ZnLlByb3BlcnR5KCdyZWZZJywgcmVmWSk7XG4gICAgICAgICAgICBpZiAocmVmWC5oYXNWYWx1ZSgpICYmIHJlZlkuaGFzVmFsdWUoKSkgeyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXNjYWxlTWluICogcmVmWC50b1BpeGVscygneCcpLCAtc2NhbGVNaW4gKiByZWZZLnRvUGl4ZWxzKCd5JykpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFsaWduXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduLm1hdGNoKC9eeE1pZC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWSkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVZKSkpIGN0eC50cmFuc2xhdGUod2lkdGggLyAyLjAgLSBkZXNpcmVkV2lkdGggLyAyLjAsIDApOyBcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ24ubWF0Y2goL1lNaWQkLykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVYKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVgpKSkgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyLjAgLSBkZXNpcmVkSGVpZ2h0IC8gMi4wKTsgXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduLm1hdGNoKC9eeE1heC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWSkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVZKSkpIGN0eC50cmFuc2xhdGUod2lkdGggLSBkZXNpcmVkV2lkdGgsIDApOyBcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ24ubWF0Y2goL1lNYXgkLykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVYKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVgpKSkgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLSBkZXNpcmVkSGVpZ2h0KTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHNjYWxlXG4gICAgICAgICAgICBpZiAoYWxpZ24gPT0gJ25vbmUnKSBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgZWxzZSBpZiAobWVldE9yU2xpY2UgPT0gJ21lZXQnKSBjdHguc2NhbGUoc2NhbGVNaW4sIHNjYWxlTWluKTsgXG4gICAgICAgICAgICBlbHNlIGlmIChtZWV0T3JTbGljZSA9PSAnc2xpY2UnKSBjdHguc2NhbGUoc2NhbGVNYXgsIHNjYWxlTWF4KTsgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGVcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUobWluWCA9PSBudWxsID8gMCA6IC1taW5YLCBtaW5ZID09IG51bGwgPyAwIDogLW1pblkpOyAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gZWxlbWVudHNcbiAgICAgICAgc3ZnLkVsZW1lbnQgPSB7fVxuICAgICAgICBcbiAgICAgICAgc3ZnLkVtcHR5UHJvcGVydHkgPSBuZXcgc3ZnLlByb3BlcnR5KCdFTVBUWScsICcnKTtcbiAgICAgICAgXG4gICAgICAgIHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkgeyAgXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGdldCBvciBjcmVhdGUgYXR0cmlidXRlXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzID09IHRydWUpIHsgYSA9IG5ldyBzdmcuUHJvcGVydHkobmFtZSwgJycpOyB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBhOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgfHwgc3ZnLkVtcHR5UHJvcGVydHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7IFxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5tYXRjaCgvOmhyZWYkLykpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2FdOyBcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN2Zy5FbXB0eVByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHN0eWxlLCBjcmF3bHMgdXAgbm9kZSB0cmVlXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlSWZOb3RFeGlzdHMsIHNraXBBbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5hdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCAmJiBhLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBhOyAvLyBtb3ZlIHVwIHRvIG1lIHRvIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoc2tpcEFuY2VzdG9ycyAhPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcyA9IHAuc3R5bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHMgIT0gbnVsbCAmJiBwcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlSWZOb3RFeGlzdHMgPT0gdHJ1ZSkgeyBzID0gbmV3IHN2Zy5Qcm9wZXJ0eShuYW1lLCAnJyk7IHRoaXMuc3R5bGVzW25hbWVdID0gczsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzIHx8IHN2Zy5FbXB0eVByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBiYXNlIHJlbmRlclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZW5kZXIgZGlzcGxheT1ub25lXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PSAnbm9uZScpIHJldHVybjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZW5kZXIgdmlzaWJpbGl0eT1oaWRkZW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09ICdoaWRkZW4nKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnbWFzaycpLmhhc1ZhbHVlKCkpIHsgLy8gbWFza1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IHRoaXMuYXR0cmlidXRlKCdtYXNrJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFzayAhPSBudWxsKSBtYXNrLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUoJ2ZpbHRlcicpLmhhc1ZhbHVlKCkpIHsgLy8gZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLnN0eWxlKCdmaWx0ZXInKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgIT0gbnVsbCkgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKGN0eCk7ICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7ICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBiYXNlIHNldCBjb250ZXh0XG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRSFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYmFzZSBjbGVhciBjb250ZXh0XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIE9WRVJSSURFIE1FIVxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGJhc2UgcmVuZGVyIGNoaWxkcmVuXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZE5vZGUsIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlKSBjaGlsZCA9IHN2Zy5DcmVhdGVFbGVtZW50KGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSAndGl0bGUnKSB7IHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChub2RlICE9IG51bGwgJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7IC8vRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgLy8gYWRkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8bm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUubm9kZU5hbWVdID0gbmV3IHN2Zy5Qcm9wZXJ0eShhdHRyaWJ1dGUubm9kZU5hbWUsIGF0dHJpYnV0ZS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGFnIHN0eWxlc1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSBzdmcuU3R5bGVzW25vZGUubm9kZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFkZCBjbGFzcyBzdHlsZXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2NsYXNzJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmF0dHJpYnV0ZSgnY2xhc3MnKS52YWx1ZSkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPGNsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHN2Zy5TdHlsZXNbJy4nK2NsYXNzZXNbal1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gc3ZnLlN0eWxlc1tub2RlLm5vZGVOYW1lKycuJytjbGFzc2VzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgaWQgc3R5bGVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdpZCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHN2Zy5TdHlsZXNbJyMnICsgdGhpcy5hdHRyaWJ1dGUoJ2lkJykudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gYWRkIGlubGluZSBzdHlsZXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3N0eWxlJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5hdHRyaWJ1dGUoJ3N0eWxlJykudmFsdWUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zy50cmltKHN0eWxlc1tpXSkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHN2Zy50cmltKHN0eWxlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdmcudHJpbShzdHlsZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBuZXcgc3ZnLlByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gICBcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBpZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnaWQnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmcuRGVmaW5pdGlvbnNbdGhpcy5hdHRyaWJ1dGUoJ2lkJykudmFsdWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5EZWZpbml0aW9uc1t0aGlzLmF0dHJpYnV0ZSgnaWQnKS52YWx1ZV0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFkZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PSAxKSB0aGlzLmFkZENoaWxkKGNoaWxkTm9kZSwgdHJ1ZSk7IC8vRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgJiYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PSAzIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PSA0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBjaGlsZE5vZGUubm9kZVZhbHVlIHx8IGNoaWxkTm9kZS50ZXh0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zy50cmltKHN2Zy5jb21wcmVzc1NwYWNlcyh0ZXh0KSkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKG5ldyBzdmcuRWxlbWVudC50c3BhbihjaGlsZE5vZGUpLCBmYWxzZSk7IC8vIFRFWFRfTk9ERVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIGZpbGxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnZmlsbCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IHRoaXMuc3R5bGUoJ2ZpbGwnKS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzICE9IG51bGwpIGN0eC5maWxsU3R5bGUgPSBmcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdHlsZSgnZmlsbCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IHRoaXMuc3R5bGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxTdHlsZS52YWx1ZSA9PSAnY3VycmVudENvbG9yJykgZmlsbFN0eWxlLnZhbHVlID0gdGhpcy5zdHlsZSgnY29sb3InKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IChmaWxsU3R5bGUudmFsdWUgPT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogZmlsbFN0eWxlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZpbGwnLCBjdHguZmlsbFN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlID0gZmlsbFN0eWxlLmFkZE9wYWNpdHkodGhpcy5zdHlsZSgnZmlsbC1vcGFjaXR5JykpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHN0cm9rZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2UnKS5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSB0aGlzLnN0eWxlKCdzdHJva2UnKS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnMgIT0gbnVsbCkgY3R4LnN0cm9rZVN0eWxlID0gZnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUoJ3N0cm9rZScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cm9rZVN0eWxlID0gdGhpcy5zdHlsZSgnc3Ryb2tlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJva2VTdHlsZS52YWx1ZSA9PSAnY3VycmVudENvbG9yJykgc3Ryb2tlU3R5bGUudmFsdWUgPSB0aGlzLnN0eWxlKCdjb2xvcicpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAoc3Ryb2tlU3R5bGUudmFsdWUgPT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogc3Ryb2tlU3R5bGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJva2VTdHlsZSA9IG5ldyBzdmcuUHJvcGVydHkoJ3N0cm9rZScsIGN0eC5zdHJva2VTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdzdHJva2Utb3BhY2l0eScpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2Utd2lkdGgnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdMaW5lV2lkdGggPSB0aGlzLnN0eWxlKCdzdHJva2Utd2lkdGgnKS50b1BpeGVscygpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbmV3TGluZVdpZHRoID09IDAgPyAwLjAwMSA6IG5ld0xpbmVXaWR0aDsgLy8gYnJvd3NlcnMgZG9uJ3QgcmVzcGVjdCAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2UtbGluZWNhcCcpLmhhc1ZhbHVlKCkpIGN0eC5saW5lQ2FwID0gdGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVjYXAnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJykuaGFzVmFsdWUoKSkgY3R4LmxpbmVKb2luID0gdGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJykudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1taXRlcmxpbWl0JykuaGFzVmFsdWUoKSkgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLnN0eWxlKCdzdHJva2UtbWl0ZXJsaW1pdCcpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JykuaGFzVmFsdWUoKSAmJiB0aGlzLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JykudmFsdWUgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnYXBzID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjdHguc2V0TGluZURhc2gpICE9ICd1bmRlZmluZWQnKSB7IGN0eC5zZXRMaW5lRGFzaChnYXBzKTsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YoY3R4LndlYmtpdExpbmVEYXNoKSAhPSAndW5kZWZpbmVkJykgeyBjdHgud2Via2l0TGluZURhc2ggPSBnYXBzOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZihjdHgubW96RGFzaCkgIT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aD09MSAmJiBnYXBzWzBdPT0wKSkgeyBjdHgubW96RGFzaCA9IGdhcHM7IH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnN0eWxlKCdzdHJva2UtZGFzaG9mZnNldCcpLm51bVZhbHVlT3JEZWZhdWx0KDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGN0eC5saW5lRGFzaE9mZnNldCkgIT0gJ3VuZGVmaW5lZCcpIHsgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0OyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZihjdHgud2Via2l0TGluZURhc2hPZmZzZXQpICE9ICd1bmRlZmluZWQnKSB7IGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZnNldDsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YoY3R4Lm1vekRhc2hPZmZzZXQpICE9ICd1bmRlZmluZWQnKSB7IGN0eC5tb3pEYXNoT2Zmc2V0ID0gb2Zmc2V0OyB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZm9udFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY3R4LmZvbnQpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gc3ZnLkZvbnQuQ3JlYXRlRm9udCggXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlKCdmb250LXN0eWxlJykudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSgnZm9udC12YXJpYW50JykudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSgnZm9udC13ZWlnaHQnKS52YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlKCdmb250LXNpemUnKS5oYXNWYWx1ZSgpID8gdGhpcy5zdHlsZSgnZm9udC1zaXplJykudG9QaXhlbHMoKSArICdweCcgOiAnJywgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlKCdmb250LWZhbWlseScpLnZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3RyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgc3ZnLlRyYW5zZm9ybSh0aGlzLmF0dHJpYnV0ZSgndHJhbnNmb3JtJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY2xpcFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdjbGlwLXBhdGgnLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IHRoaXMuc3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwICE9IG51bGwpIGNsaXAuYXBwbHkoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gb3BhY2l0eVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdvcGFjaXR5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLnN0eWxlKCdvcGFjaXR5JykubnVtVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIHN2Zy5Nb3VzZS5jaGVja1BhdGgodGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmZpbGxTdHlsZSAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnZmlsbC1ydWxlJykudmFsdWVPckRlZmF1bHQoJ2luaGVyaXQnKSAhPSAnaW5oZXJpdCcpIHsgY3R4LmZpbGwodGhpcy5zdHlsZSgnZmlsbC1ydWxlJykudmFsdWUpOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyBjdHguZmlsbCgpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT0gJycpIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ21hcmtlci1zdGFydCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5zdHlsZSgnbWFya2VyLXN0YXJ0JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcihjdHgsIG1hcmtlcnNbMF1bMF0sIG1hcmtlcnNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdtYXJrZXItbWlkJykuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLnN0eWxlKCdtYXJrZXItbWlkJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0xO2k8bWFya2Vycy5sZW5ndGgtMTtpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgbWFya2Vyc1tpXVswXSwgbWFya2Vyc1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ21hcmtlci1lbmQnKS5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuc3R5bGUoJ21hcmtlci1lbmQnKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aC0xXVswXSwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aC0xXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBzdmcgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5zdmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VDbGVhckNvbnRleHQgPSB0aGlzLmNsZWFyQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlQ2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LlJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5iYXNlU2V0Q29udGV4dCA9IHRoaXMuc2V0Q29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgdmFsdWVzIGFuZCBkZWZhdWx0c1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgICAgICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gNDsgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjdHguZm9udCkgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN0eC5jYW52YXMpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VTZXRDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyB2aWV3IHBvcnRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3gnLCB0cnVlKS52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCd5JywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpLCB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5JykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHN2Zy5WaWV3UG9ydC53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzdmcuVmlld1BvcnQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKS52YWx1ZSA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkudmFsdWUgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZih0aGlzLnJvb3QpID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdyZWZYJykuaGFzVmFsdWUoKSAmJiB0aGlzLmF0dHJpYnV0ZSgncmVmWScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAtdGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IC10aGlzLmF0dHJpYnV0ZSgncmVmWScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS52YWx1ZU9yRGVmYXVsdCgnaGlkZGVuJykgIT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuU2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB2aWV3Ym94XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykuaGFzVmFsdWUoKSkgeyAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdCb3ggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pblggPSB2aWV3Qm94WzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluWSA9IHZpZXdCb3hbMV07XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdmlld0JveFsyXTtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdmlld0JveFszXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Bc3BlY3RSYXRpbyhjdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLnZhbHVlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5WaWV3UG9ydC53aWR0aCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LmhlaWdodCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3JlZlknKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuUmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuU2V0Q3VycmVudCh2aWV3Qm94WzJdLCB2aWV3Qm94WzNdKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuc3ZnLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuXG4gICAgICAgIC8vIHJlY3QgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5yZWN0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgcnggPSB0aGlzLmF0dHJpYnV0ZSgncngnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciByeSA9IHRoaXMuYXR0cmlidXRlKCdyeScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkpIHJ5ID0gcng7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkpIHJ4ID0gcnk7XG4gICAgICAgICAgICAgICAgcnggPSBNYXRoLm1pbihyeCwgd2lkdGggLyAyLjApO1xuICAgICAgICAgICAgICAgIHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByeSlcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJ5KVxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnJlY3QucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNpcmNsZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmNpcmNsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gdGhpcy5hdHRyaWJ1dGUoJ2N4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSB0aGlzLmF0dHJpYnV0ZSgnY3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5hdHRyaWJ1dGUoJ3InKS50b1BpeGVscygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTsgXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5jaXJjbGUucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTsgXG5cbiAgICAgICAgLy8gZWxsaXBzZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmVsbGlwc2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgICAgICAgICAgICAgdmFyIHJ4ID0gdGhpcy5hdHRyaWJ1dGUoJ3J4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgcnkgPSB0aGlzLmF0dHJpYnV0ZSgncnknKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHRoaXMuYXR0cmlidXRlKCdjeCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGN4LCBjeSAtIHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyAoS0FQUEEgKiByeCksIGN5IC0gcnksICBjeCArIHJ4LCBjeSAtIChLQVBQQSAqIHJ5KSwgY3ggKyByeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIHJ4LCBjeSArIChLQVBQQSAqIHJ5KSwgY3ggKyAoS0FQUEEgKiByeCksIGN5ICsgcnksIGN4LCBjeSArIHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSAoS0FQUEEgKiByeCksIGN5ICsgcnksIGN4IC0gcngsIGN5ICsgKEtBUFBBICogcnkpLCBjeCAtIHJ4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gcngsIGN5IC0gKEtBUFBBICogcnkpLCBjeCAtIChLQVBQQSAqIHJ4KSwgY3kgLSByeSwgY3gsIGN5IC0gcnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KGN4IC0gcngsIGN5IC0gcnksIGN4ICsgcngsIGN5ICsgcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmVsbGlwc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTsgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIGxpbmUgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5saW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldFBvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBzdmcuUG9pbnQodGhpcy5hdHRyaWJ1dGUoJ3gxJykudG9QaXhlbHMoJ3gnKSwgdGhpcy5hdHRyaWJ1dGUoJ3kxJykudG9QaXhlbHMoJ3knKSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBzdmcuUG9pbnQodGhpcy5hdHRyaWJ1dGUoJ3gyJykudG9QaXhlbHMoJ3gnKSwgdGhpcy5hdHRyaWJ1dGUoJ3kyJykudG9QaXhlbHMoJ3knKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveChwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnksIHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpOyAgXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBwb2ludHNbMF0uYW5nbGVUbyhwb2ludHNbMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbW3BvaW50c1swXSwgYV0sIFtwb2ludHNbMV0sIGFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5saW5lLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7ICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyBwb2x5bGluZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LnBvbHlsaW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IHN2Zy5DcmVhdGVQYXRoKHRoaXMuYXR0cmlidXRlKCdwb2ludHMnKS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCwgdGhpcy5wb2ludHNbMF0ueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MTsgaTx0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYi5hZGRQb2ludCh0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHgubGluZVRvKHRoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goW3RoaXMucG9pbnRzW2ldLCB0aGlzLnBvaW50c1tpXS5hbmdsZVRvKHRoaXMucG9pbnRzW2krMV0pXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaChbdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoLTFdLCBtYXJrZXJzW21hcmtlcnMubGVuZ3RoLTFdWzFdXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5wb2x5bGluZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlOyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyBwb2x5Z29uIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQucG9seWdvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LnBvbHlsaW5lO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5iYXNlUGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5wb2x5Z29uLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5wb2x5bGluZTtcblxuICAgICAgICAvLyBwYXRoIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQucGF0aCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuYXR0cmlidXRlKCdkJykudmFsdWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBjb252ZXJ0IHRvIHJlYWwgbGV4ZXIgYmFzZWQgb24gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGF0aHMuaHRtbCNQYXRoRGF0YUJORlxuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvLC9nbSwnICcpOyAvLyBnZXQgcmlkIG9mIGFsbCBjb21tYXNcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbTW1aekxsSGhWdkNjU3NRcVR0QWFdKShbTW1aekxsSGhWdkNjU3NRcVR0QWFdKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgY29tbWFuZHMgZnJvbSBjb21tYW5kc1xuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pL2dtLCckMSAkMicpOyAvLyBzZXBhcmF0ZSBjb21tYW5kcyBmcm9tIGNvbW1hbmRzXG4gICAgICAgICAgICBkID0gZC5yZXBsYWNlKC8oW01tWnpMbEhoVnZDY1NzUXFUdEFhXSkoW15cXHNdKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgY29tbWFuZHMgZnJvbSBwb2ludHNcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbXlxcc10pKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pL2dtLCckMSAkMicpOyAvLyBzZXBhcmF0ZSBjb21tYW5kcyBmcm9tIHBvaW50c1xuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvKFswLTldKShbK1xcLV0pL2dtLCckMSAkMicpOyAvLyBzZXBhcmF0ZSBkaWdpdHMgd2hlbiBubyBjb21tYVxuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvKFxcLlswLTldKikoXFwuKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgZGlnaXRzIHdoZW4gbm8gY29tbWFcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbQWFdKFxccytbMC05XSspezN9KVxccysoWzAxXSlcXHMqKFswMV0pL2dtLCckMSAkMyAkNCAnKTsgLy8gc2hvcnRoYW5kIGVsbGlwdGljYWwgYXJjIHBhdGggc3ludGF4XG4gICAgICAgICAgICBkID0gc3ZnLmNvbXByZXNzU3BhY2VzKGQpOyAvLyBjb21wcmVzcyBtdWx0aXBsZSBzcGFjZXNcbiAgICAgICAgICAgIGQgPSBzdmcudHJpbShkKTtcbiAgICAgICAgICAgIHRoaXMuUGF0aFBhcnNlciA9IG5ldyAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zID0gZC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuaXNFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaSA+PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29tbWFuZE9yRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pICsgMV0ubWF0Y2goL15bQS1aYS16XSQvKSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVsYXRpdmVDb21tYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCh0aGlzLmNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2NhbGFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuZ2V0VG9rZW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENvbW1hbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZCA9IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBzdmcuUG9pbnQodGhpcy5nZXRTY2FsYXIoKSwgdGhpcy5nZXRTY2FsYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VBYnNvbHV0ZShwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBc0NvbnRyb2xQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXNDdXJyZW50UG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmdldFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwOyAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAnYycgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZC50b0xvd2VyQ2FzZSgpICE9ICdzJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAncScgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZC50b0xvd2VyQ2FzZSgpICE9ICd0JyApe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVmbGVjdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBzdmcuUG9pbnQoMiAqIHRoaXMuY3VycmVudC54IC0gdGhpcy5jb250cm9sLngsIDIgKiB0aGlzLmN1cnJlbnQueSAtIHRoaXMuY29udHJvbC55KTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlQWJzb2x1dGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmVsYXRpdmVDb21tYW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAueCArPSB0aGlzLmN1cnJlbnQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAueSArPSB0aGlzLmN1cnJlbnQueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNYXJrZXIgPSBmdW5jdGlvbihwLCBmcm9tLCBwcmlvclRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYXN0IGFuZ2xlIGlzbid0IGZpbGxlZCBpbiBiZWNhdXNlIHdlIGRpZG4ndCBoYXZlIHRoaXMgcG9pbnQgeWV0IC4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJpb3JUbyAhPSBudWxsICYmIHRoaXMuYW5nbGVzLmxlbmd0aCA+IDAgJiYgdGhpcy5hbmdsZXNbdGhpcy5hbmdsZXMubGVuZ3RoLTFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzW3RoaXMuYW5nbGVzLmxlbmd0aC0xXSA9IHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aC0xXS5hbmdsZVRvKHByaW9yVG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyQW5nbGUocCwgZnJvbSA9PSBudWxsID8gbnVsbCA6IGZyb20uYW5nbGVUbyhwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyQW5nbGUgPSBmdW5jdGlvbihwLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VyUG9pbnRzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvaW50czsgfVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VyQW5nbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmFuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5nbGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPWkrMTsgajx0aGlzLmFuZ2xlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmdsZXNbal0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXNbaV0gPSB0aGlzLmFuZ2xlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuZ2xlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShkKTtcblxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBwID0gdGhpcy5QYXRoUGFyc2VyO1xuICAgICAgICAgICAgICAgIHBwLnJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0VuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwLm5leHRDb21tYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHAuY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRQb2ludChwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHAuc3RhcnQgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihwLCBwcC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIocCwgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1AgPSBuZXcgc3ZnLlBvaW50KChwcC5pc1JlbGF0aXZlQ29tbWFuZCgpID8gcHAuY3VycmVudC54IDogMCkgKyBwcC5nZXRTY2FsYXIoKSwgcHAuY3VycmVudC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIobmV3UCwgcHAuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuY3VycmVudCA9IG5ld1A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1AgPSBuZXcgc3ZnLlBvaW50KHBwLmN1cnJlbnQueCwgKHBwLmlzUmVsYXRpdmVDb21tYW5kKCkgPyBwcC5jdXJyZW50LnkgOiAwKSArIHBwLmdldFNjYWxhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIobmV3UCwgcHAuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuY3VycmVudCA9IG5ld1A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnIgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IHBwLmdldFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihjcCwgY250cmwsIHAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRCZXppZXJDdXJ2ZShjdXJyLngsIGN1cnIueSwgcDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmV6aWVyQ3VydmVUbyhwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gcHAuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihjcCwgY250cmwsIHAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRCZXppZXJDdXJ2ZShjdXJyLngsIGN1cnIueSwgcDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmV6aWVyQ3VydmVUbyhwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihjcCwgY250cmwsIGNudHJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyLngsIGN1cnIueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHgucXVhZHJhdGljQ3VydmVUbyhjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuY29udHJvbCA9IGNudHJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyKGNwLCBjbnRybCwgY250cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZFF1YWRyYXRpY0N1cnZlKGN1cnIueCwgY3Vyci55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyID0gcHAuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBwcC5nZXRTY2FsYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBwcC5nZXRTY2FsYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEF4aXNSb3RhdGlvbiA9IHBwLmdldFNjYWxhcigpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IHBwLmdldFNjYWxhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzd2VlcEZsYWcgPSBwcC5nZXRTY2FsYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVyc2lvbiBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0ZXJpemF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEnLCB5MSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycnAgPSBuZXcgc3ZnLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnggLSBjcC54KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnIueSAtIGNwLnkpIC8gMi4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3Vyci54IC0gY3AueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnkgLSBjcC55KSAvIDIuMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHJhZGlpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBNYXRoLnBvdyhjdXJycC54LDIpL01hdGgucG93KHJ4LDIpK01hdGgucG93KGN1cnJwLnksMikvTWF0aC5wb3cocnksMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4ICo9IE1hdGguc3FydChsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnkgKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjeCcsIGN5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gKGxhcmdlQXJjRmxhZyA9PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKE1hdGgucG93KHJ4LDIpKk1hdGgucG93KHJ5LDIpKS0oTWF0aC5wb3cocngsMikqTWF0aC5wb3coY3VycnAueSwyKSktKE1hdGgucG93KHJ5LDIpKk1hdGgucG93KGN1cnJwLngsMikpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChNYXRoLnBvdyhyeCwyKSpNYXRoLnBvdyhjdXJycC55LDIpK01hdGgucG93KHJ5LDIpKk1hdGgucG93KGN1cnJwLngsMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocykpIHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcHAgPSBuZXcgc3ZnLlBvaW50KHMgKiByeCAqIGN1cnJwLnkgLyByeSwgcyAqIC1yeSAqIGN1cnJwLnggLyByeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3gsIGN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRwID0gbmV3IHN2Zy5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnIueCArIGNwLngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueCAtIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyLnkgKyBjcC55KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZWN0b3IgbWFnbml0dWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBmdW5jdGlvbih2KSB7IHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codlswXSwyKSArIE1hdGgucG93KHZbMV0sMikpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF0aW8gYmV0d2VlbiB0d28gdmVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZnVuY3Rpb24odSwgdikgeyByZXR1cm4gKHVbMF0qdlswXSt1WzFdKnZbMV0pIC8gKG0odSkqbSh2KSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKHUsIHYpIHsgcmV0dXJuICh1WzBdKnZbMV0gPCB1WzFdKnZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHIodSx2KSk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsIGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gYShbMSwwXSwgWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmdsZSBkZWx0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gWygtY3VycnAueC1jcHAueCkvcngsKC1jdXJycC55LWNwcC55KS9yeV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkID0gYSh1LCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocih1LHYpIDw9IC0xKSBhZCA9IE1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIodSx2KSA+PSAxKSBhZCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgbWFya2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSAxIC0gc3dlZXBGbGFnID8gMS4wIDogLTEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWggPSBhMSArIGRpciAqIChhZCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZXYXkgPSBuZXcgc3ZnLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50cC54ICsgcnggKiBNYXRoLmNvcyhhaCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRwLnkgKyByeSAqIE1hdGguc2luKGFoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyQW5nbGUoaGFsZldheSwgYWggLSBkaXIgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyQW5nbGUoY3AsIGFoIC0gZGlyICogTWF0aC5QSSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRQb2ludChjcC54LCBjcC55KTsgLy8gVE9ETzogdGhpcyBpcyB0b28gbmFpdmUsIG1ha2UgaXQgYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoeEF4aXNSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCAxIC0gc3dlZXBGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEvc3gsIDEvc3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2VudHAueCwgLWNlbnRwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwLmN1cnJlbnQgPSBwcC5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBiYjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuUGF0aFBhcnNlci5nZXRNYXJrZXJQb2ludHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGVzID0gdGhpcy5QYXRoUGFyc2VyLmdldE1hcmtlckFuZ2xlcygpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goW3BvaW50c1tpXSwgYW5nbGVzW2ldXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnBhdGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIHBhdHRlcm4gZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5wYXR0ZXJuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScsIHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBTdmcgPSBuZXcgc3ZnLkVsZW1lbnQuc3ZnKCk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd2aWV3Qm94J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd2aWV3Qm94JywgdGhpcy5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCB3aWR0aCArICdweCcpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3RyYW5zZm9ybSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5hdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGNjdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSAmJiB0aGlzLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2N0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcsIHRydWUpLCB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5JywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgM3gzIGdyaWQgc28gd2hlbiB3ZSB0cmFuc2Zvcm0gdGhlcmUncyBubyB3aGl0ZSBzcGFjZSBvbiBlZGdlc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHg9LTE7IHg8PTE7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5PS0xOyB5PD0xOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2N0eC50cmFuc2xhdGUoeCAqIGMud2lkdGgsIHkgKiBjLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLnJlbmRlcihjY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4oYywgJ3JlcGVhdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnBhdHRlcm4ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gbWFya2VyIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQubWFya2VyID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYmFzZVJlbmRlciA9IHRoaXMucmVuZGVyO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIHBvaW50LCBhbmdsZSkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdvcmllbnQnKS52YWx1ZU9yRGVmYXVsdCgnYXV0bycpID09ICdhdXRvJykgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdtYXJrZXJVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdzdHJva2VXaWR0aCcpID09ICdzdHJva2VXaWR0aCcpIGN0eC5zY2FsZShjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sncmVmWCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWCcsIHRoaXMuYXR0cmlidXRlKCdyZWZYJykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sncmVmWSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWScsIHRoaXMuYXR0cmlidXRlKCdyZWZZJykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgdGhpcy5hdHRyaWJ1dGUoJ21hcmtlcldpZHRoJykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCB0aGlzLmF0dHJpYnV0ZSgnbWFya2VySGVpZ2h0JykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snZmlsbCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnZmlsbCcsIHRoaXMuYXR0cmlidXRlKCdmaWxsJykudmFsdWVPckRlZmF1bHQoJ2JsYWNrJykpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snc3Ryb2tlJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCdzdHJva2UnLCB0aGlzLmF0dHJpYnV0ZSgnc3Ryb2tlJykudmFsdWVPckRlZmF1bHQoJ25vbmUnKSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnKS52YWx1ZU9yRGVmYXVsdCgnc3Ryb2tlV2lkdGgnKSA9PSAnc3Ryb2tlV2lkdGgnKSBjdHguc2NhbGUoMS9jdHgubGluZVdpZHRoLCAxL2N0eC5saW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnb3JpZW50JykudmFsdWVPckRlZmF1bHQoJ2F1dG8nKSA9PSAnYXV0bycpIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1wb2ludC54LCAtcG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQubWFya2VyLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGRlZmluaXRpb25zIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuZGVmcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpOyAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBOT09QXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZGVmcy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBiYXNlIGZvciBncmFkaWVudHNcbiAgICAgICAgc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRVbml0cyA9IHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykudmFsdWVPckRlZmF1bHQoJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc3RvcHMgPSBbXTsgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSAnc3RvcCcpIHRoaXMuc3RvcHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRSFcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdyYWRpZW50ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50LCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wc0NvbnRhaW5lciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHNDb250YWluZXIgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBhZGRQYXJlbnRPcGFjaXR5ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBzdmcuUHJvcGVydHkoJ2NvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuYWRkT3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZyA9PSBudWxsKSByZXR1cm4gYWRkUGFyZW50T3BhY2l0eShzdG9wc0NvbnRhaW5lci5zdG9wc1tzdG9wc0NvbnRhaW5lci5zdG9wcy5sZW5ndGggLSAxXS5jb2xvcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN0b3BzQ29udGFpbmVyLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGcuYWRkQ29sb3JTdG9wKHN0b3BzQ29udGFpbmVyLnN0b3BzW2ldLm9mZnNldCwgYWRkUGFyZW50T3BhY2l0eShzdG9wc0NvbnRhaW5lci5zdG9wc1tpXS5jb2xvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgYXMgdHJhbnNmb3JtZWQgcGF0dGVybiBvbiB0ZW1wb3JhcnkgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIHZhciByb290VmlldyA9IHN2Zy5WaWV3UG9ydC52aWV3UG9ydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBzdmcuRWxlbWVudC5yZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1sneCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneCcsIC1zdmcuTUFYX1ZJUlRVQUxfUElYRUxTLzMuMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIC1zdmcuTUFYX1ZJUlRVQUxfUElYRUxTLzMuMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCBzdmcuTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBzdmcuRWxlbWVudC5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmF0dHJpYnV0ZXNbJ3RyYW5zZm9ybSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5jaGlsZHJlbiA9IFsgcmVjdCBdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBTdmcgPSBuZXcgc3ZnLkVsZW1lbnQuc3ZnKCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sneCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneCcsIDApO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3knXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3knLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCByb290Vmlldy53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCByb290Vmlldy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmNoaWxkcmVuID0gWyBncm91cCBdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IHJvb3RWaWV3LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IHJvb3RWaWV3LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZmlsbFN0eWxlID0gZztcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5yZW5kZXIodGVtcEN0eCk7ICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBDdHguY3JlYXRlUGF0dGVybihjLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBnOyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBsaW5lYXIgZ3JhZGllbnQgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5saW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gZWxlbWVudC5nZXRCb3VuZGluZ0JveCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKClcbiAgICAgICAgICAgICAgICAgJiYgIXRoaXMuYXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKClcbiAgICAgICAgICAgICAgICAgJiYgIXRoaXMuYXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKClcbiAgICAgICAgICAgICAgICAgJiYgIXRoaXMuYXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3gxJywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgneTEnLCB0cnVlKS52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKCd4MicsIHRydWUpLnZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3kyJywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgneDEnKS5udW1WYWx1ZSgpIFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cmlidXRlKCd4MScpLnRvUGl4ZWxzKCd4JykpO1xuICAgICAgICAgICAgICAgIHZhciB5MSA9ICh0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyBcbiAgICAgICAgICAgICAgICAgICAgPyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCd5MScpLm51bVZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgneTEnKS50b1BpeGVscygneScpKTtcbiAgICAgICAgICAgICAgICB2YXIgeDIgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCd4MicpLm51bVZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgneDInKS50b1BpeGVscygneCcpKTtcbiAgICAgICAgICAgICAgICB2YXIgeTIgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgneTInKS5udW1WYWx1ZSgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ3kyJykudG9QaXhlbHMoJ3knKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoeDEgPT0geDIgJiYgeTEgPT0geTIpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmxpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyByYWRpYWwgZ3JhZGllbnQgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5yYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBiYiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCdjeCcpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCdjeCcsIHRydWUpLnZhbHVlID0gJzUwJSc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgnY3knKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnY3knLCB0cnVlKS52YWx1ZSA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGUoJ3InKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgncicsIHRydWUpLnZhbHVlID0gJzUwJSc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgnY3gnKS5udW1WYWx1ZSgpIFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cmlidXRlKCdjeCcpLnRvUGl4ZWxzKCd4JykpO1xuICAgICAgICAgICAgICAgIHZhciBjeSA9ICh0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyBcbiAgICAgICAgICAgICAgICAgICAgPyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCdjeScpLm51bVZhbHVlKCkgXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGZ4ID0gY3g7XG4gICAgICAgICAgICAgICAgdmFyIGZ5ID0gY3k7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdmeCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnggPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCdmeCcpLm51bVZhbHVlKCkgXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ2Z4JykudG9QaXhlbHMoJ3gnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnZnknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ5ID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLnkoKSArIGJiLmhlaWdodCgpICogdGhpcy5hdHRyaWJ1dGUoJ2Z5JykubnVtVmFsdWUoKSBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgnZnknKS50b1BpeGVscygneScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHIgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gKGJiLndpZHRoKCkgKyBiYi5oZWlnaHQoKSkgLyAyLjAgKiB0aGlzLmF0dHJpYnV0ZSgncicpLm51bVZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgncicpLnRvUGl4ZWxzKCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoZngsIGZ5LCAwLCBjeCwgY3ksIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBncmFkaWVudCBzdG9wIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuc3RvcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuYXR0cmlidXRlKCdvZmZzZXQnKS5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0IDwgMCkgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0ID4gMSkgdGhpcy5vZmZzZXQgPSAxO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc3RvcENvbG9yID0gdGhpcy5zdHlsZSgnc3RvcC1jb2xvcicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ3N0b3Atb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHN0b3BDb2xvciA9IHN0b3BDb2xvci5hZGRPcGFjaXR5KHRoaXMuc3R5bGUoJ3N0b3Atb3BhY2l0eScpKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBzdG9wQ29sb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuc3RvcC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBhbmltYXRpb24gYmFzZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN2Zy5BbmltYXRpb25zLnB1c2godGhpcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmJlZ2luID0gdGhpcy5hdHRyaWJ1dGUoJ2JlZ2luJykudG9NaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIHRoaXMubWF4RHVyYXRpb24gPSB0aGlzLmJlZ2luICsgdGhpcy5hdHRyaWJ1dGUoJ2R1cicpLnRvTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHRoaXMuYXR0cmlidXRlKCdhdHRyaWJ1dGVUeXBlJykudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLnZhbHVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVUeXBlID09ICdDU1MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5zdHlsZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTsgICAgICAgICAgXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxVbml0cyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7ICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLmNhbGNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE9WRVJSSURFIE1FIVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKSB7IFxuICAgICAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLmdldFByb3BlcnR5KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gdGhpcy5nZXRQcm9wZXJ0eSgpLmdldFVuaXRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBmb3IgaW5kZWZpbml0ZWx5IHJlcGVhdGluZyBhbmltYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgncmVwZWF0Q291bnQnKS52YWx1ZSA9PSAnaW5kZWZpbml0ZSdcbiAgICAgICAgICAgICAgICAgICAgIHx8IHRoaXMuYXR0cmlidXRlKCdyZXBlYXREdXInKS52YWx1ZSA9PSAnaW5kZWZpbml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAwLjBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdyZW1vdmUnKSA9PSAnZnJlZXplJyAmJiAhdGhpcy5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9IHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdyZW1vdmUnKSA9PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlID0gdGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuID8gdGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgOiB0aGlzLmluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiArIGRlbHRhO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgYmVnaW4gdGltZVxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmVnaW4gPCB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY1ZhbHVlKCk7IC8vIHR3ZWVuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdHJhbnNmb3JtLCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuYXR0cmlidXRlKCd0eXBlJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHR5cGUgKyAnKCcgKyBuZXdWYWx1ZSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5hdHRyaWJ1dGUoJ2Zyb20nKTtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmF0dHJpYnV0ZSgndG8nKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdGhpcy5hdHRyaWJ1dGUoJ3ZhbHVlcycpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLmhhc1ZhbHVlKCkpIHRoaXMudmFsdWVzLnZhbHVlID0gdGhpcy52YWx1ZXMudmFsdWUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZnJhY3Rpb24gb2YgZHVyYXRpb24gd2UndmUgY292ZXJlZFxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSB7IHByb2dyZXNzOiAodGhpcy5kdXJhdGlvbiAtIHRoaXMuYmVnaW4pIC8gKHRoaXMubWF4RHVyYXRpb24gLSB0aGlzLmJlZ2luKSB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcmV0LnByb2dyZXNzICogKHRoaXMudmFsdWVzLnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGIgPSBNYXRoLmZsb29yKHApLCB1YiA9IE1hdGguY2VpbChwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmZyb20gPSBuZXcgc3ZnLlByb3BlcnR5KCdmcm9tJywgcGFyc2VGbG9hdCh0aGlzLnZhbHVlcy52YWx1ZVtsYl0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnRvID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndG8nLCBwYXJzZUZsb2F0KHRoaXMudmFsdWVzLnZhbHVlW3ViXSkpO1xuICAgICAgICAgICAgICAgICAgICByZXQucHJvZ3Jlc3MgPSAocCAtIGxiKSAvICh1YiAtIGxiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5mcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgICAgICAgICByZXQudG8gPSB0aGlzLnRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gYW5pbWF0ZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHAuZnJvbS5udW1WYWx1ZSgpICsgKHAudG8ubnVtVmFsdWUoKSAtIHAuZnJvbS5udW1WYWx1ZSgpKSAqIHAucHJvZ3Jlc3M7IFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZSArIHRoaXMuaW5pdGlhbFVuaXRzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5hbmltYXRlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAvLyBhbmltYXRlIGNvbG9yIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuYW5pbWF0ZUNvbG9yID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsY1ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBuZXcgUkdCQ29sb3IocC5mcm9tLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSBuZXcgUkdCQ29sb3IocC50by52YWx1ZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGZyb20ub2sgJiYgdG8ub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdlZW4gY29sb3IgbGluZWFybHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBmcm9tLnIgKyAodG8uciAtIGZyb20ucikgKiBwLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGZyb20uZyArICh0by5nIC0gZnJvbS5nKSAqIHAucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gZnJvbS5iICsgKHRvLmIgLSBmcm9tLmIpICogcC5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZ2IoJytwYXJzZUludChyLDEwKSsnLCcrcGFyc2VJbnQoZywxMCkrJywnK3BhcnNlSW50KGIsMTApKycpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlKCdmcm9tJykudmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGVDb2xvci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBhbmltYXRlIHRyYW5zZm9ybSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gc3ZnLlRvTnVtYmVyQXJyYXkocC5mcm9tLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSBzdmcuVG9OdW1iZXJBcnJheShwLnRvLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSArPSBmcm9tW2ldICsgKHRvW2ldIC0gZnJvbVtpXSkgKiBwLnByb2dyZXNzICsgJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGVUcmFuc2Zvcm0ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LmFuaW1hdGU7XG4gICAgICAgIFxuICAgICAgICAvLyBmb250IGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuZm9udCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuXG4gICAgICAgICAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuYXR0cmlidXRlKCdob3Jpei1hZHYteCcpLm51bVZhbHVlKCk7ICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlzUlRMID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQXJhYmljID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZvbnRGYWNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWlzc2luZ0dseXBoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzID0gW107ICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSAnZm9udC1mYWNlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbnRGYWNlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5zdHlsZSgnZm9udC1mYW1pbHknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmcuRGVmaW5pdGlvbnNbY2hpbGQuc3R5bGUoJ2ZvbnQtZmFtaWx5JykudmFsdWVdID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09ICdtaXNzaW5nLWdseXBoJykgdGhpcy5taXNzaW5nR2x5cGggPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09ICdnbHlwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmFyYWJpY0Zvcm0gIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNSVEwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FyYWJpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdKSA9PSAndW5kZWZpbmVkJykgdGhpcy5nbHlwaHNbY2hpbGQudW5pY29kZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdW2NoaWxkLmFyYWJpY0Zvcm1dID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgIFxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZvbnQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gZm9udC1mYWNlIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuZm9udGZhY2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXNjZW50ID0gdGhpcy5hdHRyaWJ1dGUoJ2FzY2VudCcpLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kZXNjZW50ID0gdGhpcy5hdHRyaWJ1dGUoJ2Rlc2NlbnQnKS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudW5pdHNQZXJFbSA9IHRoaXMuYXR0cmlidXRlKCd1bml0cy1wZXItZW0nKS5udW1WYWx1ZSgpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5mb250ZmFjZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBtaXNzaW5nLWdseXBoIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQubWlzc2luZ2dseXBoID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucGF0aDtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaG9yaXpBZHZYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5taXNzaW5nZ2x5cGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LnBhdGg7XG4gICAgICAgIFxuICAgICAgICAvLyBnbHlwaCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmdseXBoID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucGF0aDtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5hdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykubnVtVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMudW5pY29kZSA9IHRoaXMuYXR0cmlidXRlKCd1bmljb2RlJykudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFyYWJpY0Zvcm0gPSB0aGlzLmF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5nbHlwaC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQucGF0aDtcbiAgICAgICAgXG4gICAgICAgIC8vIHRleHQgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC50ZXh0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYmFzZVNldENvbnRleHQgPSB0aGlzLnNldENvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VTZXRDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZSA9IHRoaXMuc3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJykudG9UZXh0QmFzZWxpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09IG51bGwpIHRleHRCYXNlbGluZSA9IHRoaXMuc3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScpLnRvVGV4dEJhc2VsaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCYXNlbGluZSAhPSBudWxsKSBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXNpemUnKS5udW1WYWx1ZU9yRGVmYXVsdChzdmcuRm9udC5QYXJzZShzdmcuY3R4LmZvbnQpLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5IC0gZm9udFNpemUsIHggKyBNYXRoLmZsb29yKGZvbnRTaXplICogMi4wIC8gMy4wKSAqIHRoaXMuY2hpbGRyZW5bMF0uZ2V0VGV4dCgpLmxlbmd0aCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLmdldEFuY2hvckRlbHRhKGN0eCwgdGhpcywgMCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZChjdHgsIHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRBbmNob3JEZWx0YSA9IGZ1bmN0aW9uIChjdHgsIHBhcmVudCwgc3RhcnRJKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbmNob3IgPSB0aGlzLnN0eWxlKCd0ZXh0LWFuY2hvcicpLnZhbHVlT3JEZWZhdWx0KCdzdGFydCcpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0QW5jaG9yICE9ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT1zdGFydEk7IGk8cGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IHN0YXJ0SSAmJiBjaGlsZC5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSBicmVhazsgLy8gbmV3IGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBjaGlsZC5tZWFzdXJlVGV4dFJlY3Vyc2l2ZShjdHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSAqICh0ZXh0QW5jaG9yID09ICdlbmQnID8gd2lkdGggOiB3aWR0aCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkID0gZnVuY3Rpb24oY3R4LCBwYXJlbnQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQueCA9IGNoaWxkLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4JykgKyB0aGlzLmdldEFuY2hvckRlbHRhKGN0eCwgcGFyZW50LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHgnKS5oYXNWYWx1ZSgpKSBjaGlsZC54ICs9IGNoaWxkLmF0dHJpYnV0ZSgnZHgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIHRoaXMueCArPSB0aGlzLmF0dHJpYnV0ZSgnZHgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIHRoaXMueCArPSBjaGlsZC5hdHRyaWJ1dGUoJ2R4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQueCA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gY2hpbGQueCArIGNoaWxkLm1lYXN1cmVUZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQueSA9IGNoaWxkLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ2R5JykuaGFzVmFsdWUoKSkgY2hpbGQueSArPSBjaGlsZC5hdHRyaWJ1dGUoJ2R5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSB0aGlzLnkgKz0gdGhpcy5hdHRyaWJ1dGUoJ2R5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSB0aGlzLnkgKz0gY2hpbGQuYXR0cmlidXRlKCdkeScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnkgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMueSA9IGNoaWxkLnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGQoY3R4LCBjaGlsZCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnRleHQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyB0ZXh0IGJhc2VcbiAgICAgICAgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRHbHlwaCA9IGZ1bmN0aW9uKGZvbnQsIHRleHQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRleHRbaV07XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZm9udC5pc0FyYWJpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJhYmljRm9ybSA9ICdpc29sYXRlZCc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaT09MCB8fCB0ZXh0W2ktMV09PScgJykgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ3Rlcm1pbmFsJzsgXG4gICAgICAgICAgICAgICAgICAgIGlmIChpPjAgJiYgdGV4dFtpLTFdIT0nICcgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ21lZGlhbCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpPjAgJiYgdGV4dFtpLTFdIT0nICcgJiYgKGkgPT0gdGV4dC5sZW5ndGgtMSB8fCB0ZXh0W2krMV09PScgJykpIGFyYWJpY0Zvcm0gPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZm9udC5nbHlwaHNbY10pICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdW2FyYWJpY0Zvcm1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdseXBoID09IG51bGwgJiYgZm9udC5nbHlwaHNbY10udHlwZSA9PSAnZ2x5cGgnKSBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGggPT0gbnVsbCkgZ2x5cGggPSBmb250Lm1pc3NpbmdHbHlwaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tRm9udCA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRm9udCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXNpemUnKS5udW1WYWx1ZU9yRGVmYXVsdChzdmcuRm9udC5QYXJzZShzdmcuY3R4LmZvbnQpLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRTdHlsZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXN0eWxlJykudmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRm9udC5pc1JUTCkgdGV4dCA9IHRleHQuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLnBhcmVudC5hdHRyaWJ1dGUoJ2R4JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IGZvbnRTaXplIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbHcgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGN0eC5saW5lV2lkdGggKiBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW0gLyBmb250U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb250U3R5bGUgPT0gJ2l0YWxpYycpIGN0eC50cmFuc2Zvcm0oMSwgMCwgLjQsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9udFN0eWxlID09ICdpdGFsaWMnKSBjdHgudHJhbnNmb3JtKDEsIDAsIC0uNCwgMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbHc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoMS9zY2FsZSwgLTEvc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy54LCAtdGhpcy55KTsgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCArPSBmb250U2l6ZSAqIChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihkeFtpXSkgIT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCArPSBkeFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUgIT0gJycpIGN0eC5maWxsVGV4dChzdmcuY29tcHJlc3NTcGFjZXModGhpcy5nZXRUZXh0KCkpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPSAnJykgY3R4LnN0cm9rZVRleHQoc3ZnLmNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0VGV4dCgpKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUZXh0UmVjdXJzaXZlID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IHRoaXMuY2hpbGRyZW5baV0ubWVhc3VyZVRleHRSZWN1cnNpdmUoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUZvbnQgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUZvbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zaXplJykubnVtVmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWFzdXJlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbUZvbnQuaXNSVEwpIHRleHQgPSB0ZXh0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLnBhcmVudC5hdHRyaWJ1dGUoJ2R4JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZHhbaV0pICE9ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlICs9IGR4W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciB0ZXh0VG9NZWFzdXJlID0gc3ZnLmNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0VGV4dCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN0eC5tZWFzdXJlVGV4dCkgcmV0dXJuIHRleHRUb01lYXN1cmUubGVuZ3RoICogMTA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dFRvTWVhc3VyZSkud2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gdHNwYW4gXG4gICAgICAgIHN2Zy5FbGVtZW50LnRzcGFuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gbm9kZS5ub2RlVmFsdWUgfHwgbm9kZS50ZXh0IHx8ICcnO1xuICAgICAgICAgICAgdGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC50c3Bhbi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gdHJlZlxuICAgICAgICBzdmcuRWxlbWVudC50cmVmID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSByZXR1cm4gZWxlbWVudC5jaGlsZHJlblswXS5nZXRUZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQudHJlZi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlOyAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIGEgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5hID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmhhc1RleHQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgIT0gMykgdGhpcy5oYXNUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHRoaXMgbWlnaHQgY29udGFpbiB0ZXh0XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmhhc1RleHQgPyBub2RlLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlIDogJyc7XG4gICAgICAgICAgICB0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICAgICAgfSAgICAgICBcblxuICAgICAgICAgICAgdGhpcy5iYXNlUmVuZGVyQ2hpbGRyZW4gPSB0aGlzLnJlbmRlckNoaWxkcmVuO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFzIHRleHQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhc2VSZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmb250U2l6ZScsIHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuTW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgc3ZnLkJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55IC0gZm9udFNpemUudG9QaXhlbHMoJ3knKSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpKTsgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFzIHRlbXBvcmFyeSBncm91cFxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IG5ldyBzdmcuRWxlbWVudC5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGcucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdmcuY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuYS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlOyAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gaW1hZ2UgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5pbWFnZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkudmFsdWU7XG4gICAgICAgICAgICBpZiAoaHJlZiA9PSAnJykgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHZhciBpc1N2ZyA9IGhyZWYubWF0Y2goL1xcLnN2ZyQvKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcuSW1hZ2VzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1N2Zykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWyd1c2VDT1JTJ10gPT0gdHJ1ZSkgeyB0aGlzLmltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnOyB9XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7IHN2Zy5sb2coJ0VSUk9SOiBpbWFnZSBcIicgKyBocmVmICsgJ1wiIG5vdCBmb3VuZCcpOyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmltZy5zcmMgPSBocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcgPSBzdmcuYWpheChocmVmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPT0gMCB8fCBoZWlnaHQgPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdTdmcodGhpcy5pbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnLkFzcGVjdFJhdGlvKGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWcuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApOyBcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCk7ICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmltYWdlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gZ3JvdXAgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBzdmcuQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYi5hZGRCb3VuZGluZ0JveCh0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kaW5nQm94KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmcucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG5cbiAgICAgICAgLy8gc3ltYm9sIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuc3ltYm9sID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBOTyBSRU5ERVJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuc3ltYm9sLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlOyAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgLy8gc3R5bGUgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5zdHlsZSA9IGZ1bmN0aW9uKG5vZGUpIHsgXG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gdGV4dCwgb3Igc3BhY2VzIHRoZW4gQ0RBVEFcbiAgICAgICAgICAgIHZhciBjc3MgPSAnJ1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjc3MgKz0gbm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzcyA9IGNzcy5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qXFwvXXxbXFxyXFxuXSkpKSpcXCorXFwvKXwoXltcXHNdKlxcL1xcLy4qKS9nbSwgJycpOyAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgICAgIGNzcyA9IHN2Zy5jb21wcmVzc1NwYWNlcyhjc3MpOyAvLyByZXBsYWNlIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHZhciBjc3NEZWZzID0gY3NzLnNwbGl0KCd9Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8Y3NzRGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzdmcudHJpbShjc3NEZWZzW2ldKSAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzRGVmID0gY3NzRGVmc1tpXS5zcGxpdCgneycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzQ2xhc3NlcyA9IGNzc0RlZlswXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzUHJvcHMgPSBjc3NEZWZbMV0uc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPGNzc0NsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3NDbGFzcyA9IHN2Zy50cmltKGNzc0NsYXNzZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NsYXNzICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaz0wOyBrPGNzc1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wID0gY3NzUHJvcHNba10uaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNzc1Byb3BzW2tdLnN1YnN0cigwLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY3NzUHJvcHNba10uc3Vic3RyKHByb3AgKyAxLCBjc3NQcm9wc1trXS5sZW5ndGggLSBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tzdmcudHJpbShuYW1lKV0gPSBuZXcgc3ZnLlByb3BlcnR5KHN2Zy50cmltKG5hbWUpLCBzdmcudHJpbSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5TdHlsZXNbY3NzQ2xhc3NdID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NsYXNzID09ICdAZm9udC1mYWNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IHByb3BzWydmb250LWZhbWlseSddLnZhbHVlLnJlcGxhY2UoL1wiL2csJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjcyA9IHByb3BzWydzcmMnXS52YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzPTA7IHM8c3Jjcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyY3Nbc10uaW5kZXhPZignZm9ybWF0KFwic3ZnXCIpJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybFN0YXJ0ID0gc3Jjc1tzXS5pbmRleE9mKCd1cmwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsRW5kID0gc3Jjc1tzXS5pbmRleE9mKCcpJywgdXJsU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzcmNzW3NdLnN1YnN0cih1cmxTdGFydCArIDUsIHVybEVuZCAtIHVybFN0YXJ0IC0gNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHN2Zy5wYXJzZVhtbChzdmcuYWpheCh1cmwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9udHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZvbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmPTA7IGY8Zm9udHMubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnQgPSBzdmcuQ3JlYXRlRWxlbWVudChmb250c1tmXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5EZWZpbml0aW9uc1tmb250RmFtaWx5XSA9IGZvbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnN0eWxlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIHVzZSBlbGVtZW50IFxuICAgICAgICBzdmcuRWxlbWVudC51c2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VTZXRDb250ZXh0ID0gdGhpcy5zZXRDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIGN0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSBjdHgudHJhbnNsYXRlKDAsIHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSBlbGVtZW50LnBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wU3ZnID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50IGluIHN5bWJvbCBjYXNlcyAoaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI1VzZUVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy50eXBlID0gJ3N2Zyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ZpZXdCb3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ZpZXdCb3gnLCBlbGVtZW50LmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sncHJlc2VydmVBc3BlY3RSYXRpbyddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncHJlc2VydmVBc3BlY3RSYXRpbycsIGVsZW1lbnQuYXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWydvdmVyZmxvdyddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnb3ZlcmZsb3cnLCBlbGVtZW50LmF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcFN2Zy50eXBlID09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzeW1ib2wgb3Igc3ZnLCBpbmhlcml0IHdpZHRoL2hlaWdodCBmcm9tIG1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRQYXJlbnQgPSB0ZW1wU3ZnLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLnBhcmVudCA9IG9sZFBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQudXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gbWFzayBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50Lm1hc2sgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wIHN2ZyAgIFxuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA9PSAwICYmIGhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBzdmcuQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZEJvdW5kaW5nQm94KHRoaXMuY2hpbGRyZW5baV0uZ2V0Qm91bmRpbmdCb3goKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKGJiLngxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKGJiLnkxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihiYi53aWR0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguZmxvb3IoYmIuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSByZW1vdmUgbWFzayB0byBhdm9pZCByZWN1cnNpb25cbiAgICAgICAgICAgICAgICB2YXIgbWFzayA9IGVsZW1lbnQuYXR0cmlidXRlKCdtYXNrJykudmFsdWU7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGUoJ21hc2snKS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgY01hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgY01hc2sud2lkdGggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNNYXNrLmhlaWdodCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXNrQ3R4ID0gY01hc2suZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihtYXNrQ3R4KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEN0eCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIodGVtcEN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC5maWxsU3R5bGUgPSBtYXNrQ3R4LmNyZWF0ZVBhdHRlcm4oY01hc2ssICduby1yZXBlYXQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRlbXBDdHguY3JlYXRlUGF0dGVybihjLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZWFzc2lnbiBtYXNrXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGUoJ21hc2snKS52YWx1ZSA9IG1hc2s7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIE5PIFJFTkRFUlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50Lm1hc2sucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gY2xpcCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmNsaXBQYXRoID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQmVnaW5QYXRoID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5iZWdpblBhdGg7XG4gICAgICAgICAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIG9sZENsb3NlUGF0aCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoO1xuICAgICAgICAgICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgb2xkQmVnaW5QYXRoLmNhbGwoY3R4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNoaWxkLnBhdGgpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ3RyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gbmV3IHN2Zy5UcmFuc2Zvcm0oY2hpbGQuYXR0cmlidXRlKCd0cmFuc2Zvcm0nKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXRoKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IG9sZENsb3NlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHsgdHJhbnNmb3JtLnVuYXBwbHkoY3R4KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9sZENsb3NlUGF0aC5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmJlZ2luUGF0aCA9IG9sZEJlZ2luUGF0aDtcbiAgICAgICAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IG9sZENsb3NlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBOTyBSRU5ERVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5jbGlwUGF0aC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG5cbiAgICAgICAgLy8gZmlsdGVyc1xuICAgICAgICBzdmcuRWxlbWVudC5maWx0ZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wIHN2ZyAgIFxuICAgICAgICAgICAgICAgIHZhciBiYiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoYmIueDEpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihiYi55MSk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihiYi53aWR0aCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihiYi5oZWlnaHQoKSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSByZW1vdmUgZmlsdGVyIHRvIGF2b2lkIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBlbGVtZW50LnN0eWxlKCdmaWx0ZXInKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlKCdmaWx0ZXInKS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBweCA9IDAsIHB5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWZkID0gdGhpcy5jaGlsZHJlbltpXS5leHRyYUZpbHRlckRpc3RhbmNlIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gTWF0aC5tYXgocHgsIGVmZCk7XG4gICAgICAgICAgICAgICAgICAgIHB5ID0gTWF0aC5tYXgocHksIGVmZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IHdpZHRoICsgMipweDtcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IGhlaWdodCArIDIqcHk7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgdGVtcEN0eC50cmFuc2xhdGUoLXggKyBweCwgLXkgKyBweSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIodGVtcEN0eCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5hcHBseSh0ZW1wQ3R4LCAwLCAwLCB3aWR0aCArIDIqcHgsIGhlaWdodCArIDIqcHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgb24gbWVcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGMsIDAsIDAsIHdpZHRoICsgMipweCwgaGVpZ2h0ICsgMipweSwgeCAtIHB4LCB5IC0gcHksIHdpZHRoICsgMipweCwgaGVpZ2h0ICsgMipweSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVhc3NpZ24gZmlsdGVyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZSgnZmlsdGVyJywgdHJ1ZSkudmFsdWUgPSBmaWx0ZXI7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgLy8gTk8gUkVOREVSXG4gICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZpbHRlci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5mZU1vcnBob2xvZ3kgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZlTW9ycGhvbG9neS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5mZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVDb21wb3NpdGUucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVDb2xvck1hdHJpeCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5hdHRyaWJ1dGUoJ3ZhbHVlcycpLnZhbHVlKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS52YWx1ZU9yRGVmYXVsdCgnbWF0cml4JykpIHsgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ZpbHRlcnMuaHRtbCNmZUNvbG9yTWF0cml4RWxlbWVudFxuICAgICAgICAgICAgICAgIGNhc2UgJ3NhdHVyYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBtYXRyaXhbMF07XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFswLjIxMyswLjc4NypzLDAuNzE1LTAuNzE1KnMsMC4wNzItMC4wNzIqcywwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjIxMy0wLjIxMypzLDAuNzE1KzAuMjg1KnMsMC4wNzItMC4wNzIqcywwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjIxMy0wLjIxMypzLDAuNzE1LTAuNzE1KnMsMC4wNzIrMC45MjgqcywwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwxLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwwLDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdodWVSb3RhdGUnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG1hdHJpeFswXSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAobTEsbTIsbTMpIHsgcmV0dXJuIG0xICsgTWF0aC5jb3MoYSkqbTIgKyBNYXRoLnNpbihhKSptMzsgfTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ID0gW2MoMC4yMTMsMC43ODcsLTAuMjEzKSxjKDAuNzE1LC0wLjcxNSwtMC43MTUpLGMoMC4wNzIsLTAuMDcyLDAuOTI4KSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjKDAuMjEzLC0wLjIxMywwLjE0MyksYygwLjcxNSwwLjI4NSwwLjE0MCksYygwLjA3MiwtMC4wNzIsLTAuMjgzKSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjKDAuMjEzLC0wLjIxMywtMC43ODcpLGMoMC43MTUsLTAuNzE1LDAuNzE1KSxjKDAuMDcyLDAuOTI4LDAuMDcyKSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwxLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwwLDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsdW1pbmFuY2VUb0FscGhhJzpcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ID0gWzAsMCwwLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwwLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwwLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMjEyNSwwLjcxNTQsMC4wNzIxLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwwLDAsMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBpbUdldChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJnYmEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1nW3kqd2lkdGgqNCArIHgqNCArIHJnYmFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBpbVNldChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJnYmEsIHZhbCkge1xuICAgICAgICAgICAgICAgIGltZ1t5KndpZHRoKjQgKyB4KjQgKyByZ2JhXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gbShpLCB2KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pID0gbWF0cml4W2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiBtaSAqIChtaSA8IDAgPyB2IC0gMjU1IDogdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWluZyB4PT0wICYmIHk9PTAgZm9yIG5vd1xuICAgICAgICAgICAgICAgIHZhciBzcmNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCBtKDAscikrbSgxLGcpK20oMixiKSttKDMsYSkrbSg0LDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSwgbSg1LHIpK20oNixnKSttKDcsYikrbSg4LGEpK20oOSwxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIsIG0oMTAscikrbSgxMSxnKSttKDEyLGIpK20oMTMsYSkrbSgxNCwxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG0oMTUscikrbSgxNixnKSttKDE3LGIpK20oMTgsYSkrbSgxOSwxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKHNyY0RhdGEsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZlQ29sb3JNYXRyaXgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVHYXVzc2lhbkJsdXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcblxuICAgICAgICAgICAgdGhpcy5ibHVyUmFkaXVzID0gTWF0aC5mbG9vcih0aGlzLmF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJykubnVtVmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLmV4dHJhRmlsdGVyRGlzdGFuY2UgPSB0aGlzLmJsdXJSYWRpdXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHN0YWNrQmx1ckNhbnZhc1JHQkEpID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN2Zy5sb2coJ0VSUk9SOiBTdGFja0JsdXIuanMgbXVzdCBiZSBpbmNsdWRlZCBmb3IgYmx1ciB0byB3b3JrJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU3RhY2tCbHVyIHJlcXVpcmVzIGNhbnZhcyBiZSBvbiBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuaWQgPSBzdmcuVW5pcXVlSWQoKTtcbiAgICAgICAgICAgICAgICBjdHguY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjdHguY2FudmFzKTtcbiAgICAgICAgICAgICAgICBzdGFja0JsdXJDYW52YXNSR0JBKGN0eC5jYW52YXMuaWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuYmx1clJhZGl1cyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjdHguY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5mZUdhdXNzaWFuQmx1ci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyB0aXRsZSBlbGVtZW50LCBkbyBub3RoaW5nXG4gICAgICAgIHN2Zy5FbGVtZW50LnRpdGxlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnRpdGxlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcblxuICAgICAgICAvLyBkZXNjIGVsZW1lbnQsIGRvIG5vdGhpbmdcbiAgICAgICAgc3ZnLkVsZW1lbnQuZGVzYyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5kZXNjLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTsgICAgICAgXG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5NSVNTSU5HID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgc3ZnLmxvZygnRVJST1I6IEVsZW1lbnQgXFwnJyArIG5vZGUubm9kZU5hbWUgKyAnXFwnIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuTUlTU0lORy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBlbGVtZW50IGZhY3RvcnlcbiAgICAgICAgc3ZnLkNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7ICAgIFxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvXlteOl0rOi8sJycpOyAvLyByZW1vdmUgbmFtZXNwYWNlXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZSgvXFwtL2csJycpOyAvLyByZW1vdmUgZGFzaGVzXG4gICAgICAgICAgICB2YXIgZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHN2Zy5FbGVtZW50W2NsYXNzTmFtZV0pICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZSA9IG5ldyBzdmcuRWxlbWVudFtjbGFzc05hbWVdKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZSA9IG5ldyBzdmcuRWxlbWVudC5NSVNTSU5HKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnR5cGUgPSBub2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgLy8gbG9hZCBmcm9tIHVybFxuICAgICAgICBzdmcubG9hZCA9IGZ1bmN0aW9uKGN0eCwgdXJsKSB7XG4gICAgICAgICAgICBzdmcubG9hZFhtbChjdHgsIHN2Zy5hamF4KHVybCkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBsb2FkIGZyb20geG1sXG4gICAgICAgIHN2Zy5sb2FkWG1sID0gZnVuY3Rpb24oY3R4LCB4bWwpIHtcbiAgICAgICAgICAgIHN2Zy5sb2FkWG1sRG9jKGN0eCwgc3ZnLnBhcnNlWG1sKHhtbCkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdmcubG9hZFhtbERvYyA9IGZ1bmN0aW9uKGN0eCwgZG9tKSB7XG4gICAgICAgICAgICBzdmcuaW5pdChjdHgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbWFwWFkgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjdHguY2FudmFzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHAueCAtPSBlLm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHAueSAtPSBlLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnNjcm9sbFgpIHAueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnNjcm9sbFkpIHAueSArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYmluZCBtb3VzZVxuICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydpZ25vcmVNb3VzZSddICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjdHguY2FudmFzLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbWFwWFkobmV3IHN2Zy5Qb2ludChlICE9IG51bGwgPyBlLmNsaWVudFggOiBldmVudC5jbGllbnRYLCBlICE9IG51bGwgPyBlLmNsaWVudFkgOiBldmVudC5jbGllbnRZKSk7XG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Nb3VzZS5vbmNsaWNrKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGN0eC5jYW52YXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbWFwWFkobmV3IHN2Zy5Qb2ludChlICE9IG51bGwgPyBlLmNsaWVudFggOiBldmVudC5jbGllbnRYLCBlICE9IG51bGwgPyBlLmNsaWVudFkgOiBldmVudC5jbGllbnRZKSk7XG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Nb3VzZS5vbm1vdXNlbW92ZShwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgZSA9IHN2Zy5DcmVhdGVFbGVtZW50KGRvbS5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZS5yb290ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyByZW5kZXIgbG9vcFxuICAgICAgICAgICAgdmFyIGlzRmlyc3RSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuQ2xlYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNhbnZhcy5wYXJlbnROb2RlKSBzdmcuVmlld1BvcnQuU2V0Q3VycmVudChjdHguY2FudmFzLnBhcmVudE5vZGUuY2xpZW50V2lkdGgsIGN0eC5jYW52YXMucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydpZ25vcmVEaW1lbnNpb25zJ10gIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FudmFzIHNpemVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuc3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IGUuc3R5bGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuc3R5bGUud2lkdGggPSBjdHguY2FudmFzLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zdHlsZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSBlLnN0eWxlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjdHguY2FudmFzLmhlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNXaWR0aCA9IGN0eC5jYW52YXMuY2xpZW50V2lkdGggfHwgY3R4LmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY0hlaWdodCA9IGN0eC5jYW52YXMuY2xpZW50SGVpZ2h0IHx8IGN0eC5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snaWdub3JlRGltZW5zaW9ucyddID09IHRydWUgJiYgZS5zdHlsZSgnd2lkdGgnKS5oYXNWYWx1ZSgpICYmIGUuc3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY1dpZHRoID0gZS5zdHlsZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgICAgICBjSGVpZ2h0ID0gZS5zdHlsZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTsgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydvZmZzZXRYJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3gnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRYJ107XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydvZmZzZXRZJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3knLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRZJ107XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydzY2FsZVdpZHRoJ10gIT0gbnVsbCB8fCBzdmcub3B0c1snc2NhbGVIZWlnaHQnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UmF0aW8gPSBudWxsLCB5UmF0aW8gPSBudWxsLCB2aWV3Qm94ID0gc3ZnLlRvTnVtYmVyQXJyYXkoZS5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgeFJhdGlvID0gZS5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKSAvIHN2Zy5vcHRzWydzY2FsZVdpZHRoJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNOYU4odmlld0JveFsyXSkpIHhSYXRpbyA9IHZpZXdCb3hbMl0gLyBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB5UmF0aW8gPSBlLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKSAvIHN2Zy5vcHRzWydzY2FsZUhlaWdodCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbM10pKSB5UmF0aW8gPSB2aWV3Qm94WzNdIC8gc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoeFJhdGlvID09IG51bGwpIHsgeFJhdGlvID0geVJhdGlvOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5UmF0aW8gPT0gbnVsbCkgeyB5UmF0aW8gPSB4UmF0aW87IH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGUuYXR0cmlidXRlKCd3aWR0aCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXTtcbiAgICAgICAgICAgICAgICAgICAgZS5hdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J107XG4gICAgICAgICAgICAgICAgICAgIGUuYXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0cnVlKS52YWx1ZSArPSAnIHNjYWxlKCcrKDEuMC94UmF0aW8pKycsJysoMS4wL3lSYXRpbykrJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGFuZCByZW5kZXJcbiAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ2lnbm9yZUNsZWFyJ10gIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNXaWR0aCwgY0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFJlbmRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHN2Zy5vcHRzWydyZW5kZXJDYWxsYmFjayddKSA9PSAnZnVuY3Rpb24nKSBzdmcub3B0c1sncmVuZGVyQ2FsbGJhY2snXShkb20pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgd2FpdGluZ0ZvckltYWdlcyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3ZnLkltYWdlc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgd2FpdGluZ0ZvckltYWdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN2Zy5pbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgIHZhciBuZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmdGb3JJbWFnZXMgJiYgc3ZnLkltYWdlc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JJbWFnZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBtb3VzZSBldmVudHM/XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydpZ25vcmVNb3VzZSddICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZFVwZGF0ZSA9IG5lZWRVcGRhdGUgfCBzdmcuTW91c2UuaGFzRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBhbmltYXRpb25zP1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snaWdub3JlQW5pbWF0aW9uJ10gIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c3ZnLkFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRVcGRhdGUgPSBuZWVkVXBkYXRlIHwgc3ZnLkFuaW1hdGlvbnNbaV0udXBkYXRlKDEwMDAgLyBzdmcuRlJBTUVSQVRFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHVwZGF0ZSBmcm9tIHJlZHJhdz9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHN2Zy5vcHRzWydmb3JjZVJlZHJhdyddKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snZm9yY2VSZWRyYXcnXSgpID09IHRydWUpIG5lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKG5lZWRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhdygpOyAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3ZnLk1vdXNlLnJ1bkV2ZW50cygpOyAvLyBydW4gYW5kIGNsZWFyIG91ciBldmVudHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwIC8gc3ZnLkZSQU1FUkFURSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN2Zy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3ZnLmludGVydmFsSUQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHN2Zy5pbnRlcnZhbElEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3ZnLk1vdXNlID0gbmV3IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmhhc0V2ZW50cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoICE9IDA7IH1cbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7IHR5cGU6ICdvbmNsaWNrJywgeDogeCwgeTogeSwgXG4gICAgICAgICAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oZSkgeyBpZiAoZS5vbmNsaWNrKSBlLm9uY2xpY2soKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goeyB0eXBlOiAnb25tb3VzZW1vdmUnLCB4OiB4LCB5OiB5LFxuICAgICAgICAgICAgICAgICAgICBydW46IGZ1bmN0aW9uKGUpIHsgaWYgKGUub25tb3VzZW1vdmUpIGUub25tb3VzZW1vdmUoKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGN0eCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LmlzUG9pbnRJblBhdGggJiYgY3R4LmlzUG9pbnRJblBhdGgoZS54LCBlLnkpKSB0aGlzLmV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jaGVja0JvdW5kaW5nQm94ID0gZnVuY3Rpb24oZWxlbWVudCwgYmIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJiLmlzUG9pbnRJbkJveChlLngsIGUueSkpIHRoaXMuZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucnVuRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3ZnLmN0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5ldmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5ldmVudEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5ydW4oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gZG9uZSBydW5uaW5nLCBjbGVhclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107IFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfVxufSkoKTtcblxuaWYgKHR5cGVvZihDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kcmF3U3ZnID0gZnVuY3Rpb24ocywgZHgsIGR5LCBkdywgZGgpIHtcbiAgICAgICAgY2FudmcodGhpcy5jYW52YXMsIHMsIHsgXG4gICAgICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSwgXG4gICAgICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsIFxuICAgICAgICAgICAgaWdub3JlRGltZW5zaW9uczogdHJ1ZSwgXG4gICAgICAgICAgICBpZ25vcmVDbGVhcjogdHJ1ZSwgXG4gICAgICAgICAgICBvZmZzZXRYOiBkeCwgXG4gICAgICAgICAgICBvZmZzZXRZOiBkeSwgXG4gICAgICAgICAgICBzY2FsZVdpZHRoOiBkdywgXG4gICAgICAgICAgICBzY2FsZUhlaWdodDogZGhcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLy8gZGVwZW5kZW5jeSBmb3IgY2Fudmdcbi8qKlxuICogQSBjbGFzcyB0byBwYXJzZSBjb2xvciB2YWx1ZXNcbiAqIEBhdXRob3IgU3RveWFuIFN0ZWZhbm92IDxzc3Rvb0BnbWFpbC5jb20+XG4gKiBAbGluayAgIGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXG4gKiBAbGljZW5zZSBVc2UgaXQgaWYgeW91IGxpa2UgaXRcbiAqL1xuZnVuY3Rpb24gUkdCQ29sb3IoY29sb3Jfc3RyaW5nKVxue1xuICAgIHRoaXMub2sgPSBmYWxzZTtcblxuICAgIC8vIHN0cmlwIGFueSBsZWFkaW5nICNcbiAgICBpZiAoY29sb3Jfc3RyaW5nLmNoYXJBdCgwKSA9PSAnIycpIHsgLy8gcmVtb3ZlICMgaWYgYW55XG4gICAgICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5zdWJzdHIoMSw2KTtcbiAgICB9XG5cbiAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcucmVwbGFjZSgvIC9nLCcnKTtcbiAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGJlZm9yZSBnZXR0aW5nIGludG8gcmVnZXhwcywgdHJ5IHNpbXBsZSBtYXRjaGVzXG4gICAgLy8gYW5kIG92ZXJ3cml0ZSB0aGUgaW5wdXRcbiAgICB2YXIgc2ltcGxlX2NvbG9ycyA9IHtcbiAgICAgICAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgICAgICAgYXF1YTogJzAwZmZmZicsXG4gICAgICAgIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICAgICAgICBhenVyZTogJ2YwZmZmZicsXG4gICAgICAgIGJlaWdlOiAnZjVmNWRjJyxcbiAgICAgICAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgICAgICAgYmxhY2s6ICcwMDAwMDAnLFxuICAgICAgICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gICAgICAgIGJsdWU6ICcwMDAwZmYnLFxuICAgICAgICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgICAgICAgYnJvd246ICdhNTJhMmEnLFxuICAgICAgICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICAgICAgICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICAgICAgICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgICAgICAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgICAgICAgY29yYWw6ICdmZjdmNTAnLFxuICAgICAgICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gICAgICAgIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgICAgICAgY3JpbXNvbjogJ2RjMTQzYycsXG4gICAgICAgIGN5YW46ICcwMGZmZmYnLFxuICAgICAgICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gICAgICAgIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgICAgICAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gICAgICAgIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgICAgICAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgICAgICAgZGFya2toYWtpOiAnYmRiNzZiJyxcbiAgICAgICAgZGFya21hZ2VudGE6ICc4YjAwOGInLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogJzU1NmIyZicsXG4gICAgICAgIGRhcmtvcmFuZ2U6ICdmZjhjMDAnLFxuICAgICAgICBkYXJrb3JjaGlkOiAnOTkzMmNjJyxcbiAgICAgICAgZGFya3JlZDogJzhiMDAwMCcsXG4gICAgICAgIGRhcmtzYWxtb246ICdlOTk2N2EnLFxuICAgICAgICBkYXJrc2VhZ3JlZW46ICc4ZmJjOGYnLFxuICAgICAgICBkYXJrc2xhdGVibHVlOiAnNDgzZDhiJyxcbiAgICAgICAgZGFya3NsYXRlZ3JheTogJzJmNGY0ZicsXG4gICAgICAgIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICAgICAgICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgICAgICAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICAgICAgICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gICAgICAgIGRpbWdyYXk6ICc2OTY5NjknLFxuICAgICAgICBkb2RnZXJibHVlOiAnMWU5MGZmJyxcbiAgICAgICAgZmVsZHNwYXI6ICdkMTkyNzUnLFxuICAgICAgICBmaXJlYnJpY2s6ICdiMjIyMjInLFxuICAgICAgICBmbG9yYWx3aGl0ZTogJ2ZmZmFmMCcsXG4gICAgICAgIGZvcmVzdGdyZWVuOiAnMjI4YjIyJyxcbiAgICAgICAgZnVjaHNpYTogJ2ZmMDBmZicsXG4gICAgICAgIGdhaW5zYm9ybzogJ2RjZGNkYycsXG4gICAgICAgIGdob3N0d2hpdGU6ICdmOGY4ZmYnLFxuICAgICAgICBnb2xkOiAnZmZkNzAwJyxcbiAgICAgICAgZ29sZGVucm9kOiAnZGFhNTIwJyxcbiAgICAgICAgZ3JheTogJzgwODA4MCcsXG4gICAgICAgIGdyZWVuOiAnMDA4MDAwJyxcbiAgICAgICAgZ3JlZW55ZWxsb3c6ICdhZGZmMmYnLFxuICAgICAgICBob25leWRldzogJ2YwZmZmMCcsXG4gICAgICAgIGhvdHBpbms6ICdmZjY5YjQnLFxuICAgICAgICBpbmRpYW5yZWQgOiAnY2Q1YzVjJyxcbiAgICAgICAgaW5kaWdvIDogJzRiMDA4MicsXG4gICAgICAgIGl2b3J5OiAnZmZmZmYwJyxcbiAgICAgICAga2hha2k6ICdmMGU2OGMnLFxuICAgICAgICBsYXZlbmRlcjogJ2U2ZTZmYScsXG4gICAgICAgIGxhdmVuZGVyYmx1c2g6ICdmZmYwZjUnLFxuICAgICAgICBsYXduZ3JlZW46ICc3Y2ZjMDAnLFxuICAgICAgICBsZW1vbmNoaWZmb246ICdmZmZhY2QnLFxuICAgICAgICBsaWdodGJsdWU6ICdhZGQ4ZTYnLFxuICAgICAgICBsaWdodGNvcmFsOiAnZjA4MDgwJyxcbiAgICAgICAgbGlnaHRjeWFuOiAnZTBmZmZmJyxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICdmYWZhZDInLFxuICAgICAgICBsaWdodGdyZXk6ICdkM2QzZDMnLFxuICAgICAgICBsaWdodGdyZWVuOiAnOTBlZTkwJyxcbiAgICAgICAgbGlnaHRwaW5rOiAnZmZiNmMxJyxcbiAgICAgICAgbGlnaHRzYWxtb246ICdmZmEwN2EnLFxuICAgICAgICBsaWdodHNlYWdyZWVuOiAnMjBiMmFhJyxcbiAgICAgICAgbGlnaHRza3libHVlOiAnODdjZWZhJyxcbiAgICAgICAgbGlnaHRzbGF0ZWJsdWU6ICc4NDcwZmYnLFxuICAgICAgICBsaWdodHNsYXRlZ3JheTogJzc3ODg5OScsXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiAnYjBjNGRlJyxcbiAgICAgICAgbGlnaHR5ZWxsb3c6ICdmZmZmZTAnLFxuICAgICAgICBsaW1lOiAnMDBmZjAwJyxcbiAgICAgICAgbGltZWdyZWVuOiAnMzJjZDMyJyxcbiAgICAgICAgbGluZW46ICdmYWYwZTYnLFxuICAgICAgICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgICAgICAgbWFyb29uOiAnODAwMDAwJyxcbiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogJzY2Y2RhYScsXG4gICAgICAgIG1lZGl1bWJsdWU6ICcwMDAwY2QnLFxuICAgICAgICBtZWRpdW1vcmNoaWQ6ICdiYTU1ZDMnLFxuICAgICAgICBtZWRpdW1wdXJwbGU6ICc5MzcwZDgnLFxuICAgICAgICBtZWRpdW1zZWFncmVlbjogJzNjYjM3MScsXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogJzdiNjhlZScsXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnMDBmYTlhJyxcbiAgICAgICAgbWVkaXVtdHVycXVvaXNlOiAnNDhkMWNjJyxcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAnYzcxNTg1JyxcbiAgICAgICAgbWlkbmlnaHRibHVlOiAnMTkxOTcwJyxcbiAgICAgICAgbWludGNyZWFtOiAnZjVmZmZhJyxcbiAgICAgICAgbWlzdHlyb3NlOiAnZmZlNGUxJyxcbiAgICAgICAgbW9jY2FzaW46ICdmZmU0YjUnLFxuICAgICAgICBuYXZham93aGl0ZTogJ2ZmZGVhZCcsXG4gICAgICAgIG5hdnk6ICcwMDAwODAnLFxuICAgICAgICBvbGRsYWNlOiAnZmRmNWU2JyxcbiAgICAgICAgb2xpdmU6ICc4MDgwMDAnLFxuICAgICAgICBvbGl2ZWRyYWI6ICc2YjhlMjMnLFxuICAgICAgICBvcmFuZ2U6ICdmZmE1MDAnLFxuICAgICAgICBvcmFuZ2VyZWQ6ICdmZjQ1MDAnLFxuICAgICAgICBvcmNoaWQ6ICdkYTcwZDYnLFxuICAgICAgICBwYWxlZ29sZGVucm9kOiAnZWVlOGFhJyxcbiAgICAgICAgcGFsZWdyZWVuOiAnOThmYjk4JyxcbiAgICAgICAgcGFsZXR1cnF1b2lzZTogJ2FmZWVlZScsXG4gICAgICAgIHBhbGV2aW9sZXRyZWQ6ICdkODcwOTMnLFxuICAgICAgICBwYXBheWF3aGlwOiAnZmZlZmQ1JyxcbiAgICAgICAgcGVhY2hwdWZmOiAnZmZkYWI5JyxcbiAgICAgICAgcGVydTogJ2NkODUzZicsXG4gICAgICAgIHBpbms6ICdmZmMwY2InLFxuICAgICAgICBwbHVtOiAnZGRhMGRkJyxcbiAgICAgICAgcG93ZGVyYmx1ZTogJ2IwZTBlNicsXG4gICAgICAgIHB1cnBsZTogJzgwMDA4MCcsXG4gICAgICAgIHJlZDogJ2ZmMDAwMCcsXG4gICAgICAgIHJvc3licm93bjogJ2JjOGY4ZicsXG4gICAgICAgIHJveWFsYmx1ZTogJzQxNjllMScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgICAgICAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgICAgICAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gICAgICAgIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgICAgICAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICAgICAgICBzaWVubmE6ICdhMDUyMmQnLFxuICAgICAgICBzaWx2ZXI6ICdjMGMwYzAnLFxuICAgICAgICBza3libHVlOiAnODdjZWViJyxcbiAgICAgICAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgICAgICAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgICAgICAgc25vdzogJ2ZmZmFmYScsXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgICAgICAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgICAgICAgdGFuOiAnZDJiNDhjJyxcbiAgICAgICAgdGVhbDogJzAwODA4MCcsXG4gICAgICAgIHRoaXN0bGU6ICdkOGJmZDgnLFxuICAgICAgICB0b21hdG86ICdmZjYzNDcnLFxuICAgICAgICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICAgICAgICB2aW9sZXQ6ICdlZTgyZWUnLFxuICAgICAgICB2aW9sZXRyZWQ6ICdkMDIwOTAnLFxuICAgICAgICB3aGVhdDogJ2Y1ZGViMycsXG4gICAgICAgIHdoaXRlOiAnZmZmZmZmJyxcbiAgICAgICAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gICAgICAgIHllbGxvdzogJ2ZmZmYwMCcsXG4gICAgICAgIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xuICAgIH07XG4gICAgZm9yICh2YXIga2V5IGluIHNpbXBsZV9jb2xvcnMpIHtcbiAgICAgICAgaWYgKGNvbG9yX3N0cmluZyA9PSBrZXkpIHtcbiAgICAgICAgICAgIGNvbG9yX3N0cmluZyA9IHNpbXBsZV9jb2xvcnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlbWQgb2Ygc2ltcGxlIHR5cGUtaW4gY29sb3JzXG5cbiAgICAvLyBhcnJheSBvZiBjb2xvciBkZWZpbml0aW9uIG9iamVjdHNcbiAgICB2YXIgY29sb3JfZGVmcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9ecmdiXFwoKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KVxcKSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWydyZ2IoMTIzLCAyMzQsIDQ1KScsICdyZ2IoMjU1LDIzNCwyNDUpJ10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXihcXHd7Mn0pKFxcd3syfSkoXFx3ezJ9KSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWycjMDBmZjAwJywgJzMzNjY5OSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdLCAxNilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL14oXFx3ezF9KShcXHd7MX0pKFxcd3sxfSkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsnI2ZiMCcsICdmMGYnXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdICsgYml0c1sxXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdICsgYml0c1syXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdICsgYml0c1szXSwgMTYpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF07XG5cbiAgICAvLyBzZWFyY2ggdGhyb3VnaCB0aGUgZGVmaW5pdGlvbnMgdG8gZmluZCBhIG1hdGNoXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcl9kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZSA9IGNvbG9yX2RlZnNbaV0ucmU7XG4gICAgICAgIHZhciBwcm9jZXNzb3IgPSBjb2xvcl9kZWZzW2ldLnByb2Nlc3M7XG4gICAgICAgIHZhciBiaXRzID0gcmUuZXhlYyhjb2xvcl9zdHJpbmcpO1xuICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgY2hhbm5lbHMgPSBwcm9jZXNzb3IoYml0cyk7XG4gICAgICAgICAgICB0aGlzLnIgPSBjaGFubmVsc1swXTtcbiAgICAgICAgICAgIHRoaXMuZyA9IGNoYW5uZWxzWzFdO1xuICAgICAgICAgICAgdGhpcy5iID0gY2hhbm5lbHNbMl07XG4gICAgICAgICAgICB0aGlzLm9rID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUvY2xlYW51cCB2YWx1ZXNcbiAgICB0aGlzLnIgPSAodGhpcy5yIDwgMCB8fCBpc05hTih0aGlzLnIpKSA/IDAgOiAoKHRoaXMuciA+IDI1NSkgPyAyNTUgOiB0aGlzLnIpO1xuICAgIHRoaXMuZyA9ICh0aGlzLmcgPCAwIHx8IGlzTmFOKHRoaXMuZykpID8gMCA6ICgodGhpcy5nID4gMjU1KSA/IDI1NSA6IHRoaXMuZyk7XG4gICAgdGhpcy5iID0gKHRoaXMuYiA8IDAgfHwgaXNOYU4odGhpcy5iKSkgPyAwIDogKCh0aGlzLmIgPiAyNTUpID8gMjU1IDogdGhpcy5iKTtcblxuICAgIC8vIHNvbWUgZ2V0dGVyc1xuICAgIHRoaXMudG9SR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLnIgKyAnLCAnICsgdGhpcy5nICsgJywgJyArIHRoaXMuYiArICcpJztcbiAgICB9XG4gICAgdGhpcy50b0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnIudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuZy50b1N0cmluZygxNik7XG4gICAgICAgIHZhciBiID0gdGhpcy5iLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHIubGVuZ3RoID09IDEpIHIgPSAnMCcgKyByO1xuICAgICAgICBpZiAoZy5sZW5ndGggPT0gMSkgZyA9ICcwJyArIGc7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PSAxKSBiID0gJzAnICsgYjtcbiAgICAgICAgcmV0dXJuICcjJyArIHIgKyBnICsgYjtcbiAgICB9XG5cbiAgICAvLyBoZWxwXG4gICAgdGhpcy5nZXRIZWxwWE1MID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBleGFtcGxlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAvLyBhZGQgcmVnZXhwc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleGFtcGxlID0gY29sb3JfZGVmc1tpXS5leGFtcGxlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleGFtcGxlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZXhhbXBsZXNbZXhhbXBsZXMubGVuZ3RoXSA9IGV4YW1wbGVbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHR5cGUtaW4gY29sb3JzXG4gICAgICAgIGZvciAodmFyIHNjIGluIHNpbXBsZV9jb2xvcnMpIHtcbiAgICAgICAgICAgIGV4YW1wbGVzW2V4YW1wbGVzLmxlbmd0aF0gPSBzYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB4bWwuc2V0QXR0cmlidXRlKCdpZCcsICdyZ2Jjb2xvci1leGFtcGxlcycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2NvbG9yID0gbmV3IFJHQkNvbG9yKGV4YW1wbGVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZV9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBleGFtcGxlX2Rpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW46IDNweDsgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYm9yZGVyOiAxcHggc29saWQgYmxhY2s7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JhY2tncm91bmQ6JyArIGxpc3RfY29sb3IudG9IZXgoKSArICc7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2NvbG9yOicgKyBsaXN0X2NvbG9yLnRvSGV4KClcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZXhhbXBsZV9kaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RfaXRlbV92YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgICAgICAgICAgICAnICcgKyBleGFtcGxlc1tpXSArICcgLT4gJyArIGxpc3RfY29sb3IudG9SR0IoKSArICcgLT4gJyArIGxpc3RfY29sb3IudG9IZXgoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGlzdF9pdGVtLmFwcGVuZENoaWxkKGV4YW1wbGVfZGl2KTtcbiAgICAgICAgICAgICAgICBsaXN0X2l0ZW0uYXBwZW5kQ2hpbGQobGlzdF9pdGVtX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB4bWwuYXBwZW5kQ2hpbGQobGlzdF9pdGVtKTtcblxuICAgICAgICAgICAgfSBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhtbDtcblxuICAgIH1cblxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gUkdCQ29sb3I7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuXy5taXhpbih7XG4gIHRyYW5zcG9zZTogZnVuY3Rpb24oYXJycykge1xuICAgIHJldHVybiBfLnppcC5hcHBseShfLCBhcnJzKTtcbiAgfVxufSk7XG4iLCIvLyBob3BlZnVsbHkgbm90IHRoYXQgdWdseSwgYnV0IHNlZW1lZCBhcyBnb29kIGEgcGxhY2UgYXMgYW55IGZvciB0aGlzIHN0dWZmLi4uXG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG5cblxudmFyIGZvcm1hdEtNQiA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgZGVjaW1hbFNlcGFyYXRvcikge1xuICB2YXIgYXBwID0gd2luZG93LmFwcDtcbiAgdmFyIGZvcm1hdFNJID0gZDMuZm9ybWF0KCcuJyArIChwcmVjaXNpb24gfHwgMykgKyAncycpO1xuICBkZWNpbWFsU2VwYXJhdG9yID0gZGVjaW1hbFNlcGFyYXRvciB8fCAnLic7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXRTSSh2YWx1ZSlcbiAgICAgIC5yZXBsYWNlKCdrJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC10aG91c2FuZCcpKVxuICAgICAgLnJlcGxhY2UoJ00nLCBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LW1pbGxpb24nKSlcbiAgICAgIC5yZXBsYWNlKCdHJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1iaWxsaW9uJykpICAvLyBub3cganVzdCBuZWVkIHRvIGNvbnZlcnQgRyBHaWdpYSAtPiBCIEJpbGxpb25cbiAgICAgIC5yZXBsYWNlKCdUJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC10cmlsbGlvbicpKVxuICAgICAgLnJlcGxhY2UoJ1AnLCBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LXBldGEnKSlcbiAgICAgIC5yZXBsYWNlKCdFJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1leGEnKSlcbiAgICAgIC5yZXBsYWNlKCcuJywgZGVjaW1hbFNlcGFyYXRvcik7XG4gIH07XG59O1xuXG52YXIgdHJhbnNsYXRlTGFuZ3VhZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgYXBwID0gd2luZG93LmFwcDtcbiAgcmV0dXJuIHZhbHVlXG4gICAgLnJlcGxhY2UoJ2snLCBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LXRob3VzYW5kJykpXG4gICAgLnJlcGxhY2UoJ00nLCBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LW1pbGxpb24nKSlcbiAgICAucmVwbGFjZSgnQicsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtYmlsbGlvbicpKVxuICAgIC5yZXBsYWNlKCdUJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC10cmlsbGlvbicpKVxuICAgIC5yZXBsYWNlKCdQJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1wZXRhJykpXG4gICAgLnJlcGxhY2UoJ0UnLCBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LWV4YScpKTtcbn07XG5cbnZhciBmb3JtYXRTaG9ydFRleHQgPSBmdW5jdGlvbihtYXhXaWR0aCkge1xuICB2YXIgZWxsaXBzZVdpZHRoID0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggLSBlbGxpcHNlV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgbWF4V2lkdGggLSBlbGxpcHNlV2lkdGgpICsgJy4uLic7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufTtcblxuXG52YXIgY2F0ZWdvcnlDb2xvdXJzID0gZnVuY3Rpb24oY2F0cykge1xuICAvLyBnZXQgYW4gYXBwcm9wcmlhdGUgY29sb3VyIHNjYWxlIGZvciB0aGUgbnVtYmVyIG9mIGNhdGVnb3JpZXMgd2UgYXJlXG4gIC8vIGRlYWxpbmcgd2l0aFxuICB2YXIgY29sb3VycyA9IGQzLnNjYWxlWydjYXRlZ29yeTIwJ10oKS5yYW5nZSgpO1xuICByZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xuICAgIHJldHVybiBkLmNvbG9yIHx8IChkLmRhdGEgJiYgZC5kYXRhLmNvbG9yKSB8fCBjb2xvdXJzW2kgJSBjb2xvdXJzLmxlbmd0aF07XG4gIH07XG59O1xuXG5cbnZhciB1MTZsZTY0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8vIGJhc2U2NC1lbmNvZGUgYSBzdHJpbmcgYXMgVVRGLTE2LUxFIChmb3IgTVMgRXhjZWwsIHByb2JhYmx5KS4gSXQgd2lsbCBvbmx5XG4gIC8vIHdvcmsgZm9yIDItYnl0ZS13aWRlIHV0Zi0xNiBjaGFyYWN0ZXJzLCBhbmQgd2lsbCBicmVhayBhdCB0aGUgZmlyc3QgaGludFxuICAvLyBvZiBhbnkgNC1ieXRlIGNoYXIuIFR3byBieXRlcyBjb3ZlcnMgdGhlIEJhc2ljIE11bHRpbmluZ3VhbCBQbGFuZSwgc28gd2VcbiAgLy8gc2hvdWxkIGJlIGdvb2QuXG4gIHZhciB1MTZudW0sXG4gICAgICBhc2NpaUJ5dGVQYWlyU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRSk7XG4gIGFzY2lpQnl0ZVBhaXJTdHJpbmcgKz0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKHN0ciwgZnVuY3Rpb24oYWNjLCBjaHIpIHtcbiAgICB1MTZudW0gPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICAvKiBqc2hpbnQgYml0d2lzZTpmYWxzZSAqL1xuICAgIHJldHVybiBhY2MgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHUxNm51bSAmIDB4RkYpICsgU3RyaW5nLmZyb21DaGFyQ29kZSh1MTZudW0gPj4gOCk7XG4gICAgLyoganNoaW50IGJpdHdpc2U6dHJ1ZSAqL1xuICB9LCAnJyk7XG4gIHJldHVybiBidG9hKGFzY2lpQnl0ZVBhaXJTdHJpbmcpO1xufTtcblxuXG52YXIgdGV4dEFzRGF0YVVSTCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gJ2RhdGE6dGV4dC9wbGFpbjtiYXNlNjQsJyArIHUxNmxlNjQoc3RyKTtcbn07XG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtQXJncyh0cmFuc2Zvcm1lciwgd3JhcHBlZCkge1xuICByZXR1cm4gZnVuY3Rpb24oLyogYXJndW1lbnRzICovKSB7XG4gICAgdmFyIHRyYW5zZm9ybWVkQXJncyA9IHRyYW5zZm9ybWVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHdyYXBwZWQuYXBwbHkobnVsbCwgdHJhbnNmb3JtZWRBcmdzKTtcbiAgfTtcbn1cblxuXG5mdW5jdGlvbiB0b0Rhc2hlZChuYW1lKSB7XG4gIC8vIHRyYW5zZm9ybSBuYW1lc0xpa2VUaGlzIHRvIG5hbWVzLWxpa2UtdGhpc1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gJy0nICsgdS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cblxuXG5mdW5jdGlvbiBkYXRhKGVsLCBuYW1lLCBuZXdWYWx1ZSkge1xuICBpZiAobmV3VmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHRvRGFzaGVkKG5hbWUpKTtcbiAgfVxuICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHRvRGFzaGVkKG5hbWUpLCBuZXdWYWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIGhvdyBtdWNoIGhlaWdodCB3ZSBuZWVkIHRvIHNob3cgYSByZWFkYWJsZSBjaGFydCB3aXRoIGRpZmZlcmVudCBudW1iZXIgb2YgbGVnZW5kcy4gXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNoYXJ0SGVpZ2h0KGxlbmd0aCwgaXNEb3dubG9hZCwgbW9kZWwpIHtcblx0dmFyIGhlaWdodCA9IG51bGw7XG5cdHZhciBiaWdOID0gbnVsbDtcblx0aWYgKGxlbmd0aCA8IDMwKSB7XG5cdFx0YmlnTiA9ICcwJztcblx0XHRpZiAoaXNEb3dubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gNDUwO1xuXHRcdH1cblx0fSBlbHNlIGlmKGxlbmd0aCA+PSAzMCAmJiBsZW5ndGggPCA0MCkge1xuXHRcdGlmIChpc0Rvd25sb2FkID09PSB0cnVlKSB7XG5cdFx0XHRoZWlnaHQgPSA1NTA7XG5cdFx0fSAgZWxzZSB7XG5cdFx0XHRoZWlnaHQgPSA0NzU7XG5cdFx0fVxuXHRcdGJpZ04gPSAnMSc7XG5cdH0gZWxzZSBpZihsZW5ndGggPj0gNDAgJiYgbGVuZ3RoIDwgNTApIHtcblx0XHRpZiAoaXNEb3dubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gNzAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWlnaHQgPSA2MjU7XG5cdFx0fVxuXHRcdGJpZ04gPSAnMic7XG5cdH0gZWxzZSBpZihsZW5ndGggPj0gNTAgJiYgbGVuZ3RoIDwgNjApIHtcblx0XHRpZiAoaXNEb3dubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gODUwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWlnaHQgPSA3NzU7XG5cdFx0fVxuXHRcdGJpZ04gPSAnMyc7XG5cdH0gZWxzZSBpZihsZW5ndGggPj0gNjAgJiYgbGVuZ3RoIDwgNzApIHtcblx0XHRpZiAoaXNEb3dubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gMTAwMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVpZ2h0ID0gOTI1O1xuXHRcdH1cblx0XHRiaWdOID0gJzQnO1xuXHR9IGVsc2UgaWYobGVuZ3RoID49IDcwICYmIGxlbmd0aCA8IDgwKSB7XG5cdFx0aWYgKGlzRG93bmxvYWQgPT09IHRydWUpIHtcblx0XHRcdGhlaWdodCA9IDExNTA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlaWdodCA9IDEwNzU7XG5cdFx0fVxuXHRcdGJpZ04gPSAnNSc7XG5cdH0gZWxzZSBpZihsZW5ndGggPj0gODAgJiYgbGVuZ3RoIDwgOTApIHtcblx0XHRpZiAoaXNEb3dubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gMTE1MDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVpZ2h0ID0gMTIyNTtcblx0XHR9XG5cdFx0YmlnTiA9ICc2JztcdFxuXHR9IGVsc2UgaWYobGVuZ3RoID49IDkwKSB7XG5cdFx0Ly8gU2VyaW91c2x5Pz8/P1xuXHRcdGlmIChpc0Rvd25sb2FkID09PSB0cnVlKSB7XG5cdFx0XHRoZWlnaHQgPSAxMzAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWlnaHQgPSAxMzc1O1xuXHRcdH1cblx0XHRiaWdOID0gJzcnO1xuXHR9XG5cdGlmIChtb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0bW9kZWwuc2V0KCdiaWdOJywgYmlnTik7XG5cdH1cblx0cmV0dXJuIGhlaWdodFxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmb3JtYXRLTUI6IGZvcm1hdEtNQixcbiAgdHJhbnNsYXRlTGFuZ3VhZ2U6IHRyYW5zbGF0ZUxhbmd1YWdlLFxuICBmb3JtYXRTaG9ydFRleHQ6IGZvcm1hdFNob3J0VGV4dCxcbiAgY2F0ZWdvcnlDb2xvdXJzOiBjYXRlZ29yeUNvbG91cnMsXG4gIHUxNmxlNjQ6IHUxNmxlNjQsXG4gIHRleHRBc0RhdGFVUkw6IHRleHRBc0RhdGFVUkwsXG4gIHRyYW5zZm9ybUFyZ3M6IHRyYW5zZm9ybUFyZ3MsXG4gIGRhdGE6IGRhdGEsXG4gIGNhbGN1bGF0ZUNoYXJ0SGVpZ2h0OiBjYWxjdWxhdGVDaGFydEhlaWdodFxufTtcbiIsIi8qXG5cdEJhYnkgUGFyc2Vcblx0djAuMi4xXG5cdGh0dHBzOi8vZ2l0aHViLmNvbS9SaWNoLUhhcnJpcy9CYWJ5UGFyc2VcblxuXHRiYXNlZCBvbiBQYXBhIFBhcnNlIHYzLjAuMVxuXHRodHRwczovL2dpdGh1Yi5jb20vbWhvbHQvUGFwYVBhcnNlXG4qL1xuXG5cbihmdW5jdGlvbiAoIGdsb2JhbCApIHtcblxuXHQvLyBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gd2hpY2ggdG8gZHJhdyBkZWZhdWx0IHNldHRpbmdzXG5cdHZhciBERUZBVUxUUyA9IHtcblx0XHRkZWxpbWl0ZXI6IFwiXCIsXHQvLyBlbXB0eTogYXV0by1kZXRlY3Rcblx0XHRoZWFkZXI6IGZhbHNlLFxuXHRcdGR5bmFtaWNUeXBpbmc6IGZhbHNlLFxuXHRcdHByZXZpZXc6IDAsXG5cdFx0c3RlcDogdW5kZWZpbmVkLFxuXHRcdGNvbW1lbnRzOiBmYWxzZSxcblx0XHRjb21wbGV0ZTogdW5kZWZpbmVkLFxuXHRcdGtlZXBFbXB0eVJvd3M6IGZhbHNlXG5cdH07XG5cblx0dmFyIEJhYnkgPSB7fTtcblx0QmFieS5wYXJzZSA9IENzdlRvSnNvbjtcblx0QmFieS51bnBhcnNlID0gSnNvblRvQ3N2O1xuXHRCYWJ5LlJFQ09SRF9TRVAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKTtcblx0QmFieS5VTklUX1NFUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzEpO1xuXHRCYWJ5LkJZVEVfT1JERVJfTUFSSyA9IFwiXFx1ZmVmZlwiO1xuXHRCYWJ5LkJBRF9ERUxJTUlURVJTID0gW1wiXFxyXCIsIFwiXFxuXCIsIFwiXFxcIlwiLCBCYWJ5LkJZVEVfT1JERVJfTUFSS107XG5cblxuXHRmdW5jdGlvbiBDc3ZUb0pzb24oX2lucHV0LCBfY29uZmlnKVxuXHR7XG5cdFx0dmFyIGNvbmZpZyA9IGNvcHlBbmRWYWxpZGF0ZUNvbmZpZyhfY29uZmlnKTtcblx0XHR2YXIgcGggPSBuZXcgUGFyc2VySGFuZGxlKGNvbmZpZyk7XG5cdFx0dmFyIHJlc3VsdHMgPSBwaC5wYXJzZShfaW5wdXQpO1xuXHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5jb21wbGV0ZSkpXG5cdFx0XHRjb25maWcuY29tcGxldGUocmVzdWx0cyk7XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXG5cblxuXHRmdW5jdGlvbiBKc29uVG9Dc3YoX2lucHV0LCBfY29uZmlnKVxuXHR7XG5cdFx0dmFyIF9vdXRwdXQgPSBcIlwiO1xuXHRcdHZhciBfZmllbGRzID0gW107XG5cblx0XHQvLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cblx0XHR2YXIgX3F1b3RlcyA9IGZhbHNlO1x0Ly8gd2hldGhlciB0byBzdXJyb3VuZCBldmVyeSBkYXR1bSB3aXRoIHF1b3Rlc1xuXHRcdHZhciBfZGVsaW1pdGVyID0gXCIsXCI7XHQvLyBkZWxpbWl0aW5nIGNoYXJhY3RlclxuXHRcdHZhciBfbmV3bGluZSA9IFwiXFxyXFxuXCI7XHQvLyBuZXdsaW5lIGNoYXJhY3RlcihzKVxuXG5cdFx0dW5wYWNrQ29uZmlnKCk7XG5cblx0XHRpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ3N0cmluZycpXG5cdFx0XHRfaW5wdXQgPSBKU09OLnBhcnNlKF9pbnB1dCk7XG5cblx0XHRpZiAoX2lucHV0IGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0e1xuXHRcdFx0aWYgKCFfaW5wdXQubGVuZ3RoIHx8IF9pbnB1dFswXSBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdFx0XHRyZXR1cm4gc2VyaWFsaXplKG51bGwsIF9pbnB1dCk7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgX2lucHV0WzBdID09PSAnb2JqZWN0Jylcblx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZShvYmplY3RLZXlzKF9pbnB1dFswXSksIF9pbnB1dCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBfaW5wdXQgPT09ICdvYmplY3QnKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2YgX2lucHV0LmRhdGEgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRfaW5wdXQuZGF0YSA9IEpTT04ucGFyc2UoX2lucHV0LmRhdGEpO1xuXG5cdFx0XHRpZiAoX2lucHV0LmRhdGEgaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFfaW5wdXQuZmllbGRzKVxuXHRcdFx0XHRcdF9pbnB1dC5maWVsZHMgPSBfaW5wdXQuZGF0YVswXSBpbnN0YW5jZW9mIEFycmF5XG5cdFx0XHRcdFx0XHRcdFx0XHQ/IF9pbnB1dC5maWVsZHNcblx0XHRcdFx0XHRcdFx0XHRcdDogb2JqZWN0S2V5cyhfaW5wdXQuZGF0YVswXSk7XG5cblx0XHRcdFx0aWYgKCEoX2lucHV0LmRhdGFbMF0gaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIF9pbnB1dC5kYXRhWzBdICE9PSAnb2JqZWN0Jylcblx0XHRcdFx0XHRfaW5wdXQuZGF0YSA9IFtfaW5wdXQuZGF0YV07XHQvLyBoYW5kbGVzIGlucHV0IGxpa2UgWzEsMiwzXSBvciBbXCJhc2RmXCJdXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXJpYWxpemUoX2lucHV0LmZpZWxkcyB8fCBbXSwgX2lucHV0LmRhdGEgfHwgW10pO1xuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgKGFueSB2YWxpZCBwYXRocyBzaG91bGQgcmV0dXJuIGJlZm9yZSB0aGlzKVxuXHRcdHRocm93IFwiZXhjZXB0aW9uOiBVbmFibGUgdG8gc2VyaWFsaXplIHVucmVjb2duaXplZCBpbnB1dFwiO1xuXG5cblx0XHRmdW5jdGlvbiB1bnBhY2tDb25maWcoKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZyAhPT0gJ29iamVjdCcpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLmRlbGltaXRlciA9PT0gJ3N0cmluZydcblx0XHRcdFx0JiYgX2NvbmZpZy5kZWxpbWl0ZXIubGVuZ3RoID09IDFcblx0XHRcdFx0JiYgQmFieS5CQURfREVMSU1JVEVSUy5pbmRleE9mKF9jb25maWcuZGVsaW1pdGVyKSA9PSAtMSlcblx0XHRcdHtcblx0XHRcdFx0X2RlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcucXVvdGVzID09PSAnYm9vbGVhbidcblx0XHRcdFx0fHwgX2NvbmZpZy5xdW90ZXMgaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0X3F1b3RlcyA9IF9jb25maWcucXVvdGVzO1xuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcubmV3bGluZSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdF9uZXdsaW5lID0gX2NvbmZpZy5uZXdsaW5lO1xuXHRcdH1cblxuXG5cdFx0Ly8gVHVybnMgYW4gb2JqZWN0J3Mga2V5cyBpbnRvIGFuIGFycmF5XG5cdFx0ZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmopXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR2YXIga2V5cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG9iailcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHRyZXR1cm4ga2V5cztcblx0XHR9XG5cblx0XHQvLyBUaGUgZG91YmxlIGZvciBsb29wIHRoYXQgaXRlcmF0ZXMgdGhlIGRhdGEgYW5kIHdyaXRlcyBvdXQgYSBDU1Ygc3RyaW5nIGluY2x1ZGluZyBoZWFkZXIgcm93XG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcywgZGF0YSlcblx0XHR7XG5cdFx0XHR2YXIgY3N2ID0gXCJcIjtcblxuXHRcdFx0aWYgKHR5cGVvZiBmaWVsZHMgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRmaWVsZHMgPSBKU09OLnBhcnNlKGZpZWxkcyk7XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblxuXHRcdFx0dmFyIGhhc0hlYWRlciA9IGZpZWxkcyBpbnN0YW5jZW9mIEFycmF5ICYmIGZpZWxkcy5sZW5ndGggPiAwO1xuXHRcdFx0dmFyIGRhdGFLZXllZEJ5RmllbGQgPSAhKGRhdGFbMF0gaW5zdGFuY2VvZiBBcnJheSk7XG5cblx0XHRcdC8vIElmIHRoZXJlIGEgaGVhZGVyIHJvdywgd3JpdGUgaXQgZmlyc3Rcblx0XHRcdGlmIChoYXNIZWFkZXIpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGkgPiAwKVxuXHRcdFx0XHRcdFx0Y3N2ICs9IF9kZWxpbWl0ZXI7XG5cdFx0XHRcdFx0Y3N2ICs9IHNhZmUoZmllbGRzW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGF0YS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGNzdiArPSBfbmV3bGluZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlbiB3cml0ZSBvdXQgdGhlIGRhdGFcblx0XHRcdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGRhdGEubGVuZ3RoOyByb3crKylcblx0XHRcdHtcblx0XHRcdFx0dmFyIG1heENvbCA9IGhhc0hlYWRlciA/IGZpZWxkcy5sZW5ndGggOiBkYXRhW3Jvd10ubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1heENvbDsgY29sKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY29sID4gMClcblx0XHRcdFx0XHRcdGNzdiArPSBfZGVsaW1pdGVyO1xuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBoYXNIZWFkZXIgJiYgZGF0YUtleWVkQnlGaWVsZCA/IGZpZWxkc1tjb2xdIDogY29sO1xuXHRcdFx0XHRcdGNzdiArPSBzYWZlKGRhdGFbcm93XVtjb2xJZHhdLCBjb2wpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJvdyA8IGRhdGEubGVuZ3RoIC0gMSlcblx0XHRcdFx0XHRjc3YgKz0gX25ld2xpbmU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjc3Y7XG5cdFx0fVxuXG5cdFx0Ly8gRW5jbG9zZXMgYSB2YWx1ZSBhcm91bmQgcXVvdGVzIGlmIG5lZWRlZCAobWFrZXMgYSB2YWx1ZSBzYWZlIGZvciBDU1YgaW5zZXJ0aW9uKVxuXHRcdGZ1bmN0aW9uIHNhZmUoc3RyLCBjb2wpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBzdHIgPT09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHRcdHJldHVybiBcIlwiO1xuXG5cdFx0XHRzdHIgPSBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpO1xuXG5cdFx0XHR2YXIgbmVlZHNRdW90ZXMgPSAodHlwZW9mIF9xdW90ZXMgPT09ICdib29sZWFuJyAmJiBfcXVvdGVzKVxuXHRcdFx0XHRcdFx0XHR8fCAoX3F1b3RlcyBpbnN0YW5jZW9mIEFycmF5ICYmIF9xdW90ZXNbY29sXSlcblx0XHRcdFx0XHRcdFx0fHwgaGFzQW55KHN0ciwgQmFieS5CQURfREVMSU1JVEVSUylcblx0XHRcdFx0XHRcdFx0fHwgc3RyLmluZGV4T2YoX2RlbGltaXRlcikgPiAtMVxuXHRcdFx0XHRcdFx0XHR8fCBzdHIuY2hhckF0KDApID09ICcgJ1xuXHRcdFx0XHRcdFx0XHR8fCBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PSAnICc7XG5cblx0XHRcdHJldHVybiBuZWVkc1F1b3RlcyA/ICdcIicgKyBzdHIgKyAnXCInIDogc3RyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhc0FueShzdHIsIHN1YnN0cmluZ3MpXG5cdFx0e1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzdHJpbmdzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRpZiAoc3RyLmluZGV4T2Yoc3Vic3RyaW5nc1tpXSkgPiAtMSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXG5cblxuXG5cblx0Ly8gVXNlIG9uZSBQYXJzZXJIYW5kbGUgcGVyIGVudGlyZSBDU1YgZmlsZSBvciBzdHJpbmdcblx0ZnVuY3Rpb24gUGFyc2VySGFuZGxlKF9jb25maWcpXG5cdHtcblx0XHQvLyBPbmUgZ29hbCBpcyB0byBtaW5pbWl6ZSB0aGUgdXNlIG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMuLi5cblx0XHR2YXIgRkxPQVQgPSAvXlxccyotPyhcXGQqXFwuP1xcZCt8XFxkK1xcLj9cXGQqKShlWy0rXT9cXGQrKT9cXHMqJC9pO1xuXG5cdFx0dmFyIF9kZWxpbWl0ZXJFcnJvcjtcdC8vIFRlbXBvcmFyeSBzdGF0ZSBiZXR3ZWVuIGRlbGltaXRlciBkZXRlY3Rpb24gYW5kIHByb2Nlc3NpbmcgcmVzdWx0c1xuXHRcdHZhciBfZmllbGRzID0gW107XHRcdC8vIEZpZWxkcyBhcmUgZnJvbSB0aGUgaGVhZGVyIHJvdyBvZiB0aGUgaW5wdXQsIGlmIHRoZXJlIGlzIG9uZVxuXHRcdHZhciBfcmVzdWx0cyA9IHtcdFx0Ly8gVGhlIGxhc3QgcmVzdWx0cyByZXR1cm5lZCBmcm9tIHRoZSBwYXJzZXJcblx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0ZXJyb3JzOiBbXSxcblx0XHRcdG1ldGE6IHt9XG5cdFx0fTtcblx0XHRfY29uZmlnID0gY29weShfY29uZmlnKTtcblxuXHRcdHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dClcblx0XHR7XG5cdFx0XHRfZGVsaW1pdGVyRXJyb3IgPSBmYWxzZTtcblx0XHRcdGlmICghX2NvbmZpZy5kZWxpbWl0ZXIpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBkZWxpbUd1ZXNzID0gZ3Vlc3NEZWxpbWl0ZXIoaW5wdXQpO1xuXHRcdFx0XHRpZiAoZGVsaW1HdWVzcy5zdWNjZXNzZnVsKVxuXHRcdFx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gZGVsaW1HdWVzcy5iZXN0RGVsaW1pdGVyO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfZGVsaW1pdGVyRXJyb3IgPSB0cnVlO1x0Ly8gYWRkIGVycm9yIGFmdGVyIHBhcnNpbmcgKG90aGVyd2lzZSBpdCB3b3VsZCBiZSBvdmVyd3JpdHRlbilcblx0XHRcdFx0XHRfY29uZmlnLmRlbGltaXRlciA9IFwiLFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXN1bHRzLm1ldGEuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc0Z1bmN0aW9uKF9jb25maWcuc3RlcCkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB1c2VyU3RlcCA9IF9jb25maWcuc3RlcDtcblx0XHRcdFx0X2NvbmZpZy5zdGVwID0gZnVuY3Rpb24ocmVzdWx0cywgcGFyc2VyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X3Jlc3VsdHMgPSByZXN1bHRzO1xuXHRcdFx0XHRcdGlmIChuZWVkc0hlYWRlclJvdygpKVxuXHRcdFx0XHRcdFx0cHJvY2Vzc1Jlc3VsdHMoKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR1c2VyU3RlcChwcm9jZXNzUmVzdWx0cygpLCBwYXJzZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRfcmVzdWx0cyA9IG5ldyBQYXJzZXIoX2NvbmZpZykucGFyc2UoaW5wdXQpO1xuXHRcdFx0cmV0dXJuIHByb2Nlc3NSZXN1bHRzKCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHRzKClcblx0XHR7XG5cdFx0XHRpZiAoX3Jlc3VsdHMgJiYgX2RlbGltaXRlckVycm9yKVxuXHRcdFx0e1xuXHRcdFx0XHRhZGRFcnJvcihcIkRlbGltaXRlclwiLCBcIlVuZGV0ZWN0YWJsZURlbGltaXRlclwiLCBcIlVuYWJsZSB0byBhdXRvLWRldGVjdCBkZWxpbWl0aW5nIGNoYXJhY3RlcjsgZGVmYXVsdGVkIHRvIGNvbW1hXCIpO1xuXHRcdFx0XHRfZGVsaW1pdGVyRXJyb3IgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5lZWRzSGVhZGVyUm93KCkpXG5cdFx0XHRcdGZpbGxIZWFkZXJGaWVsZHMoKTtcblxuXHRcdFx0cmV0dXJuIGFwcGx5SGVhZGVyQW5kRHluYW1pY1R5cGluZygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5lZWRzSGVhZGVyUm93KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2NvbmZpZy5oZWFkZXIgJiYgX2ZpZWxkcy5sZW5ndGggPT0gMDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaWxsSGVhZGVyRmllbGRzKClcblx0XHR7XG5cdFx0XHRpZiAoIV9yZXN1bHRzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgbmVlZHNIZWFkZXJSb3coKSAmJiBpIDwgX3Jlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBfcmVzdWx0cy5kYXRhW2ldLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdF9maWVsZHMucHVzaChfcmVzdWx0cy5kYXRhW2ldW2pdKTtcblx0XHRcdF9yZXN1bHRzLmRhdGEuc3BsaWNlKDAsIDEpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFwcGx5SGVhZGVyQW5kRHluYW1pY1R5cGluZygpXG5cdFx0e1xuXHRcdFx0aWYgKCFfcmVzdWx0cyB8fCAoIV9jb25maWcuaGVhZGVyICYmICFfY29uZmlnLmR5bmFtaWNUeXBpbmcpKVxuXHRcdFx0XHRyZXR1cm4gX3Jlc3VsdHM7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgX3Jlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0dmFyIHJvdyA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IF9yZXN1bHRzLmRhdGFbaV0ubGVuZ3RoOyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoX2NvbmZpZy5keW5hbWljVHlwaW5nKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IF9yZXN1bHRzLmRhdGFbaV1bal07XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gXCJ0cnVlXCIpXG5cdFx0XHRcdFx0XHRcdF9yZXN1bHRzLmRhdGFbaV1bal0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodmFsdWUgPT0gXCJmYWxzZVwiKVxuXHRcdFx0XHRcdFx0XHRfcmVzdWx0cy5kYXRhW2ldW2pdID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdF9yZXN1bHRzLmRhdGFbaV1bal0gPSB0cnlQYXJzZUZsb2F0KHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGogPj0gX2ZpZWxkcy5sZW5ndGgpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmICghcm93W1wiX19wYXJzZWRfZXh0cmFcIl0pXG5cdFx0XHRcdFx0XHRcdFx0cm93W1wiX19wYXJzZWRfZXh0cmFcIl0gPSBbXTtcblx0XHRcdFx0XHRcdFx0cm93W1wiX19wYXJzZWRfZXh0cmFcIl0ucHVzaChfcmVzdWx0cy5kYXRhW2ldW2pdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJvd1tfZmllbGRzW2pdXSA9IF9yZXN1bHRzLmRhdGFbaV1bal07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF9jb25maWcuaGVhZGVyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X3Jlc3VsdHMuZGF0YVtpXSA9IHJvdztcblx0XHRcdFx0XHRpZiAoaiA+IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoXCJGaWVsZE1pc21hdGNoXCIsIFwiVG9vTWFueUZpZWxkc1wiLCBcIlRvbyBtYW55IGZpZWxkczogZXhwZWN0ZWQgXCIgKyBfZmllbGRzLmxlbmd0aCArIFwiIGZpZWxkcyBidXQgcGFyc2VkIFwiICsgaiwgaSk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoaiA8IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoXCJGaWVsZE1pc21hdGNoXCIsIFwiVG9vRmV3RmllbGRzXCIsIFwiVG9vIGZldyBmaWVsZHM6IGV4cGVjdGVkIFwiICsgX2ZpZWxkcy5sZW5ndGggKyBcIiBmaWVsZHMgYnV0IHBhcnNlZCBcIiArIGosIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfY29uZmlnLmhlYWRlciAmJiBfcmVzdWx0cy5tZXRhKTtcblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5maWVsZHMgPSBfZmllbGRzO1xuXG5cdFx0XHRyZXR1cm4gX3Jlc3VsdHM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ3Vlc3NEZWxpbWl0ZXIoaW5wdXQpXG5cdFx0e1xuXHRcdFx0dmFyIGRlbGltQ2hvaWNlcyA9IFtcIixcIiwgXCJcXHRcIiwgXCJ8XCIsIFwiO1wiLCBCYWJ5LlJFQ09SRF9TRVAsIEJhYnkuVU5JVF9TRVBdO1xuXHRcdFx0dmFyIGJlc3REZWxpbSwgYmVzdERlbHRhLCBmaWVsZENvdW50UHJldlJvdztcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZWxpbUNob2ljZXMubGVuZ3RoOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBkZWxpbSA9IGRlbGltQ2hvaWNlc1tpXTtcblx0XHRcdFx0dmFyIGRlbHRhID0gMCwgYXZnRmllbGRDb3VudCA9IDA7XG5cdFx0XHRcdGZpZWxkQ291bnRQcmV2Um93ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHZhciBwcmV2aWV3ID0gbmV3IFBhcnNlcih7XG5cdFx0XHRcdFx0ZGVsaW1pdGVyOiBkZWxpbSxcblx0XHRcdFx0XHRwcmV2aWV3OiAxMFxuXHRcdFx0XHR9KS5wYXJzZShpbnB1dCk7XG5cblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBwcmV2aWV3LmRhdGEubGVuZ3RoOyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgZmllbGRDb3VudCA9IHByZXZpZXcuZGF0YVtqXS5sZW5ndGg7XG5cdFx0XHRcdFx0YXZnRmllbGRDb3VudCArPSBmaWVsZENvdW50O1xuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBmaWVsZENvdW50UHJldlJvdyA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSBmaWVsZENvdW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKGZpZWxkQ291bnQgPiAxKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRlbHRhICs9IE1hdGguYWJzKGZpZWxkQ291bnQgLSBmaWVsZENvdW50UHJldlJvdyk7XG5cdFx0XHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IGZpZWxkQ291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXZnRmllbGRDb3VudCAvPSBwcmV2aWV3LmRhdGEubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICgodHlwZW9mIGJlc3REZWx0YSA9PT0gJ3VuZGVmaW5lZCcgfHwgZGVsdGEgPCBiZXN0RGVsdGEpXG5cdFx0XHRcdFx0JiYgYXZnRmllbGRDb3VudCA+IDEuOTkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRiZXN0RGVsdGEgPSBkZWx0YTtcblx0XHRcdFx0XHRiZXN0RGVsaW0gPSBkZWxpbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfY29uZmlnLmRlbGltaXRlciA9IGJlc3REZWxpbTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3VjY2Vzc2Z1bDogISFiZXN0RGVsaW0sXG5cdFx0XHRcdGJlc3REZWxpbWl0ZXI6IGJlc3REZWxpbVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyeVBhcnNlRmxvYXQodmFsKVxuXHRcdHtcblx0XHRcdHZhciBpc051bWJlciA9IEZMT0FULnRlc3QodmFsKTtcblx0XHRcdHJldHVybiBpc051bWJlciA/IHBhcnNlRmxvYXQodmFsKSA6IHZhbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRFcnJvcih0eXBlLCBjb2RlLCBtc2csIHJvdylcblx0XHR7XG5cdFx0XHRfcmVzdWx0cy5lcnJvcnMucHVzaCh7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGNvZGU6IGNvZGUsXG5cdFx0XHRcdG1lc3NhZ2U6IG1zZyxcblx0XHRcdFx0cm93OiByb3dcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cblxuXG5cblxuXG5cdGZ1bmN0aW9uIFBhcnNlcihjb25maWcpXG5cdHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIEVNUFRZID0gL15cXHMqJC87XG5cblx0XHR2YXIgX2lucHV0O1x0XHQvLyBUaGUgaW5wdXQgdGV4dCBiZWluZyBwYXJzZWRcblx0XHR2YXIgX2RlbGltaXRlcjtcdC8vIFRoZSBkZWxpbWl0aW5nIGNoYXJhY3RlclxuXHRcdHZhciBfY29tbWVudHM7XHQvLyBDb21tZW50IGNoYXJhY3RlciAoZGVmYXVsdCAnIycpIG9yIGJvb2xlYW5cblx0XHR2YXIgX3N0ZXA7XHRcdC8vIFRoZSBzdGVwIChzdHJlYW1pbmcpIGZ1bmN0aW9uXG5cdFx0dmFyIF9jYWxsYmFjaztcdC8vIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiBmaW5pc2hlZFxuXHRcdHZhciBfcHJldmlldztcdC8vIE1heGltdW0gbnVtYmVyIG9mIGxpbmVzIChub3Qgcm93cykgdG8gcGFyc2Vcblx0XHR2YXIgX2NoO1x0XHQvLyBDdXJyZW50IGNoYXJhY3RlclxuXHRcdHZhciBfaTtcdFx0XHQvLyBDdXJyZW50IGNoYXJhY3RlcidzIHBvc2l0aW9uYWwgaW5kZXhcblx0XHR2YXIgX2luUXVvdGVzO1x0Ly8gV2hldGhlciBpbiBxdW90ZXMgb3Igbm90XG5cdFx0dmFyIF9saW5lTnVtO1x0Ly8gQ3VycmVudCBsaW5lIG51bWJlciAoMS1iYXNlZCBpbmRleGluZylcblx0XHR2YXIgX2RhdGE7XHRcdC8vIFBhcnNlZCBkYXRhIChyZXN1bHRzKVxuXHRcdHZhciBfZXJyb3JzO1x0Ly8gUGFyc2UgZXJyb3JzXG5cdFx0dmFyIF9yb3dJZHg7XHQvLyBDdXJyZW50IHJvdyBpbmRleCB3aXRoaW4gcmVzdWx0cyAoMC1iYXNlZClcblx0XHR2YXIgX2NvbElkeDtcdC8vIEN1cnJlbnQgY29sIGluZGV4IHdpdGhpbiByZXN1bHQgcm93ICgwLWJhc2VkKVxuXHRcdHZhciBfcnVubmluZ1Jvd0lkeDtcdFx0Ly8gQ3VtdWxhdGl2ZSByb3cgaW5kZXgsIHVzZWQgYnkgdGhlIHByZXZpZXcgZmVhdHVyZVxuXHRcdHZhciBfYWJvcnRlZCA9IGZhbHNlO1x0Ly8gQWJvcnQgZmxhZ1xuXHRcdHZhciBfcGF1c2VkID0gZmFsc2U7XHQvLyBQYXVzZSBmbGFnXG5cblx0XHQvLyBVbnBhY2sgdGhlIGNvbmZpZyBvYmplY3Rcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0X2RlbGltaXRlciA9IGNvbmZpZy5kZWxpbWl0ZXI7XG5cdFx0X2NvbW1lbnRzID0gY29uZmlnLmNvbW1lbnRzO1xuXHRcdF9zdGVwID0gY29uZmlnLnN0ZXA7XG5cdFx0X3ByZXZpZXcgPSBjb25maWcucHJldmlldztcblxuXHRcdC8vIERlbGltaXRlciBpbnRlZ3JpdHkgY2hlY2tcblx0XHRpZiAodHlwZW9mIF9kZWxpbWl0ZXIgIT09ICdzdHJpbmcnXG5cdFx0XHR8fCBfZGVsaW1pdGVyLmxlbmd0aCAhPSAxXG5cdFx0XHR8fCBCYWJ5LkJBRF9ERUxJTUlURVJTLmluZGV4T2YoX2RlbGltaXRlcikgPiAtMSlcblx0XHRcdF9kZWxpbWl0ZXIgPSBcIixcIjtcblxuXHRcdC8vIENvbW1lbnQgY2hhcmFjdGVyIGludGVncml0eSBjaGVja1xuXHRcdGlmIChfY29tbWVudHMgPT09IHRydWUpXG5cdFx0XHRfY29tbWVudHMgPSBcIiNcIjtcblx0XHRlbHNlIGlmICh0eXBlb2YgX2NvbW1lbnRzICE9PSAnc3RyaW5nJ1xuXHRcdFx0fHwgX2NvbW1lbnRzLmxlbmd0aCAhPSAxXG5cdFx0XHR8fCBCYWJ5LkJBRF9ERUxJTUlURVJTLmluZGV4T2YoX2NvbW1lbnRzKSA+IC0xXG5cdFx0XHR8fCBfY29tbWVudHMgPT0gX2RlbGltaXRlcilcblx0XHRcdF9jb21tZW50cyA9IGZhbHNlO1xuXG5cblx0XHR0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpXG5cdFx0XHRcdHRocm93IFwiSW5wdXQgbXVzdCBiZSBhIHN0cmluZ1wiO1xuXHRcdFx0cmVzZXQoaW5wdXQpO1xuXHRcdFx0cmV0dXJuIHBhcnNlckxvb3AoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5hYm9ydCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRfYWJvcnRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlckxvb3AoKVxuXHRcdHtcblx0XHRcdHdoaWxlIChfaSA8IF9pbnB1dC5sZW5ndGgpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChfYWJvcnRlZCkgYnJlYWs7XG5cdFx0XHRcdGlmIChfcHJldmlldyA+IDAgJiYgX3J1bm5pbmdSb3dJZHggPj0gX3ByZXZpZXcpIGJyZWFrO1xuXHRcdFx0XHRpZiAoX3BhdXNlZCkgcmV0dXJuIGZpbmlzaFBhcnNpbmcoKTtcblxuXHRcdFx0XHRpZiAoX2NoID09ICdcIicpXG5cdFx0XHRcdFx0cGFyc2VRdW90ZXMoKTtcblx0XHRcdFx0ZWxzZSBpZiAoX2luUXVvdGVzKVxuXHRcdFx0XHRcdHBhcnNlSW5RdW90ZXMoKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBhcnNlTm90SW5RdW90ZXMoKTtcblxuXHRcdFx0XHRuZXh0Q2hhcigpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmluaXNoUGFyc2luZygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5leHRDaGFyKClcblx0XHR7XG5cdFx0XHRfaSsrO1xuXHRcdFx0X2NoID0gX2lucHV0W19pXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5pc2hQYXJzaW5nKClcblx0XHR7XG5cdFx0XHRpZiAoX2Fib3J0ZWQpXG5cdFx0XHRcdGFkZEVycm9yKFwiQWJvcnRcIiwgXCJQYXJzZUFib3J0XCIsIFwiUGFyc2luZyB3YXMgYWJvcnRlZCBieSB0aGUgdXNlcidzIHN0ZXAgZnVuY3Rpb25cIik7XG5cdFx0XHRpZiAoX2luUXVvdGVzKVxuXHRcdFx0XHRhZGRFcnJvcihcIlF1b3Rlc1wiLCBcIk1pc3NpbmdRdW90ZXNcIiwgXCJVbmVzY2FwZWQgb3IgbWlzbWF0Y2hlZCBxdW90ZXNcIik7XG5cdFx0XHRlbmRSb3coKTtcdC8vIEVuZCBvZiBpbnB1dCBpcyBhbHNvIGVuZCBvZiB0aGUgbGFzdCByb3dcblx0XHRcdGlmICghaXNGdW5jdGlvbihfc3RlcCkpXG5cdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VRdW90ZXMoKVxuXHRcdHtcblx0XHRcdGlmIChxdW90ZXNPbkJvdW5kYXJ5KCkgJiYgIXF1b3Rlc0VzY2FwZWQoKSlcblx0XHRcdFx0X2luUXVvdGVzID0gIV9pblF1b3Rlcztcblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0c2F2ZUNoYXIoKTtcblx0XHRcdFx0aWYgKF9pblF1b3RlcyAmJiBxdW90ZXNFc2NhcGVkKCkpXG5cdFx0XHRcdFx0X2krK1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJRdW90ZXNcIiwgXCJVbmV4cGVjdGVkUXVvdGVzXCIsIFwiVW5leHBlY3RlZCBxdW90ZXNcIik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VJblF1b3RlcygpXG5cdFx0e1xuXHRcdFx0aWYgKHR3b0NoYXJMaW5lQnJlYWsoX2kpIHx8IG9uZUNoYXJMaW5lQnJlYWsoX2kpKVxuXHRcdFx0XHRfbGluZU51bSsrO1xuXHRcdFx0c2F2ZUNoYXIoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vdEluUXVvdGVzKClcblx0XHR7XG5cdFx0XHRpZiAoX2NoID09IF9kZWxpbWl0ZXIpXG5cdFx0XHRcdG5ld0ZpZWxkKCk7XG5cdFx0XHRlbHNlIGlmICh0d29DaGFyTGluZUJyZWFrKF9pKSlcblx0XHRcdHtcblx0XHRcdFx0bmV3Um93KCk7XG5cdFx0XHRcdG5leHRDaGFyKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChvbmVDaGFyTGluZUJyZWFrKF9pKSlcblx0XHRcdFx0bmV3Um93KCk7XG5cdFx0XHRlbHNlIGlmIChpc0NvbW1lbnRTdGFydCgpKVxuXHRcdFx0XHRza2lwTGluZSgpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzYXZlQ2hhcigpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ29tbWVudFN0YXJ0KClcblx0XHR7XG5cdFx0XHRpZiAoIV9jb21tZW50cylcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR2YXIgZmlyc3RDaGFyT2ZMaW5lID0gX2kgPT0gMFxuXHRcdFx0XHRcdFx0XHRcdFx0fHwgb25lQ2hhckxpbmVCcmVhayhfaS0xKVxuXHRcdFx0XHRcdFx0XHRcdFx0fHwgdHdvQ2hhckxpbmVCcmVhayhfaS0yKTtcblx0XHRcdHJldHVybiBmaXJzdENoYXJPZkxpbmUgJiYgX2lucHV0W19pXSA9PT0gX2NvbW1lbnRzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNraXBMaW5lKClcblx0XHR7XG5cdFx0XHR3aGlsZSAoIXR3b0NoYXJMaW5lQnJlYWsoX2kpXG5cdFx0XHRcdCYmICFvbmVDaGFyTGluZUJyZWFrKF9pKVxuXHRcdFx0XHQmJiBfaSA8IF9pbnB1dC5sZW5ndGgpXG5cdFx0XHR7XG5cdFx0XHRcdG5leHRDaGFyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2F2ZUNoYXIoKVxuXHRcdHtcblx0XHRcdF9kYXRhW19yb3dJZHhdW19jb2xJZHhdICs9IF9jaDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZXdGaWVsZCgpXG5cdFx0e1xuXHRcdFx0X2RhdGFbX3Jvd0lkeF0ucHVzaChcIlwiKTtcblx0XHRcdF9jb2xJZHggPSBfZGF0YVtfcm93SWR4XS5sZW5ndGggLSAxO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5ld1JvdygpXG5cdFx0e1xuXHRcdFx0ZW5kUm93KCk7XG5cblx0XHRcdF9saW5lTnVtKys7XG5cdFx0XHRfcnVubmluZ1Jvd0lkeCsrO1xuXHRcdFx0X2RhdGEucHVzaChbXSk7XG5cdFx0XHRfcm93SWR4ID0gX2RhdGEubGVuZ3RoIC0gMTtcblx0XHRcdG5ld0ZpZWxkKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5kUm93KClcblx0XHR7XG5cdFx0XHR0cmltRW1wdHlMYXN0Um93KCk7XG5cdFx0XHRpZiAoaXNGdW5jdGlvbihfc3RlcCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChfZGF0YVtfcm93SWR4XSlcblx0XHRcdFx0XHRfc3RlcChyZXR1cm5hYmxlKCksIHNlbGYpO1xuXHRcdFx0XHRjbGVhckVycm9yc0FuZERhdGEoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmltRW1wdHlMYXN0Um93KClcblx0XHR7XG5cdFx0XHRpZiAoX2RhdGFbX3Jvd0lkeF0ubGVuZ3RoID09IDEgJiYgRU1QVFkudGVzdChfZGF0YVtfcm93SWR4XVswXSkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjb25maWcua2VlcEVtcHR5Um93cylcblx0XHRcdFx0XHRfZGF0YVtfcm93SWR4XS5zcGxpY2UoMCwgMSk7XHQvLyBsZWF2ZSByb3csIGJ1dCBubyBmaWVsZHNcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdF9kYXRhLnNwbGljZShfcm93SWR4LCAxKTtcdFx0Ly8gY3V0IG91dCByb3cgZW50aXJlbHlcblx0XHRcdFx0X3Jvd0lkeCA9IF9kYXRhLmxlbmd0aCAtIDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHdvQ2hhckxpbmVCcmVhayhpKVxuXHRcdHtcblx0XHRcdHJldHVybiBpIDwgX2lucHV0Lmxlbmd0aCAtIDEgJiZcblx0XHRcdFx0KChfaW5wdXRbaV0gPT0gXCJcXHJcIiAmJiBfaW5wdXRbaSsxXSA9PSBcIlxcblwiKVxuXHRcdFx0XHR8fCAoX2lucHV0W2ldID09IFwiXFxuXCIgJiYgX2lucHV0W2krMV0gPT0gXCJcXHJcIikpXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25lQ2hhckxpbmVCcmVhayhpKVxuXHRcdHtcblx0XHRcdHJldHVybiBfaW5wdXRbaV0gPT0gXCJcXHJcIiB8fCBfaW5wdXRbaV0gPT0gXCJcXG5cIjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBxdW90ZXNFc2NhcGVkKClcblx0XHR7XG5cdFx0XHQvLyBRdW90ZXMgYXMgZGF0YSBjYW5ub3QgYmUgb24gYm91bmRhcnksIGZvciBleGFtcGxlOiAsXCJcIiwgYXJlIG5vdCBlc2NhcGVkIHF1b3Rlc1xuXHRcdFx0cmV0dXJuICFxdW90ZXNPbkJvdW5kYXJ5KCkgJiYgX2kgPCBfaW5wdXQubGVuZ3RoIC0gMSAmJiBfaW5wdXRbX2krMV0gPT0gJ1wiJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBxdW90ZXNPbkJvdW5kYXJ5KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gKCFfaW5RdW90ZXMgJiYgaXNCb3VuZGFyeShfaS0xKSkgfHwgaXNCb3VuZGFyeShfaSsxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0JvdW5kYXJ5KGkpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBpICE9ICdudW1iZXInKVxuXHRcdFx0XHRpID0gX2k7XG5cblx0XHRcdHZhciBjaCA9IF9pbnB1dFtpXTtcblxuXHRcdFx0cmV0dXJuIChpIDw9IC0xIHx8IGkgPj0gX2lucHV0Lmxlbmd0aClcblx0XHRcdFx0fHwgKGNoID09IF9kZWxpbWl0ZXJcblx0XHRcdFx0XHR8fCBjaCA9PSBcIlxcclwiXG5cdFx0XHRcdFx0fHwgY2ggPT0gXCJcXG5cIik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkRXJyb3IodHlwZSwgY29kZSwgbXNnKVxuXHRcdHtcblx0XHRcdF9lcnJvcnMucHVzaCh7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGNvZGU6IGNvZGUsXG5cdFx0XHRcdG1lc3NhZ2U6IG1zZyxcblx0XHRcdFx0bGluZTogX2xpbmVOdW0sXG5cdFx0XHRcdHJvdzogX3Jvd0lkeCxcblx0XHRcdFx0aW5kZXg6IF9pXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNldChpbnB1dClcblx0XHR7XG5cdFx0XHRfaW5wdXQgPSBpbnB1dDtcblx0XHRcdF9pblF1b3RlcyA9IGZhbHNlO1xuXHRcdFx0X2kgPSAwLCBfcnVubmluZ1Jvd0lkeCA9IDAsIF9saW5lTnVtID0gMTtcblx0XHRcdGNsZWFyRXJyb3JzQW5kRGF0YSgpO1xuXHRcdFx0X2RhdGEgPSBbIFtcIlwiXSBdO1x0Ly8gc3RhcnRpbmcgcGFyc2luZyByZXF1aXJlcyBhbiBlbXB0eSBmaWVsZFxuXHRcdFx0X2NoID0gX2lucHV0W19pXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjbGVhckVycm9yc0FuZERhdGEoKVxuXHRcdHtcblx0XHRcdF9kYXRhID0gW107XG5cdFx0XHRfZXJyb3JzID0gW107XG5cdFx0XHRfcm93SWR4ID0gMDtcblx0XHRcdF9jb2xJZHggPSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJldHVybmFibGUoKVxuXHRcdHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IF9kYXRhLFxuXHRcdFx0XHRlcnJvcnM6IF9lcnJvcnMsXG5cdFx0XHRcdG1ldGE6IHtcblx0XHRcdFx0XHRsaW5lczogX2xpbmVOdW0sXG5cdFx0XHRcdFx0ZGVsaW1pdGVyOiBfZGVsaW1pdGVyLFxuXHRcdFx0XHRcdGFib3J0ZWQ6IF9hYm9ydGVkXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVwbGFjZXMgYmFkIGNvbmZpZyB2YWx1ZXMgd2l0aCBnb29kLCBkZWZhdWx0IG9uZXNcblx0ZnVuY3Rpb24gY29weUFuZFZhbGlkYXRlQ29uZmlnKG9yaWdDb25maWcpXG5cdHtcblx0XHRpZiAodHlwZW9mIG9yaWdDb25maWcgIT09ICdvYmplY3QnKVxuXHRcdFx0b3JpZ0NvbmZpZyA9IHt9O1xuXG5cdFx0dmFyIGNvbmZpZyA9IGNvcHkob3JpZ0NvbmZpZyk7XG5cblx0XHRpZiAodHlwZW9mIGNvbmZpZy5kZWxpbWl0ZXIgIT09ICdzdHJpbmcnXG5cdFx0XHR8fCBjb25maWcuZGVsaW1pdGVyLmxlbmd0aCAhPSAxXG5cdFx0XHR8fCBCYWJ5LkJBRF9ERUxJTUlURVJTLmluZGV4T2YoY29uZmlnLmRlbGltaXRlcikgPiAtMSlcblx0XHRcdGNvbmZpZy5kZWxpbWl0ZXIgPSBERUZBVUxUUy5kZWxpbWl0ZXI7XG5cblx0XHRpZiAodHlwZW9mIGNvbmZpZy5oZWFkZXIgIT09ICdib29sZWFuJylcblx0XHRcdGNvbmZpZy5oZWFkZXIgPSBERUZBVUxUUy5oZWFkZXI7XG5cblx0XHRpZiAodHlwZW9mIGNvbmZpZy5keW5hbWljVHlwaW5nICE9PSAnYm9vbGVhbicpXG5cdFx0XHRjb25maWcuZHluYW1pY1R5cGluZyA9IERFRkFVTFRTLmR5bmFtaWNUeXBpbmc7XG5cblx0XHRpZiAodHlwZW9mIGNvbmZpZy5wcmV2aWV3ICE9PSAnbnVtYmVyJylcblx0XHRcdGNvbmZpZy5wcmV2aWV3ID0gREVGQVVMVFMucHJldmlldztcblxuXHRcdGlmICh0eXBlb2YgY29uZmlnLnN0ZXAgIT09ICdmdW5jdGlvbicpXG5cdFx0XHRjb25maWcuc3RlcCA9IERFRkFVTFRTLnN0ZXA7XG5cblx0XHRpZiAodHlwZW9mIGNvbmZpZy5jb21wbGV0ZSAhPT0gJ2Z1bmN0aW9uJylcblx0XHRcdGNvbmZpZy5jb21wbGV0ZSA9IERFRkFVTFRTLmNvbXBsZXRlO1xuXG5cdFx0aWYgKHR5cGVvZiBjb25maWcua2VlcEVtcHR5Um93cyAhPT0gJ2Jvb2xlYW4nKVxuXHRcdFx0Y29uZmlnLmtlZXBFbXB0eVJvd3MgPSBERUZBVUxUUy5rZWVwRW1wdHlSb3dzO1xuXG5cdFx0cmV0dXJuIGNvbmZpZztcblx0fVxuXG5cdGZ1bmN0aW9uIGNvcHkob2JqKVxuXHR7XG5cdFx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR2YXIgY3B5ID0gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuXHRcdGZvciAodmFyIGtleSBpbiBvYmopXG5cdFx0XHRjcHlba2V5XSA9IGNvcHkob2JqW2tleV0pO1xuXHRcdHJldHVybiBjcHk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmMpXG5cdHtcblx0XHRyZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG5cdH1cblxuXG5cblxuXG5cblx0Ly8gZXhwb3J0IHRvIE5vZGUuLi5cblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IEJhYnk7XG5cdH1cblxuXHQvLyAuLi5vciBhcyBBTUQgbW9kdWxlLi4uXG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKCBmdW5jdGlvbiAoKSB7IHJldHVybiBCYWJ5OyB9KTtcblx0fVxuXG5cdC8vIC4uLm9yIGFzIGJyb3dzZXIgZ2xvYmFsXG5cdGVsc2Uge1xuXHRcdGdsb2JhbC5CYWJ5ID0gQmFieTtcblx0fVxuXG5cblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzICkpO1xuIiwiLyohXG4gKiBudW1lcmFsLmpzXG4gKiB2ZXJzaW9uIDogMS41LjNcbiAqIGF1dGhvciA6IEFkYW0gRHJhcGVyXG4gKiBsaWNlbnNlIDogTUlUXG4gKiBodHRwOi8vYWRhbXdkcmFwZXIuZ2l0aHViLmNvbS9OdW1lcmFsLWpzL1xuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0YW50c1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBudW1lcmFsLFxuICAgICAgICBWRVJTSU9OID0gJzEuNS4zJyxcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbGFuZ3VhZ2UgY29uZmlnIGZpbGVzXG4gICAgICAgIGxhbmd1YWdlcyA9IHt9LFxuICAgICAgICBjdXJyZW50TGFuZ3VhZ2UgPSAnZW4nLFxuICAgICAgICB6ZXJvRm9ybWF0ID0gbnVsbCxcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9ICcwLDAnLFxuICAgICAgICAvLyBjaGVjayBmb3Igbm9kZUpTXG4gICAgICAgIGhhc01vZHVsZSA9ICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyk7XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RydWN0b3JzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBOdW1lcmFsIHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBOdW1lcmFsIChudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgdG9GaXhlZCgpIHRoYXQgdHJlYXRzIGZsb2F0cyBtb3JlIGxpa2UgZGVjaW1hbHNcbiAgICAgKlxuICAgICAqIEZpeGVzIGJpbmFyeSByb3VuZGluZyBpc3N1ZXMgKGVnLiAoMC42MTUpLnRvRml4ZWQoMikgPT09ICcwLjYxJykgdGhhdCBwcmVzZW50XG4gICAgICogcHJvYmxlbXMgZm9yIGFjY291bnRpbmctIGFuZCBmaW5hbmNlLXJlbGF0ZWQgc29mdHdhcmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaXhlZCAodmFsdWUsIHByZWNpc2lvbiwgcm91bmRpbmdGdW5jdGlvbiwgb3B0aW9uYWxzKSB7XG4gICAgICAgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pLFxuICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwLFxuICAgICAgICAgICAgb3V0cHV0O1xuICAgICAgICAgICAgXG4gICAgICAgIC8vcm91bmRpbmdGdW5jdGlvbiA9IChyb3VuZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQgPyByb3VuZGluZ0Z1bmN0aW9uIDogTWF0aC5yb3VuZCk7XG4gICAgICAgIC8vIE11bHRpcGx5IHVwIGJ5IHByZWNpc2lvbiwgcm91bmQgYWNjdXJhdGVseSwgdGhlbiBkaXZpZGUgYW5kIHVzZSBuYXRpdmUgdG9GaXhlZCgpOlxuICAgICAgICBvdXRwdXQgPSAocm91bmRpbmdGdW5jdGlvbih2YWx1ZSAqIHBvd2VyKSAvIHBvd2VyKS50b0ZpeGVkKHByZWNpc2lvbik7XG5cbiAgICAgICAgaWYgKG9wdGlvbmFscykge1xuICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwID0gbmV3IFJlZ0V4cCgnMHsxLCcgKyBvcHRpb25hbHMgKyAnfSQnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKG9wdGlvbmFsc1JlZ0V4cCwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEZvcm1hdHRpbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBkZXRlcm1pbmUgd2hhdCB0eXBlIG9mIGZvcm1hdHRpbmcgd2UgbmVlZCB0byBkb1xuICAgIGZ1bmN0aW9uIGZvcm1hdE51bWVyYWwgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgb3V0cHV0O1xuXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgd2hhdCBraW5kIG9mIGZvcm1hdCB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignJCcpID4gLTEpIHsgLy8gY3VycmVuY3khISEhIVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0Q3VycmVuY3kobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignJScpID4gLTEpIHsgLy8gcGVyY2VudGFnZVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0UGVyY2VudGFnZShuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCc6JykgPiAtMSkgeyAvLyB0aW1lXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRUaW1lKG4sIGZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHBsYWluIG9sJyBudW1iZXJzIG9yIGJ5dGVzXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIobi5fdmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gc3RyaW5nXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJ0IHRvIG51bWJlclxuICAgIGZ1bmN0aW9uIHVuZm9ybWF0TnVtZXJhbCAobiwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBzdHJpbmdPcmlnaW5hbCA9IHN0cmluZyxcbiAgICAgICAgICAgIHRob3VzYW5kUmVnRXhwLFxuICAgICAgICAgICAgbWlsbGlvblJlZ0V4cCxcbiAgICAgICAgICAgIGJpbGxpb25SZWdFeHAsXG4gICAgICAgICAgICB0cmlsbGlvblJlZ0V4cCxcbiAgICAgICAgICAgIHN1ZmZpeGVzID0gWydLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddLFxuICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gZmFsc2UsXG4gICAgICAgICAgICBwb3dlcjtcblxuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgICAgICAgICBuLl92YWx1ZSA9IHVuZm9ybWF0VGltZShzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gemVyb0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIG4uX3ZhbHVlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMuZGVjaW1hbCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXC4vZywnJykucmVwbGFjZShsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwsICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGFiYnJldmlhdGlvbnMgYXJlIHRoZXJlIHNvIHRoYXQgd2UgY2FuIG11bHRpcGx5IHRvIHRoZSBjb3JyZWN0IG51bWJlclxuICAgICAgICAgICAgICAgIHRob3VzYW5kUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudGhvdXNhbmQgKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIG1pbGxpb25SZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5taWxsaW9uICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICBiaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMuYmlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgdHJpbGxpb25SZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50cmlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgYnl0ZXMgYXJlIHRoZXJlIHNvIHRoYXQgd2UgY2FuIG11bHRpcGx5IHRvIHRoZSBjb3JyZWN0IG51bWJlclxuICAgICAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBzdWZmaXhlcy5sZW5ndGg7IHBvd2VyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gKHN0cmluZy5pbmRleE9mKHN1ZmZpeGVzW3Bvd2VyXSkgPiAtMSkgPyBNYXRoLnBvdygxMDI0LCBwb3dlciArIDEpIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzTXVsdGlwbGllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBzb21lIG1hdGggdG8gY3JlYXRlIG91ciBudW1iZXJcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9ICgoYnl0ZXNNdWx0aXBsaWVyKSA/IGJ5dGVzTXVsdGlwbGllciA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaCh0aG91c2FuZFJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDMpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKG1pbGxpb25SZWdFeHApKSA/IE1hdGgucG93KDEwLCA2KSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaChiaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgOSkgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2godHJpbGxpb25SZWdFeHApKSA/IE1hdGgucG93KDEwLCAxMikgOiAxKSAqICgoc3RyaW5nLmluZGV4T2YoJyUnKSA+IC0xKSA/IDAuMDEgOiAxKSAqICgoKHN0cmluZy5zcGxpdCgnLScpLmxlbmd0aCArIE1hdGgubWluKHN0cmluZy5zcGxpdCgnKCcpLmxlbmd0aC0xLCBzdHJpbmcuc3BsaXQoJyknKS5sZW5ndGgtMSkpICUgMik/IDE6IC0xKSAqIE51bWJlcihzdHJpbmcucmVwbGFjZSgvW14wLTlcXC5dKy9nLCAnJykpO1xuXG4gICAgICAgICAgICAgICAgLy8gcm91bmQgaWYgd2UgYXJlIHRhbGtpbmcgYWJvdXQgYnl0ZXNcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9IChieXRlc011bHRpcGxpZXIpID8gTWF0aC5jZWlsKG4uX3ZhbHVlKSA6IG4uX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuLl92YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRDdXJyZW5jeSAobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBzeW1ib2xJbmRleCA9IGZvcm1hdC5pbmRleE9mKCckJyksXG4gICAgICAgICAgICBvcGVuUGFyZW5JbmRleCA9IGZvcm1hdC5pbmRleE9mKCcoJyksXG4gICAgICAgICAgICBtaW51c1NpZ25JbmRleCA9IGZvcm1hdC5pbmRleE9mKCctJyksXG4gICAgICAgICAgICBzcGFjZSA9ICcnLFxuICAgICAgICAgICAgc3BsaWNlSW5kZXgsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBvciBhZnRlciBjdXJyZW5jeVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyAkJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICQnLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyQgJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJCAnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJCcsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcihuLl92YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAvLyBwb3NpdGlvbiB0aGUgc3ltYm9sXG4gICAgICAgIGlmIChzeW1ib2xJbmRleCA8PSAxKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJygnKSA+IC0xIHx8IG91dHB1dC5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAxO1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xJbmRleCA8IG9wZW5QYXJlbkluZGV4IHx8IHN5bWJvbEluZGV4IDwgbWludXNTaWduSW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3ltYm9sIGFwcGVhcnMgYmVmb3JlIHRoZSBcIihcIiBvciBcIi1cIlxuICAgICAgICAgICAgICAgICAgICBzcGxpY2VJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2Uoc3BsaWNlSW5kZXgsIDAsIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArIHNwYWNlICsgb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcpJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgc3BhY2UgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFBlcmNlbnRhZ2UgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgIHZhbHVlID0gbi5fdmFsdWUgKiAxMDA7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSAlXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignICUnKSA+IC0xKSB7XG4gICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgJScsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCclJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICBcbiAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcpJykgPiAtMSApIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArICclJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArICclJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VGltZSAobikge1xuICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKG4uX3ZhbHVlLzYwLzYwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmZsb29yKChuLl92YWx1ZSAtIChob3VycyAqIDYwICogNjApKS82MCksXG4gICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5yb3VuZChuLl92YWx1ZSAtIChob3VycyAqIDYwICogNjApIC0gKG1pbnV0ZXMgKiA2MCkpO1xuICAgICAgICByZXR1cm4gaG91cnMgKyAnOicgKyAoKG1pbnV0ZXMgPCAxMCkgPyAnMCcgKyBtaW51dGVzIDogbWludXRlcykgKyAnOicgKyAoKHNlY29uZHMgPCAxMCkgPyAnMCcgKyBzZWNvbmRzIDogc2Vjb25kcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5mb3JtYXRUaW1lIChzdHJpbmcpIHtcbiAgICAgICAgdmFyIHRpbWVBcnJheSA9IHN0cmluZy5zcGxpdCgnOicpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICAgIC8vIHR1cm4gaG91cnMgYW5kIG1pbnV0ZXMgaW50byBzZWNvbmRzIGFuZCBhZGQgdGhlbSBhbGwgdXBcbiAgICAgICAgaWYgKHRpbWVBcnJheS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIGhvdXJzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwICogNjApO1xuICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVsxXSkgKiA2MCk7XG4gICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIE51bWJlcih0aW1lQXJyYXlbMl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVBcnJheS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMF0pICogNjApO1xuICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyKHNlY29uZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdE51bWJlciAodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgbmVnUCA9IGZhbHNlLFxuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2UsXG4gICAgICAgICAgICBvcHREZWMgPSBmYWxzZSxcbiAgICAgICAgICAgIGFiYnIgPSAnJyxcbiAgICAgICAgICAgIGFiYnJLID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byB0aG91c2FuZHNcbiAgICAgICAgICAgIGFiYnJNID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBtaWxsaW9uc1xuICAgICAgICAgICAgYWJickIgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIGJpbGxpb25zXG4gICAgICAgICAgICBhYmJyVCA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdHJpbGxpb25zXG4gICAgICAgICAgICBhYmJyRm9yY2UgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICBieXRlcyA9ICcnLFxuICAgICAgICAgICAgb3JkID0gJycsXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyh2YWx1ZSksXG4gICAgICAgICAgICBzdWZmaXhlcyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddLFxuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICAgICAgdGhvdXNhbmRzLFxuICAgICAgICAgICAgZCA9ICcnLFxuICAgICAgICAgICAgbmVnID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgbnVtYmVyIGlzIHplcm8gYW5kIGEgY3VzdG9tIHplcm8gZm9ybWF0IGhhcyBiZWVuIHNldFxuICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgemVyb0Zvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9Gb3JtYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzZWUgaWYgd2Ugc2hvdWxkIHVzZSBwYXJlbnRoZXNlcyBmb3IgbmVnYXRpdmUgbnVtYmVyIG9yIGlmIHdlIHNob3VsZCBwcmVmaXggd2l0aCBhIHNpZ25cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIHByZXNlbnQgd2UgZGVmYXVsdCB0byBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcoJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG5lZ1AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCcrJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xcKy9nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb24gaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2EnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYWJicmV2aWF0aW9uIGlzIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIGFiYnJLID0gZm9ybWF0LmluZGV4T2YoJ2FLJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyTSA9IGZvcm1hdC5pbmRleE9mKCdhTScpID49IDA7XG4gICAgICAgICAgICAgICAgYWJickIgPSBmb3JtYXQuaW5kZXhPZignYUInKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJUID0gZm9ybWF0LmluZGV4T2YoJ2FUJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyRm9yY2UgPSBhYmJySyB8fCBhYmJyTSB8fCBhYmJyQiB8fCBhYmJyVDtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBhJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdhJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhYnMgPj0gTWF0aC5wb3coMTAsIDEyKSAmJiAhYWJickZvcmNlIHx8IGFiYnJUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50cmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCAxMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgMTIpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgOSkgJiYgIWFiYnJGb3JjZSB8fCBhYmJyQikge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5iaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDkpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgNikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyTSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5taWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDYpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgMykgJiYgIWFiYnJGb3JjZSB8fCBhYmJySykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aG91c2FuZFxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudGhvdXNhbmQ7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgd2UgYXJlIGZvcm1hdHRpbmcgYnl0ZXNcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignYicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgYicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYicsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnYicsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgucG93KDEwMjQsIHBvd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5wb3coMTAyNCwgcG93ZXIrMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcyArIHN1ZmZpeGVzW3Bvd2VyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgb3JkaW5hbCBpcyB3YW50ZWRcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignbycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgbycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIG8nLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ28nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3JkID0gb3JkICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0ub3JkaW5hbCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignWy5dJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG9wdERlYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ1suXScsICcuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHcgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJylbMF07XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBmb3JtYXQuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgICAgIHRob3VzYW5kcyA9IGZvcm1hdC5pbmRleE9mKCcsJyk7XG5cbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uLmluZGV4T2YoJ1snKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5yZXBsYWNlKCddJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24uc3BsaXQoJ1snKTtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRvRml4ZWQodmFsdWUsIChwcmVjaXNpb25bMF0ubGVuZ3RoICsgcHJlY2lzaW9uWzFdLmxlbmd0aCksIHJvdW5kaW5nRnVuY3Rpb24sIHByZWNpc2lvblsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24ubGVuZ3RoLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3ID0gZC5zcGxpdCgnLicpWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGQuc3BsaXQoJy4nKVsxXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMuZGVjaW1hbCArIGQuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdERlYyAmJiBOdW1iZXIoZC5zbGljZSgxKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IHRvRml4ZWQodmFsdWUsIG51bGwsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmb3JtYXQgbnVtYmVyXG4gICAgICAgICAgICBpZiAody5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHcgPSB3LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIG5lZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aG91c2FuZHMgPiAtMSkge1xuICAgICAgICAgICAgICAgIHcgPSB3LnRvU3RyaW5nKCkucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy50aG91c2FuZHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHcgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICgobmVnUCAmJiBuZWcpID8gJygnIDogJycpICsgKCghbmVnUCAmJiBuZWcpID8gJy0nIDogJycpICsgKCghbmVnICYmIHNpZ25lZCkgPyAnKycgOiAnJykgKyB3ICsgZCArICgob3JkKSA/IG9yZCA6ICcnKSArICgoYWJicikgPyBhYmJyIDogJycpICsgKChieXRlcykgPyBieXRlcyA6ICcnKSArICgobmVnUCAmJiBuZWcpID8gJyknIDogJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBUb3AgTGV2ZWwgRnVuY3Rpb25zXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgbnVtZXJhbCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAobnVtZXJhbC5pc051bWVyYWwoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IDAgfHwgdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaW5wdXQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKCFOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG51bWVyYWwuZm4udW5mb3JtYXQoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmFsKE51bWJlcihpbnB1dCkpO1xuICAgIH07XG5cbiAgICAvLyB2ZXJzaW9uIG51bWJlclxuICAgIG51bWVyYWwudmVyc2lvbiA9IFZFUlNJT047XG5cbiAgICAvLyBjb21wYXJlIG51bWVyYWwgb2JqZWN0XG4gICAgbnVtZXJhbC5pc051bWVyYWwgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW1lcmFsO1xuICAgIH07XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsYW5ndWFnZXMgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbGFuZ3VhZ2UuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbGFuZ3VhZ2Uga2V5LlxuICAgIG51bWVyYWwubGFuZ3VhZ2UgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGFuZ3VhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICYmICF2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZSA6ICcgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudExhbmd1YWdlID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcyB8fCAhbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIGxvYWRMYW5ndWFnZShrZXksIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtZXJhbDtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBsb2FkZWQgbGFuZ3VhZ2UgZGF0YS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGdsb2JhbCBsYW5ndWFnZSBvYmplY3QuXG4gICAgbnVtZXJhbC5sYW5ndWFnZURhdGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZSA6ICcgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tleV07XG4gICAgfTtcblxuICAgIG51bWVyYWwubGFuZ3VhZ2UoJ2VuJywge1xuICAgICAgICBkZWxpbWl0ZXJzOiB7XG4gICAgICAgICAgICB0aG91c2FuZHM6ICcsJyxcbiAgICAgICAgICAgIGRlY2ltYWw6ICcuJ1xuICAgICAgICB9LFxuICAgICAgICBhYmJyZXZpYXRpb25zOiB7XG4gICAgICAgICAgICB0aG91c2FuZDogJ2snLFxuICAgICAgICAgICAgbWlsbGlvbjogJ20nLFxuICAgICAgICAgICAgYmlsbGlvbjogJ2InLFxuICAgICAgICAgICAgdHJpbGxpb246ICd0J1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwO1xuICAgICAgICAgICAgcmV0dXJuICh+fiAobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgc3ltYm9sOiAnJCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbnVtZXJhbC56ZXJvRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB6ZXJvRm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5kZWZhdWx0Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogJzAuMCc7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgSGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIGxvYWRMYW5ndWFnZShrZXksIHZhbHVlcykge1xuICAgICAgICBsYW5ndWFnZXNba2V5XSA9IHZhbHVlcztcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEZsb2F0aW5nLXBvaW50IGhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBUaGUgZmxvYXRpbmctcG9pbnQgaGVscGVyIGZ1bmN0aW9ucyBhbmQgaW1wbGVtZW50YXRpb25cbiAgICAvLyBib3Jyb3dzIGhlYXZpbHkgZnJvbSBzaW5mdWwuanM6IGh0dHA6Ly9ndWlwbi5naXRodWIuaW8vc2luZnVsLmpzL1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkucHJvdG90eXBlLnJlZHVjZSBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0XG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvUmVkdWNlI0NvbXBhdGliaWxpdHlcbiAgICAgKi9cbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2luaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gdGhpcyB8fCAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGUgbW9tZW50IGFsbCBtb2Rlcm4gYnJvd3NlcnMsIHRoYXQgc3VwcG9ydCBzdHJpY3QgbW9kZSwgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlLiBGb3IgaW5zdGFuY2UsIElFOFxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHN1cHBvcnQgc3RyaWN0IG1vZGUsIHNvIHRoaXMgY2hlY2sgaXMgYWN0dWFsbHkgdXNlbGVzcy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUucmVkdWNlIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvcHRfaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgbGVuZ3RoID4gaW5kZXg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUsIHRoaXNbaW5kZXhdLCBpbmRleCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtdWx0aXBsaWVyIG5lY2Vzc2FyeSB0byBtYWtlIHggPj0gMSxcbiAgICAgKiBlZmZlY3RpdmVseSBlbGltaW5hdGluZyBtaXNjYWxjdWxhdGlvbnMgY2F1c2VkIGJ5XG4gICAgICogZmluaXRlIHByZWNpc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtdWx0aXBsaWVyKHgpIHtcbiAgICAgICAgdmFyIHBhcnRzID0geC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIHBhcnRzWzFdLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBtYXhpbXVtXG4gICAgICogbXVsdGlwbGllciB0aGF0IG11c3QgYmUgdXNlZCB0byBub3JtYWxpemUgYW4gb3BlcmF0aW9uIGludm9sdmluZ1xuICAgICAqIGFsbCBvZiB0aGVtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3Rpb25GYWN0b3IoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgICAgICAgICB2YXIgbXAgPSBtdWx0aXBsaWVyKHByZXYpLFxuICAgICAgICAgICAgICAgIG1uID0gbXVsdGlwbGllcihuZXh0KTtcbiAgICAgICAgcmV0dXJuIG1wID4gbW4gPyBtcCA6IG1uO1xuICAgICAgICB9LCAtSW5maW5pdHkpO1xuICAgIH0gICAgICAgIFxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIE51bWVyYWwgUHJvdG90eXBlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBudW1lcmFsLmZuID0gTnVtZXJhbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY2xvbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQgOiBmdW5jdGlvbiAoaW5wdXRTdHJpbmcsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1lcmFsKHRoaXMsIFxuICAgICAgICAgICAgICAgICAgaW5wdXRTdHJpbmcgPyBpbnB1dFN0cmluZyA6IGRlZmF1bHRGb3JtYXQsIFxuICAgICAgICAgICAgICAgICAgKHJvdW5kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkgPyByb3VuZGluZ0Z1bmN0aW9uIDogTWF0aC5yb3VuZFxuICAgICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0U3RyaW5nKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0U3RyaW5nOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmZvcm1hdE51bWVyYWwodGhpcywgaW5wdXRTdHJpbmcgPyBpbnB1dFN0cmluZyA6IGRlZmF1bHRGb3JtYXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyBjb3JyRmFjdG9yICogY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrLCAwKSAvIGNvcnJGYWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJ0cmFjdCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yLmNhbGwobnVsbCwgdGhpcy5fdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSAtIGNvcnJGYWN0b3IgKiBjdXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdmFsdWVdLnJlZHVjZShjYmFjaywgdGhpcy5fdmFsdWUgKiBjb3JyRmFjdG9yKSAvIGNvcnJGYWN0b3I7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBtdWx0aXBseSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjY3VtICogY29yckZhY3RvcikgKiAoY3VyciAqIGNvcnJGYWN0b3IpIC9cbiAgICAgICAgICAgICAgICAgICAgKGNvcnJGYWN0b3IgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpdmlkZSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjY3VtICogY29yckZhY3RvcikgLyAoY3VyciAqIGNvcnJGYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdGhpcy5fdmFsdWUsIHZhbHVlXS5yZWR1Y2UoY2JhY2spOyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlmZmVyZW5jZSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG51bWVyYWwodGhpcy5fdmFsdWUpLnN1YnRyYWN0KHZhbHVlKS52YWx1ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRXhwb3NpbmcgTnVtZXJhbFxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIENvbW1vbkpTIG1vZHVsZSBpcyBkZWZpbmVkXG4gICAgaWYgKGhhc01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG51bWVyYWw7XG4gICAgfVxuXG4gICAgLypnbG9iYWwgZW5kZXI6ZmFsc2UgKi9cbiAgICBpZiAodHlwZW9mIGVuZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBoZXJlLCBgdGhpc2AgbWVhbnMgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gYWRkIGBudW1lcmFsYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gICAgICAgIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyICdhZHZhbmNlZCcgbW9kZVxuICAgICAgICB0aGlzWydudW1lcmFsJ10gPSBudW1lcmFsO1xuICAgIH1cblxuICAgIC8qZ2xvYmFsIGRlZmluZTpmYWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhbDtcbiAgICAgICAgfSk7XG4gICAgfVxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIG52ZDMgdmVyc2lvbiAxLjcuMShodHRwczovL2dpdGh1Yi5jb20vbm92dXMvbnZkMykgMjAxNS0wMi0wNSAqL1xuKGZ1bmN0aW9uKCl7XG5cbi8vIHNldCB1cCBtYWluIG52IG9iamVjdCBvbiB3aW5kb3dcbnZhciBudiA9IHdpbmRvdy5udiB8fCB7fTtcbndpbmRvdy5udiA9IG52O1xuXG4vLyB0aGUgbWFqb3IgZ2xvYmFsIG9iamVjdHMgdW5kZXIgdGhlIG52IG5hbWVzcGFjZVxubnYuZGV2ID0gZmFsc2U7IC8vc2V0IGZhbHNlIHdoZW4gaW4gcHJvZHVjdGlvblxubnYudG9vbHRpcCA9IG52LnRvb2x0aXAgfHwge307IC8vIEZvciB0aGUgdG9vbHRpcCBzeXN0ZW1cbm52LnV0aWxzID0gbnYudXRpbHMgfHwge307IC8vIFV0aWxpdHkgc3Vic3lzdGVtXG5udi5tb2RlbHMgPSBudi5tb2RlbHMgfHwge307IC8vc3RvcmVzIGFsbCB0aGUgcG9zc2libGUgbW9kZWxzL2NvbXBvbmVudHNcbm52LmNoYXJ0cyA9IHt9OyAvL3N0b3JlcyBhbGwgdGhlIHJlYWR5IHRvIHVzZSBjaGFydHNcbm52LmdyYXBocyA9IFtdOyAvL3N0b3JlcyBhbGwgdGhlIGdyYXBocyBjdXJyZW50bHkgb24gdGhlIHBhZ2Vcbm52LmxvZ3MgPSB7fTsgLy9zdG9yZXMgc29tZSBzdGF0aXN0aWNzIGFuZCBwb3RlbnRpYWwgZXJyb3IgbWVzc2FnZXNcblxubnYuZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgncmVuZGVyX3N0YXJ0JywgJ3JlbmRlcl9lbmQnKTtcblxuLy8gRnVuY3Rpb24gYmluZCBwb2x5ZmlsbFxuLy8gTmVlZGVkIE9OTFkgZm9yIHBoYW50b21KUyBhcyBpdCdzIG1pc3NpbmcgdW50aWwgdmVyc2lvbiAyLjAgd2hpY2ggaXMgdW5yZWxlYXNlZCBhcyBvZiB0aGlzIGNvbW1lbnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzEwNTIyXG4vLyBodHRwOi8va2FuZ2F4LmdpdGh1Yi5pby9jb21wYXQtdGFibGUvZXM1LyNGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuLy8gcGhhbnRvbUpTIGlzIHVzZWQgZm9yIHJ1bm5pbmcgdGhlIHRlc3Qgc3VpdGVcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1IGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICAgIGZOT1AgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcbiAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufVxuXG4vLyAgRGV2ZWxvcG1lbnQgcmVuZGVyIHRpbWVycyAtIGRpc2FibGVkIGlmIGRldiA9IGZhbHNlXG5pZiAobnYuZGV2KSB7XG4gICAgbnYuZGlzcGF0Y2gub24oJ3JlbmRlcl9zdGFydCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbnYubG9ncy5zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICB9KTtcblxuICAgIG52LmRpc3BhdGNoLm9uKCdyZW5kZXJfZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBudi5sb2dzLmVuZFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgICAgbnYubG9ncy50b3RhbFRpbWUgPSBudi5sb2dzLmVuZFRpbWUgLSBudi5sb2dzLnN0YXJ0VGltZTtcbiAgICAgICAgbnYubG9nKCd0b3RhbCcsIG52LmxvZ3MudG90YWxUaW1lKTsgLy8gdXNlZCBmb3IgZGV2ZWxvcG1lbnQsIHRvIGtlZXAgdHJhY2sgb2YgZ3JhcGggZ2VuZXJhdGlvbiB0aW1lc1xuICAgIH0pO1xufVxuXG4vLyBMb2dzIGFsbCBhcmd1bWVudHMsIGFuZCByZXR1cm5zIHRoZSBsYXN0IHNvIHlvdSBjYW4gdGVzdCB0aGluZ3MgaW4gcGxhY2Vcbi8vIE5vdGU6IGluIElFOCBjb25zb2xlLmxvZyBpcyBhbiBvYmplY3Qgbm90IGEgZnVuY3Rpb24sIGFuZCBpZiBtb2Rlcm5penIgaXMgdXNlZFxuLy8gdGhlbiBjYWxsaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHdpdGggd2l0aCBhbnl0aGluZyBvdGhlciB0aGFuIGEgZnVuY3Rpb25cbi8vIGNhdXNlcyBhIFR5cGVFcnJvciB0byBiZSB0aHJvd24uXG5udi5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobnYuZGV2ICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUubG9nICYmIGNvbnNvbGUubG9nLmFwcGx5KVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIGVsc2UgaWYgKG52LmRldiAmJiB3aW5kb3cuY29uc29sZSAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgICAgIHZhciBsb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgICAgICAgbG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xufTtcblxuLy8gcHJpbnQgY29uc29sZSB3YXJuaW5nLCBzaG91bGQgYmUgdXNlZCBieSBkZXByZWNhdGVkIGZ1bmN0aW9uc1xubnYuZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAobnYuZGV2ICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYCcgKyBuYW1lICsgJ2AgaGFzIGJlZW4gZGVwcmVjYXRlZC4nKTtcbiAgICB9XG59O1xuXG4vLyByZW5kZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBxdWV1ZSB1cCBjaGFydCByZW5kZXJpbmdcbi8vIGluIG5vbi1ibG9ja2luZyB0aW1lb3V0IGZ1bmN0aW9uc1xubnYucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHN0ZXApIHtcbiAgICAvLyBudW1iZXIgb2YgZ3JhcGhzIHRvIGdlbmVyYXRlIGluIGVhY2ggdGltZW91dCBsb29wXG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIG52LnJlbmRlci5hY3RpdmUgPSB0cnVlO1xuICAgIG52LmRpc3BhdGNoLnJlbmRlcl9zdGFydCgpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYXJ0LCBncmFwaDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXAgJiYgKGdyYXBoID0gbnYucmVuZGVyLnF1ZXVlW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBjaGFydCA9IGdyYXBoLmdlbmVyYXRlKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdyYXBoLmNhbGxiYWNrID09IHR5cGVvZihGdW5jdGlvbikpIGdyYXBoLmNhbGxiYWNrKGNoYXJ0KTtcbiAgICAgICAgICAgIG52LmdyYXBocy5wdXNoKGNoYXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG52LnJlbmRlci5xdWV1ZS5zcGxpY2UoMCwgaSk7XG5cbiAgICAgICAgaWYgKG52LnJlbmRlci5xdWV1ZS5sZW5ndGgpIHNldFRpbWVvdXQoYXJndW1lbnRzLmNhbGxlZSwgMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbnYuZGlzcGF0Y2gucmVuZGVyX2VuZCgpO1xuICAgICAgICAgICAgbnYucmVuZGVyLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgMCk7XG59O1xuXG5udi5yZW5kZXIuYWN0aXZlID0gZmFsc2U7XG5udi5yZW5kZXIucXVldWUgPSBbXTtcblxuLy8gbWFpbiBmdW5jdGlvbiB0byB1c2Ugd2hlbiBhZGRpbmcgYSBuZXcgZ3JhcGgsIHNlZSBleGFtcGxlc1xubnYuYWRkR3JhcGggPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gdHlwZW9mKEZ1bmN0aW9uKSkge1xuICAgICAgICBvYmogPSB7Z2VuZXJhdGU6IGFyZ3VtZW50c1swXSwgY2FsbGJhY2s6IGFyZ3VtZW50c1sxXX07XG4gICAgfVxuXG4gICAgbnYucmVuZGVyLnF1ZXVlLnB1c2gob2JqKTtcblxuICAgIGlmICghbnYucmVuZGVyLmFjdGl2ZSkge1xuICAgICAgICBudi5yZW5kZXIoKTtcbiAgICB9XG59Oy8qIFV0aWxpdHkgY2xhc3MgdG8gaGFuZGxlIGNyZWF0aW9uIG9mIGFuIGludGVyYWN0aXZlIGxheWVyLlxuIFRoaXMgcGxhY2VzIGEgcmVjdGFuZ2xlIG9uIHRvcCBvZiB0aGUgY2hhcnQuIFdoZW4geW91IG1vdXNlIG1vdmUgb3ZlciBpdCwgaXQgc2VuZHMgYSBkaXNwYXRjaFxuIGNvbnRhaW5pbmcgdGhlIFgtY29vcmRpbmF0ZS4gSXQgY2FuIGFsc28gcmVuZGVyIGEgdmVydGljYWwgbGluZSB3aGVyZSB0aGUgbW91c2UgaXMgbG9jYXRlZC5cblxuIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUgaXMgdGhlIGltcG9ydGFudCBldmVudCB0byBsYXRjaCBvbnRvLiAgSXQgaXMgZmlyZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIG92ZXJcbiB0aGUgcmVjdGFuZ2xlLiBUaGUgZGlzcGF0Y2ggaXMgZ2l2ZW4gb25lIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgbW91c2VYL1kgbG9jYXRpb24uXG4gSXQgYWxzbyBoYXMgJ3BvaW50WFZhbHVlJywgd2hpY2ggaXMgdGhlIGNvbnZlcnNpb24gb2YgbW91c2VYIHRvIHRoZSB4LWF4aXMgc2NhbGUuXG4gKi9cbm52LmludGVyYWN0aXZlR3VpZGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgdG9vbHRpcCA9IG52Lm1vZGVscy50b29sdGlwKCk7XG5cbiAgICAvL1B1YmxpYyBzZXR0aW5nc1xuICAgIHZhciB3aWR0aCA9IG51bGw7XG4gICAgdmFyIGhlaWdodCA9IG51bGw7XG5cbiAgICAvL1BsZWFzZSBwYXNzIGluIHRoZSBib3VuZGluZyBjaGFydCdzIHRvcCBhbmQgbGVmdCBtYXJnaW5zXG4gICAgLy9UaGlzIGlzIGltcG9ydGFudCBmb3IgY2FsY3VsYXRpbmcgdGhlIGNvcnJlY3QgbW91c2VYL1kgcG9zaXRpb25zLlxuICAgIHZhciBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwfVxuICAgICAgICAsIHhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdlbGVtZW50TW91c2Vtb3ZlJywgJ2VsZW1lbnRNb3VzZW91dCcsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibGNsaWNrJylcbiAgICAgICAgLCBzaG93R3VpZGVMaW5lID0gdHJ1ZTtcbiAgICAvL011c3QgcGFzcyBpbiB0aGUgYm91bmRpbmcgY2hhcnQncyA8c3ZnPiBjb250YWluZXIuXG4gICAgLy9UaGUgbW91c2Vtb3ZlIGV2ZW50IGlzIGF0dGFjaGVkIHRvIHRoaXMgY29udGFpbmVyLlxuICAgIHZhciBzdmdDb250YWluZXIgPSBudWxsO1xuXG4gICAgLy8gY2hlY2sgaWYgSUUgYnkgbG9va2luZyBmb3IgYWN0aXZlWFxuICAgIHZhciBpc01TSUUgPSBcIkFjdGl2ZVhPYmplY3RcIiBpbiB3aW5kb3c7XG5cblxuICAgIGZ1bmN0aW9uIGxheWVyKHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoIHx8IDk2MCksIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgNDAwKTtcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbChcImcubnYtd3JhcC5udi1pbnRlcmFjdGl2ZUxpbmVMYXllclwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiIG52LXdyYXAgbnYtaW50ZXJhY3RpdmVMaW5lTGF5ZXJcIik7XG4gICAgICAgICAgICB3cmFwRW50ZXIuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIixcIm52LWludGVyYWN0aXZlR3VpZGVMaW5lXCIpO1xuXG4gICAgICAgICAgICBpZiAoIXN2Z0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbW91c2VIYW5kbGVyKCkge1xuICAgICAgICAgICAgICAgIHZhciBkM21vdXNlID0gZDMubW91c2UodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIG1vdXNlWCA9IGQzbW91c2VbMF07XG4gICAgICAgICAgICAgICAgdmFyIG1vdXNlWSA9IGQzbW91c2VbMV07XG4gICAgICAgICAgICAgICAgdmFyIHN1YnRyYWN0TWFyZ2luID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbW91c2VPdXRBbnlSZWFzb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNU0lFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICBEMy5qcyAob3IgbWF5YmUgU1ZHLmdldFNjcmVlbkNUTSkgaGFzIGEgbmFzdHkgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICAgICAgICAgICAgICAgICAgICAgZDMubW91c2UoKSByZXR1cm5zIGluY29ycmVjdCBYLFkgbW91c2UgY29vcmRpbmF0ZXMgd2hlbiBtb3VzZSBtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgIG92ZXIgYSByZWN0IGluIElFIDEwLlxuICAgICAgICAgICAgICAgICAgICAgSG93ZXZlciwgZDMuZXZlbnQub2Zmc2V0WC9ZIGFsc28gcmV0dXJucyB0aGUgbW91c2UgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlIHRvIHRoZSB0cmlnZ2VyaW5nIDxyZWN0Pi4gU28gd2UgdXNlIG9mZnNldFgvWSBvbiBJRS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlWCA9IGQzLmV2ZW50Lm9mZnNldFg7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlWSA9IGQzLmV2ZW50Lm9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgIE9uIElFLCBpZiB5b3UgYXR0YWNoIGEgbW91c2UgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIDxzdmc+IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgYWN0dWFsbHkgdHJpZ2dlciBpdCBmb3IgYWxsIHRoZSBjaGlsZCBlbGVtZW50cyAobGlrZSA8cGF0aD4sIDxjaXJjbGU+LCBldGMpLlxuICAgICAgICAgICAgICAgICAgICAgV2hlbiB0aGlzIGhhcHBlbnMgb24gSUUsIHRoZSBvZmZzZXRYL1kgaXMgc2V0IHRvIHdoZXJlIGV2ZXIgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgIGlzIGxvY2F0ZWQuXG4gICAgICAgICAgICAgICAgICAgICBBcyBhIHJlc3VsdCwgd2UgZG8gTk9UIG5lZWQgdG8gc3VidHJhY3QgbWFyZ2lucyB0byBmaWd1cmUgb3V0IHRoZSBtb3VzZSBYL1lcbiAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIHVuZGVyIHRoaXMgc2NlbmFyaW8uIFJlbW92aW5nIHRoZSBsaW5lIGJlbG93ICp3aWxsKiBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgdGhlIGludGVyYWN0aXZlIGxheWVyIHRvIG5vdCB3b3JrIHJpZ2h0IG9uIElFLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYoZDMuZXZlbnQudGFyZ2V0LnRhZ05hbWUgIT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0TWFyZ2luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZDMuZXZlbnQudGFyZ2V0LmNsYXNzTmFtZS5iYXNlVmFsLm1hdGNoKFwibnYtbGVnZW5kXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZU91dEFueVJlYXNvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHN1YnRyYWN0TWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlWCAtPSBtYXJnaW4ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VZIC09IG1hcmdpbi50b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogSWYgbW91c2VYL1kgaXMgb3V0c2lkZSBvZiB0aGUgY2hhcnQncyBib3VuZHMsXG4gICAgICAgICAgICAgICAgIHRyaWdnZXIgYSBtb3VzZU91dCBldmVudC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAobW91c2VYIDwgMCB8fCBtb3VzZVkgPCAwXG4gICAgICAgICAgICAgICAgICAgIHx8IG1vdXNlWCA+IGF2YWlsYWJsZVdpZHRoIHx8IG1vdXNlWSA+IGF2YWlsYWJsZUhlaWdodFxuICAgICAgICAgICAgICAgICAgICB8fCAoZDMuZXZlbnQucmVsYXRlZFRhcmdldCAmJiBkMy5ldmVudC5yZWxhdGVkVGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB8fCBtb3VzZU91dEFueVJlYXNvblxuICAgICAgICAgICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNU0lFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZDMuZXZlbnQucmVsYXRlZFRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGQzLmV2ZW50LnJlbGF0ZWRUYXJnZXQub3duZXJTVkdFbGVtZW50ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBkMy5ldmVudC5yZWxhdGVkVGFyZ2V0LmNsYXNzTmFtZS5tYXRjaCh0b29sdGlwLm52UG9pbnRlckV2ZW50c0NsYXNzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVg6IG1vdXNlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZW5kZXJHdWlkZUxpbmUobnVsbCk7IC8vaGlkZSB0aGUgZ3VpZGVsaW5lXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRYVmFsdWUgPSB4U2NhbGUuaW52ZXJ0KG1vdXNlWCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlbW92ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgICAgICBtb3VzZVk6IG1vdXNlWSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRYVmFsdWU6IHBvaW50WFZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL0lmIHVzZXIgZG91YmxlIGNsaWNrcyB0aGUgbGF5ZXIsIGZpcmUgYSBlbGVtZW50RGJsY2xpY2tcbiAgICAgICAgICAgICAgICBpZiAoZDMuZXZlbnQudHlwZSA9PT0gXCJkYmxjbGlja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnREYmxjbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVg6IG1vdXNlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRYVmFsdWU6IHBvaW50WFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgc2luZ2xlIGNsaWNrcyB0aGUgbGF5ZXIsIGZpcmUgZWxlbWVudENsaWNrXG4gICAgICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VZOiBtb3VzZVksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFhWYWx1ZTogcG9pbnRYVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdmdDb250YWluZXJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIixtb3VzZUhhbmRsZXIsIHRydWUpXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiAsbW91c2VIYW5kbGVyLHRydWUpXG4gICAgICAgICAgICAgICAgLm9uKFwiZGJsY2xpY2tcIiAsbW91c2VIYW5kbGVyKVxuICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIG1vdXNlSGFuZGxlcilcbiAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgLy9EcmF3cyBhIHZlcnRpY2FsIGd1aWRlbGluZSBhdCB0aGUgZ2l2ZW4gWCBwb3N0aW9uLlxuICAgICAgICAgICAgbGF5ZXIucmVuZGVyR3VpZGVMaW5lID0gZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgIGlmICghc2hvd0d1aWRlTGluZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVHdWlkZUxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoKHggIT0gbnVsbCkgPyBbbnYudXRpbHMuTmFOdG9aZXJvKHgpXSA6IFtdLCBTdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgbGluZS5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJudi1ndWlkZWxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLDApXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGxpbmUuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxheWVyLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgbGF5ZXIudG9vbHRpcCA9IHRvb2x0aXA7XG5cbiAgICBsYXllci5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICAgICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIueFNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4U2NhbGU7XG4gICAgICAgIHhTY2FsZSA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIuc2hvd0d1aWRlTGluZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0d1aWRlTGluZTtcbiAgICAgICAgc2hvd0d1aWRlTGluZSA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIuc3ZnQ29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdmdDb250YWluZXI7XG4gICAgICAgIHN2Z0NvbnRhaW5lciA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxheWVyO1xufTtcblxuLyogVXRpbGl0eSBjbGFzcyB0aGF0IHVzZXMgZDMuYmlzZWN0IHRvIGZpbmQgdGhlIGluZGV4IGluIGEgZ2l2ZW4gYXJyYXksIHdoZXJlIGEgc2VhcmNoIHZhbHVlIGNhbiBiZSBpbnNlcnRlZC5cbiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIG5vcm1hbCBiaXNlY3RMZWZ0OyB0aGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBuZWFyZXN0IGluZGV4IHRvIGluc2VydCB0aGUgc2VhcmNoIHZhbHVlLlxuXG4gRm9yIGluc3RhbmNlLCBsZXRzIHNheSB5b3VyIGFycmF5IGlzIFsxLDIsMyw1LDEwLDMwXSwgYW5kIHlvdSBzZWFyY2ggZm9yIDI4LlxuIE5vcm1hbCBkMy5iaXNlY3RMZWZ0IHdpbGwgcmV0dXJuIDQsIGJlY2F1c2UgMjggaXMgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIG51bWJlciAxMC4gIEJ1dCBpbnRlcmFjdGl2ZUJpc2VjdCB3aWxsIHJldHVybiA1XG4gYmVjYXVzZSAyOCBpcyBjbG9zZXIgdG8gMzAgdGhhbiAxMC5cblxuIFVuaXQgdGVzdHMgY2FuIGJlIGZvdW5kIGluOiBpbnRlcmFjdGl2ZUJpc2VjdFRlc3QuaHRtbFxuXG4gSGFzIHRoZSBmb2xsb3dpbmcga25vd24gaXNzdWVzOlxuICogV2lsbCBub3Qgd29yayBpZiB0aGUgZGF0YSBwb2ludHMgbW92ZSBiYWNrd2FyZHMgKGllLCAxMCw5LDgsNywgZXRjKSBvciBpZiB0aGUgZGF0YSBwb2ludHMgYXJlIGluIHJhbmRvbSBvcmRlci5cbiAqIFdvbid0IHdvcmsgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZSB4IGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5udi5pbnRlcmFjdGl2ZUJpc2VjdCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNlYXJjaFZhbCwgeEFjY2Vzc29yKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKCEgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4QWNjZXNzb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgeEFjY2Vzc29yID0gZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICByZXR1cm4gZC54O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJpc2VjdCA9IGQzLmJpc2VjdG9yKHhBY2Nlc3NvcikubGVmdDtcbiAgICB2YXIgaW5kZXggPSBkMy5tYXgoWzAsIGJpc2VjdCh2YWx1ZXMsc2VhcmNoVmFsKSAtIDFdKTtcbiAgICB2YXIgY3VycmVudFZhbHVlID0geEFjY2Vzc29yKHZhbHVlc1tpbmRleF0sIGluZGV4KTtcblxuICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjdXJyZW50VmFsdWUgPSBpbmRleDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFZhbHVlID09PSBzZWFyY2hWYWwpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4OyAvL2ZvdW5kIGV4YWN0IG1hdGNoXG4gICAgfVxuXG4gICAgdmFyIG5leHRJbmRleCA9IGQzLm1pbihbaW5kZXgrMSwgdmFsdWVzLmxlbmd0aCAtIDFdKTtcbiAgICB2YXIgbmV4dFZhbHVlID0geEFjY2Vzc29yKHZhbHVlc1tuZXh0SW5kZXhdLCBuZXh0SW5kZXgpO1xuXG4gICAgaWYgKHR5cGVvZiBuZXh0VmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5leHRWYWx1ZSA9IG5leHRJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMobmV4dFZhbHVlIC0gc2VhcmNoVmFsKSA+PSBNYXRoLmFicyhjdXJyZW50VmFsdWUgLSBzZWFyY2hWYWwpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4XG4gICAgfVxufTtcblxuLypcbiBSZXR1cm5zIHRoZSBpbmRleCBpbiB0aGUgYXJyYXkgXCJ2YWx1ZXNcIiB0aGF0IGlzIGNsb3Nlc3QgdG8gc2VhcmNoVmFsLlxuIE9ubHkgcmV0dXJucyBhbiBpbmRleCBpZiBzZWFyY2hWYWwgaXMgd2l0aGluIHNvbWUgXCJ0aHJlc2hvbGRcIi5cbiBPdGhlcndpc2UsIHJldHVybnMgbnVsbC5cbiAqL1xubnYubmVhcmVzdFZhbHVlSW5kZXggPSBmdW5jdGlvbiAodmFsdWVzLCBzZWFyY2hWYWwsIHRocmVzaG9sZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB5RGlzdE1heCA9IEluZmluaXR5LCBpbmRleFRvSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoc2VhcmNoVmFsIC0gZCk7XG4gICAgICAgIGlmICggZGVsdGEgPD0geURpc3RNYXggJiYgZGVsdGEgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHlEaXN0TWF4ID0gZGVsdGE7XG4gICAgICAgICAgICBpbmRleFRvSGlnaGxpZ2h0ID0gaTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbmRleFRvSGlnaGxpZ2h0O1xufTtcbi8qIFRvb2x0aXAgcmVuZGVyaW5nIG1vZGVsIGZvciBudmQzIGNoYXJ0cy5cbiB3aW5kb3cubnYubW9kZWxzLnRvb2x0aXAgaXMgdGhlIHVwZGF0ZWQsbmV3IHdheSB0byByZW5kZXIgdG9vbHRpcHMuXG5cbiB3aW5kb3cubnYudG9vbHRpcC5zaG93IGlzIHRoZSBvbGQgdG9vbHRpcCBjb2RlLlxuIHdpbmRvdy5udi50b29sdGlwLiogYWxzbyBoYXMgdmFyaW91cyBoZWxwZXIgbWV0aG9kcy5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHdpbmRvdy5udi50b29sdGlwID0ge307XG5cbiAgICAvKiBNb2RlbCB3aGljaCBjYW4gYmUgaW5zdGFudGlhdGVkIHRvIGhhbmRsZSB0b29sdGlwIHJlbmRlcmluZy5cbiAgICAgRXhhbXBsZSB1c2FnZTpcbiAgICAgdmFyIHRpcCA9IG52Lm1vZGVscy50b29sdGlwKCkuZ3Jhdml0eSgndycpLmRpc3RhbmNlKDIzKVxuICAgICAuZGF0YShteURhdGFPYmplY3QpO1xuXG4gICAgIHRpcCgpOyAgICAvL2p1c3QgaW52b2tlIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB0byByZW5kZXIgdG9vbHRpcC5cbiAgICAgKi9cbiAgICB3aW5kb3cubnYubW9kZWxzLnRvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9IVE1MIGNvbnRlbnRzIG9mIHRoZSB0b29sdGlwLiAgSWYgbnVsbCwgdGhlIGNvbnRlbnQgaXMgZ2VuZXJhdGVkIHZpYSB0aGUgZGF0YSB2YXJpYWJsZS5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBudWxsO1xuXG4gICAgICAgIC8qXG4gICAgICAgIFRvb2x0aXAgZGF0YS4gSWYgZGF0YSBpcyBnaXZlbiBpbiB0aGUgcHJvcGVyIGZvcm1hdCwgYSBjb25zaXN0ZW50IHRvb2x0aXAgaXMgZ2VuZXJhdGVkLlxuICAgICAgICBFeGFtcGxlIEZvcm1hdCBvZiBkYXRhOlxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiRGF0ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwiQXVndXN0IDIwMDlcIixcbiAgICAgICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAgICAgIHtrZXk6IFwiU2VyaWVzIDFcIiwgdmFsdWU6IFwiVmFsdWUgMVwiLCBjb2xvcjogXCIjMDAwXCJ9LFxuICAgICAgICAgICAgICAgIHtrZXk6IFwiU2VyaWVzIDJcIiwgdmFsdWU6IFwiVmFsdWUgMlwiLCBjb2xvcjogXCIjMDBmXCJ9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgIHZhciBncmF2aXR5ID0gJ3cnICAgLy9DYW4gYmUgJ24nLCdzJywnZScsJ3cnLiBEZXRlcm1pbmVzIGhvdyB0b29sdGlwIGlzIHBvc2l0aW9uZWQuXG4gICAgICAgICAgICAsZGlzdGFuY2UgPSA1MCAgIC8vRGlzdGFuY2UgdG8gb2Zmc2V0IHRvb2x0aXAgZnJvbSB0aGUgbW91c2UgbG9jYXRpb24uXG4gICAgICAgICAgICAsc25hcERpc3RhbmNlID0gMjUgICAvL1RvbGVyYW5jZSBhbGxvd2VkIGJlZm9yZSB0b29sdGlwIGlzIG1vdmVkIGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24gKGNyZWF0ZXMgJ3NuYXBwaW5nJyBlZmZlY3QpXG4gICAgICAgICAgICAsICAgZml4ZWRUb3AgPSBudWxsIC8vSWYgbm90IG51bGwsIHRoaXMgZml4ZXMgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICwgICBjbGFzc2VzID0gbnVsbCAgLy9BdHRhY2hlcyBhZGRpdGlvbmFsIENTUyBjbGFzc2VzIHRvIHRoZSB0b29sdGlwIERJViB0aGF0IGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAsICAgY2hhcnRDb250YWluZXIgPSBudWxsICAgLy9QYXJlbnQgRElWLCBvZiB0aGUgU1ZHIENvbnRhaW5lciB0aGF0IGhvbGRzIHRoZSBjaGFydC5cbiAgICAgICAgICAgICwgICB0b29sdGlwRWxlbSA9IG51bGwgIC8vYWN0dWFsIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICwgICBwb3NpdGlvbiA9IHtsZWZ0OiBudWxsLCB0b3A6IG51bGx9ICAgICAgLy9SZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCBpbnNpZGUgY2hhcnRDb250YWluZXIuXG4gICAgICAgICAgICAsICAgZW5hYmxlZCA9IHRydWU7ICAvL1RydWUgLT4gdG9vbHRpcHMgYXJlIHJlbmRlcmVkLiBGYWxzZSAtPiBkb24ndCByZW5kZXIgdG9vbHRpcHMuXG5cbiAgICAgICAgLy9HZW5lcmF0ZXMgYSB1bmlxdWUgaWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHRvb2x0aXAoKSBvYmplY3RcbiAgICAgICAgdmFyIGlkID0gXCJudnRvb2x0aXAtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApO1xuXG4gICAgICAgIC8vQ1NTIGNsYXNzIHRvIHNwZWNpZnkgd2hldGhlciBlbGVtZW50IHNob3VsZCBub3QgaGF2ZSBtb3VzZSBldmVudHMuXG4gICAgICAgIHZhciAgbnZQb2ludGVyRXZlbnRzQ2xhc3MgPSBcIm52LXBvaW50ZXItZXZlbnRzLW5vbmVcIjtcblxuICAgICAgICAvL0Zvcm1hdCBmdW5jdGlvbiBmb3IgdGhlIHRvb2x0aXAgdmFsdWVzIGNvbHVtblxuICAgICAgICB2YXIgdmFsdWVGb3JtYXR0ZXIgPSBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vRm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgdG9vbHRpcCBoZWFkZXIgdmFsdWUuXG4gICAgICAgIHZhciBoZWFkZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvL0J5IGRlZmF1bHQsIHRoZSB0b29sdGlwIG1vZGVsIHJlbmRlcnMgYSBiZWF1dGlmdWwgdGFibGUgaW5zaWRlIGEgRElWLlxuICAgICAgICAvL1lvdSBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpZiBhIGN1c3RvbSB0b29sdGlwIGlzIGRlc2lyZWQuXG4gICAgICAgIHZhciBjb250ZW50R2VuZXJhdG9yID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpKTtcbiAgICAgICAgICAgIHZhciB0aGVhZEVudGVyID0gdGFibGUuc2VsZWN0QWxsKFwidGhlYWRcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbZF0pXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGhlYWRcIik7XG5cbiAgICAgICAgICAgIHRoZWFkRW50ZXIuYXBwZW5kKFwidHJcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGRcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNvbHNwYW5cIiwzKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJzdHJvbmdcIilcbiAgICAgICAgICAgICAgICAuY2xhc3NlZChcIngtdmFsdWVcIix0cnVlKVxuICAgICAgICAgICAgICAgIC5odG1sKGhlYWRlckZvcm1hdHRlcihkLnZhbHVlKSk7XG5cbiAgICAgICAgICAgIHZhciB0Ym9keUVudGVyID0gdGFibGUuc2VsZWN0QWxsKFwidGJvZHlcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbZF0pXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGJvZHlcIik7XG5cbiAgICAgICAgICAgIHZhciB0cm93RW50ZXIgPSB0Ym9keUVudGVyLnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuc2VyaWVzfSlcbiAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwiaGlnaGxpZ2h0XCIsIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuaGlnaGxpZ2h0fSk7XG5cbiAgICAgICAgICAgIHRyb3dFbnRlci5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwibGVnZW5kLWNvbG9yLWd1aWRlXCIsdHJ1ZSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBmdW5jdGlvbihwKSB7IHJldHVybiBwLmNvbG9yfSk7XG5cbiAgICAgICAgICAgIHRyb3dFbnRlci5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwia2V5XCIsdHJ1ZSlcbiAgICAgICAgICAgICAgICAuaHRtbChmdW5jdGlvbihwKSB7cmV0dXJuIHAua2V5fSk7XG5cbiAgICAgICAgICAgIHRyb3dFbnRlci5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwidmFsdWVcIix0cnVlKVxuICAgICAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uKHAsaSkgeyByZXR1cm4gdmFsdWVGb3JtYXR0ZXIocC52YWx1ZSxpKSB9KTtcblxuXG4gICAgICAgICAgICB0cm93RW50ZXIuc2VsZWN0QWxsKFwidGRcIikuZWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAuaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWzAsMV0pLnJhbmdlKFtcIiNmZmZcIixwLmNvbG9yXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMC42O1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImJvcmRlci1ib3R0b20tY29sb3JcIiwgb3BhY2l0eVNjYWxlKG9wYWNpdHkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiYm9yZGVyLXRvcC1jb2xvclwiLCBvcGFjaXR5U2NhbGUob3BhY2l0eSkpXG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGh0bWwgPSB0YWJsZS5ub2RlKCkub3V0ZXJIVE1MO1xuICAgICAgICAgICAgaWYgKGQuZm9vdGVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgaHRtbCArPSBcIjxkaXYgY2xhc3M9J2Zvb3Rlcic+XCIgKyBkLmZvb3RlciArIFwiPC9kaXY+XCI7XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkYXRhU2VyaWVzRXhpc3RzID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKGQgJiYgZC5zZXJpZXMgJiYgZC5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vSW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgY2hhcnQgaXMgaW4gYSAndmlld0JveCcsIHJlLXBvc2l0aW9uIHRoZSB0b29sdGlwIGJhc2VkIG9uIGhvdyBmYXIgY2hhcnQgaXMgem9vbWVkLlxuICAgICAgICBmdW5jdGlvbiBjb252ZXJ0Vmlld0JveFJhdGlvKCkge1xuICAgICAgICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChjaGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5ub2RlKCkudGFnTmFtZSAhPT0gXCJzdmdcIikge1xuICAgICAgICAgICAgICAgICAgICBzdmcgPSBzdmcuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmlld0JveCA9IChzdmcubm9kZSgpKSA/IHN2Zy5hdHRyKCd2aWV3Qm94JykgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdCb3ggPSB2aWV3Qm94LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHBhcnNlSW50KHN2Zy5zdHlsZSgnd2lkdGgnKSkgLyB2aWV3Qm94WzJdO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSBwb3NpdGlvbi5sZWZ0ICogcmF0aW87XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnRvcCAgPSBwb3NpdGlvbi50b3AgKiByYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL0NyZWF0ZXMgbmV3IHRvb2x0aXAgY29udGFpbmVyLCBvciB1c2VzIGV4aXN0aW5nIG9uZSBvbiBET00uXG4gICAgICAgIGZ1bmN0aW9uIGdldFRvb2x0aXBDb250YWluZXIobmV3Q29udGVudCkge1xuICAgICAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgICAgICBpZiAoY2hhcnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gZDMuc2VsZWN0KGNoYXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGQzLnNlbGVjdChcImJvZHlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBib2R5LnNlbGVjdChcIi5udnRvb2x0aXBcIik7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGUoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vQ3JlYXRlIG5ldyB0b29sdGlwIGRpdiBpZiBpdCBkb2Vzbid0IGV4aXN0IG9uIERPTS5cbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBib2R5LmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibnZ0b29sdGlwIFwiICsgKGNsYXNzZXM/IGNsYXNzZXM6IFwieHktdG9vbHRpcFwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLGlkKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyLm5vZGUoKS5pbm5lckhUTUwgPSBuZXdDb250ZW50O1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlKFwidG9wXCIsMCkuc3R5bGUoXCJsZWZ0XCIsMCkuc3R5bGUoXCJvcGFjaXR5XCIsMCk7XG4gICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKFwiZGl2LCB0YWJsZSwgdGQsIHRyXCIpLmNsYXNzZWQobnZQb2ludGVyRXZlbnRzQ2xhc3MsdHJ1ZSlcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc2VkKG52UG9pbnRlckV2ZW50c0NsYXNzLHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5ub2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0RyYXcgdGhlIHRvb2x0aXAgb250byB0aGUgRE9NLlxuICAgICAgICBmdW5jdGlvbiBudnRvb2x0aXAoKSB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghZGF0YVNlcmllc0V4aXN0cyhkYXRhKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb252ZXJ0Vmlld0JveFJhdGlvKCk7XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIHZhciB0b3AgPSAoZml4ZWRUb3AgIT0gbnVsbCkgPyBmaXhlZFRvcCA6IHBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBnZXRUb29sdGlwQ29udGFpbmVyKGNvbnRlbnRHZW5lcmF0b3IoZGF0YSkpO1xuICAgICAgICAgICAgdG9vbHRpcEVsZW0gPSBjb250YWluZXI7XG4gICAgICAgICAgICBpZiAoY2hhcnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ZnQ29tcCA9IGNoYXJ0Q29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZFJlY3QgPSAoc3ZnQ29tcCkgPyBzdmdDb21wLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY2hhcnRDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN2Z09mZnNldCA9IHtsZWZ0OjAsdG9wOjB9O1xuICAgICAgICAgICAgICAgIGlmIChzdmdDb21wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdmdCb3VuZCA9IHN2Z0NvbXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFydEJvdW5kID0gY2hhcnRDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdmdCb3VuZFRvcCA9IHN2Z0JvdW5kLnRvcDtcblxuICAgICAgICAgICAgICAgICAgICAvL0RlZmVuc2l2ZSBjb2RlLiBTb21ldGltZXMsIHN2Z0JvdW5kVG9wIGNhbiBiZSBhIHJlYWxseSBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyAgbnVtYmVyLCBsaWtlIC0xMzQyNTQuIFRoYXQncyBhIGJ1Zy5cbiAgICAgICAgICAgICAgICAgICAgLy8gIElmIHN1Y2ggYSBudW1iZXIgaXMgZm91bmQsIHVzZSB6ZXJvIGluc3RlYWQuIEZpcmVGb3ggYnVnIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN2Z0JvdW5kVG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckJvdW5kID0gY2hhcnRDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmdCb3VuZFRvcCA9IChNYXRoLmFicyhzdmdCb3VuZFRvcCkgPiBjb250YWluZXJCb3VuZC5oZWlnaHQpID8gMCA6IHN2Z0JvdW5kVG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN2Z09mZnNldC50b3AgPSBNYXRoLmFicyhzdmdCb3VuZFRvcCAtIGNoYXJ0Qm91bmQudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnT2Zmc2V0LmxlZnQgPSBNYXRoLmFicyhzdmdCb3VuZC5sZWZ0IC0gY2hhcnRCb3VuZC5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9JZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBhbiBvdmVyZmxvdyA8ZGl2PiB3aXRoIHNjcm9sbGJhcnMsIHN1YnRyYWN0IHRoZSBzY3JvbGwgb2Zmc2V0cy5cbiAgICAgICAgICAgICAgICAvL1lvdSBuZWVkIHRvIGFsc28gYWRkIGFueSBvZmZzZXQgYmV0d2VlbiB0aGUgPHN2Zz4gZWxlbWVudCBhbmQgaXRzIGNvbnRhaW5pbmcgPGRpdj5cbiAgICAgICAgICAgICAgICAvL0ZpbmFsbHksIGFkZCBhbnkgb2Zmc2V0IG9mIHRoZSBjb250YWluaW5nIDxkaXY+IG9uIHRoZSB3aG9sZSBwYWdlLlxuICAgICAgICAgICAgICAgIGxlZnQgKz0gY2hhcnRDb250YWluZXIub2Zmc2V0TGVmdCArIHN2Z09mZnNldC5sZWZ0IC0gMipjaGFydENvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIHRvcCArPSBjaGFydENvbnRhaW5lci5vZmZzZXRUb3AgKyBzdmdPZmZzZXQudG9wIC0gMipjaGFydENvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzbmFwRGlzdGFuY2UgJiYgc25hcERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGguZmxvb3IodG9wL3NuYXBEaXN0YW5jZSkgKiBzbmFwRGlzdGFuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG52LnRvb2x0aXAuY2FsY1Rvb2x0aXBQb3NpdGlvbihbbGVmdCx0b3BdLCBncmF2aXR5LCBkaXN0YW5jZSwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH1cblxuICAgICAgICBudnRvb2x0aXAubnZQb2ludGVyRXZlbnRzQ2xhc3MgPSBudlBvaW50ZXJFdmVudHNDbGFzcztcblxuICAgICAgICBudnRvb2x0aXAuY29udGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICBjb250ZW50ID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9SZXR1cm5zIHRvb2x0aXBFbGVtLi4ubm90IGFibGUgdG8gc2V0IGl0LlxuICAgICAgICBudnRvb2x0aXAudG9vbHRpcEVsZW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0b29sdGlwRWxlbTtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuY29udGVudEdlbmVyYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRlbnRHZW5lcmF0b3I7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50R2VuZXJhdG9yID0gXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmRhdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5ncmF2aXR5ID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3Jhdml0eTtcbiAgICAgICAgICAgIGdyYXZpdHkgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuZGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkaXN0YW5jZTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLnNuYXBEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNuYXBEaXN0YW5jZTtcbiAgICAgICAgICAgIHNuYXBEaXN0YW5jZSA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5jbGFzc2VzID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgICAgIGNsYXNzZXMgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuY2hhcnRDb250YWluZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIGNoYXJ0Q29udGFpbmVyID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLnBvc2l0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gKHR5cGVvZiBfLmxlZnQgIT09ICd1bmRlZmluZWQnKSA/IF8ubGVmdCA6IHBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICBwb3NpdGlvbi50b3AgPSAodHlwZW9mIF8udG9wICE9PSAndW5kZWZpbmVkJykgPyBfLnRvcCA6IHBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmZpeGVkVG9wID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZml4ZWRUb3A7XG4gICAgICAgICAgICBmaXhlZFRvcCA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5lbmFibGVkID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5hYmxlZDtcbiAgICAgICAgICAgIGVuYWJsZWQgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAudmFsdWVGb3JtYXR0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZUZvcm1hdHRlcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlRm9ybWF0dGVyID0gXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmhlYWRlckZvcm1hdHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlYWRlckZvcm1hdHRlcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhlYWRlckZvcm1hdHRlciA9IF87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vaWQoKSBpcyBhIHJlYWQtb25seSBmdW5jdGlvbi4gWW91IGNhbid0IHVzZSBpdCB0byBzZXQgdGhlIGlkLlxuICAgICAgICBudnRvb2x0aXAuaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgIH07XG5cbiAgICAvL09yaWdpbmFsIHRvb2x0aXAuc2hvdyBmdW5jdGlvbi4gS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAvLyBwb3MgPSBbbGVmdCx0b3BdXG4gICAgbnYudG9vbHRpcC5zaG93ID0gZnVuY3Rpb24ocG9zLCBjb250ZW50LCBncmF2aXR5LCBkaXN0LCBwYXJlbnRDb250YWluZXIsIGNsYXNzZXMpIHtcblxuICAgICAgICAvL0NyZWF0ZSBuZXcgdG9vbHRpcCBkaXYgaWYgaXQgZG9lc24ndCBleGlzdCBvbiBET00uXG4gICAgICAgIHZhciAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gJ252dG9vbHRpcCAnICsgKGNsYXNzZXMgPyBjbGFzc2VzIDogJ3h5LXRvb2x0aXAnKTtcblxuICAgICAgICB2YXIgYm9keSA9IHBhcmVudENvbnRhaW5lcjtcbiAgICAgICAgaWYgKCAhcGFyZW50Q29udGFpbmVyIHx8IHBhcmVudENvbnRhaW5lci50YWdOYW1lLm1hdGNoKC9nfHN2Zy9pKSkge1xuICAgICAgICAgICAgLy9JZiB0aGUgcGFyZW50IGVsZW1lbnQgaXMgYW4gU1ZHIGVsZW1lbnQsIHBsYWNlIHRvb2x0aXAgaW4gdGhlIDxib2R5PiBlbGVtZW50LlxuICAgICAgICAgICAgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSAwO1xuICAgICAgICBjb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIC8vIENvbnRlbnQgY2FuIGFsc28gYmUgZG9tIGVsZW1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgICAvL0lmIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGFuIG92ZXJmbG93IDxkaXY+IHdpdGggc2Nyb2xsYmFycywgc3VidHJhY3QgdGhlIHNjcm9sbCBvZmZzZXRzLlxuICAgICAgICBpZiAocGFyZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBwb3NbMF0gPSBwb3NbMF0gLSBwYXJlbnRDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHBvc1sxXSA9IHBvc1sxXSAtIHBhcmVudENvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgbnYudG9vbHRpcC5jYWxjVG9vbHRpcFBvc2l0aW9uKHBvcywgZ3Jhdml0eSwgZGlzdCwgY29udGFpbmVyKTtcbiAgICB9O1xuXG4gICAgLy9Mb29rcyB1cCB0aGUgYW5jZXN0cnkgb2YgYSBET00gZWxlbWVudCwgYW5kIHJldHVybnMgdGhlIGZpcnN0IE5PTi1zdmcgbm9kZS5cbiAgICBudi50b29sdGlwLmZpbmRGaXJzdE5vblNWR1BhcmVudCA9IGZ1bmN0aW9uKEVsZW0pIHtcbiAgICAgICAgd2hpbGUoRWxlbS50YWdOYW1lLm1hdGNoKC9eZ3xzdmckL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBFbGVtID0gRWxlbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFbGVtO1xuICAgIH07XG5cbiAgICAvL0ZpbmRzIHRoZSB0b3RhbCBvZmZzZXRUb3Agb2YgYSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAvL0xvb2tzIHVwIHRoZSBlbnRpcmUgYW5jZXN0cnkgb2YgYW4gZWxlbWVudCwgdXAgdG8gdGhlIGZpcnN0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBlbGVtZW50LlxuICAgIG52LnRvb2x0aXAuZmluZFRvdGFsT2Zmc2V0VG9wID0gZnVuY3Rpb24gKCBFbGVtLCBpbml0aWFsVG9wICkge1xuICAgICAgICB2YXIgb2Zmc2V0VG9wID0gaW5pdGlhbFRvcDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiggIWlzTmFOKCBFbGVtLm9mZnNldFRvcCApICkge1xuICAgICAgICAgICAgICAgIG9mZnNldFRvcCArPSAoRWxlbS5vZmZzZXRUb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlKCBFbGVtID0gRWxlbS5vZmZzZXRQYXJlbnQgKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldFRvcDtcbiAgICB9O1xuXG4gICAgLy9GaW5kcyB0aGUgdG90YWwgb2Zmc2V0TGVmdCBvZiBhIGdpdmVuIERPTSBlbGVtZW50LlxuICAgIC8vTG9va3MgdXAgdGhlIGVudGlyZSBhbmNlc3RyeSBvZiBhbiBlbGVtZW50LCB1cCB0byB0aGUgZmlyc3QgcmVsYXRpdmVseSBwb3NpdGlvbmVkIGVsZW1lbnQuXG4gICAgbnYudG9vbHRpcC5maW5kVG90YWxPZmZzZXRMZWZ0ID0gZnVuY3Rpb24gKCBFbGVtLCBpbml0aWFsTGVmdCkge1xuICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IGluaXRpYWxMZWZ0O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmKCAhaXNOYU4oIEVsZW0ub2Zmc2V0TGVmdCApICkge1xuICAgICAgICAgICAgICAgIG9mZnNldExlZnQgKz0gKEVsZW0ub2Zmc2V0TGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUoIEVsZW0gPSBFbGVtLm9mZnNldFBhcmVudCApO1xuICAgICAgICByZXR1cm4gb2Zmc2V0TGVmdDtcbiAgICB9O1xuXG4gICAgLy9HbG9iYWwgdXRpbGl0eSBmdW5jdGlvbiB0byByZW5kZXIgYSB0b29sdGlwIG9uIHRoZSBET00uXG4gICAgLy9wb3MgPSBbbGVmdCx0b3BdIGNvb3JkaW5hdGVzIG9mIHdoZXJlIHRvIHBsYWNlIHRoZSB0b29sdGlwLCByZWxhdGl2ZSB0byB0aGUgU1ZHIGNoYXJ0IGNvbnRhaW5lci5cbiAgICAvL2dyYXZpdHkgPSBob3cgdG8gb3JpZW50IHRoZSB0b29sdGlwXG4gICAgLy9kaXN0ID0gaG93IGZhciBhd2F5IGZyb20gdGhlIG1vdXNlIHRvIHBsYWNlIHRvb2x0aXBcbiAgICAvL2NvbnRhaW5lciA9IHRvb2x0aXAgRElWXG4gICAgbnYudG9vbHRpcC5jYWxjVG9vbHRpcFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zLCBncmF2aXR5LCBkaXN0LCBjb250YWluZXIpIHtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQoY29udGFpbmVyLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KGNvbnRhaW5lci5vZmZzZXRXaWR0aCksXG4gICAgICAgICAgICB3aW5kb3dXaWR0aCA9IG52LnV0aWxzLndpbmRvd1NpemUoKS53aWR0aCxcbiAgICAgICAgICAgIHdpbmRvd0hlaWdodCA9IG52LnV0aWxzLndpbmRvd1NpemUoKS5oZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgbGVmdCwgdG9wO1xuXG4gICAgICAgIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoID49IGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGggPyB3aW5kb3dIZWlnaHQgOiB3aW5kb3dIZWlnaHQgLSAxNjtcbiAgICAgICAgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJIZWlnaHQgPj0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPyB3aW5kb3dXaWR0aCA6IHdpbmRvd1dpZHRoIC0gMTY7XG5cbiAgICAgICAgZ3Jhdml0eSA9IGdyYXZpdHkgfHwgJ3MnO1xuICAgICAgICBkaXN0ID0gZGlzdCB8fCAyMDtcblxuICAgICAgICB2YXIgdG9vbHRpcFRvcCA9IGZ1bmN0aW9uICggRWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBudi50b29sdGlwLmZpbmRUb3RhbE9mZnNldFRvcChFbGVtLCB0b3ApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b29sdGlwTGVmdCA9IGZ1bmN0aW9uICggRWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBudi50b29sdGlwLmZpbmRUb3RhbE9mZnNldExlZnQoRWxlbSxsZWZ0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBzd2l0Y2ggKGdyYXZpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBwb3NbMF0gLSB3aWR0aCAtIGRpc3Q7XG4gICAgICAgICAgICAgICAgdG9wID0gcG9zWzFdIC0gKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHRMZWZ0IDwgc2Nyb2xsTGVmdCkgbGVmdCA9IHBvc1swXSArIGRpc3QgPiBzY3JvbGxMZWZ0ID8gcG9zWzBdICsgZGlzdCA6IHNjcm9sbExlZnQgLSB0TGVmdCArIGxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRUb3AgPCBzY3JvbGxUb3ApIHRvcCA9IHNjcm9sbFRvcCAtIHRUb3AgKyB0b3A7XG4gICAgICAgICAgICAgICAgaWYgKHRUb3AgKyBoZWlnaHQgPiBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQpIHRvcCA9IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodCAtIHRUb3AgKyB0b3AgLSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcG9zWzBdICsgZGlzdDtcbiAgICAgICAgICAgICAgICB0b3AgPSBwb3NbMV0gLSAoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIHRMZWZ0ID0gdG9vbHRpcExlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgdFRvcCA9IHRvb2x0aXBUb3AoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAodExlZnQgKyB3aWR0aCA+IHdpbmRvd1dpZHRoKSBsZWZ0ID0gcG9zWzBdIC0gd2lkdGggLSBkaXN0O1xuICAgICAgICAgICAgICAgIGlmICh0VG9wIDwgc2Nyb2xsVG9wKSB0b3AgPSBzY3JvbGxUb3AgKyA1O1xuICAgICAgICAgICAgICAgIGlmICh0VG9wICsgaGVpZ2h0ID4gc2Nyb2xsVG9wICsgd2luZG93SGVpZ2h0KSB0b3AgPSBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQgLSB0VG9wICsgdG9wIC0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXSAtICh3aWR0aCAvIDIpIC0gNTtcbiAgICAgICAgICAgICAgICB0b3AgPSBwb3NbMV0gKyBkaXN0O1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHRMZWZ0IDwgc2Nyb2xsTGVmdCkgbGVmdCA9IHNjcm9sbExlZnQgKyA1O1xuICAgICAgICAgICAgICAgIGlmICh0TGVmdCArIHdpZHRoID4gd2luZG93V2lkdGgpIGxlZnQgPSBsZWZ0IC0gd2lkdGgvMiArIDU7XG4gICAgICAgICAgICAgICAgaWYgKHRUb3AgKyBoZWlnaHQgPiBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQpIHRvcCA9IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodCAtIHRUb3AgKyB0b3AgLSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcG9zWzBdIC0gKHdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgdG9wID0gcG9zWzFdIC0gaGVpZ2h0IC0gZGlzdDtcbiAgICAgICAgICAgICAgICB2YXIgdExlZnQgPSB0b29sdGlwTGVmdChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHZhciB0VG9wID0gdG9vbHRpcFRvcChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0TGVmdCA8IHNjcm9sbExlZnQpIGxlZnQgPSBzY3JvbGxMZWZ0ICsgNTtcbiAgICAgICAgICAgICAgICBpZiAodExlZnQgKyB3aWR0aCA+IHdpbmRvd1dpZHRoKSBsZWZ0ID0gbGVmdCAtIHdpZHRoLzIgKyA1O1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgPiB0VG9wKSB0b3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcG9zWzBdO1xuICAgICAgICAgICAgICAgIHRvcCA9IHBvc1sxXSAtIGRpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIHRMZWZ0ID0gdG9vbHRpcExlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgdFRvcCA9IHRvb2x0aXBUb3AoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCsncHgnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gdG9wKydweCc7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG5cbiAgICAvL0dsb2JhbCB1dGlsaXR5IGZ1bmN0aW9uIHRvIHJlbW92ZSB0b29sdGlwcyBmcm9tIHRoZSBET00uXG4gICAgbnYudG9vbHRpcC5jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgdG9vbHRpcHMsIG1hcmsgdGhlbSBmb3IgcmVtb3ZhbCBieSB0aGlzIGNsYXNzIChzbyBvdGhlcnMgY2xlYW51cHMgd29uJ3QgZmluZCBpdClcbiAgICAgICAgdmFyIHRvb2x0aXBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbnZ0b29sdGlwJyk7XG4gICAgICAgIHZhciBwdXJnaW5nID0gW107XG4gICAgICAgIHdoaWxlKHRvb2x0aXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHVyZ2luZy5wdXNoKHRvb2x0aXBzWzBdKTtcbiAgICAgICAgICAgIHRvb2x0aXBzWzBdLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9ICcwICFpbXBvcnRhbnQnO1xuICAgICAgICAgICAgdG9vbHRpcHNbMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICB0b29sdGlwc1swXS5jbGFzc05hbWUgPSAnbnZ0b29sdGlwLXBlbmRpbmctcmVtb3ZhbCc7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB3aGlsZSAocHVyZ2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlTWUgPSBwdXJnaW5nLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlbW92ZU1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVtb3ZlTWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgIH07XG5cbn0pKCk7XG5cblxuLypcbkdldHMgdGhlIGJyb3dzZXIgd2luZG93IHNpemVcblxuUmV0dXJucyBvYmplY3Qgd2l0aCBoZWlnaHQgYW5kIHdpZHRoIHByb3BlcnRpZXNcbiAqL1xubnYudXRpbHMud2luZG93U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNhbmUgZGVmYXVsdHNcbiAgICB2YXIgc2l6ZSA9IHt3aWR0aDogNjQwLCBoZWlnaHQ6IDQ4MH07XG5cbiAgICAvLyBFYXJsaWVyIElFIHVzZXMgRG9jLmJvZHlcbiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKSB7XG4gICAgICAgIHNpemUud2lkdGggPSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICBzaXplLmhlaWdodCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIElFIGNhbiB1c2UgZGVwZW5kaW5nIG9uIG1vZGUgaXQgaXMgaW5cbiAgICBpZiAoZG9jdW1lbnQuY29tcGF0TW9kZT09J0NTUzFDb21wYXQnICYmXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGggKSB7XG5cbiAgICAgICAgc2l6ZS53aWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgc2l6ZS5oZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIE1vc3QgcmVjZW50IGJyb3dzZXJzIHVzZVxuICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAmJiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgc2l6ZS53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBzaXplLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIChzaXplKTtcbn07XG5cblxuLypcbkJpbmRzIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHdpbmRvdyBpcyByZXNpemVkXG4gKi9cbm52LnV0aWxzLndpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG52LmxvZyhcIkVSUk9SOiBGYWlsZWQgdG8gYmluZCB0byB3aW5kb3cucmVzaXplIHdpdGg6IFwiLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIG9iamVjdCB3aXRoIGNsZWFyIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgc2luZ2xlIGFkZGVkIGNhbGxiYWNrLlxuICAgIHJldHVybiB7XG4gICAgICAgIGNhbGxiYWNrOiBoYW5kbGVyLFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qXG5CYWNrd2FyZHMgY29tcGF0aWJsZSB3YXkgdG8gaW1wbGVtZW50IG1vcmUgZDMtbGlrZSBjb2xvcmluZyBvZiBncmFwaHMuXG5JZiBwYXNzZWQgYW4gYXJyYXksIHdyYXAgaXQgaW4gYSBmdW5jdGlvbiB3aGljaCBpbXBsZW1lbnRzIHRoZSBvbGQgYmVoYXZpb3JcbkVsc2UgcmV0dXJuIHdoYXQgd2FzIHBhc3NlZCBpblxuKi9cbm52LnV0aWxzLmdldENvbG9yID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICAvL2lmIHlvdSBwYXNzIGluIG5vdGhpbmcsIGdldCBkZWZhdWx0IGNvbG9ycyBiYWNrXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudi51dGlscy5kZWZhdWx0Q29sb3IoKTtcblxuICAgIC8vaWYgcGFzc2VkIGFuIGFycmF5LCB3cmFwIGl0IGluIGEgZnVuY3Rpb25cbiAgICB9IGVsc2UgaWYoY29sb3IgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZC5jb2xvciB8fCBjb2xvcltpICUgY29sb3IubGVuZ3RoXTsgfTtcblxuICAgIC8vaWYgcGFzc2VkIGEgZnVuY3Rpb24sIHJldHVybiB0aGUgZnVuY3Rpb24sIG9yIHdoYXRldmVyIGl0IG1heSBiZVxuICAgIC8vZXh0ZXJuYWwgbGlicywgc3VjaCBhcyBhbmd1bGFyanMtbnZkMy1kaXJlY3RpdmVzIHVzZSB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy9jYW4ndCByZWFsbHkgaGVscCBpdCBpZiBzb21lb25lIHBhc3NlcyBydWJiaXNoIGFzIGNvbG9yXG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG59O1xuXG5cbi8qXG5EZWZhdWx0IGNvbG9yIGNob29zZXIgdXNlcyB0aGUgaW5kZXggb2YgYW4gb2JqZWN0IGFzIGJlZm9yZS5cbiAqL1xubnYudXRpbHMuZGVmYXVsdENvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbG9ycyA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKS5yYW5nZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yc1tpICUgY29sb3JzLmxlbmd0aF1cbiAgICB9O1xufTtcblxuXG4vKlxuUmV0dXJucyBhIGNvbG9yIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHJlc3VsdCBvZiAnZ2V0S2V5JyBmb3IgZWFjaCBzZXJpZXMgYW5kXG5sb29rcyBmb3IgYSBjb3JyZXNwb25kaW5nIGNvbG9yIGZyb20gdGhlIGRpY3Rpb25hcnlcbiovXG5udi51dGlscy5jdXN0b21UaGVtZSA9IGZ1bmN0aW9uKGRpY3Rpb25hcnksIGdldEtleSwgZGVmYXVsdENvbG9ycykge1xuICAgIC8vIHVzZSBkZWZhdWx0IHNlcmllcy5rZXkgaWYgZ2V0S2V5IGlzIHVuZGVmaW5lZFxuICAgIGdldEtleSA9IGdldEtleSB8fCBmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy5rZXkgfTtcbiAgICBkZWZhdWx0Q29sb3JzID0gZGVmYXVsdENvbG9ycyB8fCBkMy5zY2FsZS5jYXRlZ29yeTIwKCkucmFuZ2UoKTtcblxuICAgIC8vIHN0YXJ0IGF0IGVuZCBvZiBkZWZhdWx0IGNvbG9yIGxpc3QgYW5kIHdhbGsgYmFjayB0byBpbmRleCAwXG4gICAgdmFyIGRlZkluZGV4ID0gZGVmYXVsdENvbG9ycy5sZW5ndGg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc2VyaWVzLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gZ2V0S2V5KHNlcmllcyk7XG4gICAgICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeVtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZGljdGlvbmFyeVtrZXldKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGljdGlvbmFyeVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkaWN0aW9uYXJ5W2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaCBpbiBkaWN0aW9uYXJ5LCB1c2UgYSBkZWZhdWx0IGNvbG9yXG4gICAgICAgICAgICBpZiAoIWRlZkluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlZCBhbGwgdGhlIGRlZmF1bHQgY29sb3JzLCBzdGFydCBvdmVyXG4gICAgICAgICAgICAgICAgZGVmSW5kZXggPSBkZWZhdWx0Q29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZkluZGV4ID0gZGVmSW5kZXggLSAxO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2xvcnNbZGVmSW5kZXhdO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblxuLypcbkZyb20gdGhlIFBKQVggZXhhbXBsZSBvbiBkM2pzLm9yZywgd2hpbGUgdGhpcyBpcyBub3QgcmVhbGx5IGRpcmVjdGx5IG5lZWRlZFxuaXQncyBhIHZlcnkgY29vbCBtZXRob2QgZm9yIGRvaW5nIHBqYXgsIEkgbWF5IGV4cGFuZCB1cG9uIGl0IGEgbGl0dGxlIGJpdCxcbm9wZW4gdG8gc3VnZ2VzdGlvbnMgb24gYW55dGhpbmcgdGhhdCBtYXkgYmUgdXNlZnVsXG4qL1xubnYudXRpbHMucGpheCA9IGZ1bmN0aW9uKGxpbmtzLCBjb250ZW50KSB7XG5cbiAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uKGhyZWYpIHtcbiAgICAgICAgZDMuaHRtbChocmVmLCBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGQzLnNlbGVjdChjb250ZW50KS5ub2RlKCk7XG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KGZyYWdtZW50KS5zZWxlY3QoY29udGVudCkubm9kZSgpLFxuICAgICAgICAgICAgICAgIHRhcmdldCk7XG4gICAgICAgICAgICBudi51dGlscy5wamF4KGxpbmtzLCBjb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGQzLnNlbGVjdEFsbChsaW5rcykub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUodGhpcy5ocmVmLCB0aGlzLnRleHRDb250ZW50LCB0aGlzLmhyZWYpO1xuICAgICAgICBsb2FkKHRoaXMuaHJlZik7XG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICBkMy5zZWxlY3Qod2luZG93KS5vbihcInBvcHN0YXRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQuc3RhdGUpIHtcbiAgICAgICAgICAgIGxvYWQoZDMuZXZlbnQuc3RhdGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qXG5Gb3Igd2hlbiB3ZSB3YW50IHRvIGFwcHJveGltYXRlIHRoZSB3aWR0aCBpbiBwaXhlbHMgZm9yIGFuIFNWRzp0ZXh0IGVsZW1lbnQuXG5Nb3N0IGNvbW1vbiBpbnN0YW5jZSBpcyB3aGVuIHRoZSBlbGVtZW50IGlzIGluIGEgZGlzcGxheTpub25lOyBjb250YWluZXIuXG5Gb3J1bWxhIGlzIDogdGV4dC5sZW5ndGggKiBmb250LXNpemUgKiBjb25zdGFudF9mYWN0b3JcbiovXG5udi51dGlscy5jYWxjQXBwcm94VGV4dFdpZHRoID0gZnVuY3Rpb24gKHN2Z1RleHRFbGVtKSB7XG4gICAgaWYgKHR5cGVvZiBzdmdUZXh0RWxlbS5zdHlsZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAmJiB0eXBlb2Ygc3ZnVGV4dEVsZW0udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHBhcnNlSW50KHN2Z1RleHRFbGVtLnN0eWxlKFwiZm9udC1zaXplXCIpLnJlcGxhY2UoXCJweFwiLFwiXCIpKTtcbiAgICAgICAgdmFyIHRleHRMZW5ndGggPSBzdmdUZXh0RWxlbS50ZXh0KCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGV4dExlbmd0aCAqIGZvbnRTaXplICogMC41O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cblxuLypcbk51bWJlcnMgdGhhdCBhcmUgdW5kZWZpbmVkLCBudWxsIG9yIE5hTiwgY29udmVydCB0aGVtIHRvIHplcm9zLlxuKi9cbm52LnV0aWxzLk5hTnRvWmVybyA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInXG4gICAgICAgIHx8IGlzTmFOKG4pXG4gICAgICAgIHx8IG4gPT09IG51bGxcbiAgICAgICAgfHwgbiA9PT0gSW5maW5pdHlcbiAgICAgICAgfHwgbiA9PT0gLUluZmluaXR5KSB7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBuO1xufTtcblxuLypcbkFkZCBhIHdheSB0byB3YXRjaCBmb3IgZDMgdHJhbnNpdGlvbiBlbmRzIHRvIGQzXG4qL1xuZDMuc2VsZWN0aW9uLnByb3RvdHlwZS53YXRjaFRyYW5zaXRpb24gPSBmdW5jdGlvbihyZW5kZXJXYXRjaCl7XG4gICAgdmFyIGFyZ3MgPSBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgcmV0dXJuIHJlbmRlcldhdGNoLnRyYW5zaXRpb24uYXBwbHkocmVuZGVyV2F0Y2gsIGFyZ3MpO1xufTtcblxuXG4vKlxuSGVscGVyIG9iamVjdCB0byB3YXRjaCB3aGVuIGQzIGhhcyByZW5kZXJlZCBzb21ldGhpbmdcbiovXG5udi51dGlscy5yZW5kZXJXYXRjaCA9IGZ1bmN0aW9uKGRpc3BhdGNoLCBkdXJhdGlvbikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBudi51dGlscy5yZW5kZXJXYXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuICAgIH1cblxuICAgIHZhciBfZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiAyNTA7XG4gICAgdmFyIHJlbmRlclN0YWNrID0gW107XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5tb2RlbHMgPSBmdW5jdGlvbihtb2RlbHMpIHtcbiAgICAgICAgbW9kZWxzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbihtb2RlbCl7XG4gICAgICAgICAgICBtb2RlbC5fX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAoZnVuY3Rpb24obSl7XG4gICAgICAgICAgICAgICAgbS5kaXNwYXRjaC5vbigncmVuZGVyRW5kJywgZnVuY3Rpb24oYXJnKXtcbiAgICAgICAgICAgICAgICAgICAgbS5fX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJFbmQoJ21vZGVsJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KShtb2RlbCk7XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJTdGFjay5pbmRleE9mKG1vZGVsKSA8IDApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGFjay5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyU3RhY2sgPSBbXTtcbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2l0aW9uID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBhcmdzLCBkdXJhdGlvbikge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF9kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gX2R1cmF0aW9uIDogMjUwO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5fX3JlbmRlcmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YWNrLmluZGV4T2Yoc2VsZWN0aW9uKSA8IDApIHtcbiAgICAgICAgICAgIHJlbmRlclN0YWNrLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLl9fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmRlbGF5ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuICAgICAgICAgICAgc2VsZWN0aW9uLmR1cmF0aW9uID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl9fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb24uZXZlcnkoIGZ1bmN0aW9uKGQpeyByZXR1cm4gIWQubGVuZ3RoOyB9ICkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX19yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCl7ICsrbjsgfSlcbiAgICAgICAgICAgICAgICAuZWFjaCgnZW5kJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLS1uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX19yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlckVuZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVuZGVyRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZW5kZXJTdGFjay5ldmVyeSggZnVuY3Rpb24oZCl7IHJldHVybiBkLl9fcmVuZGVyZWQ7IH0gKSkge1xuICAgICAgICAgICAgcmVuZGVyU3RhY2suZm9yRWFjaCggZnVuY3Rpb24oZCl7IGQuX19yZW5kZXJlZCA9IGZhbHNlOyB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoLnJlbmRlckVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5cbi8qXG5UYWtlcyBtdWx0aXBsZSBvYmplY3RzIGFuZCBjb21iaW5lcyB0aGVtIGludG8gdGhlIGZpcnN0IG9uZSAoZHN0KVxuZXhhbXBsZTogIG52LnV0aWxzLmRlZXBFeHRlbmQoe2E6IDF9LCB7YTogMiwgYjogM30sIHtjOiA0fSk7XG5naXZlczogIHthOiAyLCBiOiAzLCBjOiA0fVxuKi9cbm52LnV0aWxzLmRlZXBFeHRlbmQgPSBmdW5jdGlvbihkc3Qpe1xuICAgIHZhciBzb3VyY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSBkc3Rba2V5XSBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIGRzdFtrZXldID09PSAnb2JqZWN0JztcbiAgICAgICAgICAgIHZhciBzcmNPYmogPSB0eXBlb2Ygc291cmNlW2tleV0gPT09ICdvYmplY3QnO1xuXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QgJiYgIWlzQXJyYXkgJiYgc3JjT2JqKSB7XG4gICAgICAgICAgICAgICAgbnYudXRpbHMuZGVlcEV4dGVuZChkc3Rba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qXG5zdGF0ZSB1dGlsaXR5IG9iamVjdCwgdXNlZCB0byB0cmFjayBkMyBzdGF0ZXMgaW4gdGhlIG1vZGVsc1xuKi9cbm52LnV0aWxzLnN0YXRlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbnYudXRpbHMuc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgbnYudXRpbHMuc3RhdGUoKTtcbiAgICB9XG4gICAgdmFyIHN0YXRlID0ge307XG4gICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICB2YXIgX3NldFN0YXRlID0gZnVuY3Rpb24oKXt9O1xuICAgIHZhciBfZ2V0U3RhdGUgPSBmdW5jdGlvbigpeyByZXR1cm4ge307IH07XG4gICAgdmFyIGluaXQgPSBudWxsO1xuICAgIHZhciBjaGFuZ2VkID0gbnVsbDtcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnY2hhbmdlJywgJ3NldCcpO1xuXG4gICAgdGhpcy5kaXNwYXRjaC5vbignc2V0JywgZnVuY3Rpb24oc3RhdGUpe1xuICAgICAgICBfc2V0U3RhdGUoc3RhdGUsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbihmbil7XG4gICAgICAgIF9nZXRTdGF0ZSA9IGZuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zZXR0ZXIgPSBmdW5jdGlvbihmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbigpe307XG4gICAgICAgIH1cbiAgICAgICAgX3NldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHVwZGF0ZSl7XG4gICAgICAgICAgICBmbihzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgICAgICAgaW5pdCA9IGluaXQgfHwge307XG4gICAgICAgIG52LnV0aWxzLmRlZXBFeHRlbmQoaW5pdCwgc3RhdGUpO1xuICAgIH07XG5cbiAgICB2YXIgX3NldCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IF9nZXRTdGF0ZSgpO1xuXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShzZXR0aW5ncykgPT09IEpTT04uc3RyaW5naWZ5KHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHNldHRpbmdzW2tleV07XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgX3NldFN0YXRlKGluaXQsIGZhbHNlKTtcbiAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfc2V0LmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2guY2hhbmdlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn07XG5cblxuLypcblNuaXBwZXQgb2YgY29kZSB5b3UgY2FuIGluc2VydCBpbnRvIGVhY2ggbnYubW9kZWxzLiogdG8gZ2l2ZSB5b3UgdGhlIGFiaWxpdHkgdG9cbmRvIHRoaW5ncyBsaWtlOlxuY2hhcnQub3B0aW9ucyh7XG4gIHNob3dYQXhpczogdHJ1ZSxcbiAgdG9vbHRpcHM6IHRydWVcbn0pO1xuXG5UbyBlbmFibGUgaW4gdGhlIGNoYXJ0OlxuY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuKi9cbm52LnV0aWxzLm9wdGlvbnNGdW5jID0gZnVuY3Rpb24oYXJncykge1xuICAgIG52LmRlcHJlY2F0ZWQoJ252LnV0aWxzLm9wdGlvbnNGdW5jJyk7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZDMubWFwKGFyZ3MpLmZvckVhY2goKGZ1bmN0aW9uKGtleSx2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2tleV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLypcbm51bVRpY2tzOiAgcmVxdWVzdGVkIG51bWJlciBvZiB0aWNrc1xuZGF0YTogIHRoZSBjaGFydCBkYXRhXG5cbnJldHVybnMgdGhlIG51bWJlciBvZiB0aWNrcyB0byBhY3R1YWxseSB1c2Ugb24gWCBheGlzLCBiYXNlZCBvbiBjaGFydCBkYXRhXG50byBhdm9pZCBkdXBsaWNhdGUgdGlja3Mgd2l0aCB0aGUgc2FtZSB2YWx1ZVxuKi9cbm52LnV0aWxzLmNhbGNUaWNrc1ggPSBmdW5jdGlvbihudW1UaWNrcywgZGF0YSkge1xuICAgIC8vIGZpbmQgbWF4IG51bWJlciBvZiB2YWx1ZXMgZnJvbSBhbGwgZGF0YSBzdHJlYW1zXG4gICAgdmFyIG51bVZhbHVlcyA9IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoaTsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0cmVhbV9sZW4gPSBkYXRhW2ldICYmIGRhdGFbaV0udmFsdWVzID8gZGF0YVtpXS52YWx1ZXMubGVuZ3RoIDogMDtcbiAgICAgICAgbnVtVmFsdWVzID0gc3RyZWFtX2xlbiA+IG51bVZhbHVlcyA/IHN0cmVhbV9sZW4gOiBudW1WYWx1ZXM7XG4gICAgfVxuICAgIG52LmxvZyhcIlJlcXVlc3RlZCBudW1iZXIgb2YgdGlja3M6IFwiLCBudW1UaWNrcyk7XG4gICAgbnYubG9nKFwiQ2FsY3VsYXRlZCBtYXggdmFsdWVzIHRvIGJlOiBcIiwgbnVtVmFsdWVzKTtcbiAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBtb3JlIHRpY2tzIHRoYW4gdmFsdWVzIHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICBudW1UaWNrcyA9IG51bVRpY2tzID4gbnVtVmFsdWVzID8gbnVtVGlja3MgPSBudW1WYWx1ZXMgLSAxIDogbnVtVGlja3M7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHRpY2tcbiAgICBudW1UaWNrcyA9IG51bVRpY2tzIDwgMSA/IDEgOiBudW1UaWNrcztcbiAgICAvLyBtYWtlIHN1cmUgaXQncyBhbiBpbnRlZ2VyXG4gICAgbnVtVGlja3MgPSBNYXRoLmZsb29yKG51bVRpY2tzKTtcbiAgICBudi5sb2coXCJDYWxjdWxhdGluZyB0aWNrIGNvdW50IGFzOiBcIiwgbnVtVGlja3MpO1xuICAgIHJldHVybiBudW1UaWNrcztcbn07XG5cblxuLypcbnJldHVybnMgbnVtYmVyIG9mIHRpY2tzIHRvIGFjdHVhbGx5IHVzZSBvbiBZIGF4aXMsIGJhc2VkIG9uIGNoYXJ0IGRhdGFcbiovXG5udi51dGlscy5jYWxjVGlja3NZID0gZnVuY3Rpb24obnVtVGlja3MsIGRhdGEpIHtcbiAgICAvLyBjdXJyZW50bHkgdXNlcyB0aGUgc2FtZSBsb2dpYyBidXQgd2UgY2FuIGFkanVzdCBoZXJlIGlmIG5lZWRlZCBsYXRlclxuICAgIHJldHVybiBudi51dGlscy5jYWxjVGlja3NYKG51bVRpY2tzLCBkYXRhKTtcbn07XG5cblxuLypcbkFkZCBhIHBhcnRpY3VsYXIgb3B0aW9uIGZyb20gYW4gb3B0aW9ucyBvYmplY3Qgb250byBjaGFydFxuT3B0aW9ucyBleHBvc2VkIG9uIGEgY2hhcnQgYXJlIGEgZ2V0dGVyL3NldHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgY2hhcnRcbm9uIHNldCB0byBtaW1pYyB0eXBpY2FsIGQzIG9wdGlvbiBjaGFpbmluZywgZS5nLiBzdmcub3B0aW9uMSgnYScpLm9wdGlvbjIoJ2InKTtcblxub3B0aW9uIG9iamVjdHMgc2hvdWxkIGJlIGdlbmVyYXRlZCB2aWEgT2JqZWN0LmNyZWF0ZSgpIHRvIHByb3ZpZGVcbnRoZSBvcHRpb24gb2YgbWFuaXB1bGF0aW5nIGRhdGEgdmlhIGdldC9zZXQgZnVuY3Rpb25zLlxuKi9cbm52LnV0aWxzLmluaXRPcHRpb24gPSBmdW5jdGlvbihjaGFydCwgbmFtZSkge1xuICAgIC8vIGlmIGl0J3MgYSBjYWxsIG9wdGlvbiwganVzdCBjYWxsIGl0IGRpcmVjdGx5LCBvdGhlcndpc2UgZG8gZ2V0L3NldFxuICAgIGlmIChjaGFydC5fY2FsbHMgJiYgY2hhcnQuX2NhbGxzW25hbWVdKSB7XG4gICAgICAgIGNoYXJ0W25hbWVdID0gY2hhcnQuX2NhbGxzW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJ0W25hbWVdID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJ0Ll9vcHRpb25zW25hbWVdO1xuICAgICAgICAgICAgY2hhcnQuX29wdGlvbnNbbmFtZV0gPSBfO1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cblxuLypcbkFkZCBhbGwgb3B0aW9ucyBpbiBhbiBvcHRpb25zIG9iamVjdCB0byB0aGUgY2hhcnRcbiovXG5udi51dGlscy5pbml0T3B0aW9ucyA9IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIG9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoYXJ0Ll9vcHRpb25zIHx8IHt9KTtcbiAgICB2YXIgY2FsbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjaGFydC5fY2FsbHMgfHwge30pO1xuICAgIG9wcyA9IG9wcy5jb25jYXQoY2FsbHMpO1xuICAgIGZvciAodmFyIGkgaW4gb3BzKSB7XG4gICAgICAgIG52LnV0aWxzLmluaXRPcHRpb24oY2hhcnQsIG9wc1tpXSk7XG4gICAgfVxufTtcblxuXG4vKlxuSW5oZXJpdCBvcHRpb25zIGZyb20gYSBEMyBvYmplY3RcbmQzLnJlYmluZCBtYWtlcyBjYWxsaW5nIHRoZSBmdW5jdGlvbiBvbiB0YXJnZXQgYWN0dWFsbHkgY2FsbCBpdCBvbiBzb3VyY2VcbkFsc28gdXNlIF9kM29wdGlvbnMgc28gd2UgY2FuIHRyYWNrIHdoYXQgd2UgaW5oZXJpdCBmb3IgZG9jdW1lbnRhdGlvbiBhbmQgY2hhaW5lZCBpbmhlcml0YW5jZVxuKi9cbm52LnV0aWxzLmluaGVyaXRPcHRpb25zRDMgPSBmdW5jdGlvbih0YXJnZXQsIGQzX3NvdXJjZSwgb3BsaXN0KSB7XG4gICAgdGFyZ2V0Ll9kM29wdGlvbnMgPSBvcGxpc3QuY29uY2F0KHRhcmdldC5fZDNvcHRpb25zIHx8IFtdKTtcbiAgICBvcGxpc3QudW5zaGlmdChkM19zb3VyY2UpO1xuICAgIG9wbGlzdC51bnNoaWZ0KHRhcmdldCk7XG4gICAgZDMucmViaW5kLmFwcGx5KHRoaXMsIG9wbGlzdCk7XG59O1xuXG5cbi8qXG5SZW1vdmUgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5XG4qL1xubnYudXRpbHMuYXJyYXlVbmlxdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGEuc29ydCgpLmZpbHRlcihmdW5jdGlvbihpdGVtLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuICFwb3MgfHwgaXRlbSAhPSBhW3BvcyAtIDFdO1xuICAgIH0pO1xufTtcblxuXG4vKlxuS2VlcHMgYSBsaXN0IG9mIGN1c3RvbSBzeW1ib2xzIHRvIGRyYXcgZnJvbSBpbiBhZGRpdGlvbiB0byBkMy5zdmcuc3ltYm9sXG5OZWNlc3Nhcnkgc2luY2UgZDMgZG9lc24ndCBsZXQgeW91IGV4dGVuZCBpdHMgbGlzdCAtXy1cbkFkZCBuZXcgc3ltYm9scyBieSBkb2luZyBudi51dGlscy5zeW1ib2xzLnNldCgnbmFtZScsIGZ1bmN0aW9uKHNpemUpey4uLn0pO1xuKi9cbm52LnV0aWxzLnN5bWJvbE1hcCA9IGQzLm1hcCgpO1xuXG5cbi8qXG5SZXBsYWNlcyBkMy5zdmcuc3ltYm9sIHNvIHRoYXQgd2UgY2FuIGxvb2sgYm90aCB0aGVyZSBhbmQgb3VyIG93biBtYXBcbiAqL1xubnYudXRpbHMuc3ltYm9sID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGUsXG4gICAgICAgIHNpemUgPSA2NDtcbiAgICBmdW5jdGlvbiBzeW1ib2woZCxpKSB7XG4gICAgICAgIHZhciB0ID0gdHlwZS5jYWxsKHRoaXMsZCxpKTtcbiAgICAgICAgdmFyIHMgPSBzaXplLmNhbGwodGhpcyxkLGkpO1xuICAgICAgICBpZiAoZDMuc3ZnLnN5bWJvbFR5cGVzLmluZGV4T2YodCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZDMuc3ZnLnN5bWJvbCgpLnR5cGUodCkuc2l6ZShzKSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG52LnV0aWxzLnN5bWJvbE1hcC5nZXQodCkocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHR5cGU7XG4gICAgICAgIHR5cGUgPSBkMy5mdW5jdG9yKF8pO1xuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICAgIHNpemUgPSBkMy5mdW5jdG9yKF8pO1xuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbDtcbn07XG5cblxuLypcbkluaGVyaXQgb3B0aW9uIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zIGZyb20gc291cmNlIHRvIHRhcmdldFxuZDMucmViaW5kIG1ha2VzIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIG9uIHRhcmdldCBhY3R1YWxseSBjYWxsIGl0IG9uIHNvdXJjZVxuQWxzbyB0cmFjayB2aWEgX2luaGVyaXRlZCBhbmQgX2Qzb3B0aW9ucyBzbyB3ZSBjYW4gdHJhY2sgd2hhdCB3ZSBpbmhlcml0XG5mb3IgZG9jdW1lbnRhdGlvbiBnZW5lcmF0aW9uIHB1cnBvc2VzIGFuZCBjaGFpbmVkIGluaGVyaXRhbmNlXG4qL1xubnYudXRpbHMuaW5oZXJpdE9wdGlvbnMgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIC8vIGluaGVyaXQgYWxsIHRoZSB0aGluZ3NcbiAgICB2YXIgb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlLl9vcHRpb25zIHx8IHt9KTtcbiAgICB2YXIgY2FsbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UuX2NhbGxzIHx8IHt9KTtcbiAgICB2YXIgaW5oZXJpdGVkID0gc291cmNlLl9pbmhlcml0ZWQgfHwgW107XG4gICAgdmFyIGQzb3BzID0gc291cmNlLl9kM29wdGlvbnMgfHwgW107XG4gICAgdmFyIGFyZ3MgPSBvcHMuY29uY2F0KGNhbGxzKS5jb25jYXQoaW5oZXJpdGVkKS5jb25jYXQoZDNvcHMpO1xuICAgIGFyZ3MudW5zaGlmdChzb3VyY2UpO1xuICAgIGFyZ3MudW5zaGlmdCh0YXJnZXQpO1xuICAgIGQzLnJlYmluZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAvLyBwYXNzIGFsb25nIHRoZSBsaXN0cyB0byBrZWVwIHRyYWNrIG9mIHRoZW0sIGRvbid0IGFsbG93IGR1cGxpY2F0ZXNcbiAgICB0YXJnZXQuX2luaGVyaXRlZCA9IG52LnV0aWxzLmFycmF5VW5pcXVlKG9wcy5jb25jYXQoY2FsbHMpLmNvbmNhdChpbmhlcml0ZWQpLmNvbmNhdChvcHMpLmNvbmNhdCh0YXJnZXQuX2luaGVyaXRlZCB8fCBbXSkpO1xuICAgIHRhcmdldC5fZDNvcHRpb25zID0gbnYudXRpbHMuYXJyYXlVbmlxdWUoZDNvcHMuY29uY2F0KHRhcmdldC5fZDNvcHRpb25zIHx8IFtdKSk7XG59O1xuXG5cbi8qXG5SdW5zIGNvbW1vbiBpbml0aWFsaXplIGNvZGUgb24gdGhlIHN2ZyBiZWZvcmUgdGhlIGNoYXJ0IGJ1aWxkc1xuKi9cbm52LnV0aWxzLmluaXRTVkcgPSBmdW5jdGlvbihzdmcpIHtcbiAgICBzdmcuY2xhc3NlZCh7J252ZDMtc3ZnJzp0cnVlfSk7XG59O252Lm1vZGVscy5heGlzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBheGlzID0gZDMuc3ZnLmF4aXMoKTtcbiAgICB2YXIgc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKTtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gNzUgLy9vbmx5IHVzZWQgZm9yIHRpY2tMYWJlbCBjdXJyZW50bHlcbiAgICAgICAgLCBoZWlnaHQgPSA2MCAvL29ubHkgdXNlZCBmb3IgdGlja0xhYmVsIGN1cnJlbnRseVxuICAgICAgICAsIGF4aXNMYWJlbFRleHQgPSBudWxsXG4gICAgICAgICwgc2hvd01heE1pbiA9IHRydWUgLy9UT0RPOiBzaG93TWF4TWluIHNob3VsZCBiZSBkaXNhYmxlZCBvbiBhbGwgb3JkaW5hbCBzY2FsZWQgYXhlc1xuICAgICAgICAsIGhpZ2hsaWdodFplcm8gPSB0cnVlXG4gICAgICAgICwgcm90YXRlTGFiZWxzID0gMFxuICAgICAgICAsIHJvdGF0ZVlMYWJlbCA9IHRydWVcbiAgICAgICAgLCBzdGFnZ2VyTGFiZWxzID0gZmFsc2VcbiAgICAgICAgLCBpc09yZGluYWwgPSBmYWxzZVxuICAgICAgICAsIHRpY2tzID0gbnVsbFxuICAgICAgICAsIGF4aXNMYWJlbERpc3RhbmNlID0gMFxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgncmVuZGVyRW5kJylcbiAgICAgICAgLCBheGlzUmVuZGVyZWQgPSBmYWxzZVxuICAgICAgICAsIG1heE1pblJlbmRlcmVkID0gZmFsc2VcbiAgICAgICAgO1xuICAgIGF4aXNcbiAgICAgICAgLnNjYWxlKHNjYWxlKVxuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja0Zvcm1hdChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pXG4gICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2NhbGUwO1xuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWF4aXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1heGlzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpXG5cbiAgICAgICAgICAgIGlmICh0aWNrcyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBheGlzLnRpY2tzKHRpY2tzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGF4aXMub3JpZW50KCkgPT0gJ3RvcCcgfHwgYXhpcy5vcmllbnQoKSA9PSAnYm90dG9tJylcbiAgICAgICAgICAgICAgICBheGlzLnRpY2tzKE1hdGguYWJzKHNjYWxlLnJhbmdlKClbMV0gLSBzY2FsZS5yYW5nZSgpWzBdKSAvIDEwMCk7XG5cbiAgICAgICAgICAgIC8vVE9ETzogY29uc2lkZXIgY2FsY3VsYXRpbmcgd2lkdGgvaGVpZ2h0IGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGxhYmVsIGlzIGFkZGVkLCBmb3IgcmVmZXJlbmNlIGluIGNoYXJ0cyB1c2luZyB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgZy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdheGlzJykuY2FsbChheGlzKTtcblxuICAgICAgICAgICAgc2NhbGUwID0gc2NhbGUwIHx8IGF4aXMuc2NhbGUoKTtcblxuICAgICAgICAgICAgdmFyIGZtdCA9IGF4aXMudGlja0Zvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGZtdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm10ID0gc2NhbGUwLnRpY2tGb3JtYXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4aXNMYWJlbCA9IGcuc2VsZWN0QWxsKCd0ZXh0Lm52LWF4aXNsYWJlbCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2F4aXNMYWJlbFRleHQgfHwgbnVsbF0pO1xuICAgICAgICAgICAgYXhpc0xhYmVsLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgc3dpdGNoIChheGlzLm9yaWVudCgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYtYXhpc2xhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUucmFuZ2UoKS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY2FsZS5yYW5nZSgpLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHNjYWxlLnJhbmdlKClbMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gc2NhbGUucmFuZ2UoKVtzY2FsZS5yYW5nZSgpLmxlbmd0aC0xXSsoc2NhbGUucmFuZ2UoKVsxXS1zY2FsZS5yYW5nZSgpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB3LzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNNYXhNaW4gPSB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShzY2FsZS5kb21haW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYXhpc01heE1pbicpLmFwcGVuZCgndGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbnYudXRpbHMuTmFOdG9aZXJvKHNjYWxlKGQpKSArICcsMCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLTAuNWVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIC1heGlzLnRpY2tQYWRkaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZm10KGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCcnICsgdikubWF0Y2goJ05hTicpID8gJycgOiB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtaW4tbWF4IHRvcCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbnYudXRpbHMuTmFOdG9aZXJvKHNjYWxlLnJhbmdlKClbaV0pICsgJywwKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgeExhYmVsTWFyZ2luID0gYXhpc0xhYmVsRGlzdGFuY2UgKyAzNjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFRleHRXaWR0aCA9IDMwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3RBbGwoJ2cnKS5zZWxlY3QoXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlTGFiZWxzJTM2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9DYWxjdWxhdGUgdGhlIGxvbmdlc3QgeFRpY2sgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHhUaWNrcy5lYWNoKGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih3aWR0aCA+IG1heFRleHRXaWR0aCkgbWF4VGV4dFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQ29udmVydCB0byByYWRpYW5zIGJlZm9yZSBjYWxjdWxhdGluZyBzaW4uIEFkZCAzMCB0byBtYXJnaW4gZm9yIGhlYWx0aHkgcGFkZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3RhdGVMYWJlbHMqTWF0aC5QSS8xODApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4TGFiZWxNYXJnaW4gPSAoc2luID8gc2luKm1heFRleHRXaWR0aCA6IG1heFRleHRXaWR0aCkrMzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1JvdGF0ZSBhbGwgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuICdyb3RhdGUoJyArIHJvdGF0ZUxhYmVscyArICcgMCwwKScgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcm90YXRlTGFiZWxzJTM2MCA+IDAgPyAnc3RhcnQnIDogJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbC5lbnRlcigpLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNsYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlLnJhbmdlKCkubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NhbGUucmFuZ2UoKS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBzY2FsZS5yYW5nZSgpWzFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHNjYWxlLnJhbmdlKClbc2NhbGUucmFuZ2UoKS5sZW5ndGgtMV0rKHNjYWxlLnJhbmdlKClbMV0tc2NhbGUucmFuZ2UoKVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeExhYmVsTWFyZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB3LzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoc2hvd01heE1pbiAmJiAhaXNPcmRpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc01heE1pbiA9IHdyYXAuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLmRhdGEoc2NhbGUuZG9tYWluKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW3NjYWxlLmRvbWFpbigpWzBdLCBzY2FsZS5kb21haW4oKVtzY2FsZS5kb21haW4oKS5sZW5ndGggLSAxXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNNYXhNaW4nKS5hcHBlbmQoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIG52LnV0aWxzLk5hTnRvWmVybygoc2NhbGUoZCkgKyAoaXNPcmRpbmFsID8gc2NhbGUucmFuZ2VCYW5kKCkgLyAyIDogMCkpKSArICcsMCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjcxZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gJ3JvdGF0ZSgnICsgcm90YXRlTGFiZWxzICsgJyAwLDApJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVMYWJlbHMgPyAocm90YXRlTGFiZWxzJTM2MCA+IDAgPyAnc3RhcnQnIDogJ2VuZCcpIDogJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZm10KGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCcnICsgdikubWF0Y2goJ05hTicpID8gJycgOiB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtaW4tbWF4IGJvdHRvbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbnYudXRpbHMuTmFOdG9aZXJvKChzY2FsZShkKSArIChpc09yZGluYWwgPyBzY2FsZS5yYW5nZUJhbmQoKSAvIDIgOiAwKSkpICsgJywwKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgKGkgJSAyID09IDAgPyAnMCcgOiAnMTInKSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYtYXhpc2xhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIHJvdGF0ZVlMYWJlbCA/ICdtaWRkbGUnIDogJ2JlZ2luJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCByb3RhdGVZTGFiZWwgPyAncm90YXRlKDkwKScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgcm90YXRlWUxhYmVsID8gKC1NYXRoLm1heChtYXJnaW4ucmlnaHQsd2lkdGgpICsgMTIpIDogLTEwKSAvL1RPRE86IGNvbnNpZGVyIGNhbGN1bGF0aW5nIHRoaXMgYmFzZWQgb24gbGFyZ2VzdCB0aWNrIHdpZHRoLi4uIE9SIGF0IGxlYXN0IGV4cG9zZSB0aGlzIG9uIGNoYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHJvdGF0ZVlMYWJlbCA/IChzY2FsZS5yYW5nZSgpWzBdIC8gMikgOiBheGlzLnRpY2tQYWRkaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNNYXhNaW4gPSB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShzY2FsZS5kb21haW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYXhpc01heE1pbicpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZShkKSkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMzJlbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHYpLm1hdGNoKCdOYU4nKSA/ICcnIDogdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4ud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbWluLW1heCByaWdodCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyBudi51dGlscy5OYU50b1plcm8oc2NhbGUucmFuZ2UoKVtpXSkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgLy9Gb3IgZHluYW1pY2FsbHkgcGxhY2luZyB0aGUgbGFiZWwuIENhbiBiZSB1c2VkIHdpdGggZHluYW1pY2FsbHktc2l6ZWQgY2hhcnQgYXhpcyBtYXJnaW5zXG4gICAgICAgICAgICAgICAgICAgICB2YXIgeVRpY2tzID0gZy5zZWxlY3RBbGwoJ2cnKS5zZWxlY3QoXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgeVRpY2tzLmVhY2goZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFBhZGRpbmcgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgYXhpcy50aWNrUGFkZGluZygpICsgMTY7XG4gICAgICAgICAgICAgICAgICAgICBpZihsYWJlbFBhZGRpbmcgPiB3aWR0aCkgd2lkdGggPSBsYWJlbFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbC5lbnRlcigpLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNsYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVZTGFiZWwgPyAnbWlkZGxlJyA6ICdlbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIHJvdGF0ZVlMYWJlbCA/ICdyb3RhdGUoLTkwKScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgcm90YXRlWUxhYmVsID8gKC1NYXRoLm1heChtYXJnaW4ubGVmdCx3aWR0aCkgKyAyNSAtIChheGlzTGFiZWxEaXN0YW5jZSB8fCAwKSkgOiAtMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHJvdGF0ZVlMYWJlbCA/ICgtc2NhbGUucmFuZ2UoKVswXSAvIDIpIDogLWF4aXMudGlja1BhZGRpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93TWF4TWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc01heE1pbiA9IHdyYXAuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHNjYWxlLmRvbWFpbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1heGlzTWF4TWluJykuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgbnYudXRpbHMuTmFOdG9aZXJvKHNjYWxlMChkKSkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMzJlbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLWF4aXMudGlja1BhZGRpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBmbXQoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyB2KS5tYXRjaCgnTmFOJykgPyAnJyA6IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ21pbi1tYXggcmlnaHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgbnYudXRpbHMuTmFOdG9aZXJvKHNjYWxlLnJhbmdlKClbaV0pICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF4aXNMYWJlbC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgIGlmIChzaG93TWF4TWluICYmIChheGlzLm9yaWVudCgpID09PSAnbGVmdCcgfHwgYXhpcy5vcmllbnQoKSA9PT0gJ3JpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIG1heCBhbmQgbWluIG92ZXJsYXAgb3RoZXIgdmFsdWVzLCBpZiBzbywgaGlkZSB0aGUgdmFsdWVzIHRoYXQgb3ZlcmxhcFxuICAgICAgICAgICAgICAgIGcuc2VsZWN0QWxsKCdnJykgLy8gdGhlIGcncyB3cmFwcGluZyBlYWNoIHRpY2tcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JykuYXR0cignb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlKGQpIDwgc2NhbGUucmFuZ2UoKVsxXSArIDEwIHx8IHNjYWxlKGQpID4gc2NhbGUucmFuZ2UoKVswXSAtIDEwKSB7IC8vIDEwIGlzIGFzc3VtaW5nIHRleHQgaGVpZ2h0IGlzIDE2Li4uIGlmIGQgaXMgMCwgbGVhdmUgaXQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiAxZS0xMCB8fCBkIDwgLTFlLTEwKSAvLyBhY2NvdW50cyBmb3IgbWlub3IgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLi4uIHRob3VnaCBjb3VsZCBiZSBwcm9ibGVtYXRpYyBpZiB0aGUgc2NhbGUgaXMgRVhUUkVNRUxZIFNNQUxMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdvcGFjaXR5JywgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JykuYXR0cignb3BhY2l0eScsIDApOyAvLyBEb24ndCByZW1vdmUgdGhlIFpFUk8gbGluZSEhXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9pZiBNYXggYW5kIE1pbiA9IDAgb25seSBzaG93IG1pbiwgSXNzdWUgIzI4MVxuICAgICAgICAgICAgICAgIGlmIChzY2FsZS5kb21haW4oKVswXSA9PSBzY2FsZS5kb21haW4oKVsxXSAmJiBzY2FsZS5kb21haW4oKVswXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4nKS5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWkgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93TWF4TWluICYmIChheGlzLm9yaWVudCgpID09PSAndG9wJyB8fCBheGlzLm9yaWVudCgpID09PSAnYm90dG9tJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4TWluUmFuZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJylcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSAvLyBpPT0gMSwgbWF4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heE1pblJhbmdlLnB1c2goc2NhbGUoZCkgLSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gNCkgIC8vYXNzdW1pbmcgdGhlIG1heCBhbmQgbWluIGxhYmVscyBhcmUgYXMgd2lkZSBhcyB0aGUgbmV4dCB0aWNrICh3aXRoIGFuIGV4dHJhIDQgcGl4ZWxzIGp1c3QgaW4gY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIGk9PTAsIG1pbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhNaW5SYW5nZS5wdXNoKHNjYWxlKGQpICsgdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9Y2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSAvLyBpPT0gMSwgbWF4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heE1pblJhbmdlLnB1c2goc2NhbGUoZCkgLSA0KTsgIC8vYXNzdW1pbmcgdGhlIG1heCBhbmQgbWluIGxhYmVscyBhcmUgYXMgd2lkZSBhcyB0aGUgbmV4dCB0aWNrICh3aXRoIGFuIGV4dHJhIDQgcGl4ZWxzIGp1c3QgaW4gY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIGk9PTAsIG1pbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhNaW5SYW5nZS5wdXNoKHNjYWxlKGQpICsgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBnJ3Mgd3JhcHBpbmcgZWFjaCB0aWNrXG4gICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoJ2cnKS5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUoZCkgPCBtYXhNaW5SYW5nZVswXSB8fCBzY2FsZShkKSA+IG1heE1pblJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IDFlLTEwIHx8IGQgPCAtMWUtMTApIC8vIGFjY291bnRzIGZvciBtaW5vciBmbG9hdGluZyBwb2ludCBlcnJvcnMuLi4gdGhvdWdoIGNvdWxkIGJlIHByb2JsZW1hdGljIGlmIHRoZSBzY2FsZSBpcyBFWFRSRU1FTFkgU01BTExcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgndGV4dCcpLnJlbW92ZSgpOyAvLyBEb24ndCByZW1vdmUgdGhlIFpFUk8gbGluZSEhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9oaWdobGlnaHQgemVybyBsaW5lIC4uLiBNYXliZSBzaG91bGQgbm90IGJlIGFuIG9wdGlvbiBhbmQgc2hvdWxkIGp1c3QgYmUgaW4gQ1NTP1xuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodFplcm8pIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdEFsbCgnLnRpY2snKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXBhcnNlRmxvYXQoTWF0aC5yb3VuZCh0aGlzLl9fZGF0YV9fICogMTAwMDAwKSAvIDEwMDAwMDApICYmICh0aGlzLl9fZGF0YV9fICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIH0pIC8vdGhpcyBpcyBiZWNhdXNlIHNvbWV0aW1lcyB0aGUgMCB0aWNrIGlzIGEgdmVyeSBzbWFsbCBmcmFjdGlvbiwgVE9ETzogdGhpbmsgb2YgY2xlYW5lciB0ZWNobmlxdWVcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3plcm8nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgICAgICAgc2NhbGUwID0gc2NhbGUuY29weSgpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnYXhpcyBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5heGlzID0gYXhpcztcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIGF4aXNMYWJlbERpc3RhbmNlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBheGlzTGFiZWxEaXN0YW5jZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2F4aXNMYWJlbERpc3RhbmNlPV87fX0sXG4gICAgICAgIHN0YWdnZXJMYWJlbHM6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFnZ2VyTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7c3RhZ2dlckxhYmVscz1fO319LFxuICAgICAgICByb3RhdGVMYWJlbHM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcm90YXRlTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7cm90YXRlTGFiZWxzPV87fX0sXG4gICAgICAgIHJvdGF0ZVlMYWJlbDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByb3RhdGVZTGFiZWw7fSwgc2V0OiBmdW5jdGlvbihfKXtyb3RhdGVZTGFiZWw9Xzt9fSxcbiAgICAgICAgaGlnaGxpZ2h0WmVybzogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhpZ2hsaWdodFplcm87fSwgc2V0OiBmdW5jdGlvbihfKXtoaWdobGlnaHRaZXJvPV87fX0sXG4gICAgICAgIHNob3dNYXhNaW46ICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TWF4TWluO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd01heE1pbj1fO319LFxuICAgICAgICBheGlzTGFiZWw6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYXhpc0xhYmVsVGV4dDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2F4aXNMYWJlbFRleHQ9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB0aWNrczogICAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdGlja3M7fSwgc2V0OiBmdW5jdGlvbihfKXt0aWNrcz1fO319LFxuICAgICAgICB3aWR0aDogICAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAhPT0gdW5kZWZpbmVkICAgID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgIT09IHVuZGVmaW5lZCAgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAhPT0gdW5kZWZpbmVkICAgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbj1fO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgc2NhbGU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNjYWxlO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBzY2FsZSA9IF87XG4gICAgICAgICAgICBheGlzLnNjYWxlKHNjYWxlKTtcbiAgICAgICAgICAgIGlzT3JkaW5hbCA9IHR5cGVvZiBzY2FsZS5yYW5nZUJhbmRzID09PSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnNEMyhjaGFydCwgc2NhbGUsIFsnZG9tYWluJywgJ3JhbmdlJywgJ3JhbmdlQmFuZCcsICdyYW5nZUJhbmRzJ10pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zRDMoY2hhcnQsIGF4aXMsIFsnb3JpZW50JywgJ3RpY2tWYWx1ZXMnLCAndGlja1N1YmRpdmlkZScsICd0aWNrU2l6ZScsICd0aWNrUGFkZGluZycsICd0aWNrRm9ybWF0J10pO1xuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zRDMoY2hhcnQsIHNjYWxlLCBbJ2RvbWFpbicsICdyYW5nZScsICdyYW5nZUJhbmQnLCAncmFuZ2VCYW5kcyddKTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbi8vIENoYXJ0IGRlc2lnbiBiYXNlZCBvbiB0aGUgcmVjb21tZW5kYXRpb25zIG9mIFN0ZXBoZW4gRmV3LiBJbXBsZW1lbnRhdGlvblxuLy8gYmFzZWQgb24gdGhlIHdvcmsgb2YgQ2xpbnQgSXZ5LCBKYW1pZSBMb3ZlLCBhbmQgSmFzb24gRGF2aWVzLlxuLy8gaHR0cDovL3Byb2plY3RzLmluc3RhbnRjb2duaXRpb24uY29tL3Byb3RvdmlzL2J1bGxldGNoYXJ0L1xuXG5udi5tb2RlbHMuYnVsbGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIG9yaWVudCA9ICdsZWZ0JyAvLyBUT0RPIHRvcCAmIGJvdHRvbVxuICAgICAgICAsIHJldmVyc2UgPSBmYWxzZVxuICAgICAgICAsIHJhbmdlcyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQucmFuZ2VzIH1cbiAgICAgICAgLCBtYXJrZXJzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tYXJrZXJzID8gZC5tYXJrZXJzIDogWzBdIH1cbiAgICAgICAgLCBtZWFzdXJlcyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubWVhc3VyZXMgfVxuICAgICAgICAsIHJhbmdlTGFiZWxzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5yYW5nZUxhYmVscyA/IGQucmFuZ2VMYWJlbHMgOiBbXSB9XG4gICAgICAgICwgbWFya2VyTGFiZWxzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tYXJrZXJMYWJlbHMgPyBkLm1hcmtlckxhYmVscyA6IFtdICB9XG4gICAgICAgICwgbWVhc3VyZUxhYmVscyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubWVhc3VyZUxhYmVscyA/IGQubWVhc3VyZUxhYmVscyA6IFtdICB9XG4gICAgICAgICwgZm9yY2VYID0gWzBdIC8vIExpc3Qgb2YgbnVtYmVycyB0byBGb3JjZSBpbnRvIHRoZSBYIHNjYWxlIChpZS4gMCwgb3IgYSBtYXggLyBtaW4sIGV0Yy4pXG4gICAgICAgICwgd2lkdGggPSAzODBcbiAgICAgICAgLCBoZWlnaHQgPSAzMFxuICAgICAgICAsIHRpY2tGb3JtYXQgPSBudWxsXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihbJyMxZjc3YjQnXSlcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcpXG4gICAgICAgIDtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFyIHJhbmdleiA9IHJhbmdlcy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCkuc29ydChkMy5kZXNjZW5kaW5nKSxcbiAgICAgICAgICAgICAgICBtYXJrZXJ6ID0gbWFya2Vycy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCkuc29ydChkMy5kZXNjZW5kaW5nKSxcbiAgICAgICAgICAgICAgICBtZWFzdXJleiA9IG1lYXN1cmVzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpLFxuICAgICAgICAgICAgICAgIHJhbmdlTGFiZWx6ID0gcmFuZ2VMYWJlbHMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLFxuICAgICAgICAgICAgICAgIG1hcmtlckxhYmVseiA9IG1hcmtlckxhYmVscy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgbWVhc3VyZUxhYmVseiA9IG1lYXN1cmVMYWJlbHMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG5ldyB4LXNjYWxlLlxuICAgICAgICAgICAgdmFyIHgxID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgICAgICAuZG9tYWluKCBkMy5leHRlbnQoZDMubWVyZ2UoW2ZvcmNlWCwgcmFuZ2V6XSkpIClcbiAgICAgICAgICAgICAgICAucmFuZ2UocmV2ZXJzZSA/IFthdmFpbGFibGVXaWR0aCwgMF0gOiBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIG9sZCB4LXNjYWxlLCBpZiB0aGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX19jaGFydF9fIHx8IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgSW5maW5pdHldKVxuICAgICAgICAgICAgICAgIC5yYW5nZSh4MS5yYW5nZSgpKTtcblxuICAgICAgICAgICAgLy8gU3Rhc2ggdGhlIG5ldyBzY2FsZS5cbiAgICAgICAgICAgIHRoaXMuX19jaGFydF9fID0geDE7XG5cbiAgICAgICAgICAgIHZhciByYW5nZU1pbiA9IGQzLm1pbihyYW5nZXopLCAvL3JhbmdlelsyXVxuICAgICAgICAgICAgICAgIHJhbmdlTWF4ID0gZDMubWF4KHJhbmdleiksIC8vcmFuZ2V6WzBdXG4gICAgICAgICAgICAgICAgcmFuZ2VBdmcgPSByYW5nZXpbMV07XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1idWxsZXQnKS5kYXRhKFtkXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1idWxsZXQnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudi1yYW5nZSBudi1yYW5nZU1heCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2NsYXNzJywgJ252LXJhbmdlIG52LXJhbmdlQXZnJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnYtcmFuZ2UgbnYtcmFuZ2VNaW4nKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudi1tZWFzdXJlJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdwYXRoJykuYXR0cignY2xhc3MnLCAnbnYtbWFya2VyVHJpYW5nbGUnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICB2YXIgdzAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLmFicyh4MChkKSAtIHgwKDApKSB9LCAvLyBUT0RPOiBjb3VsZCBvcHRpbWl6ZSBieSBwcmVjYWxjdWxhdGluZyB4MCgwKSBhbmQgeDEoMClcbiAgICAgICAgICAgICAgICB3MSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgxKGQpIC0geDEoMCkpIH07XG4gICAgICAgICAgICB2YXIgeHAwID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZCA8IDAgPyB4MChkKSA6IHgwKDApIH0sXG4gICAgICAgICAgICAgICAgeHAxID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZCA8IDAgPyB4MShkKSA6IHgxKDApIH07XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCdyZWN0Lm52LXJhbmdlTWF4JylcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcxKHJhbmdlTWF4ID4gMCA/IHJhbmdlTWF4IDogcmFuZ2VNaW4pKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeHAxKHJhbmdlTWF4ID4gMCA/IHJhbmdlTWF4IDogcmFuZ2VNaW4pKVxuICAgICAgICAgICAgICAgIC5kYXR1bShyYW5nZU1heCA+IDAgPyByYW5nZU1heCA6IHJhbmdlTWluKVxuXG4gICAgICAgICAgICBnLnNlbGVjdCgncmVjdC5udi1yYW5nZUF2ZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3MShyYW5nZUF2ZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4cDEocmFuZ2VBdmcpKVxuICAgICAgICAgICAgICAgIC5kYXR1bShyYW5nZUF2ZylcblxuICAgICAgICAgICAgZy5zZWxlY3QoJ3JlY3QubnYtcmFuZ2VNaW4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdzEocmFuZ2VNYXgpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeHAxKHJhbmdlTWF4KSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3MShyYW5nZU1heCA+IDAgPyByYW5nZU1pbiA6IHJhbmdlTWF4KSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHhwMShyYW5nZU1heCA+IDAgPyByYW5nZU1pbiA6IHJhbmdlTWF4KSlcbiAgICAgICAgICAgICAgICAuZGF0dW0ocmFuZ2VNYXggPiAwID8gcmFuZ2VNaW4gOiByYW5nZU1heClcblxuICAgICAgICAgICAgZy5zZWxlY3QoJ3JlY3QubnYtbWVhc3VyZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY29sb3IpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCAvIDMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBhdmFpbGFibGVIZWlnaHQgLyAzKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG1lYXN1cmV6IDwgMCA/XG4gICAgICAgICAgICAgICAgICAgIHgxKDApIC0geDEobWVhc3VyZXpbMF0pXG4gICAgICAgICAgICAgICAgICAgIDogeDEobWVhc3VyZXpbMF0pIC0geDEoMCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4cDEobWVhc3VyZXopKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lYXN1cmV6WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG1lYXN1cmVMYWJlbHpbMF0gfHwgJ0N1cnJlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeDEobWVhc3VyZXpbMF0pLCBhdmFpbGFibGVIZWlnaHQvMl1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZWFzdXJlelswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBtZWFzdXJlTGFiZWx6WzBdIHx8ICdDdXJyZW50J1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgaDMgPSAgYXZhaWxhYmxlSGVpZ2h0IC8gNjtcbiAgICAgICAgICAgIGlmIChtYXJrZXJ6WzBdKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoJ3BhdGgubnYtbWFya2VyVHJpYW5nbGUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDEobWFya2VyelswXSkgKyAnLCcgKyAoYXZhaWxhYmxlSGVpZ2h0IC8gMikgKyAnKScgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsJyArIGgzICsgJ0wnICsgaDMgKyAnLCcgKyAoLWgzKSArICcgJyArICgtaDMpICsgJywnICsgKC1oMykgKyAnWicpXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFya2VyelswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbWFya2VyTGFiZWx6WzBdIHx8ICdQcmV2aW91cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeDEobWFya2VyelswXSksIGF2YWlsYWJsZUhlaWdodC8yXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFya2VyelswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbWFya2VyTGFiZWx6WzBdIHx8ICdQcmV2aW91cydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdEFsbCgncGF0aC5udi1tYXJrZXJUcmlhbmdsZScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLnNlbGVjdEFsbCgnLm52LXJhbmdlJylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSByYW5nZUxhYmVseltpXSB8fCAoIWkgPyBcIk1heGltdW1cIiA6IGkgPT0gMSA/IFwiTWVhblwiIDogXCJNaW5pbXVtXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4MShkKSwgYXZhaWxhYmxlSGVpZ2h0LzJdXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHJhbmdlTGFiZWx6W2ldIHx8ICghaSA/IFwiTWF4aW11bVwiIDogaSA9PSAxID8gXCJNZWFuXCIgOiBcIk1pbmltdW1cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgcmFuZ2VzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJhbmdlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Jhbmdlcz1fO319LCAvLyByYW5nZXMgKGJhZCwgc2F0aXNmYWN0b3J5LCBnb29kKVxuICAgICAgICBtYXJrZXJzOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFya2Vyczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21hcmtlcnM9Xzt9fSwgLy8gbWFya2VycyAocHJldmlvdXMsIGdvYWwpXG4gICAgICAgIG1lYXN1cmVzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtZWFzdXJlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21lYXN1cmVzPV87fX0sIC8vIG1lYXN1cmVzIChhY3R1YWwsIGZvcmVjYXN0KVxuICAgICAgICBmb3JjZVg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VYO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VYPV87fX0sXG4gICAgICAgIHdpZHRoOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHRpY2tGb3JtYXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt0aWNrRm9ybWF0PV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBvcmllbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG9yaWVudDt9LCBzZXQ6IGZ1bmN0aW9uKF8peyAvLyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b21cbiAgICAgICAgICAgIG9yaWVudCA9IF87XG4gICAgICAgICAgICByZXZlcnNlID0gb3JpZW50ID09ICdyaWdodCcgfHwgb3JpZW50ID09ICdib3R0b20nO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5cblxuLy8gQ2hhcnQgZGVzaWduIGJhc2VkIG9uIHRoZSByZWNvbW1lbmRhdGlvbnMgb2YgU3RlcGhlbiBGZXcuIEltcGxlbWVudGF0aW9uXG4vLyBiYXNlZCBvbiB0aGUgd29yayBvZiBDbGludCBJdnksIEphbWllIExvdmUsIGFuZCBKYXNvbiBEYXZpZXMuXG4vLyBodHRwOi8vcHJvamVjdHMuaW5zdGFudGNvZ25pdGlvbi5jb20vcHJvdG92aXMvYnVsbGV0Y2hhcnQvXG5udi5tb2RlbHMuYnVsbGV0Q2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGJ1bGxldCA9IG52Lm1vZGVscy5idWxsZXQoKVxuICAgICAgICA7XG5cbiAgICB2YXIgb3JpZW50ID0gJ2xlZnQnIC8vIFRPRE8gdG9wICYgYm90dG9tXG4gICAgICAgICwgcmV2ZXJzZSA9IGZhbHNlXG4gICAgICAgICwgbWFyZ2luID0ge3RvcDogNSwgcmlnaHQ6IDQwLCBib3R0b206IDIwLCBsZWZ0OiAxMjB9XG4gICAgICAgICwgcmFuZ2VzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5yYW5nZXMgfVxuICAgICAgICAsIG1hcmtlcnMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1hcmtlcnMgPyBkLm1hcmtlcnMgOiBbMF0gfVxuICAgICAgICAsIG1lYXN1cmVzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tZWFzdXJlcyB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gNTVcbiAgICAgICAgLCB0aWNrRm9ybWF0ID0gbnVsbFxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsgeCArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgeSArICc8L3A+J1xuICAgICAgICB9XG4gICAgICAgICwgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLidcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApICsgbWFyZ2luLmxlZnQsXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCkgKyBtYXJnaW4udG9wLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5rZXksIGUubGFiZWwsIGUudmFsdWUsIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ2UnIDogJ3cnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjaGFydChzZWxlY3Rpb24pIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZCB8fCAhcmFuZ2VzLmNhbGwodGhpcywgZCwgaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDE4ICsgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhbmdleiA9IHJhbmdlcy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCkuc29ydChkMy5kZXNjZW5kaW5nKSxcbiAgICAgICAgICAgICAgICBtYXJrZXJ6ID0gbWFya2Vycy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCkuc29ydChkMy5kZXNjZW5kaW5nKSxcbiAgICAgICAgICAgICAgICBtZWFzdXJleiA9IG1lYXN1cmVzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtYnVsbGV0Q2hhcnQnKS5kYXRhKFtkXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1idWxsZXRDaGFydCcpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJ1bGxldFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi10aXRsZXMnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBuZXcgeC1zY2FsZS5cbiAgICAgICAgICAgIHZhciB4MSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgTWF0aC5tYXgocmFuZ2V6WzBdLCBtYXJrZXJ6WzBdLCBtZWFzdXJlelswXSldKSAgLy8gVE9ETzogbmVlZCB0byBhbGxvdyBmb3JjZVggYW5kIGZvcmNlWSwgYW5kIHhEb21haW4sIHlEb21haW5cbiAgICAgICAgICAgICAgICAucmFuZ2UocmV2ZXJzZSA/IFthdmFpbGFibGVXaWR0aCwgMF0gOiBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIG9sZCB4LXNjYWxlLCBpZiB0aGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX19jaGFydF9fIHx8IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgSW5maW5pdHldKVxuICAgICAgICAgICAgICAgIC5yYW5nZSh4MS5yYW5nZSgpKTtcblxuICAgICAgICAgICAgLy8gU3Rhc2ggdGhlIG5ldyBzY2FsZS5cbiAgICAgICAgICAgIHRoaXMuX19jaGFydF9fID0geDE7XG5cbiAgICAgICAgICAgIHZhciB3MCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgwKGQpIC0geDAoMCkpIH0sIC8vIFRPRE86IGNvdWxkIG9wdGltaXplIGJ5IHByZWNhbGN1bGF0aW5nIHgwKDApIGFuZCB4MSgwKVxuICAgICAgICAgICAgICAgIHcxID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gTWF0aC5hYnMoeDEoZCkgLSB4MSgwKSkgfTtcblxuICAgICAgICAgICAgdmFyIHRpdGxlID0gZ0VudGVyLnNlbGVjdCgnLm52LXRpdGxlcycpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLTYsJyArIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSkgLyAyICsgJyknKTtcbiAgICAgICAgICAgIHRpdGxlLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LXRpdGxlJylcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLnRpdGxlOyB9KTtcblxuICAgICAgICAgICAgdGl0bGUuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtc3VidGl0bGUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxZW0nKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3VidGl0bGU7IH0pO1xuXG4gICAgICAgICAgICBidWxsZXRcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG5cbiAgICAgICAgICAgIHZhciBidWxsZXRXcmFwID0gZy5zZWxlY3QoJy5udi1idWxsZXRXcmFwJyk7XG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGJ1bGxldFdyYXApLmNhbGwoYnVsbGV0KTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdGljayBmb3JtYXQuXG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gdGlja0Zvcm1hdCB8fCB4MS50aWNrRm9ybWF0KCBhdmFpbGFibGVXaWR0aCAvIDEwMCApO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRpY2sgZ3JvdXBzLlxuICAgICAgICAgICAgdmFyIHRpY2sgPSBnLnNlbGVjdEFsbCgnZy5udi10aWNrJylcbiAgICAgICAgICAgICAgICAuZGF0YSh4MS50aWNrcyggYXZhaWxhYmxlV2lkdGggLyA1MCApLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRDb250ZW50IHx8IGZvcm1hdChkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGlja3Mgd2l0aCB0aGUgb2xkIHNjYWxlLCB4MC5cbiAgICAgICAgICAgIHZhciB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtdGljaycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgwKGQpICsgJywwKScgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KTtcblxuICAgICAgICAgICAgdGlja0VudGVyLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGF2YWlsYWJsZUhlaWdodCAqIDcgLyA2KTtcblxuICAgICAgICAgICAgdGlja0VudGVyLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzFlbScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBhdmFpbGFibGVIZWlnaHQgKiA3IC8gNilcbiAgICAgICAgICAgICAgICAudGV4dChmb3JtYXQpO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRoZSB1cGRhdGluZyB0aWNrcyB0byB0aGUgbmV3IHNjYWxlLCB4MS5cbiAgICAgICAgICAgIHZhciB0aWNrVXBkYXRlID0gZDMudHJhbnNpdGlvbih0aWNrKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4MShkKSArICcsMCknIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG5cbiAgICAgICAgICAgIHRpY2tVcGRhdGUuc2VsZWN0KCdsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgYXZhaWxhYmxlSGVpZ2h0ICogNyAvIDYpO1xuXG4gICAgICAgICAgICB0aWNrVXBkYXRlLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBhdmFpbGFibGVIZWlnaHQgKiA3IC8gNik7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gdGhlIGV4aXRpbmcgdGlja3MgdG8gdGhlIG5ldyBzY2FsZSwgeDEuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKHRpY2suZXhpdCgpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4MShkKSArICcsMCknIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLmtleSA9IGQudGl0bGU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZDMudGltZXIuZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBidWxsZXQuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBidWxsZXQuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5idWxsZXQgPSBidWxsZXQ7XG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICByYW5nZXM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmFuZ2VzO30sIHNldDogZnVuY3Rpb24oXyl7cmFuZ2VzPV87fX0sIC8vIHJhbmdlcyAoYmFkLCBzYXRpc2ZhY3RvcnksIGdvb2QpXG4gICAgICAgIG1hcmtlcnM6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJrZXJzO30sIHNldDogZnVuY3Rpb24oXyl7bWFya2Vycz1fO319LCAvLyBtYXJrZXJzIChwcmV2aW91cywgZ29hbClcbiAgICAgICAgbWVhc3VyZXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1lYXN1cmVzO30sIHNldDogZnVuY3Rpb24oXyl7bWVhc3VyZXM9Xzt9fSwgLy8gbWVhc3VyZXMgKGFjdHVhbCwgZm9yZWNhc3QpXG4gICAgICAgIHdpZHRoOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHRpY2tGb3JtYXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt0aWNrRm9ybWF0PV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgb3JpZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBvcmllbnQ7fSwgc2V0OiBmdW5jdGlvbihfKXsgLy8gbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXG4gICAgICAgICAgICBvcmllbnQgPSBfO1xuICAgICAgICAgICAgcmV2ZXJzZSA9IG9yaWVudCA9PSAncmlnaHQnIHx8IG9yaWVudCA9PSAnYm90dG9tJztcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBidWxsZXQpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cblxuXG5udi5tb2RlbHMuY3VtdWxhdGl2ZUxpbmVDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbGluZXMgPSBudi5tb2RlbHMubGluZSgpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBpbnRlcmFjdGl2ZUxheWVyID0gbnYuaW50ZXJhY3RpdmVHdWlkZWxpbmUoKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAgICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXG4gICAgICAgICwgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBmYWxzZVxuICAgICAgICAsIHJlc2NhbGVZID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgYXQgJyArIHggKyAnPC9wPidcbiAgICAgICAgfVxuICAgICAgICAsIHggLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnhTY2FsZSgpXG4gICAgICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAgICAgLCBpZCA9IGxpbmVzLmlkKClcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLidcbiAgICAgICAgLCBhdmVyYWdlID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5hdmVyYWdlIH1cbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgbm9FcnJvckNoZWNrID0gZmFsc2UgIC8vaWYgc2V0IHRvIFRSVUUsIHdpbGwgYnlwYXNzIGFuIGVycm9yIGNoZWNrIGluIHRoZSBpbmRleGlmeSBmdW5jdGlvbi5cbiAgICAgICAgO1xuXG4gICAgc3RhdGUuaW5kZXggPSAwO1xuICAgIHN0YXRlLnJlc2NhbGVZID0gcmVzY2FsZVk7XG5cbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1BhZGRpbmcoNylcbiAgICA7XG4gICAgeUF4aXNcbiAgICAgICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgO1xuXG4gICAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgZHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGluZGV4ID0ge2k6IDAsIHg6IDB9XG4gICAgICAgICwgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pXG4gICAgICAgIDtcblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobGluZXMueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShsaW5lcy55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIG51bGwsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleC5pLFxuICAgICAgICAgICAgICAgIHJlc2NhbGVZOiByZXNjYWxlWVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmluZGV4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgaW5kZXguaSA9IHN0YXRlLmluZGV4O1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlc2NhbGVZICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzY2FsZVkgPSBzdGF0ZS5yZXNjYWxlWTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKGxpbmVzKTtcbiAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc2VkKCdudi1jaGFydC0nICsgaWQsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgc2V0IHN0YXRlLmRpc2FibGVkZGlzYWJsZWRcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4RHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKVxuICAgICAgICAgICAgICAgIC5vbignZHJhZ3N0YXJ0JywgZHJhZ1N0YXJ0KVxuICAgICAgICAgICAgICAgIC5vbignZHJhZycsIGRyYWdNb3ZlKVxuICAgICAgICAgICAgICAgIC5vbignZHJhZ2VuZCcsIGRyYWdFbmQpO1xuXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYWdTdGFydChkLGkpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoY2hhcnQuY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2N1cnNvcicsICdldy1yZXNpemUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhZ01vdmUoZCxpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgueCA9IGQzLmV2ZW50Lng7XG4gICAgICAgICAgICAgICAgaW5kZXguaSA9IE1hdGgucm91bmQoZHguaW52ZXJ0KGluZGV4LngpKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVaZXJvKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYWdFbmQoZCxpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KGNoYXJ0LmNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdjdXJzb3InLCAnYXV0bycpO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXRlIGFuZCBzZW5kIHN0YXRlQ2hhbmdlIHdpdGggbmV3IGluZGV4XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleC5pO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBsaW5lcy54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBsaW5lcy55U2NhbGUoKTtcblxuICAgICAgICAgICAgaWYgKCFyZXNjYWxlWSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNEb21haW5zID0gZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gIXNlcmllcy5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbERvbWFpbiA9IGQzLmV4dGVudChzZXJpZXMudmFsdWVzLCBsaW5lcy55KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FjY291bnQgZm9yIHNlcmllcyBiZWluZyBkaXNhYmxlZCB3aGVuIGxvc2luZyA5NSUgb3IgbW9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxEb21haW5bMF0gPCAtLjk1KSBpbml0aWFsRG9tYWluWzBdID0gLS45NTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxEb21haW5bMF0gLSBpbml0aWFsRG9tYWluWzFdKSAvICgxICsgaW5pdGlhbERvbWFpblsxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsRG9tYWluWzFdIC0gaW5pdGlhbERvbWFpblswXSkgLyAoMSArIGluaXRpYWxEb21haW5bMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZURvbWFpbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgZDMubWluKHNlcmllc0RvbWFpbnMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF0gfSksXG4gICAgICAgICAgICAgICAgICAgIGQzLm1heChzZXJpZXNEb21haW5zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzFdIH0pXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGxpbmVzLnlEb21haW4oY29tcGxldGVEb21haW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lcy55RG9tYWluKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkeC5kb21haW4oWzAsIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIDFdKSAvL0Fzc3VtZXMgYWxsIHNlcmllcyBoYXZlIHNhbWUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCBhdmFpbGFibGVXaWR0aF0pXG4gICAgICAgICAgICAgICAgLmNsYW1wKHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGluZGV4aWZ5KGluZGV4LmksIGRhdGEpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIGludGVyYWN0aXZlUG9pbnRlckV2ZW50cyA9ICh1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSkgPyBcIm5vbmVcIiA6IFwiYWxsXCI7XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1jdW11bGF0aXZlTGluZScpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWN1bXVsYXRpdmVMaW5lJykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1pbnRlcmFjdGl2ZScpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIik7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxpbmVzV3JhcCcpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixpbnRlcmFjdGl2ZVBvaW50ZXJFdmVudHMpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWF2Z0xpbmVzV3JhcCcpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIik7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRyb2xzV3JhcCcpO1xuXG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb250cm9sc1xuICAgICAgICAgICAgaWYgKHNob3dDb250cm9scykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiAnUmUtc2NhbGUgeS1heGlzJywgZGlzYWJsZWQ6ICFyZXNjYWxlWSB9XG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aCgxNDApXG4gICAgICAgICAgICAgICAgICAgIC5jb2xvcihbJyM0NDQnLCAnIzQ0NCcsICcjNDQ0J10pXG4gICAgICAgICAgICAgICAgICAgIC5yaWdodEFsaWduKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHt0b3A6IDUsIHJpZ2h0OiAwLCBib3R0b206IDUsIGxlZnQ6IDIwfSlcbiAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoY29udHJvbHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaG93IGVycm9yIGlmIHNlcmllcyBnb2VzIGJlbG93IDEwMCVcbiAgICAgICAgICAgIHZhciB0ZW1wRGlzYWJsZWQgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnRlbXBEaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy50ZW1wRGlzYWJsZWQnKS5yZW1vdmUoKTsgLy9jbGVhbi11cCBhbmQgcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgICAgICBpZiAodGVtcERpc2FibGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAndGVtcERpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJy0uNzFlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQodGVtcERpc2FibGVkLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KS5qb2luKCcsICcpICsgJyB2YWx1ZXMgY2Fubm90IGJlIGNhbGN1bGF0ZWQgZm9yIHRoaXMgdGltZSBwZXJpb2QuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vU2V0IHVwIGludGVyYWN0aXZlIGxheWVyXG4gICAgICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXJnaW4oe2xlZnQ6bWFyZ2luLmxlZnQsdG9wOm1hcmdpbi50b3B9KVxuICAgICAgICAgICAgICAgICAgICAuc3ZnQ29udGFpbmVyKGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnhTY2FsZSh4KTtcbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdChcIi5udi1pbnRlcmFjdGl2ZVwiKS5jYWxsKGludGVyYWN0aXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnRW50ZXIuc2VsZWN0KCcubnYtYmFja2dyb3VuZCcpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWJhY2tncm91bmQgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGxpbmVzXG4gICAgICAgICAgICAgICAgLy8ueChmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSlcbiAgICAgICAgICAgICAgICAueShmdW5jdGlvbihkKSB7IHJldHVybiBkLmRpc3BsYXkueSB9KVxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmICFkYXRhW2ldLnRlbXBEaXNhYmxlZDsgfSkpO1xuXG4gICAgICAgICAgICB2YXIgbGluZXNXcmFwID0gZy5zZWxlY3QoJy5udi1saW5lc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAgIWQuZGlzYWJsZWQgJiYgIWQudGVtcERpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgbGluZXNXcmFwLmNhbGwobGluZXMpO1xuXG4gICAgICAgICAgICAvL1N0b3JlIGEgc2VyaWVzIGluZGV4IG51bWJlciBpbiB0aGUgZGF0YSBhcnJheS5cbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBkLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgYXZnTGluZURhdGEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFkLmRpc2FibGVkICYmICEhYXZlcmFnZShkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgYXZnTGluZXMgPSBnLnNlbGVjdChcIi5udi1hdmdMaW5lc1dyYXBcIikuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGF2Z0xpbmVEYXRhLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleTsgfSk7XG5cbiAgICAgICAgICAgIHZhciBnZXRBdmdMaW5lWSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAvL0lmIGF2ZXJhZ2UgbGluZXMgZ28gb2ZmIHRoZSBzdmcgZWxlbWVudCwgY2xhbXAgdGhlbSB0byB0aGUgc3ZnIGJvdW5kcy5cbiAgICAgICAgICAgICAgICB2YXIgeVZhbCA9IHkoYXZlcmFnZShkKSk7XG4gICAgICAgICAgICAgICAgaWYgKHlWYWwgPCAwKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBpZiAoeVZhbCA+IGF2YWlsYWJsZUhlaWdodCkgcmV0dXJuIGF2YWlsYWJsZUhlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4geVZhbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGF2Z0xpbmVzLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknLCcxMCwxMCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLGZ1bmN0aW9uIChkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzLmNvbG9yKCkoZCxkLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsMClcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGdldEF2Z0xpbmVZKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGdldEF2Z0xpbmVZKTtcblxuICAgICAgICAgICAgYXZnTGluZXNcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JyxmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICAgICAgLy9JZiBhdmVyYWdlIGxpbmVzIGdvIG9mZnNjcmVlbiwgbWFrZSB0aGVtIHRyYW5zcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciB5VmFsID0geShhdmVyYWdlKGQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWwgPCAwIHx8IHlWYWwgPiBhdmFpbGFibGVIZWlnaHQpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsMClcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGdldEF2Z0xpbmVZKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGdldEF2Z0xpbmVZKTtcblxuICAgICAgICAgICAgYXZnTGluZXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvL0NyZWF0ZSBpbmRleCBsaW5lXG4gICAgICAgICAgICB2YXIgaW5kZXhMaW5lID0gbGluZXNXcmFwLnNlbGVjdEFsbCgnLm52LWluZGV4TGluZScpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG4gICAgICAgICAgICBpbmRleExpbmUuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudi1pbmRleExpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtMilcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdyZWQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAuNSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLFwiYWxsXCIpXG4gICAgICAgICAgICAgICAgLmNhbGwoaW5kZXhEcmFnKTtcblxuICAgICAgICAgICAgaW5kZXhMaW5lXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIGR4KGQuaSkgKyAnLDApJyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC83MCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlWmVybygpIHtcbiAgICAgICAgICAgICAgICBpbmRleExpbmVcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAvL1doZW4gZHJhZ2dpbmcgdGhlIGluZGV4IGxpbmUsIHR1cm4gb2ZmIGxpbmUgdHJhbnNpdGlvbnMuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiB0dXJuIHRoZW0gYmFjayBvbiB3aGVuIGRvbmUgZHJhZ2dpbmcuXG4gICAgICAgICAgICAgICAgdmFyIG9sZER1cmF0aW9uID0gY2hhcnQuZHVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBjaGFydC5kdXJhdGlvbigwKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBjaGFydC5kdXJhdGlvbihvbGREdXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtYmFja2dyb3VuZCByZWN0JylcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LnggPSBkMy5tb3VzZSh0aGlzKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguaSA9IE1hdGgucm91bmQoZHguaW52ZXJ0KGluZGV4LngpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgc3RhdGUgYW5kIHNlbmQgc3RhdGVDaGFuZ2Ugd2l0aCBuZXcgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleC5pO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlWmVybygpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudENsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGluZGV4LmkgPSBlLnBvaW50SW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXgueCA9IGR4KGluZGV4LmkpO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXRlIGFuZCBzZW5kIHN0YXRlQ2hhbmdlIHdpdGggbmV3IGluZGV4XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleC5pO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVplcm8oKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgcmVzY2FsZVkgPSAhZC5kaXNhYmxlZDtcblxuICAgICAgICAgICAgICAgIHN0YXRlLnJlc2NhbGVZID0gcmVzY2FsZVk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgbGluZXMuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZVBvaW50LCBwb2ludEluZGV4LCBwb2ludFhMb2NhdGlvbiwgYWxsRGF0YSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5oaWdobGlnaHRQb2ludChpLCBwb2ludEluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaW5nbGVQb2ludCA9PT0gJ3VuZGVmaW5lZCcpIHNpbmdsZVBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50WExvY2F0aW9uID09PSAndW5kZWZpbmVkJykgcG9pbnRYTG9jYXRpb24gPSBjaGFydC54U2NhbGUoKShjaGFydC54KCkocG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yKHNlcmllcyxzZXJpZXMuc2VyaWVzSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL0hpZ2hsaWdodCB0aGUgdG9vbHRpcCBlbnRyeSBiYXNlZCBvbiB3aGljaCBwb2ludCB0aGUgbW91c2UgaXMgY2xvc2VzdCB0by5cbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5VmFsdWUgPSBjaGFydC55U2NhbGUoKS5pbnZlcnQoZS5tb3VzZVkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluRXh0ZW50ID0gTWF0aC5hYnMoY2hhcnQueVNjYWxlKCkuZG9tYWluKClbMF0gLSBjaGFydC55U2NhbGUoKS5kb21haW4oKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjAzICogZG9tYWluRXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhUb0hpZ2hsaWdodCA9IG52Lm5lYXJlc3RWYWx1ZUluZGV4KGFsbERhdGEubWFwKGZ1bmN0aW9uKGQpe3JldHVybiBkLnZhbHVlfSkseVZhbHVlLHRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFRvSGlnaGxpZ2h0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YVtpbmRleFRvSGlnaGxpZ2h0XS5oaWdobGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSB4QXhpcy50aWNrRm9ybWF0KCkoY2hhcnQueCgpKHNpbmdsZVBvaW50LHBvaW50SW5kZXgpLCBwb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLnBvc2l0aW9uKHtsZWZ0OiBwb2ludFhMb2NhdGlvbiArIG1hcmdpbi5sZWZ0LCB0b3A6IGUubW91c2VZICsgbWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAgIC5jaGFydENvbnRhaW5lcih0aGF0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC5lbmFibGVkKHRvb2x0aXBzKVxuICAgICAgICAgICAgICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geUF4aXMudGlja0Zvcm1hdCgpKGQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHhWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogYWxsRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSgpO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5yZW5kZXJHdWlkZUxpbmUocG9pbnRYTG9jYXRpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oXCJlbGVtZW50TW91c2VvdXRcIixmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5pbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguaSA9IGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LnggPSBkeChpbmRleC5pKTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pbmRleCA9IGUuaW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5kZXhMaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUucmVzY2FsZVkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2NhbGVZID0gZS5yZXNjYWxlWTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnY3VtdWxhdGl2ZUxpbmVDaGFydCBpbW1lZGlhdGUnKTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRnVuY3Rpb25zXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBpbmRleGlmeVlHZXR0ZXIgPSBudWxsO1xuICAgIC8qIE5vcm1hbGl6ZSB0aGUgZGF0YSBhY2NvcmRpbmcgdG8gYW4gaW5kZXggcG9pbnQuICovXG4gICAgZnVuY3Rpb24gaW5kZXhpZnkoaWR4LCBkYXRhKSB7XG4gICAgICAgIGlmICghaW5kZXhpZnlZR2V0dGVyKSBpbmRleGlmeVlHZXR0ZXIgPSBsaW5lcy55KCk7XG4gICAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmUudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXhWYWx1ZSA9IGxpbmUudmFsdWVzW2lkeF07XG4gICAgICAgICAgICBpZiAoaW5kZXhWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdiA9IGluZGV4aWZ5WUdldHRlcihpbmRleFZhbHVlLCBpZHgpO1xuXG4gICAgICAgICAgICAvL1RPRE86IGltcGxlbWVudCBjaGVjayBiZWxvdywgYW5kIGRpc2FibGUgc2VyaWVzIGlmIHNlcmllcyBsb3NlcyAxMDAlIG9yIG1vcmUgY2F1c2UgZGl2aWRlIGJ5IDAgaXNzdWVcbiAgICAgICAgICAgIGlmICh2IDwgLS45NSAmJiAhbm9FcnJvckNoZWNrKSB7XG4gICAgICAgICAgICAgICAgLy9pZiBhIHNlcmllcyBsb3NlcyBtb3JlIHRoYW4gMTAwJSwgY2FsY3VsYXRpb25zIGZhaWwuLiBhbnl0aGluZyBjbG9zZSBjYW4gY2F1c2UgbWFqb3IgZGlzdG9ydGlvbiAoYnV0IGlzIG1hdGhlbWF0aWNhbGx5IGNvcnJlY3QgdGlsbCBpdCBoaXRzIDEwMClcblxuICAgICAgICAgICAgICAgIGxpbmUudGVtcERpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZS50ZW1wRGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGluZS52YWx1ZXMgPSBsaW5lLnZhbHVlcy5tYXAoZnVuY3Rpb24ocG9pbnQsIHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwb2ludC5kaXNwbGF5ID0geyd5JzogKGluZGV4aWZ5WUdldHRlcihwb2ludCwgcG9pbnRJbmRleCkgLSB2KSAvICgxICsgdikgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubGluZXMgPSBsaW5lcztcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LmludGVyYWN0aXZlTGF5ZXIgPSBpbnRlcmFjdGl2ZUxheWVyO1xuICAgIGNoYXJ0LnN0YXRlID0gc3RhdGU7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICByZXNjYWxlWTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc2NhbGVZO30sIHNldDogZnVuY3Rpb24oXyl7cmVzY2FsZVk9Xzt9fSxcbiAgICAgICAgc2hvd0NvbnRyb2xzOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0NvbnRyb2xzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0NvbnRyb2xzPV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIGF2ZXJhZ2U6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGF2ZXJhZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXthdmVyYWdlPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICBzaG93WEF4aXM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dYQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dYQXhpcz1fO319LFxuICAgICAgICBzaG93WUF4aXM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICBub0Vycm9yQ2hlY2s6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRXJyb3JDaGVjazt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRXJyb3JDaGVjaz1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgIH19LFxuICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gXztcbiAgICAgICAgICAgIGlmIChfID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVzZVZvcm9ub2koZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICBsaW5lcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgbGluZXMpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07Ly9UT0RPOiBjb25zaWRlciBkZXByZWNhdGluZyBieSBhZGRpbmcgbmVjZXNzYXJ5IGZlYXR1cmVzIHRvIG11bHRpQmFyIG1vZGVsXG5udi5tb2RlbHMuZGlzY3JldGVCYXIgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA5NjBcbiAgICAgICAgLCBoZWlnaHQgPSA1MDBcbiAgICAgICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgICAgICwgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGZvcmNlWSA9IFswXSAvLyAwIGlzIGZvcmNlZCBieSBkZWZhdWx0Li4gdGhpcyBtYWtlcyBzZW5zZSBmb3IgdGhlIG1ham9yaXR5IG9mIGJhciBncmFwaHMuLi4gdXNlciBjYW4gYWx3YXlzIGRvIGNoYXJ0LmZvcmNlWShbXSkgdG8gcmVtb3ZlXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHNob3dWYWx1ZXMgPSBmYWxzZVxuICAgICAgICAsIHZhbHVlRm9ybWF0ID0gZDMuZm9ybWF0KCcsLjJmJylcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsJ3JlbmRlckVuZCcpXG4gICAgICAgICwgcmVjdENsYXNzID0gJ2Rpc2NyZXRlQmFyJ1xuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHgwLCB5MDtcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvL2FkZCBzZXJpZXMgaW5kZXggdG8gZWFjaCBkYXRhIHBvaW50IGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuc2VyaWVzID0gaTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIC8vIHJlbWFwIGFuZCBmbGF0dGVuIHRoZSBkYXRhIGZvciB1c2UgaW4gY2FsY3VsYXRpbmcgdGhlIHNjYWxlcycgZG9tYWluc1xuICAgICAgICAgICAgdmFyIHNlcmllc0RhdGEgPSAoeERvbWFpbiAmJiB5RG9tYWluKSA/IFtdIDogLy8gaWYgd2Uga25vdyB4RG9tYWluIGFuZCB5RG9tYWluLCBubyBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpLCB5MDogZC55MCB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHggICAuZG9tYWluKHhEb21haW4gfHwgZDMubWVyZ2Uoc2VyaWVzRGF0YSkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9KSlcbiAgICAgICAgICAgICAgICAucmFuZ2VCYW5kcyh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSwgLjEpO1xuICAgICAgICAgICAgeSAgIC5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzRGF0YSkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9KS5jb25jYXQoZm9yY2VZKSkpO1xuXG4gICAgICAgICAgICAvLyBJZiBzaG93VmFsdWVzLCBwYWQgdGhlIFkgYXhpcyByYW5nZSB0byBhY2NvdW50IGZvciBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgIGlmIChzaG93VmFsdWVzKSB5LnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0IC0gKHkuZG9tYWluKClbMF0gPCAwID8gMTIgOiAwKSwgeS5kb21haW4oKVsxXSA+IDAgPyAxMiA6IDBdKTtcbiAgICAgICAgICAgIGVsc2UgeS5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgaWYgdGhleSBleGlzdFxuICAgICAgICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgICAgICAgeTAgPSB5MCB8fCB5LmNvcHkoKS5yYW5nZShbeSgwKSx5KDApXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1kaXNjcmV0ZWJhcicpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWRpc2NyZXRlYmFyJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vVE9ETzogYnkgZGVmaW5pdGlvbiwgdGhlIGRpc2NyZXRlIGJhciBzaG91bGQgbm90IGhhdmUgbXVsdGlwbGUgZ3JvdXBzLCB3aWxsIG1vZGlmeS9yZW1vdmUgbGF0ZXJcbiAgICAgICAgICAgIHZhciBncm91cHMgPSB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5IH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpO1xuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKVxuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdkaXNjcmV0ZUJhcjogZXhpdCBncm91cHMnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICBncm91cHNcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1ncm91cCBudi1zZXJpZXMtJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhvdmVyIH0pO1xuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2Rpc2NyZXRlQmFyOiBncm91cHMnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgLjc1KTtcblxuICAgICAgICAgICAgdmFyIGJhcnMgPSBncm91cHMuc2VsZWN0QWxsKCdnLm52LWJhcicpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSk7XG4gICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdmFyIGJhcnNFbnRlciA9IGJhcnMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKHgoZ2V0WChkLGkpKSArIHgucmFuZ2VCYW5kKCkgKiAuMDUgKSArICcsICcgKyB5KDApICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkgeyAvL1RPRE86IGZpZ3VyZSBvdXQgd2h5IGogd29ya3MgYWJvdmUsIGJ1dCBub3QgaGVyZVxuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCksIHkoZ2V0WShkLGkpKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCksIHkoZ2V0WShkLGkpKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSArICh4LnJhbmdlQmFuZCgpICogKGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYmFyc0VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeC5yYW5nZUJhbmQoKSAqIC45IC8gZGF0YS5sZW5ndGggKVxuXG4gICAgICAgICAgICBpZiAoc2hvd1ZhbHVlcykge1xuICAgICAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gdmFsdWVGb3JtYXQoZ2V0WShkLGkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnZGlzY3JldGVCYXI6IGJhcnMgdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeC5yYW5nZUJhbmQoKSAqIC45IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyB5KGdldFkoZCxpKSkgLSB5KDApICsgMTIgOiAtNCB9KVxuXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdEFsbCgndGV4dCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ252LWJhciBuZWdhdGl2ZScgOiAnbnYtYmFyIHBvc2l0aXZlJyB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCxpKSB9KVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIHJlY3RDbGFzcylcbiAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnZGlzY3JldGVCYXI6IGJhcnMgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeC5yYW5nZUJhbmQoKSAqIC45IC8gZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgYmFycy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdkaXNjcmV0ZUJhcjogYmFycycpXG4gICAgICAgICAgICAgICAgLy8uZGVsYXkoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpICogMTIwMCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSB4KGdldFgoZCxpKSkgKyB4LnJhbmdlQmFuZCgpICogLjA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gZ2V0WShkLGkpIDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgLSB5KGdldFkoZCxpKSkgPCAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KDApIC0gMSA6IC8vbWFrZSAxIHB4IHBvc2l0aXZlIGJhcnMgc2hvdyB1cCBhYm92ZSB5PTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KGdldFkoZCxpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGxlZnQgKyAnLCAnICsgdG9wICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAgTWF0aC5tYXgoTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgoeURvbWFpbiAmJiB5RG9tYWluWzBdKSB8fCAwKSkgfHwgMSlcbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICAgICAgICB5MCA9IHkuY29weSgpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnZGlzY3JldGVCYXIgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VZO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VZPV87fX0sXG4gICAgICAgIHNob3dWYWx1ZXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dWYWx1ZXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93VmFsdWVzPV87fX0sXG4gICAgICAgIHg6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYPV87fX0sXG4gICAgICAgIHk6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZPV87fX0sXG4gICAgICAgIHhTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHg7fSwgc2V0OiBmdW5jdGlvbihfKXt4PV87fX0sXG4gICAgICAgIHlTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHhEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt4RG9tYWluPV87fX0sXG4gICAgICAgIHlEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgdmFsdWVGb3JtYXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHZhbHVlRm9ybWF0O30sIHNldDogZnVuY3Rpb24oXyl7dmFsdWVGb3JtYXQ9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgcmVjdENsYXNzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByZWN0Q2xhc3M7fSwgc2V0OiBmdW5jdGlvbihfKXtyZWN0Q2xhc3M9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5kaXNjcmV0ZUJhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBkaXNjcmV0ZWJhciA9IG52Lm1vZGVscy5kaXNjcmV0ZUJhcigpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAxNSwgcmlnaHQ6IDEwLCBib3R0b206IDUwLCBsZWZ0OiA2MH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcigpXG4gICAgICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHN0YWdnZXJMYWJlbHMgPSBmYWxzZVxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsgeCArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnPC9wPidcbiAgICAgICAgfVxuICAgICAgICAsIHhcbiAgICAgICAgLCB5XG4gICAgICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ2JlZm9yZVVwZGF0ZScsJ3JlbmRlckVuZCcpXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgO1xuXG4gICAgeEF4aXNcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLmhpZ2hsaWdodFplcm8oZmFsc2UpXG4gICAgICAgIC5zaG93TWF4TWluKGZhbHNlKVxuICAgICAgICAudGlja0Zvcm1hdChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pXG4gICAgO1xuICAgIHlBeGlzXG4gICAgICAgIC5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgICAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcbiAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkoZGlzY3JldGViYXIueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShkaXNjcmV0ZWJhci55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoZGlzY3JldGViYXIpO1xuICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5iZWZvcmVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCA9IGRpc2NyZXRlYmFyLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IGRpc2NyZXRlYmFyLnlTY2FsZSgpLmNsYW1wKHRydWUpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtZGlzY3JldGVCYXJXaXRoQXhlcycpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWRpc2NyZXRlQmFyV2l0aEF4ZXMnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi16ZXJvTGluZScpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFyc1dyYXAnKTtcblxuICAgICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcbiAgICAgICAgICAgIGRpc2NyZXRlYmFyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgdmFyIGJhcnNXcmFwID0gZy5zZWxlY3QoJy5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuXG4gICAgICAgICAgICBiYXJzV3JhcC50cmFuc2l0aW9uKCkuY2FsbChkaXNjcmV0ZWJhcik7XG5cblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi14LWxhYmVsLWNsaXAtJyArIGRpc2NyZXRlYmFyLmlkKCkpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnI252LXgtbGFiZWwtY2xpcC0nICsgZGlzY3JldGViYXIuaWQoKSArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeC5yYW5nZUJhbmQoKSAqIChzdGFnZ2VyTGFiZWxzID8gMiA6IDEpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxNilcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIC14LnJhbmdlQmFuZCgpIC8gKHN0YWdnZXJMYWJlbHMgPyAxIDogMiApKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKHkucmFuZ2UoKVswXSArICgoZGlzY3JldGViYXIuc2hvd1ZhbHVlcygpICYmIHkuZG9tYWluKClbMF0gPCAwKSA/IDE2IDogMCkpICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhUaWNrcyA9IGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuc2VsZWN0QWxsKCdnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWdnZXJMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyAoaiAlIDIgPT0gMCA/ICc1JyA6ICcxNycpICsgJyknIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKS5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWmVybyBsaW5lXG4gICAgICAgICAgICBnLnNlbGVjdChcIi5udi16ZXJvTGluZSBsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLDApXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeSgwKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHkoMCkpXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2Rpc2NyZXRlQmFyIGNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRpc2NyZXRlYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGRpc2NyZXRlYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5kaXNjcmV0ZWJhciA9IGRpc2NyZXRlYmFyO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHN0YWdnZXJMYWJlbHM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YWdnZXJMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzdGFnZ2VyTGFiZWxzPV87fX0sXG4gICAgICAgIHNob3dYQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBkaXNjcmV0ZWJhci5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgZGlzY3JldGViYXIuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGRpc2NyZXRlYmFyKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5kaXN0cmlidXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gNDAwIC8vdGVjaG5pY2FsbHkgd2lkdGggb3IgaGVpZ2h0IGRlcGVuZGluZyBvbiB4IG9yIHkuLi4uXG4gICAgICAgICwgc2l6ZSA9IDhcbiAgICAgICAgLCBheGlzID0gJ3gnIC8vICd4JyBvciAneScuLi4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuICAgICAgICAsIGdldERhdGEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkW2F4aXNdIH0gIC8vIGRlZmF1bHRzIGQueCBvciBkLnlcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGRvbWFpblxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2NhbGUwO1xuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUxlbmd0aCA9IHdpZHRoIC0gKGF4aXMgPT09ICd4JyA/IG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0IDogbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pLFxuICAgICAgICAgICAgICAgIG5heGlzID0gYXhpcyA9PSAneCcgPyAneScgOiAneCcsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMCB8fCBzY2FsZTtcblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LWRpc3RyaWJ1dGlvbicpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi1kaXN0cmlidXRpb24nKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKVxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgICAgICAgIHZhciBkaXN0V3JhcCA9IGcuc2VsZWN0QWxsKCdnLm52LWRpc3QnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfSk7XG5cbiAgICAgICAgICAgIGRpc3RXcmFwLmVudGVyKCkuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICBkaXN0V3JhcFxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWRpc3QgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pO1xuXG4gICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RXcmFwLnNlbGVjdEFsbCgnbGluZS5udi1kaXN0JyArIGF4aXMpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSlcbiAgICAgICAgICAgIGRpc3QuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUwKGdldERhdGEoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihheGlzICsgJzInLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlMChnZXREYXRhKGQsaSkpIH0pXG4gICAgICAgICAgICByZW5kZXJXYXRjaC50cmFuc2l0aW9uKGRpc3RXcmFwLmV4aXQoKS5zZWxlY3RBbGwoJ2xpbmUubnYtZGlzdCcgKyBheGlzKSwgJ2Rpc3QgZXhpdCcpXG4gICAgICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUoZ2V0RGF0YShkLGkpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUoZ2V0RGF0YShkLGkpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAwKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRpc3RcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1kaXN0JyArIGF4aXMgKyAnIG52LWRpc3QnICsgYXhpcyArICctJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihuYXhpcyArICcxJywgMClcbiAgICAgICAgICAgICAgICAuYXR0cihuYXhpcyArICcyJywgc2l6ZSk7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC50cmFuc2l0aW9uKGRpc3QsICdkaXN0JylcbiAgICAgICAgICAgICAgICAvLyAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmF0dHIoYXhpcyArICcxJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBzY2FsZShnZXREYXRhKGQsaSkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoYXhpcyArICcyJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBzY2FsZShnZXREYXRhKGQsaSkpIH0pXG5cblxuICAgICAgICAgICAgc2NhbGUwID0gc2NhbGUuY29weSgpO1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2Rpc3RyaWJ1dGlvbiBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbiAgICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICAgICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgICAgIHdpZHRoID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5heGlzID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBheGlzO1xuICAgICAgICBheGlzID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgICBzaXplID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5nZXREYXRhID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXREYXRhO1xuICAgICAgICBnZXREYXRhID0gZDMuZnVuY3RvcihfKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgICAgIHNjYWxlID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgcmV0dXJuIGNoYXJ0O1xufVxuLy9UT0RPOiBjb25zaWRlciBkZXByZWNhdGluZyBhbmQgdXNpbmcgbXVsdGliYXIgd2l0aCBzaW5nbGUgc2VyaWVzIGZvciB0aGlzXG5udi5tb2RlbHMuaGlzdG9yaWNhbEJhciA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICAsIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGZvcmNlWCA9IFtdXG4gICAgICAgICwgZm9yY2VZID0gWzBdXG4gICAgICAgICwgcGFkRGF0YSA9IGZhbHNlXG4gICAgICAgICwgY2xpcEVkZ2UgPSB0cnVlXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHhEb21haW5cbiAgICAgICAgLCB5RG9tYWluXG4gICAgICAgICwgeFJhbmdlXG4gICAgICAgICwgeVJhbmdlXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnY2hhcnRDbGljaycsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ3JlbmRlckVuZCcpXG4gICAgICAgICwgaW50ZXJhY3RpdmUgPSB0cnVlXG4gICAgICAgIDtcblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCAwKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4LmRvbWFpbih4RG9tYWluIHx8IGQzLmV4dGVudChkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0WCkuY29uY2F0KGZvcmNlWCkgKSk7XG5cbiAgICAgICAgICAgIGlmIChwYWREYXRhKVxuICAgICAgICAgICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFthdmFpbGFibGVXaWR0aCAqIC41IC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoLCBhdmFpbGFibGVXaWR0aCAqIChkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAuNSkgIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoIF0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICB5LmRvbWFpbih5RG9tYWluIHx8IGQzLmV4dGVudChkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0WSkuY29uY2F0KGZvcmNlWSkgKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgLy8gSWYgc2NhbGUncyBkb21haW4gZG9uJ3QgaGF2ZSBhIHJhbmdlLCBzbGlnaHRseSBhZGp1c3QgdG8gbWFrZSBvbmUuLi4gc28gYSBjaGFydCBjYW4gc2hvdyBhIHNpbmdsZSBkYXRhIHBvaW50XG4gICAgICAgICAgICBpZiAoeC5kb21haW4oKVswXSA9PT0geC5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB4LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeC5kb21haW4oW3guZG9tYWluKClbMF0gLSB4LmRvbWFpbigpWzBdICogMC4wMSwgeC5kb21haW4oKVsxXSArIHguZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB4LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICBpZiAoeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB5LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0gKyB5LmRvbWFpbigpWzBdICogMC4wMSwgeS5kb21haW4oKVsxXSAtIHkuZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB5LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtaGlzdG9yaWNhbEJhci0nICsgaWQpLmRhdGEoW2RhdGFbMF0udmFsdWVzXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1oaXN0b3JpY2FsQmFyLScgKyBpZCk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnMnKTtcbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5jaGFydENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGcuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgYmFycyA9IHdyYXAuc2VsZWN0KCcubnYtYmFycycpLnNlbGVjdEFsbCgnLm52LWJhcicpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkLGkpIHtyZXR1cm4gZ2V0WChkLGkpfSk7XG4gICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdmFyIGJhcnNFbnRlciA9IGJhcnMuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMCApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHsgIHJldHVybiBudi51dGlscy5OYU50b1plcm8oeShNYXRoLm1heCgwLCBnZXRZKGQsaSkpKSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgwKSkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKHgoZ2V0WChkLGkpKSAtIGF2YWlsYWJsZVdpZHRoIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoICogLjQ1KSArICcsMCknOyB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSksIHkoZ2V0WShkLGkpKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbGFiZWw6IGRbbGFiZWxdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSwgeShnZXRZKGQsaSkpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sYWJlbDogZFtsYWJlbF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpLCB5KGdldFkoZCxpKSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAoZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZScpICsgJyBudi1iYXItJyArIGogKyAnLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2JhcnMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArICh4KGdldFgoZCxpKSkgLSBhdmFpbGFibGVXaWR0aCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAqIC40NSkgKyAnLDApJzsgfSlcbiAgICAgICAgICAgICAgICAvL1RPRE86IGJldHRlciB3aWR0aCBjYWxjdWxhdGlvbnMgdGhhdCBkb24ndCBhc3N1bWUgYWx3YXlzIHVuaWZvcm0gZGF0YSBzcGFjaW5nO3dcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgpICogLjkgKTtcblxuICAgICAgICAgICAgYmFycy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdiYXJzJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnZhbCA9IGdldFkoZCxpKSA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIHkoZ2V0WShkLGkpKSA8IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIDEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgeShnZXRZKGQsaSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHJ2YWwpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKE1hdGgubWF4KE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoMCkpLDEpKSB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2hpc3RvcmljYWxCYXIgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvL0NyZWF0ZSBtZXRob2RzIHRvIGFsbG93IG91dHNpZGUgZnVuY3Rpb25zIHRvIGhpZ2hsaWdodCBhIHNwZWNpZmljIGJhci5cbiAgICBjaGFydC5oaWdobGlnaHRQb2ludCA9IGZ1bmN0aW9uKHBvaW50SW5kZXgsIGlzSG92ZXJPdmVyKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIi5udi1oaXN0b3JpY2FsQmFyLVwiICsgaWQpXG4gICAgICAgICAgICAuc2VsZWN0KFwiLm52LWJhcnMgLm52LWJhci0wLVwiICsgcG9pbnRJbmRleClcbiAgICAgICAgICAgIC5jbGFzc2VkKFwiaG92ZXJcIiwgaXNIb3Zlck92ZXIpXG4gICAgICAgIDtcbiAgICB9O1xuXG4gICAgY2hhcnQuY2xlYXJIaWdobGlnaHRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIi5udi1oaXN0b3JpY2FsQmFyLVwiICsgaWQpXG4gICAgICAgICAgICAuc2VsZWN0KFwiLm52LWJhcnMgLm52LWJhci5ob3ZlclwiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJob3ZlclwiLCBmYWxzZSlcbiAgICAgICAgO1xuICAgIH07XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgZm9yY2VYOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VYO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VYPV87fX0sXG4gICAgICAgIGZvcmNlWTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWT1fO319LFxuICAgICAgICBwYWREYXRhOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBwYWREYXRhO30sIHNldDogZnVuY3Rpb24oXyl7cGFkRGF0YT1fO319LFxuICAgICAgICB4OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1fO319LFxuICAgICAgICB5OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WT1fO319LFxuICAgICAgICB4U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4O30sIHNldDogZnVuY3Rpb24oXyl7eD1fO319LFxuICAgICAgICB5U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5O30sIHNldDogZnVuY3Rpb24oXyl7eT1fO319LFxuICAgICAgICB4RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbj1fO319LFxuICAgICAgICB4UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt4UmFuZ2U9Xzt9fSxcbiAgICAgICAgeVJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwRWRnZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBFZGdlPV87fX0sXG4gICAgICAgIGlkOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG4gICAgICAgIGludGVyYWN0aXZlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcmFjdGl2ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVyYWN0aXZlPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLmhpc3RvcmljYWxCYXJDaGFydCA9IGZ1bmN0aW9uKGJhcl9tb2RlbCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgYmFycyA9IGJhcl9tb2RlbCB8fCBudi5tb2RlbHMuaGlzdG9yaWNhbEJhcigpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgaW50ZXJhY3RpdmVMYXllciA9IG52LmludGVyYWN0aXZlR3VpZGVsaW5lKClcbiAgICAgICAgO1xuXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiA5MCwgYm90dG9tOiA1MCwgbGVmdDogOTB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBzaG93TGVnZW5kID0gZmFsc2VcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBmYWxzZVxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgYXQgJyArIHggKyAnPC9wPidcbiAgICAgICAgfVxuICAgICAgICAsIHhcbiAgICAgICAgLCB5XG4gICAgICAgICwgc3RhdGUgPSB7fVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJ1xuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywgJ3JlbmRlckVuZCcpXG4gICAgICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIHhBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrUGFkZGluZyg3KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KCAocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG5cbiAgICAgICAgLy8gTmV3IGFkZGl0aW9uIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBTVkcgaXMgc2NhbGVkIHdpdGggdmlld0JveCwgbWF5IG1vdmUgVE9ETzogY29uc2lkZXIgaW1wbGVtZW50aW5nIGV2ZXJ5d2hlcmUgZWxzZVxuICAgICAgICBpZiAob2Zmc2V0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChvZmZzZXRFbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICAgICAgdmFyIHZpZXdCb3ggPSAoc3ZnLm5vZGUoKSkgPyBzdmcuYXR0cigndmlld0JveCcpIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgICAgICAgICAgdmlld0JveCA9IHZpZXdCb3guc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBwYXJzZUludChzdmcuc3R5bGUoJ3dpZHRoJykpIC8gdmlld0JveFsyXTtcbiAgICAgICAgICAgICAgICBlLnBvc1swXSA9IGUucG9zWzBdICogcmF0aW87XG4gICAgICAgICAgICAgICAgZS5wb3NbMV0gPSBlLnBvc1sxXSAqIHJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkoYmFycy54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICB5ID0geUF4aXMudGlja0Zvcm1hdCgpKGJhcnMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBudWxsLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCAwKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKGJhcnMpO1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG5cbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChjaGFydCkgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vc2V0IHN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgbm9EYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBiYXJzLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IGJhcnMueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1oaXN0b3JpY2FsQmFyQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1oaXN0b3JpY2FsQmFyQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWludGVyYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgoYXZhaWxhYmxlV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NldCB1cCBpbnRlcmFjdGl2ZSBsYXllclxuICAgICAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHtsZWZ0Om1hcmdpbi5sZWZ0LCB0b3A6bWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAueFNjYWxlKHgpO1xuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KFwiLm52LWludGVyYWN0aXZlXCIpLmNhbGwoaW50ZXJhY3RpdmVMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpO1xuXG4gICAgICAgICAgICB2YXIgYmFyc1dyYXAgPSBnLnNlbGVjdCgnLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpO1xuICAgICAgICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwoYmFycyk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEF4ZXNcbiAgICAgICAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGJhcnMuY2xlYXJIaWdobGlnaHRzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUG9pbnQsIHBvaW50SW5kZXgsIHBvaW50WExvY2F0aW9uLCBhbGxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJzLmhpZ2hsaWdodFBvaW50KHBvaW50SW5kZXgsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlUG9pbnQgPT09ICd1bmRlZmluZWQnKSBzaW5nbGVQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFhMb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHBvaW50WExvY2F0aW9uID0gY2hhcnQueFNjYWxlKCkoY2hhcnQueCgpKHBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGFydC55KCkocG9pbnQsIHBvaW50SW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcihzZXJpZXMsc2VyaWVzLnNlcmllc0luZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0geEF4aXMudGlja0Zvcm1hdCgpKGNoYXJ0LngoKShzaW5nbGVQb2ludCxwb2ludEluZGV4KSk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIC5wb3NpdGlvbih7bGVmdDogcG9pbnRYTG9jYXRpb24gKyBtYXJnaW4ubGVmdCwgdG9wOiBlLm1vdXNlWSArIG1hcmdpbi50b3B9KVxuICAgICAgICAgICAgICAgICAgICAuY2hhcnRDb250YWluZXIodGhhdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAuZW5hYmxlZCh0b29sdGlwcylcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkoKTtcblxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIucmVuZGVyR3VpZGVMaW5lKHBvaW50WExvY2F0aW9uKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oXCJlbGVtZW50TW91c2VvdXRcIixmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoKTtcbiAgICAgICAgICAgICAgICBiYXJzLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdEFsbCgnLm52LXNlcmllcycpLmNsYXNzZWQoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi50cmFuc2l0aW9uKCkuY2FsbChjaGFydCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdsZWdlbmREYmxjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAvL0RvdWJsZSBjbGlja2luZyBzaG91bGQgYWx3YXlzIGVuYWJsZSBjdXJyZW50IHNlcmllcywgYW5kIGRpc2FibGVkIGFsbCBvdGhlcnMuXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2hpc3RvcmljYWxCYXJDaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGJhcnMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuYmFycyA9IGJhcnM7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5pbnRlcmFjdGl2ZUxheWVyID0gaW50ZXJhY3RpdmVMYXllcjtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHNob3dYQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBiYXJzLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0cmFuc2l0aW9uRHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbj1fO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fSxcbiAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IF87XG4gICAgICAgICAgICBpZiAoXyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNoYXJ0LmludGVyYWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBiYXJzKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5cbi8vIG9obGNDaGFydCBpcyBqdXN0IGEgaGlzdG9yaWNhbCBjaGFydCB3aXRoIG9jbGMgYmFycyBhbmQgc29tZSB0d2Vha3Ncbm52Lm1vZGVscy5vaGxjQmFyQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hhcnQgPSBudi5tb2RlbHMuaGlzdG9yaWNhbEJhckNoYXJ0KG52Lm1vZGVscy5vaGxjQmFyKCkpO1xuXG4gICAgLy8gc3BlY2lhbCBkZWZhdWx0IHRvb2x0aXAgc2luY2Ugd2Ugc2hvdyBtdWx0aXBsZSB2YWx1ZXMgcGVyIHhcbiAgICBjaGFydC51c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSh0cnVlKTtcbiAgICBjaGFydC5pbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXAuY29udGVudEdlbmVyYXRvcihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFzc3VtZSBvbmx5IG9uZSBzZXJpZXMgZXhpc3RzIGZvciB0aGlzIGNoYXJ0XG4gICAgICAgIHZhciBkID0gZGF0YS5zZXJpZXNbMF0uZGF0YTtcbiAgICAgICAgLy8gbWF0Y2ggbGluZSBjb2xvcnMgYXMgZGVmaW5lZCBpbiBudi5kMy5jc3NcbiAgICAgICAgdmFyIGNvbG9yID0gZC5vcGVuIDwgZC5jbG9zZSA/IFwiMmNhMDJjXCIgOiBcImQ2MjcyOFwiO1xuICAgICAgICByZXR1cm4gJycgK1xuICAgICAgICAgICAgJzxoMyBzdHlsZT1cImNvbG9yOiAjJyArIGNvbG9yICsgJ1wiPicgKyBkYXRhLnZhbHVlICsgJzwvaDM+JyArXG4gICAgICAgICAgICAnPHRhYmxlPicgK1xuICAgICAgICAgICAgJzx0cj48dGQ+b3Blbjo8L3RkPjx0ZD4nICsgY2hhcnQueUF4aXMudGlja0Zvcm1hdCgpKGQub3BlbikgKyAnPC90ZD48L3RyPicgK1xuICAgICAgICAgICAgJzx0cj48dGQ+Y2xvc2U6PC90ZD48dGQ+JyArIGNoYXJ0LnlBeGlzLnRpY2tGb3JtYXQoKShkLmNsb3NlKSArICc8L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPjx0ZD5oaWdoPC90ZD48dGQ+JyArIGNoYXJ0LnlBeGlzLnRpY2tGb3JtYXQoKShkLmhpZ2gpICsgJzwvdGQ+PC90cj4nICtcbiAgICAgICAgICAgICc8dHI+PHRkPmxvdzo8L3RkPjx0ZD4nICsgY2hhcnQueUF4aXMudGlja0Zvcm1hdCgpKGQubG93KSArICc8L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGFydDtcbn07bnYubW9kZWxzLmxlZ2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogNSwgcmlnaHQ6IDAsIGJvdHRvbTogNSwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDQwMFxuICAgICAgICAsIGhlaWdodCA9IDIwXG4gICAgICAgICwgZ2V0S2V5ID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBhbGlnbiA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduID0gdHJ1ZVxuICAgICAgICAsIHVwZGF0ZVN0YXRlID0gdHJ1ZSAgIC8vSWYgdHJ1ZSwgbGVnZW5kIHdpbGwgdXBkYXRlIGRhdGEuZGlzYWJsZWQgYW5kIHRyaWdnZXIgYSAnc3RhdGVDaGFuZ2UnIGRpc3BhdGNoLlxuICAgICAgICAsIHJhZGlvQnV0dG9uTW9kZSA9IGZhbHNlICAgLy9JZiB0cnVlLCBjbGlja2luZyBsZWdlbmQgaXRlbXMgd2lsbCBjYXVzZSBpdCB0byBiZWhhdmUgbGlrZSBhIHJhZGlvIGJ1dHRvbi4gKG9ubHkgb25lIGNhbiBiZSBzZWxlY3RlZCBhdCBhIHRpbWUpXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnbGVnZW5kQ2xpY2snLCAnbGVnZW5kRGJsY2xpY2snLCAnbGVnZW5kTW91c2VvdmVyJywgJ2xlZ2VuZE1vdXNlb3V0JywgJ3N0YXRlQ2hhbmdlJylcbiAgICAgICAgO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LWxlZ2VuZCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi1sZWdlbmQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gZy5zZWxlY3RBbGwoJy5udi1zZXJpZXMnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG4gICAgICAgICAgICB2YXIgc2VyaWVzRW50ZXIgPSBzZXJpZXMuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zZXJpZXMnKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmxlZ2VuZE1vdXNlb3ZlcihkLGkpOyAgLy9UT0RPOiBNYWtlIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBldmVudCBvYmplY3RzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmxlZ2VuZE1vdXNlb3V0KGQsaSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmxlZ2VuZENsaWNrKGQsaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvQnV0dG9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUmFkaW8gYnV0dG9uIG1vZGU6IHNldCBldmVyeSBzZXJpZXMgdG8gZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGFuZCBlbmFibGUgdGhlIGNsaWNrZWQgc2VyaWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMpIHsgc2VyaWVzLmRpc2FibGVkID0gdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSAhZC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ldmVyeShmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy5kaXNhYmxlZH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgTlZEMyBsZWdlbmRzIGlzLCBpZiBldmVyeSBzaW5nbGUgc2VyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGRpc2FibGVkLCB0dXJuIGFsbCBzZXJpZXMnIGJhY2sgb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMpIHsgc2VyaWVzLmRpc2FibGVkID0gZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kRGJsY2xpY2soZCxpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIE5WRDMgbGVnZW5kcywgd2hlbiBkb3VibGUgY2xpY2tpbmcgb25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdG8gc2V0IGFsbCBvdGhlciBzZXJpZXMnIHRvIGZhbHNlLCBhbmQgbWFrZSB0aGUgZG91YmxlIGNsaWNrZWQgc2VyaWVzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXJpZXNFbnRlci5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ252LWxlZ2VuZC1zeW1ib2wnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSk7XG4gICAgICAgICAgICBzZXJpZXNFbnRlci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywnbnYtbGVnZW5kLXRleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMzJlbScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgJzgnKTtcbiAgICAgICAgICAgIHNlcmllcy5jbGFzc2VkKCdudi1kaXNhYmxlZCcsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICBzZXJpZXMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgc2VyaWVzLnNlbGVjdCgnY2lyY2xlJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCxpKX0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSkgfSk7XG4gICAgICAgICAgICBzZXJpZXMuc2VsZWN0KCd0ZXh0JykudGV4dChnZXRLZXkpO1xuXG4gICAgICAgICAgICAvL1RPRE86IGltcGxlbWVudCBmaXhlZC13aWR0aCBhbmQgbWF4LXdpZHRoIG9wdGlvbnMgKG1heC13aWR0aCBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aXRoIHRoZSBhbGlnbiBvcHRpb24pXG4gICAgICAgICAgICAvLyBORVcgQUxJR05JTkcgQ09ERSwgVE9ETzogY2xlYW4gdXBcbiAgICAgICAgICAgIGlmIChhbGlnbikge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc1dpZHRocyA9IFtdO1xuICAgICAgICAgICAgICAgIHNlcmllcy5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVnZW5kVGV4dCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVUZXh0TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRleHRMZW5ndGggPSBsZWdlbmRUZXh0Lm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsZWdlbmRUZXh0IGlzIGRpc3BsYXk6bm9uZSdkIChub2RlVGV4dExlbmd0aCA9PSAwKSwgc2ltdWxhdGUgYW4gZXJyb3Igc28gd2UgYXBwcm94aW1hdGUsIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGVUZXh0TGVuZ3RoIDw9IDApIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRleHRMZW5ndGggPSBudi51dGlscy5jYWxjQXBwcm94VGV4dFdpZHRoKGxlZ2VuZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzV2lkdGhzLnB1c2gobm9kZVRleHRMZW5ndGggKyAyOCk7IC8vIDI4IGlzIH4gdGhlIHdpZHRoIG9mIHRoZSBjaXJjbGUgcGx1cyBzb21lIHBhZGRpbmdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNQZXJSb3cgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbldpZHRocyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBsZWdlbmRXaWR0aCA8IGF2YWlsYWJsZVdpZHRoICYmIHNlcmllc1BlclJvdyA8IHNlcmllc1dpZHRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGhzW3Nlcmllc1BlclJvd10gPSBzZXJpZXNXaWR0aHNbc2VyaWVzUGVyUm93XTtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kV2lkdGggKz0gc2VyaWVzV2lkdGhzW3Nlcmllc1BlclJvdysrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc1BlclJvdyA9PT0gMCkgc2VyaWVzUGVyUm93ID0gMTsgLy9taW5pbXVtIG9mIG9uZSBzZXJpZXMgcGVyIHJvd1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBsZWdlbmRXaWR0aCA+IGF2YWlsYWJsZVdpZHRoICYmIHNlcmllc1BlclJvdyA+IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNQZXJSb3ctLTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlcmllc1dpZHRocy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc1dpZHRoc1trXSA+IChjb2x1bW5XaWR0aHNbayAlIHNlcmllc1BlclJvd10gfHwgMCkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoc1trICUgc2VyaWVzUGVyUm93XSA9IHNlcmllc1dpZHRoc1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gY29sdW1uV2lkdGhzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBjdXI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB4UG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGN1clggPSAwOyBpIDwgc2VyaWVzUGVyUm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeFBvc2l0aW9uc1tpXSA9IGN1clg7XG4gICAgICAgICAgICAgICAgICAgIGN1clggKz0gY29sdW1uV2lkdGhzW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhQb3NpdGlvbnNbaSAlIHNlcmllc1BlclJvd10gKyAnLCcgKyAoNSArIE1hdGguZmxvb3IoaSAvIHNlcmllc1BlclJvdykgKiAyMCkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9wb3NpdGlvbiBsZWdlbmQgYXMgZmFyIHJpZ2h0IGFzIHBvc3NpYmxlIHdpdGhpbiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICh3aWR0aCAtIG1hcmdpbi5yaWdodCAtIGxlZ2VuZFdpZHRoKSArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAnICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20gKyAoTWF0aC5jZWlsKHNlcmllc1dpZHRocy5sZW5ndGggLyBzZXJpZXNQZXJSb3cpICogMjApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIHlwb3MgPSA1LFxuICAgICAgICAgICAgICAgICAgICBuZXd4cG9zID0gNSxcbiAgICAgICAgICAgICAgICAgICAgbWF4d2lkdGggPSAwLFxuICAgICAgICAgICAgICAgICAgICB4cG9zO1xuICAgICAgICAgICAgICAgIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKS5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgKyAyODtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhwb3MgPSBuZXd4cG9zO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPCBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCArIHhwb3MgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXd4cG9zID0geHBvcyA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXBvcyArPSAyMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3eHBvcyArPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3eHBvcyA+IG1heHdpZHRoKSBtYXh3aWR0aCA9IG5ld3hwb3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4cG9zICsgJywnICsgeXBvcyArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL3Bvc2l0aW9uIGxlZ2VuZCBhcyBmYXIgcmlnaHQgYXMgcG9zc2libGUgd2l0aGluIHRoZSB0b3RhbCB3aWR0aFxuICAgICAgICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHdpZHRoIC0gbWFyZ2luLnJpZ2h0IC0gbWF4d2lkdGgpICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSArIHlwb3MgKyAxNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBrZXk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldEtleTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldEtleT1fO319LFxuICAgICAgICBhbGlnbjogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBhbGlnbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2FsaWduPV87fX0sXG4gICAgICAgIHJpZ2h0QWxpZ246ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ247fSwgc2V0OiBmdW5jdGlvbihfKXtyaWdodEFsaWduPV87fX0sXG4gICAgICAgIHVwZGF0ZVN0YXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB1cGRhdGVTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3VwZGF0ZVN0YXRlPV87fX0sXG4gICAgICAgIHJhZGlvQnV0dG9uTW9kZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmFkaW9CdXR0b25Nb2RlO30sIHNldDogZnVuY3Rpb24oXyl7cmFkaW9CdXR0b25Nb2RlPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLmxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciAgc2NhdHRlciA9IG52Lm1vZGVscy5zY2F0dGVyKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA5NjBcbiAgICAgICAgLCBoZWlnaHQgPSA1MDBcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpIC8vIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29sb3JcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSB4IHZhbHVlIGZyb20gYSBkYXRhIHBvaW50XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeSB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICAgICAsIGRlZmluZWQgPSBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFpc05hTihnZXRZKGQsaSkpICYmIGdldFkoZCxpKSAhPT0gbnVsbCB9IC8vIGFsbG93cyBhIGxpbmUgdG8gYmUgbm90IGNvbnRpbnVvdXMgd2hlbiBpdCBpcyBub3QgZGVmaW5lZFxuICAgICAgICAsIGlzQXJlYSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuYXJlYSB9IC8vIGRlY2lkZXMgaWYgYSBsaW5lIGlzIGFuIGFyZWEgb3IganVzdCBhIGxpbmVcbiAgICAgICAgLCBjbGlwRWRnZSA9IGZhbHNlIC8vIGlmIHRydWUsIG1hc2tzIGxpbmVzIHdpdGhpbiB4IGFuZCB5IHNjYWxlXG4gICAgICAgICwgeCAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueFNjYWxlKClcbiAgICAgICAgLCB5IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC55U2NhbGUoKVxuICAgICAgICAsIGludGVycG9sYXRlID0gXCJsaW5lYXJcIiAvLyBjb250cm9scyB0aGUgbGluZSBpbnRlcnBvbGF0aW9uXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdlbGVtZW50Q2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgc2NhdHRlclxuICAgICAgICAucG9pbnRTaXplKDE2KSAvLyBkZWZhdWx0IHNpemVcbiAgICAgICAgLnBvaW50RG9tYWluKFsxNiwyNTZdKSAvL3NldCB0byBzcGVlZCB1cCBjYWxjdWxhdGlvbiwgbmVlZHMgdG8gYmUgdW5zZXQgaWYgdGhlcmUgaXMgYSBjdXN0b20gc2l6ZSBhY2Nlc3NvclxuICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHgwLCB5MCAvL3VzZWQgdG8gc3RvcmUgcHJldmlvdXMgc2NhbGVzXG4gICAgICAgICwgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoc2NhdHRlcik7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBzY2F0dGVyLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IHNjYXR0ZXIueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIHgwID0geDAgfHwgeDtcbiAgICAgICAgICAgIHkwID0geTAgfHwgeTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmUnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1saW5lJyk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWdyb3VwcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXNjYXR0ZXJXcmFwJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgc2NhdHRlclxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBzY2F0dGVyV3JhcCA9IHdyYXAuc2VsZWN0KCcubnYtc2NhdHRlcldyYXAnKTtcbiAgICAgICAgICAgIHNjYXR0ZXJXcmFwLmNhbGwoc2NhdHRlcik7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICAgICAgICB3cmFwLnNlbGVjdCgnI252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpICsgJyByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGF2YWlsYWJsZUhlaWdodCA+IDApID8gYXZhaWxhYmxlSGVpZ2h0IDogMCk7XG5cbiAgICAgICAgICAgIGcgICAuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1lZGdlLWNsaXAtJyArIHNjYXR0ZXIuaWQoKSArICcpJyA6ICcnKTtcbiAgICAgICAgICAgIHNjYXR0ZXJXcmFwXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgIHZhciBncm91cHMgPSB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5IH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpO1xuXG4gICAgICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBncm91cHNcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1ncm91cCBudi1zZXJpZXMtJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhvdmVyIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpeyByZXR1cm4gY29sb3IoZCwgaSl9KTtcbiAgICAgICAgICAgIGdyb3Vwcy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdsaW5lOiBncm91cHMnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgLjUpO1xuXG4gICAgICAgICAgICB2YXIgYXJlYVBhdGhzID0gZ3JvdXBzLnNlbGVjdEFsbCgncGF0aC5udi1hcmVhJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBpc0FyZWEoZCkgPyBbZF0gOiBbXSB9KTsgLy8gdGhpcyBpcyBkb25lIGRpZmZlcmVudGx5IHRoYW4gbGluZXMgYmVjYXVzZSBJIG5lZWQgdG8gY2hlY2sgaWYgc2VyaWVzIGlzIGFuIGFyZWFcbiAgICAgICAgICAgIGFyZWFQYXRocy5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWFyZWEnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHgwKGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeTAoZ2V0WShkLGkpKSkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHkwKCB5LmRvbWFpbigpWzBdIDw9IDAgPyB5LmRvbWFpbigpWzFdID49IDAgPyAwIDogeS5kb21haW4oKVsxXSA6IHkuZG9tYWluKClbMF0gKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ueTEoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5MCgwKSB9KSAvL2Fzc3VtaW5nIDAgaXMgd2l0aGluIHkgZG9tYWluLi4gbWF5IG5lZWQgdG8gdHdlYWsgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5KHRoaXMsIFtkLnZhbHVlc10pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cHMuZXhpdCgpLnNlbGVjdEFsbCgncGF0aC5udi1hcmVhJylcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIGFyZWFQYXRocy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdsaW5lOiBhcmVhUGF0aHMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHgoZ2V0WChkLGkpKSkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5KGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5KCB5LmRvbWFpbigpWzBdIDw9IDAgPyB5LmRvbWFpbigpWzFdID49IDAgPyAwIDogeS5kb21haW4oKVsxXSA6IHkuZG9tYWluKClbMF0gKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ueTEoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5MCgwKSB9KSAvL2Fzc3VtaW5nIDAgaXMgd2l0aGluIHkgZG9tYWluLi4gbWF5IG5lZWQgdG8gdHdlYWsgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5KHRoaXMsIFtkLnZhbHVlc10pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lUGF0aHMgPSBncm91cHMuc2VsZWN0QWxsKCdwYXRoLm52LWxpbmUnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFtkLnZhbHVlc10gfSk7XG4gICAgICAgICAgICBsaW5lUGF0aHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1saW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsXG4gICAgICAgICAgICAgICAgICAgIGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZChkZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4MChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAueShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5MChnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGluZVBhdGhzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2xpbmU6IGxpbmVQYXRocycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLFxuICAgICAgICAgICAgICAgICAgICBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAueShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5KGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICAgICAgICB5MCA9IHkuY29weSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdsaW5lIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuc2NhdHRlciA9IHNjYXR0ZXI7XG4gICAgLy8gUGFzcyB0aHJvdWdoIGV2ZW50c1xuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljaycsIGZ1bmN0aW9uKCl7IGRpc3BhdGNoLmVsZW1lbnRDbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9KVxuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXInLCBmdW5jdGlvbigpeyBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0pXG4gICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0JywgZnVuY3Rpb24oKXsgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0pXG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBkZWZpbmVkOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZpbmVkO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmaW5lZD1fO319LFxuICAgICAgICBpbnRlcnBvbGF0ZTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcnBvbGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVycG9sYXRlPV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwRWRnZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBFZGdlPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHNjYXR0ZXIuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgaXNBcmVhOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpc0FyZWE7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGlzQXJlYSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRYID0gXztcbiAgICAgICAgICAgIHNjYXR0ZXIueChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGdldFkgPSBfO1xuICAgICAgICAgICAgc2NhdHRlci55KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIHNjYXR0ZXIuY29sb3IoY29sb3IpO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHNjYXR0ZXIpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMubGluZUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBsaW5lcyA9IG52Lm1vZGVscy5saW5lKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBpbnRlcmFjdGl2ZUxheWVyID0gbnYuaW50ZXJhY3RpdmVHdWlkZWxpbmUoKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAgICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAgICAgLCB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZhbHNlXG4gICAgICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJyBhdCAnICsgeCArICc8L3A+J1xuICAgICAgICB9XG4gICAgICAgICwgeFxuICAgICAgICAsIHlcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLidcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIHhBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrUGFkZGluZyg3KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobGluZXMueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShsaW5lcy55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIG51bGwsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMobGluZXMpO1xuICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChjaGFydClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgIC5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBzZXQgc3RhdGUuZGlzYWJsZWRkaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBsaW5lcy54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBsaW5lcy55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmVDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWxpbmVDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKFwicmVjdFwiKS5zdHlsZShcIm9wYWNpdHlcIiwwKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtaW50ZXJhY3RpdmUnKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsKGF2YWlsYWJsZUhlaWdodCA+IDApID8gYXZhaWxhYmxlSGVpZ2h0IDogMCk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgoYXZhaWxhYmxlV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXkubnYtYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGF2YWlsYWJsZVdpZHRoICsgXCIsMClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vU2V0IHVwIGludGVyYWN0aXZlIGxheWVyXG4gICAgICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXJnaW4oe2xlZnQ6bWFyZ2luLmxlZnQsIHRvcDptYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLnN2Z0NvbnRhaW5lcihjb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC54U2NhbGUoeCk7XG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVcIikuY2FsbChpbnRlcmFjdGl2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZXNcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG5cblxuICAgICAgICAgICAgdmFyIGxpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpO1xuXG4gICAgICAgICAgICBsaW5lc1dyYXAuY2FsbChsaW5lcyk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEF4ZXNcbiAgICAgICAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUG9pbnQsIHBvaW50SW5kZXgsIHBvaW50WExvY2F0aW9uLCBhbGxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5oaWdobGlnaHRQb2ludChpLCBwb2ludEluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaW5nbGVQb2ludCA9PT0gJ3VuZGVmaW5lZCcpIHNpbmdsZVBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50WExvY2F0aW9uID09PSAndW5kZWZpbmVkJykgcG9pbnRYTG9jYXRpb24gPSBjaGFydC54U2NhbGUoKShjaGFydC54KCkocG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yKHNlcmllcyxzZXJpZXMuc2VyaWVzSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy9IaWdobGlnaHQgdGhlIHRvb2x0aXAgZW50cnkgYmFzZWQgb24gd2hpY2ggcG9pbnQgdGhlIG1vdXNlIGlzIGNsb3Nlc3QgdG8uXG4gICAgICAgICAgICAgICAgaWYgKGFsbERhdGEubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVZhbHVlID0gY2hhcnQueVNjYWxlKCkuaW52ZXJ0KGUubW91c2VZKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkV4dGVudCA9IE1hdGguYWJzKGNoYXJ0LnlTY2FsZSgpLmRvbWFpbigpWzBdIC0gY2hhcnQueVNjYWxlKCkuZG9tYWluKClbMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gMC4wMyAqIGRvbWFpbkV4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4VG9IaWdobGlnaHQgPSBudi5uZWFyZXN0VmFsdWVJbmRleChhbGxEYXRhLm1hcChmdW5jdGlvbihkKXtyZXR1cm4gZC52YWx1ZX0pLHlWYWx1ZSx0aHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb0hpZ2hsaWdodCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGFbaW5kZXhUb0hpZ2hsaWdodF0uaGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0geEF4aXMudGlja0Zvcm1hdCgpKGNoYXJ0LngoKShzaW5nbGVQb2ludCxwb2ludEluZGV4KSk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIC5wb3NpdGlvbih7bGVmdDogcG9pbnRYTG9jYXRpb24gKyBtYXJnaW4ubGVmdCwgdG9wOiBlLm1vdXNlWSArIG1hcmdpbi50b3B9KVxuICAgICAgICAgICAgICAgICAgICAuY2hhcnRDb250YWluZXIodGhhdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAuZW5hYmxlZCh0b29sdGlwcylcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkoKTtcblxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIucmVuZGVyR3VpZGVMaW5lKHBvaW50WExvY2F0aW9uKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcblxuICAgICAgICAgICAgICAgIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRYTG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSBwb2ludFhMb2NhdGlvbiA9IGNoYXJ0LnhTY2FsZSgpKGNoYXJ0LngoKShwb2ludCxwb2ludEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5UG9zID0gY2hhcnQueVNjYWxlKCkoY2hhcnQueSgpKHBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IHBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFtwb2ludFhMb2NhdGlvbiwgeVBvc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsaW5lcy5kaXNwYXRjaC5lbGVtZW50Q2xpY2soYWxsRGF0YSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbihcImVsZW1lbnRNb3VzZW91dFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZSgpO1xuICAgICAgICAgICAgICAgIGxpbmVzLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhLmxlbmd0aCA9PT0gZS5kaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2xpbmVDaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5saW5lcyA9IGxpbmVzO1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzID0geUF4aXM7XG4gICAgY2hhcnQuaW50ZXJhY3RpdmVMYXllciA9IGludGVyYWN0aXZlTGF5ZXI7XG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHNob3dYQXhpczogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WEF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WEF4aXM9Xzt9fSxcbiAgICAgICAgc2hvd1lBeGlzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBzO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcHM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcENvbnRlbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXA7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwPV87fX0sXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGxpbmVzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgbGluZXMuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIHJpZ2h0QWxpZ25ZQXhpcyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fSxcbiAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IF87XG4gICAgICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5pbnRlcmFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGluZXMudXNlVm9yb25vaShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgbGluZXMpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMubGluZVBsdXNCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbGluZXMgPSBudi5tb2RlbHMubGluZSgpXG4gICAgICAgICwgbGluZXMyID0gbnYubW9kZWxzLmxpbmUoKVxuICAgICAgICAsIGJhcnMgPSBudi5tb2RlbHMuaGlzdG9yaWNhbEJhcigpXG4gICAgICAgICwgYmFyczIgPSBudi5tb2RlbHMuaGlzdG9yaWNhbEJhcigpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeDJBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHkxQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5MkF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeTNBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHk0QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBicnVzaCA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDMwLCBib3R0b206IDMwLCBsZWZ0OiA2MH1cbiAgICAgICAgLCBtYXJnaW4yID0ge3RvcDogMCwgcmlnaHQ6IDMwLCBib3R0b206IDIwLCBsZWZ0OiA2MH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgZm9jdXNFbmFibGUgPSB0cnVlXG4gICAgICAgICwgZm9jdXNTaG93QXhpc1kgPSBmYWxzZVxuICAgICAgICAsIGZvY3VzU2hvd0F4aXNYID0gdHJ1ZVxuICAgICAgICAsIGZvY3VzSGVpZ2h0ID0gNTBcbiAgICAgICAgLCBleHRlbnRcbiAgICAgICAgLCBicnVzaEV4dGVudCA9IG51bGxcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIGF0ICcgKyB4ICsgJzwvcD4nO1xuICAgICAgICB9XG4gICAgICAgICwgeFxuICAgICAgICAsIHgyXG4gICAgICAgICwgeTFcbiAgICAgICAgLCB5MlxuICAgICAgICAsIHkzXG4gICAgICAgICwgeTRcbiAgICAgICAgLCBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnYnJ1c2gnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgICAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDBcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbGVnZW5kTGVmdEF4aXNIaW50ID0gJyAobGVmdCBheGlzKSdcbiAgICAgICAgLCBsZWdlbmRSaWdodEF4aXNIaW50ID0gJyAocmlnaHQgYXhpcyknXG4gICAgICAgIDtcblxuICAgIGxpbmVzXG4gICAgICAgIC5jbGlwRWRnZSh0cnVlKVxuICAgIDtcbiAgICBsaW5lczJcbiAgICAgICAgLmludGVyYWN0aXZlKGZhbHNlKVxuICAgIDtcbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1BhZGRpbmcoNSlcbiAgICA7XG4gICAgeTFBeGlzXG4gICAgICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgIDtcbiAgICB5MkF4aXNcbiAgICAgICAgLm9yaWVudCgncmlnaHQnKVxuICAgIDtcbiAgICB4MkF4aXNcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnRpY2tQYWRkaW5nKDUpXG4gICAgO1xuICAgIHkzQXhpc1xuICAgICAgICAub3JpZW50KCdsZWZ0JylcbiAgICA7XG4gICAgeTRBeGlzXG4gICAgICAgIC5vcmllbnQoJ3JpZ2h0JylcbiAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgZS5wb2ludEluZGV4ICs9IE1hdGguY2VpbChleHRlbnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGxpbmVzLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHkgPSAoZS5zZXJpZXMuYmFyID8geTFBeGlzIDogeTJBeGlzKS50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICduJyA6ICdzJywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZUdldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0MSA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tIC0gKGZvY3VzRW5hYmxlID8gZm9jdXNIZWlnaHQgOiAwKSAsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0MiA9IGZvY3VzSGVpZ2h0IC0gbWFyZ2luMi50b3AgLSBtYXJnaW4yLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodDEgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgdmFyIGRhdGFCYXJzID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgJiYgZC5iYXIgfSk7XG4gICAgICAgICAgICB2YXIgZGF0YUxpbmVzID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuYmFyIH0pOyAvLyByZW1vdmVkIHRoZSAhZC5kaXNhYmxlZCBjbGF1c2UgaGVyZSB0byBmaXggSXNzdWUgIzI0MFxuXG4gICAgICAgICAgICB4ID0gYmFycy54U2NhbGUoKTtcbiAgICAgICAgICAgIHgyID0geDJBeGlzLnNjYWxlKCk7XG4gICAgICAgICAgICB5MSA9IGJhcnMueVNjYWxlKCk7XG4gICAgICAgICAgICB5MiA9IGxpbmVzLnlTY2FsZSgpO1xuICAgICAgICAgICAgeTMgPSBiYXJzMi55U2NhbGUoKTtcbiAgICAgICAgICAgIHk0ID0gbGluZXMyLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzMSA9IGRhdGFcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkICYmIGQuYmFyIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZXRYKGQsaSksIHk6IGdldFkoZCxpKSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXMyID0gZGF0YVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgJiYgIWQuYmFyIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZXRYKGQsaSksIHk6IGdldFkoZCxpKSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHgucmFuZ2UoWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHgyICAuZG9tYWluKGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXMxLmNvbmNhdChzZXJpZXMyKSksIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9ICkpXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbGluZVBsdXNCYXInKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1saW5lUGx1c0JhcicpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBtYWluIGNoYXJ0XG4gICAgICAgICAgICB2YXIgZm9jdXNFbnRlciA9IGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1mb2N1cycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteTEgbnYtYXhpcycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MiBudi1heGlzJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxpbmVzV3JhcCcpO1xuXG4gICAgICAgICAgICAvLyBjb250ZXh0IGNoYXJ0IGlzIHdoZXJlIHlvdSBjYW4gZm9jdXMgaW5cbiAgICAgICAgICAgIHZhciBjb250ZXh0RW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udGV4dCcpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkxIG52LWF4aXMnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MiBudi1heGlzJyk7XG4gICAgICAgICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFyc1dyYXAnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1icnVzaEJhY2tncm91bmQnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWJydXNoJyk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKCBhdmFpbGFibGVXaWR0aCAvIDIgKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLm1hcChmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5vcmlnaW5hbEtleSA9IHNlcmllcy5vcmlnaW5hbEtleSA9PT0gdW5kZWZpbmVkID8gc2VyaWVzLmtleSA6IHNlcmllcy5vcmlnaW5hbEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5rZXkgPSBzZXJpZXMub3JpZ2luYWxLZXkgKyAoc2VyaWVzLmJhciA/IGxlZ2VuZExlZnRBeGlzSGludCA6IGxlZ2VuZFJpZ2h0QXhpc0hpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDEgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20gLSBmb2N1c0hlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKCBhdmFpbGFibGVXaWR0aCAvIDIgKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIENvbnRleHQgY2hhcnQgKGZvY3VzIGNoYXJ0KSBjb21wb25lbnRzXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvLyBoaWRlIG9yIHNob3cgdGhlIGZvY3VzIGNvbnRleHQgY2hhcnRcbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCcpLnN0eWxlKCdkaXNwbGF5JywgZm9jdXNFbmFibGUgPyAnaW5pdGlhbCcgOiAnbm9uZScpO1xuXG4gICAgICAgICAgICBiYXJzMlxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDIpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS5iYXJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsaW5lczJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQyKVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmICFkYXRhW2ldLmJhclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdmFyIGJhcnMyV3JhcCA9IGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYtYmFyc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhQmFycy5sZW5ndGggPyBkYXRhQmFycyA6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlczogW119XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB2YXIgbGluZXMyV3JhcCA9IGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oIWRhdGFMaW5lc1swXS5kaXNhYmxlZCA/IGRhdGFMaW5lcyA6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlczogW119XG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKCBhdmFpbGFibGVIZWlnaHQxICsgbWFyZ2luLmJvdHRvbSArIG1hcmdpbjIudG9wKSArICcpJyk7XG5cbiAgICAgICAgICAgIGJhcnMyV3JhcC50cmFuc2l0aW9uKCkuY2FsbChiYXJzMik7XG4gICAgICAgICAgICBsaW5lczJXcmFwLnRyYW5zaXRpb24oKS5jYWxsKGxpbmVzMik7XG5cbiAgICAgICAgICAgIC8vIGNvbnRleHQgKGZvY3VzIGNoYXJ0KSBheGlzIGNvbnRyb2xzXG4gICAgICAgICAgICBpZiAoZm9jdXNTaG93QXhpc1gpIHtcbiAgICAgICAgICAgICAgICB4MkF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGggLyAxMDAsIGRhdGEpKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodDIsIDApO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeTMucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi14Lm52LWF4aXMnKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeDJBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvY3VzU2hvd0F4aXNZKSB7XG4gICAgICAgICAgICAgICAgeTNBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5MylcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQyIC8gMzYgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgeTRBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5NClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQyIC8gMzYgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoZGF0YUJhcnMubGVuZ3RoID8gMCA6IC1hdmFpbGFibGVXaWR0aCwgMCk7IC8vIFNob3cgdGhlIHkyIHJ1bGVzIG9ubHkgaWYgeTEgaGFzIG5vbmVcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteTMubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFCYXJzLmxlbmd0aCA/IDEgOiAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB4Mi5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXkyLm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBkYXRhTGluZXMubGVuZ3RoID8gMSA6IDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4Mi5yYW5nZSgpWzFdICsgJywwKScpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi15MS5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHkzQXhpcyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi15Mi5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHk0QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEJydXNoXG4gICAgICAgICAgICBicnVzaC54KHgyKS5vbignYnJ1c2gnLCBvbkJydXNoKTtcblxuICAgICAgICAgICAgaWYgKGJydXNoRXh0ZW50KSBicnVzaC5leHRlbnQoYnJ1c2hFeHRlbnQpO1xuXG4gICAgICAgICAgICB2YXIgYnJ1c2hCRyA9IGcuc2VsZWN0KCcubnYtYnJ1c2hCYWNrZ3JvdW5kJykuc2VsZWN0QWxsKCdnJylcbiAgICAgICAgICAgICAgICAuZGF0YShbYnJ1c2hFeHRlbnQgfHwgYnJ1c2guZXh0ZW50KCldKTtcblxuICAgICAgICAgICAgdmFyIGJydXNoQkdlbnRlciA9IGJydXNoQkcuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKTtcblxuICAgICAgICAgICAgYnJ1c2hCR2VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZnQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuXG4gICAgICAgICAgICBicnVzaEJHZW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncmlnaHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuXG4gICAgICAgICAgICB2YXIgZ0JydXNoID0gZy5zZWxlY3QoJy5udi14Lm52LWJydXNoJylcbiAgICAgICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgICAgICBnQnJ1c2guc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgICAgICAgICAvLy5hdHRyKCd5JywgLTUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuICAgICAgICAgICAgZ0JydXNoLnNlbGVjdEFsbCgnLnJlc2l6ZScpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCByZXNpemVQYXRoKTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRnVuY3Rpb25zXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvLyBUYWtlbiBmcm9tIGNyb3NzZmlsdGVyIChodHRwOi8vc3F1YXJlLmdpdGh1Yi5jb20vY3Jvc3NmaWx0ZXIvKVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzaXplUGF0aChkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSArKGQgPT0gJ2UnKSxcbiAgICAgICAgICAgICAgICAgICAgeCA9IGUgPyAxIDogLTEsXG4gICAgICAgICAgICAgICAgICAgIHkgPSBhdmFpbGFibGVIZWlnaHQyIC8gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gJ00nICsgKC41ICogeCkgKyAnLCcgKyB5XG4gICAgICAgICAgICAgICAgICAgICsgJ0E2LDYgMCAwICcgKyBlICsgJyAnICsgKDYuNSAqIHgpICsgJywnICsgKHkgKyA2KVxuICAgICAgICAgICAgICAgICAgICArICdWJyArICgyICogeSAtIDYpXG4gICAgICAgICAgICAgICAgICAgICsgJ0E2LDYgMCAwICcgKyBlICsgJyAnICsgKC41ICogeCkgKyAnLCcgKyAoMiAqIHkpXG4gICAgICAgICAgICAgICAgICAgICsgJ1onXG4gICAgICAgICAgICAgICAgICAgICsgJ00nICsgKDIuNSAqIHgpICsgJywnICsgKHkgKyA4KVxuICAgICAgICAgICAgICAgICAgICArICdWJyArICgyICogeSAtIDgpXG4gICAgICAgICAgICAgICAgICAgICsgJ00nICsgKDQuNSAqIHgpICsgJywnICsgKHkgKyA4KVxuICAgICAgICAgICAgICAgICAgICArICdWJyArICgyICogeSAtIDgpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUJydXNoQkcoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFicnVzaC5lbXB0eSgpKSBicnVzaC5leHRlbnQoYnJ1c2hFeHRlbnQpO1xuICAgICAgICAgICAgICAgIGJydXNoQkdcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2JydXNoLmVtcHR5KCkgPyB4Mi5kb21haW4oKSA6IGJydXNoRXh0ZW50XSlcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdFdpZHRoID0geDIoZFswXSkgLSB4Mi5yYW5nZSgpWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0V2lkdGggPSB4Mi5yYW5nZSgpWzFdIC0geDIoZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCcubGVmdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgIGxlZnRXaWR0aCA8IDAgPyAwIDogbGVmdFdpZHRoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgnLnJpZ2h0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgyKGRbMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHJpZ2h0V2lkdGggPCAwID8gMCA6IHJpZ2h0V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25CcnVzaCgpIHtcbiAgICAgICAgICAgICAgICBicnVzaEV4dGVudCA9IGJydXNoLmVtcHR5KCkgPyBudWxsIDogYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gYnJ1c2guZW1wdHkoKSA/IHgyLmRvbWFpbigpIDogYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guYnJ1c2goe2V4dGVudDogZXh0ZW50LCBicnVzaDogYnJ1c2h9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVCcnVzaEJHKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIE1haW4gKEZvY3VzKSBCYXJzIGFuZCBMaW5lc1xuICAgICAgICAgICAgICAgIGJhcnNcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDEpXG4gICAgICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLmJhciB9KSk7XG5cbiAgICAgICAgICAgICAgICBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0MSlcbiAgICAgICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmICFkYXRhW2ldLmJhciB9KSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9jdXNCYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKCFkYXRhQmFycy5sZW5ndGggPyBbe3ZhbHVlczpbXX1dIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCYXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGQudmFsdWVzLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFycy54KCkoZCxpKSA+PSBleHRlbnRbMF0gJiYgYmFycy54KCkoZCxpKSA8PSBleHRlbnRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzTGluZXNXcmFwID0gZy5zZWxlY3QoJy5udi1mb2N1cyAubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGFMaW5lc1swXS5kaXNhYmxlZCA/IFt7dmFsdWVzOltdfV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGQudmFsdWVzLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXMueCgpKGQsaSkgPj0gZXh0ZW50WzBdICYmIGxpbmVzLngoKShkLGkpIDw9IGV4dGVudFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgTWFpbiAoRm9jdXMpIFggQXhpc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhQmFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGJhcnMueFNjYWxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGxpbmVzLnhTY2FsZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0MSwgMCk7XG5cbiAgICAgICAgICAgICAgICB4QXhpcy5kb21haW4oW01hdGguY2VpbChleHRlbnRbMF0pLCBNYXRoLmZsb29yKGV4dGVudFsxXSldKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBCYXJzIGFuZCBMaW5lc1xuICAgICAgICAgICAgICAgIGZvY3VzQmFyc1dyYXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChiYXJzKTtcbiAgICAgICAgICAgICAgICBmb2N1c0xpbmVzV3JhcC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGxpbmVzKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldHVwIGFuZCBVcGRhdGUgTWFpbiAoRm9jdXMpIFkgQXhlc1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkxLnJhbmdlKClbMF0gKyAnKScpO1xuXG4gICAgICAgICAgICAgICAgeTFBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5MSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodDEvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVXaWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgeTJBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5MilcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodDEvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKGRhdGFCYXJzLmxlbmd0aCA/IDAgOiAtYXZhaWxhYmxlV2lkdGgsIDApOyAvLyBTaG93IHRoZSB5MiBydWxlcyBvbmx5IGlmIHkxIGhhcyBub25lXG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15MS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZGF0YUJhcnMubGVuZ3RoID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXkyLm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBkYXRhTGluZXMubGVuZ3RoICYmICFkYXRhTGluZXNbMF0uZGlzYWJsZWQgPyAxIDogMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHgucmFuZ2UoKVsxXSArICcsMCknKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXkxLm52LWF4aXMnKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5MUF4aXMpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXkyLm52LWF4aXMnKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5MkF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbkJydXNoKCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgYmFycy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC5saW5lcyA9IGxpbmVzO1xuICAgIGNoYXJ0LmxpbmVzMiA9IGxpbmVzMjtcbiAgICBjaGFydC5iYXJzID0gYmFycztcbiAgICBjaGFydC5iYXJzMiA9IGJhcnMyO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueDJBeGlzID0geDJBeGlzO1xuICAgIGNoYXJ0LnkxQXhpcyA9IHkxQXhpcztcbiAgICBjaGFydC55MkF4aXMgPSB5MkF4aXM7XG4gICAgY2hhcnQueTNBeGlzID0geTNBeGlzO1xuICAgIGNoYXJ0Lnk0QXhpcyA9IHk0QXhpcztcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBicnVzaEV4dGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYnJ1c2hFeHRlbnQ7fSwgc2V0OiBmdW5jdGlvbihfKXticnVzaEV4dGVudD1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICBmb2N1c0VuYWJsZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNFbmFibGU7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c0VuYWJsZT1fO319LFxuICAgICAgICBmb2N1c0hlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNIZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c0hlaWdodD1fO319LFxuICAgICAgICBmb2N1c1Nob3dBeGlzWDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNTaG93QXhpc1g7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c1Nob3dBeGlzWD1fO319LFxuICAgICAgICBmb2N1c1Nob3dBeGlzWTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNTaG93QXhpc1k7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c1Nob3dBeGlzWT1fO319LFxuICAgICAgICBsZWdlbmRMZWZ0QXhpc0hpbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxlZ2VuZExlZnRBeGlzSGludDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xlZ2VuZExlZnRBeGlzSGludD1fO319LFxuICAgICAgICBsZWdlbmRSaWdodEF4aXNIaW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsZWdlbmRSaWdodEF4aXNIaW50O30sIHNldDogZnVuY3Rpb24oXyl7bGVnZW5kUmlnaHRBeGlzSGludD1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gXztcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgeDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZ2V0WCA9IF87XG4gICAgICAgICAgICBsaW5lcy54KF8pO1xuICAgICAgICAgICAgbGluZXMyLngoXyk7XG4gICAgICAgICAgICBiYXJzLngoXyk7XG4gICAgICAgICAgICBiYXJzMi54KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZ2V0WSA9IF87XG4gICAgICAgICAgICBsaW5lcy55KF8pO1xuICAgICAgICAgICAgbGluZXMyLnkoXyk7XG4gICAgICAgICAgICBiYXJzLnkoXyk7XG4gICAgICAgICAgICBiYXJzMi55KF8pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGxpbmVzKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLmxpbmVXaXRoRm9jdXNDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbGluZXMgPSBudi5tb2RlbHMubGluZSgpXG4gICAgICAgICwgbGluZXMyID0gbnYubW9kZWxzLmxpbmUoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHgyQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5MkF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiAzMCwgbGVmdDogNjB9XG4gICAgICAgICwgbWFyZ2luMiA9IHt0b3A6IDAsIHJpZ2h0OiAzMCwgYm90dG9tOiAyMCwgbGVmdDogNjB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQyID0gMTAwXG4gICAgICAgICwgeFxuICAgICAgICAsIHlcbiAgICAgICAgLCB4MlxuICAgICAgICAsIHkyXG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBicnVzaEV4dGVudCA9IG51bGxcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIGF0ICcgKyB4ICsgJzwvcD4nXG4gICAgICAgIH1cbiAgICAgICAgLCBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnYnJ1c2gnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgICAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgO1xuXG4gICAgbGluZXNcbiAgICAgICAgLmNsaXBFZGdlKHRydWUpXG4gICAgO1xuICAgIGxpbmVzMlxuICAgICAgICAuaW50ZXJhY3RpdmUoZmFsc2UpXG4gICAgO1xuICAgIHhBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrUGFkZGluZyg1KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KCdsZWZ0JylcbiAgICA7XG4gICAgeDJBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrUGFkZGluZyg1KVxuICAgIDtcbiAgICB5MkF4aXNcbiAgICAgICAgLm9yaWVudCgnbGVmdCcpXG4gICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGxpbmVzLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBudWxsLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQxID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20gLSBoZWlnaHQyLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDIgPSBoZWlnaHQyIC0gbWFyZ2luMi50b3AgLSBtYXJnaW4yLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgc2V0IHN0YXRlLmRpc2FibGVkZGlzYWJsZWRcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0MSAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gbGluZXMueVNjYWxlKCk7XG4gICAgICAgICAgICB4MiA9IGxpbmVzMi54U2NhbGUoKTtcbiAgICAgICAgICAgIHkyID0gbGluZXMyLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbGluZVdpdGhGb2N1c0NoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbGluZVdpdGhGb2N1c0NoYXJ0JykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG5cbiAgICAgICAgICAgIHZhciBmb2N1c0VudGVyID0gZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWZvY3VzJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGluZXNXcmFwJyk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0RW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udGV4dCcpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxpbmVzV3JhcCcpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJydXNoQmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYnJ1c2gnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0MSA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSAtIGhlaWdodDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICBsaW5lc1xuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDEpXG4gICAgICAgICAgICAgICAgLmNvbG9yKFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGluZXMyXG4gICAgICAgICAgICAgICAgLmRlZmluZWQobGluZXMuZGVmaW5lZCgpKVxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDIpXG4gICAgICAgICAgICAgICAgLmNvbG9yKFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoIGF2YWlsYWJsZUhlaWdodDEgKyBtYXJnaW4uYm90dG9tICsgbWFyZ2luMi50b3ApICsgJyknKVxuXG4gICAgICAgICAgICB2YXIgY29udGV4dExpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG5cbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24oY29udGV4dExpbmVzV3JhcCkuY2FsbChsaW5lczIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBNYWluIChGb2N1cykgQXhlc1xuICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQxLCAwKTtcblxuICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0MS8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBhdmFpbGFibGVIZWlnaHQxICsgJyknKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQnJ1c2hcbiAgICAgICAgICAgIGJydXNoXG4gICAgICAgICAgICAgICAgLngoeDIpXG4gICAgICAgICAgICAgICAgLm9uKCdicnVzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvL1doZW4gYnJ1c2hpbmcsIHR1cm4gb2ZmIHRyYW5zaXRpb25zIGJlY2F1c2UgY2hhcnQgbmVlZHMgdG8gY2hhbmdlIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkVHJhbnNpdGlvbiA9IGNoYXJ0LmR1cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmR1cmF0aW9uKDApO1xuICAgICAgICAgICAgICAgICAgICBvbkJydXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmR1cmF0aW9uKG9sZFRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoYnJ1c2hFeHRlbnQpIGJydXNoLmV4dGVudChicnVzaEV4dGVudCk7XG5cbiAgICAgICAgICAgIHZhciBicnVzaEJHID0gZy5zZWxlY3QoJy5udi1icnVzaEJhY2tncm91bmQnKS5zZWxlY3RBbGwoJ2cnKVxuICAgICAgICAgICAgICAgIC5kYXRhKFticnVzaEV4dGVudCB8fCBicnVzaC5leHRlbnQoKV0pXG5cbiAgICAgICAgICAgIHZhciBicnVzaEJHZW50ZXIgPSBicnVzaEJHLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJyk7XG5cbiAgICAgICAgICAgIGJydXNoQkdlbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWZ0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcblxuICAgICAgICAgICAgYnJ1c2hCR2VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3JpZ2h0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcblxuICAgICAgICAgICAgdmFyIGdCcnVzaCA9IGcuc2VsZWN0KCcubnYteC5udi1icnVzaCcpXG4gICAgICAgICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgICAgICAgZ0JydXNoLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLy8uYXR0cigneScsIC01KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcbiAgICAgICAgICAgIGdCcnVzaC5zZWxlY3RBbGwoJy5yZXNpemUnKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgcmVzaXplUGF0aCk7XG5cbiAgICAgICAgICAgIG9uQnJ1c2goKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2Vjb25kYXJ5IChDb250ZXh0KSBBeGVzXG4gICAgICAgICAgICB4MkF4aXNcbiAgICAgICAgICAgICAgICAuc2NhbGUoeDIpXG4gICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0MiwgMCk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5Mi5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi14Lm52LWF4aXMnKSlcbiAgICAgICAgICAgICAgICAuY2FsbCh4MkF4aXMpO1xuXG4gICAgICAgICAgICB5MkF4aXNcbiAgICAgICAgICAgICAgICAuc2NhbGUoeTIpXG4gICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodDIvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi15Lm52LWF4aXMnKSlcbiAgICAgICAgICAgICAgICAuY2FsbCh5MkF4aXMpO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeTIucmFuZ2UoKVswXSArICcpJyk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLy8gVGFrZW4gZnJvbSBjcm9zc2ZpbHRlciAoaHR0cDovL3NxdWFyZS5naXRodWIuY29tL2Nyb3NzZmlsdGVyLylcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2l6ZVBhdGgoZCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gKyhkID09ICdlJyksXG4gICAgICAgICAgICAgICAgICAgIHggPSBlID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICB5ID0gYXZhaWxhYmxlSGVpZ2h0MiAvIDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNJyArICguNSAqIHgpICsgJywnICsgeVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICg2LjUgKiB4KSArICcsJyArICh5ICsgNilcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA2KVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICguNSAqIHgpICsgJywnICsgKDIgKiB5KVxuICAgICAgICAgICAgICAgICAgICArICdaJ1xuICAgICAgICAgICAgICAgICAgICArICdNJyArICgyLjUgKiB4KSArICcsJyArICh5ICsgOClcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KVxuICAgICAgICAgICAgICAgICAgICArICdNJyArICg0LjUgKiB4KSArICcsJyArICh5ICsgOClcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVCcnVzaEJHKCkge1xuICAgICAgICAgICAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcbiAgICAgICAgICAgICAgICBicnVzaEJHXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFticnVzaC5lbXB0eSgpID8geDIuZG9tYWluKCkgOiBicnVzaEV4dGVudF0pXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRXaWR0aCA9IHgyKGRbMF0pIC0geC5yYW5nZSgpWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0V2lkdGggPSB4LnJhbmdlKClbMV0gLSB4MihkWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJy5sZWZ0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAgbGVmdFdpZHRoIDwgMCA/IDAgOiBsZWZ0V2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCcucmlnaHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeDIoZFsxXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgcmlnaHRXaWR0aCA8IDAgPyAwIDogcmlnaHRXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uQnJ1c2goKSB7XG4gICAgICAgICAgICAgICAgYnJ1c2hFeHRlbnQgPSBicnVzaC5lbXB0eSgpID8gbnVsbCA6IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnQgPSBicnVzaC5lbXB0eSgpID8geDIuZG9tYWluKCkgOiBicnVzaC5leHRlbnQoKTtcblxuICAgICAgICAgICAgICAgIC8vVGhlIGJydXNoIGV4dGVudCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZS4gIElmIGl0IGlzLCBkb24ndCB1cGRhdGUgdGhlIGxpbmUgY2hhcnQuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGV4dGVudFswXSAtIGV4dGVudFsxXSkgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guYnJ1c2goe2V4dGVudDogZXh0ZW50LCBicnVzaDogYnJ1c2h9KTtcblxuXG4gICAgICAgICAgICAgICAgdXBkYXRlQnJ1c2hCRygpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKVxuICAgICAgICAgICAgICAgIHZhciBmb2N1c0xpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBkLmFyZWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZC52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzLngoKShkLGkpID49IGV4dGVudFswXSAmJiBsaW5lcy54KCkoZCxpKSA8PSBleHRlbnRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZvY3VzTGluZXNXcmFwLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pLmNhbGwobGluZXMpO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgTWFpbiAoRm9jdXMpIEF4ZXNcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi14Lm52LWF4aXMnKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteS5udi1heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC5saW5lcyA9IGxpbmVzO1xuICAgIGNoYXJ0LmxpbmVzMiA9IGxpbmVzMjtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzID0geUF4aXM7XG4gICAgY2hhcnQueDJBeGlzID0geDJBeGlzO1xuICAgIGNoYXJ0LnkyQXhpcyA9IHkyQXhpcztcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIGZvY3VzSGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0Mjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodDI9Xzt9fSxcbiAgICAgICAgc2hvd0xlZ2VuZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcbiAgICAgICAgYnJ1c2hFeHRlbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGJydXNoRXh0ZW50O30sIHNldDogZnVuY3Rpb24oXyl7YnJ1c2hFeHRlbnQ9Xzt9fSxcbiAgICAgICAgdG9vbHRpcHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBzO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcHM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcENvbnRlbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXA7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwPV87fX0sXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIC8vIGxpbmUgY29sb3IgaXMgaGFuZGxlZCBhYm92ZT9cbiAgICAgICAgfX0sXG4gICAgICAgIGludGVycG9sYXRlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsaW5lcy5pbnRlcnBvbGF0ZSgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBsaW5lcy5pbnRlcnBvbGF0ZShfKTtcbiAgICAgICAgICAgIGxpbmVzMi5pbnRlcnBvbGF0ZShfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHhUaWNrRm9ybWF0OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4QXhpcy54VGlja0Zvcm1hdCgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB4QXhpcy54VGlja0Zvcm1hdChfKTtcbiAgICAgICAgICAgIHgyQXhpcy54VGlja0Zvcm1hdChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHlUaWNrRm9ybWF0OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5QXhpcy55VGlja0Zvcm1hdCgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB5QXhpcy55VGlja0Zvcm1hdChfKTtcbiAgICAgICAgICAgIHkyQXhpcy55VGlja0Zvcm1hdChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0cmFuc2l0aW9uRHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbj1fO1xuICAgICAgICAgICAgeUF4aXMuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsaW5lcy54KCk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGxpbmVzLngoXyk7XG4gICAgICAgICAgICBsaW5lczIueChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxpbmVzLnkoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbGluZXMueShfKTtcbiAgICAgICAgICAgIGxpbmVzMi55KF8pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGxpbmVzKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMubXVsdGlCYXIgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA5NjBcbiAgICAgICAgLCBoZWlnaHQgPSA1MDBcbiAgICAgICAgLCB4ID0gZDMuc2NhbGUub3JkaW5hbCgpXG4gICAgICAgICwgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGZvcmNlWSA9IFswXSAvLyAwIGlzIGZvcmNlZCBieSBkZWZhdWx0Li4gdGhpcyBtYWtlcyBzZW5zZSBmb3IgdGhlIG1ham9yaXR5IG9mIGJhciBncmFwaHMuLi4gdXNlciBjYW4gYWx3YXlzIGRvIGNoYXJ0LmZvcmNlWShbXSkgdG8gcmVtb3ZlXG4gICAgICAgICwgY2xpcEVkZ2UgPSB0cnVlXG4gICAgICAgICwgc3RhY2tlZCA9IGZhbHNlXG4gICAgICAgICwgc3RhY2tPZmZzZXQgPSAnemVybycgLy8gb3B0aW9ucyBpbmNsdWRlICdzaWxob3VldHRlJywgJ3dpZ2dsZScsICdleHBhbmQnLCAnemVybycsIG9yIGEgY3VzdG9tIGZ1bmN0aW9uXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIGhpZGVhYmxlID0gZmFsc2VcbiAgICAgICAgLCBiYXJDb2xvciA9IG51bGwgLy8gYWRkaW5nIHRoZSBhYmlsaXR5IHRvIHNldCB0aGUgY29sb3IgZm9yIGVhY2ggcmF0aGVyIHRoYW4gdGhlIHdob2xlIGdyb3VwXG4gICAgICAgICwgZGlzYWJsZWQgLy8gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGJhckNvbG9yIHRvIGNvbW11bmljYXRlIGZyb20gbXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQgd2hhdCBzZXJpZXMgYXJlIGRpc2FibGVkXG4gICAgICAgICwgZHVyYXRpb24gPSA1MDBcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGdyb3VwU3BhY2luZyA9IDAuMVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdyZW5kZXJFbmQnKVxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTAgLy91c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgICAgICAsIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKVxuICAgICAgICA7XG5cbiAgICB2YXIgbGFzdF9kYXRhbGVuZ3RoID0gMDtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBkZWZpbmVzIHRoZSByZXF1aXJlbWVudHMgZm9yIHJlbmRlciBjb21wbGV0ZVxuICAgICAgICAgICAgdmFyIGVuZEZuID0gZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChkLnNlcmllcyA9PT0gZGF0YS5sZW5ndGggLSAxICYmIGkgPT09IGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKGhpZGVhYmxlICYmIGRhdGEubGVuZ3RoKSBoaWRlYWJsZSA9IFt7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhWzBdLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDAuMDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH07fVxuICAgICAgICAgICAgICAgICl9XTtcblxuICAgICAgICAgICAgaWYgKHN0YWNrZWQpXG4gICAgICAgICAgICAgICAgZGF0YSA9IGQzLmxheW91dC5zdGFjaygpXG4gICAgICAgICAgICAgICAgICAgIC5vZmZzZXQoc3RhY2tPZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIC52YWx1ZXMoZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlcyB9KVxuICAgICAgICAgICAgICAgICAgICAueShnZXRZKVxuICAgICAgICAgICAgICAgICghZGF0YS5sZW5ndGggJiYgaGlkZWFibGUgPyBoaWRlYWJsZSA6IGRhdGEpO1xuXG5cbiAgICAgICAgICAgIC8vYWRkIHNlcmllcyBpbmRleCB0byBlYWNoIGRhdGEgcG9pbnQgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5zZXJpZXMgPSBpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEhBQ0sgZm9yIG5lZ2F0aXZlIHZhbHVlIHN0YWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgICAgICAgICBkYXRhWzBdLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NCYXNlID0gMCwgbmVnQmFzZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gZC52YWx1ZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGYuc2l6ZSA9IE1hdGguYWJzKGYueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi55PDApICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi55MSA9IG5lZ0Jhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVnQmFzZSA9IG5lZ0Jhc2UgLSBmLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnkxID0gZi5zaXplICsgcG9zQmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NCYXNlID0gcG9zQmFzZSArIGYuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgLy8gcmVtYXAgYW5kIGZsYXR0ZW4gdGhlIGRhdGEgZm9yIHVzZSBpbiBjYWxjdWxhdGluZyB0aGUgc2NhbGVzJyBkb21haW5zXG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9ICh4RG9tYWluICYmIHlEb21haW4pID8gW10gOiAvLyBpZiB3ZSBrbm93IHhEb21haW4gYW5kIHlEb21haW4sIG5vIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSksIHkwOiBkLnkwLCB5MTogZC55MSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHguZG9tYWluKHhEb21haW4gfHwgZDMubWVyZ2Uoc2VyaWVzRGF0YSkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9KSlcbiAgICAgICAgICAgICAgICAucmFuZ2VCYW5kcyh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSwgZ3JvdXBTcGFjaW5nKTtcblxuICAgICAgICAgICAgeS5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzRGF0YSkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHN0YWNrZWQgPyAoZC55ID4gMCA/IGQueTEgOiBkLnkxICsgZC55ICkgOiBkLnkgfSkuY29uY2F0KGZvcmNlWSkpKVxuICAgICAgICAgICAgICAgIC5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAgICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHguZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB4LmRvbWFpbihbeC5kb21haW4oKVswXSAtIHguZG9tYWluKClbMF0gKiAwLjAxLCB4LmRvbWFpbigpWzFdICsgeC5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHguZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIGlmICh5LmRvbWFpbigpWzBdID09PSB5LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHkuZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSArIHkuZG9tYWluKClbMF0gKiAwLjAxLCB5LmRvbWFpbigpWzFdIC0geS5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHkuZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIHgwID0geDAgfHwgeDtcbiAgICAgICAgICAgIHkwID0geTAgfHwgeTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LW11bHRpYmFyJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbXVsdGliYXInKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpXG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1lZGdlLWNsaXAtJyArIGlkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtZWRnZS1jbGlwLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGcuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1lZGdlLWNsaXAtJyArIGlkICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSk7XG4gICAgICAgICAgICBncm91cHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNik7XG5cbiAgICAgICAgICAgIHZhciBleGl0VHJhbnNpdGlvbiA9IHJlbmRlcldhdGNoXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oZ3JvdXBzLmV4aXQoKS5zZWxlY3RBbGwoJ3JlY3QubnYtYmFyJyksICdtdWx0aWJhckV4aXQnLCBNYXRoLm1pbigxMDAsIGR1cmF0aW9uKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIChzdGFja2VkID8geTAoZC55MCkgOiB5MCgwKSkgfHwgMCB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAwKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChleGl0VHJhbnNpdGlvbi5kZWxheSlcbiAgICAgICAgICAgICAgICBleGl0VHJhbnNpdGlvbi5kZWxheShmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gaSAqIChkdXJhdGlvbiAvIChsYXN0X2RhdGFsZW5ndGggKyAxKSkgLSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsYXk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cHNcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1ncm91cCBudi1zZXJpZXMtJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhvdmVyIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpeyByZXR1cm4gY29sb3IoZCwgaSkgfSk7XG4gICAgICAgICAgICBncm91cHNcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDAuNzUpO1xuXG4gICAgICAgICAgICB2YXIgYmFycyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ3JlY3QubnYtYmFyJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiAoaGlkZWFibGUgJiYgIWRhdGEubGVuZ3RoKSA/IGhpZGVhYmxlLnZhbHVlcyA6IGQudmFsdWVzIH0pO1xuICAgICAgICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzRW50ZXIgPSBiYXJzLmVudGVyKCkuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ252LWJhciBuZWdhdGl2ZScgOiAnbnYtYmFyIHBvc2l0aXZlJ30pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja2VkID8gMCA6IChqICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkKSB7IHJldHVybiB5MChzdGFja2VkID8gZC55MCA6IDApIHx8IDAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgLyAoc3RhY2tlZCA/IDEgOiBkYXRhLmxlbmd0aCkgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGdldFgoZCxpKSkgKyAnLDApJzsgfSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpLGopeyByZXR1cm4gY29sb3IoZCwgaiwgaSk7ICB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpLGopeyByZXR1cm4gY29sb3IoZCwgaiwgaSk7IH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHsgLy9UT0RPOiBmaWd1cmUgb3V0IHdoeSBqIHdvcmtzIGFib3ZlLCBidXQgbm90IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSArICh4LnJhbmdlQmFuZCgpICogKHN0YWNrZWQgPyBkYXRhLmxlbmd0aCAvIDIgOiBkLnNlcmllcyArIC41KSAvIGRhdGEubGVuZ3RoKSwgeShnZXRZKGQsaSkgKyAoc3RhY2tlZCA/IGQueTAgOiAwKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSArICh4LnJhbmdlQmFuZCgpICogKHN0YWNrZWQgPyBkYXRhLmxlbmd0aCAvIDIgOiBkLnNlcmllcyArIC41KSAvIGRhdGEubGVuZ3RoKSwgeShnZXRZKGQsaSkgKyAoc3RhY2tlZCA/IGQueTAgOiAwKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChzdGFja2VkID8gZGF0YS5sZW5ndGggLyAyIDogZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCksIHkoZ2V0WShkLGkpICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ252LWJhciBuZWdhdGl2ZScgOiAnbnYtYmFyIHBvc2l0aXZlJ30pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChnZXRYKGQsaSkpICsgJywwKSc7IH0pXG5cbiAgICAgICAgICAgIGlmIChiYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZWQpIGRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGJhcnNcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIGQzLnJnYihiYXJDb2xvcihkLGkpKS5kYXJrZXIoICBkaXNhYmxlZC5tYXAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpeyByZXR1cm4gIWRpc2FibGVkW2ldICB9KVtqXSAgICkudG9TdHJpbmcoKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gZDMucmdiKGJhckNvbG9yKGQsaSkpLmRhcmtlciggIGRpc2FibGVkLm1hcChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSl7IHJldHVybiAhZGlzYWJsZWRbaV0gIH0pW2pdICAgKS50b1N0cmluZygpOyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJhclNlbGVjdGlvbiA9XG4gICAgICAgICAgICAgICAgYmFycy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtdWx0aWJhcicsIE1hdGgubWluKDI1MCwgZHVyYXRpb24pKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAqIGR1cmF0aW9uIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdGFja2VkKVxuICAgICAgICAgICAgICAgIGJhclNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoKHN0YWNrZWQgPyBkLnkxIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoeShkLnkgKyAoc3RhY2tlZCA/IGQueTAgOiAwKSkgLSB5KChzdGFja2VkID8gZC55MCA6IDApKSksMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA/IDAgOiAoZC5zZXJpZXMgKiB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB4LnJhbmdlQmFuZCgpIC8gKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpICk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYmFyU2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5zZXJpZXMgKiB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFkoZCxpKSA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KDApIC0geShnZXRZKGQsaSkpIDwgMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIDEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoZ2V0WShkLGkpKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgwKSksMSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgICAgICAgeDAgPSB4LmNvcHkoKTtcbiAgICAgICAgICAgIHkwID0geS5jb3B5KCk7XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgZGF0YSB2YWx1ZSBsZW5ndGggZm9yIHRyYW5zaXRpb24gY2FsY3VsYXRpb25zXG4gICAgICAgICAgICBpZiAoZGF0YVswXSAmJiBkYXRhWzBdLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIGxhc3RfZGF0YWxlbmd0aCA9IGRhdGFbMF0udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ211bHRpYmFyIGltbWVkaWF0ZScpO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB4OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1fO319LFxuICAgICAgICB5OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WT1fO319LFxuICAgICAgICB4U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4O30sIHNldDogZnVuY3Rpb24oXyl7eD1fO319LFxuICAgICAgICB5U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5O30sIHNldDogZnVuY3Rpb24oXyl7eT1fO319LFxuICAgICAgICB4RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbj1fO319LFxuICAgICAgICB4UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt4UmFuZ2U9Xzt9fSxcbiAgICAgICAgeVJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIGZvcmNlWTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWT1fO319LFxuICAgICAgICBzdGFja2VkOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFja2VkO30sIHNldDogZnVuY3Rpb24oXyl7c3RhY2tlZD1fO319LFxuICAgICAgICBzdGFja09mZnNldDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhY2tPZmZzZXQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzdGFja09mZnNldD1fO319LFxuICAgICAgICBjbGlwRWRnZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcEVkZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjbGlwRWRnZT1fO319LFxuICAgICAgICBkaXNhYmxlZDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGlzYWJsZWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtkaXNhYmxlZD1fO319LFxuICAgICAgICBpZDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtpZD1fO319LFxuICAgICAgICBoaWRlYWJsZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGlkZWFibGU7fSwgc2V0OiBmdW5jdGlvbihfKXtoaWRlYWJsZT1fO319LFxuICAgICAgICBncm91cFNwYWNpbmc6e2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ3JvdXBTcGFjaW5nO30sIHNldDogZnVuY3Rpb24oXyl7Z3JvdXBTcGFjaW5nPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBiYXJDb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGJhckNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBiYXJDb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLm11bHRpQmFyQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG11bHRpYmFyID0gbnYubW9kZWxzLm11bHRpQmFyKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBjb250cm9scyA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXG4gICAgICAgICwgY29udHJvbExhYmVscyA9IHt9XG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgcmVkdWNlWFRpY2tzID0gdHJ1ZSAvLyBpZiBmYWxzZSBhIHRpY2sgd2lsbCBzaG93IGZvciBldmVyeSBkYXRhIHBvaW50XG4gICAgICAgICwgc3RhZ2dlckxhYmVscyA9IGZhbHNlXG4gICAgICAgICwgcm90YXRlTGFiZWxzID0gMFxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgb24gJyArIHggKyAnPC9wPidcbiAgICAgICAgfVxuICAgICAgICAsIHggLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnhTY2FsZSgpXG4gICAgICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywgJ3JlbmRlckVuZCcpXG4gICAgICAgICwgY29udHJvbFdpZHRoID0gZnVuY3Rpb24oKSB7IHJldHVybiBzaG93Q29udHJvbHMgPyAxODAgOiAwIH1cbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICBzdGF0ZS5zdGFja2VkID0gZmFsc2UgLy8gREVQUkVDQVRFRCBNYWludGFpbmVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICBtdWx0aWJhclxuICAgICAgICAuc3RhY2tlZChmYWxzZSlcbiAgICA7XG4gICAgeEF4aXNcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnRpY2tQYWRkaW5nKDcpXG4gICAgICAgIC5oaWdobGlnaHRaZXJvKHRydWUpXG4gICAgICAgIC5zaG93TWF4TWluKGZhbHNlKVxuICAgICAgICAudGlja0Zvcm1hdChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pXG4gICAgO1xuICAgIHlBeGlzXG4gICAgICAgIC5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgICAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcbiAgICA7XG5cbiAgICBjb250cm9scy51cGRhdGVTdGF0ZShmYWxzZSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoKTtcbiAgICB2YXIgc3RhY2tlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICB5ID0geUF4aXMudGlja0Zvcm1hdCgpKG11bHRpYmFyLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLFxuICAgICAgICAgICAgICAgIHN0YWNrZWQ6IHN0YWNrZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFja2VkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc3RhY2tlZCA9IHN0YXRlLnN0YWNrZWQ7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhtdWx0aWJhcik7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgbm9EYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBtdWx0aWJhci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBtdWx0aWJhci55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LW11bHRpQmFyV2l0aExlZ2VuZCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LW11bHRpQmFyV2l0aExlZ2VuZCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFyc1dyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udHJvbHNXcmFwJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgoYXZhaWxhYmxlV2lkdGggLSBjb250cm9sV2lkdGgoKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGliYXIuYmFyQ29sb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuY29sb3IgPSBkMy5yZ2IoJyNjY2MnKS5kYXJrZXIoaSAqIDEuNSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjb250cm9sV2lkdGgoKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2xzXG4gICAgICAgICAgICBpZiAoc2hvd0NvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xzRGF0YSA9IFtcbiAgICAgICAgICAgICAgICAgICAgeyBrZXk6IGNvbnRyb2xMYWJlbHMuZ3JvdXBlZCB8fCAnR3JvdXBlZCcsIGRpc2FibGVkOiBtdWx0aWJhci5zdGFja2VkKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBrZXk6IGNvbnRyb2xMYWJlbHMuc3RhY2tlZCB8fCAnU3RhY2tlZCcsIGRpc2FibGVkOiAhbXVsdGliYXIuc3RhY2tlZCgpIH1cbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgY29udHJvbHMud2lkdGgoY29udHJvbFdpZHRoKCkpLmNvbG9yKFsnIzQ0NCcsICcjNDQ0JywgJyM0NDQnXSk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oY29udHJvbHNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXkubnYtYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGF2YWlsYWJsZVdpZHRoICsgXCIsMClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICBtdWx0aWJhclxuICAgICAgICAgICAgICAgIC5kaXNhYmxlZChkYXRhLm1hcChmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG5cblxuICAgICAgICAgICAgdmFyIGJhcnNXcmFwID0gZy5zZWxlY3QoJy5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgYmFyc1dyYXAuY2FsbChtdWx0aWJhcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEF4ZXNcbiAgICAgICAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3QoJy5udi14Lm52LWF4aXMgPiBnJykuc2VsZWN0QWxsKCdnJyk7XG5cbiAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGluZSwgdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oeCx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWdnZXJVcCA9IDUsIHN0YWdnZXJEb3duID0gMTc7ICAvL3BpeGVscyB0byBzdGFnZ2VyIGJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIElzc3VlICMxNDBcbiAgICAgICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICBnZXRUcmFuc2xhdGUoMCwgKGogJSAyID09IDAgPyBzdGFnZ2VyVXAgOiBzdGFnZ2VyRG93bikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsSW5CZXR3ZWVuVGlja3MgPSBkMy5zZWxlY3RBbGwoXCIubnYteC5udi1heGlzIC5udi13cmFwIGcgZyB0ZXh0XCIpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoXCIubnYteC5udi1heGlzIC5udi1heGlzTWF4TWluIHRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc2xhdGUoMCwgKGkgPT09IDAgfHwgdG90YWxJbkJldHdlZW5UaWNrcyAlIDIgIT09IDApID8gc3RhZ2dlckRvd24gOiBzdGFnZ2VyVXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZVhUaWNrcylcbiAgICAgICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpICUgTWF0aC5jZWlsKGRhdGFbMF0udmFsdWVzLmxlbmd0aCAvIChhdmFpbGFibGVXaWR0aCAvIDEwMCkpICE9PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQsIGxpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMCk7XG5cbiAgICAgICAgICAgICAgICBpZihyb3RhdGVMYWJlbHMpXG4gICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnLnRpY2sgdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgnICsgcm90YXRlTGFiZWxzICsgJyAwLDApJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVMYWJlbHMgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4gdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRyb2xzLmRpc3BhdGNoLm9uKCdsZWdlbmRDbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGlmICghZC5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICBzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdHcm91cGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1N0YWNrZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGliYXIuc3RhY2tlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrZWQgPSBtdWx0aWJhci5zdGFja2VkKCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5zdGFja2VkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGUuc3RhY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrZWQgPSBlLnN0YWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWQgPSBlLnN0YWNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdtdWx0aWJhcmNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIG11bHRpYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIG11bHRpYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5tdWx0aWJhciA9IG11bHRpYmFyO1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzID0geUF4aXM7XG4gICAgY2hhcnQuc3RhdGUgPSBzdGF0ZTtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHNob3dDb250cm9sczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0NvbnRyb2xzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0NvbnRyb2xzPV87fX0sXG4gICAgICAgIGNvbnRyb2xMYWJlbHM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbnRyb2xMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtjb250cm9sTGFiZWxzPV87fX0sXG4gICAgICAgIHNob3dYQXhpczogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WEF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WEF4aXM9Xzt9fSxcbiAgICAgICAgc2hvd1lBeGlzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBzO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcHM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcENvbnRlbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXA7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwPV87fX0sXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIHJlZHVjZVhUaWNrczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmVkdWNlWFRpY2tzO30sIHNldDogZnVuY3Rpb24oXyl7cmVkdWNlWFRpY2tzPV87fX0sXG4gICAgICAgIHJvdGF0ZUxhYmVsczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcm90YXRlTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7cm90YXRlTGFiZWxzPV87fX0sXG4gICAgICAgIHN0YWdnZXJMYWJlbHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YWdnZXJMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzdGFnZ2VyTGFiZWxzPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIG11bHRpYmFyLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIHJpZ2h0QWxpZ25ZQXhpcyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIG11bHRpYmFyKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMubXVsdGlCYXJIb3Jpem9udGFsID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gOTYwXG4gICAgICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICAsIHggPSBkMy5zY2FsZS5vcmRpbmFsKClcbiAgICAgICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBnZXRZZXJyID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55RXJyIH1cbiAgICAgICAgLCBmb3JjZVkgPSBbMF0gLy8gMCBpcyBmb3JjZWQgYnkgZGVmYXVsdC4uIHRoaXMgbWFrZXMgc2Vuc2UgZm9yIHRoZSBtYWpvcml0eSBvZiBiYXIgZ3JhcGhzLi4uIHVzZXIgY2FuIGFsd2F5cyBkbyBjaGFydC5mb3JjZVkoW10pIHRvIHJlbW92ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBiYXJDb2xvciA9IG51bGwgLy8gYWRkaW5nIHRoZSBhYmlsaXR5IHRvIHNldCB0aGUgY29sb3IgZm9yIGVhY2ggcmF0aGVyIHRoYW4gdGhlIHdob2xlIGdyb3VwXG4gICAgICAgICwgZGlzYWJsZWQgLy8gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGJhckNvbG9yIHRvIGNvbW11bmljYXRlIGZyb20gbXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQgd2hhdCBzZXJpZXMgYXJlIGRpc2FibGVkXG4gICAgICAgICwgc3RhY2tlZCA9IGZhbHNlXG4gICAgICAgICwgc2hvd1ZhbHVlcyA9IGZhbHNlXG4gICAgICAgICwgc2hvd0JhckxhYmVscyA9IGZhbHNlXG4gICAgICAgICwgdmFsdWVQYWRkaW5nID0gNjBcbiAgICAgICAgLCB2YWx1ZUZvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgICAgICwgZGVsYXkgPSAxMjAwXG4gICAgICAgICwgeERvbWFpblxuICAgICAgICAsIHlEb21haW5cbiAgICAgICAgLCB4UmFuZ2VcbiAgICAgICAgLCB5UmFuZ2VcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHgwLCB5MDsgLy91c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChzdGFja2VkKVxuICAgICAgICAgICAgICAgIGRhdGEgPSBkMy5sYXlvdXQuc3RhY2soKVxuICAgICAgICAgICAgICAgICAgICAub2Zmc2V0KCd6ZXJvJylcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlcyhmdW5jdGlvbihkKXsgcmV0dXJuIGQudmFsdWVzIH0pXG4gICAgICAgICAgICAgICAgICAgIC55KGdldFkpXG4gICAgICAgICAgICAgICAgKGRhdGEpO1xuXG4gICAgICAgICAgICAvL2FkZCBzZXJpZXMgaW5kZXggdG8gZWFjaCBkYXRhIHBvaW50IGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuc2VyaWVzID0gaTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBIQUNLIGZvciBuZWdhdGl2ZSB2YWx1ZSBzdGFja2luZ1xuICAgICAgICAgICAgaWYgKHN0YWNrZWQpXG4gICAgICAgICAgICAgICAgZGF0YVswXS52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zQmFzZSA9IDAsIG5lZ0Jhc2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGQudmFsdWVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICBmLnNpemUgPSBNYXRoLmFicyhmLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYueTwwKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYueTEgPSBuZWdCYXNlIC0gZi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZ0Jhc2UgPSBuZWdCYXNlIC0gZi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi55MSA9IHBvc0Jhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zQmFzZSA9IHBvc0Jhc2UgKyBmLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIC8vIHJlbWFwIGFuZCBmbGF0dGVuIHRoZSBkYXRhIGZvciB1c2UgaW4gY2FsY3VsYXRpbmcgdGhlIHNjYWxlcycgZG9tYWluc1xuICAgICAgICAgICAgdmFyIHNlcmllc0RhdGEgPSAoeERvbWFpbiAmJiB5RG9tYWluKSA/IFtdIDogLy8gaWYgd2Uga25vdyB4RG9tYWluIGFuZCB5RG9tYWluLCBubyBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpLCB5MDogZC55MCwgeTE6IGQueTEgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4LmRvbWFpbih4RG9tYWluIHx8IGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSkpXG4gICAgICAgICAgICAgICAgLnJhbmdlQmFuZHMoeFJhbmdlIHx8IFswLCBhdmFpbGFibGVIZWlnaHRdLCAuMSk7XG5cbiAgICAgICAgICAgIHkuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBzdGFja2VkID8gKGQueSA+IDAgPyBkLnkxICsgZC55IDogZC55MSApIDogZC55IH0pLmNvbmNhdChmb3JjZVkpKSlcblxuICAgICAgICAgICAgaWYgKHNob3dWYWx1ZXMgJiYgIXN0YWNrZWQpXG4gICAgICAgICAgICAgICAgeS5yYW5nZSh5UmFuZ2UgfHwgWyh5LmRvbWFpbigpWzBdIDwgMCA/IHZhbHVlUGFkZGluZyA6IDApLCBhdmFpbGFibGVXaWR0aCAtICh5LmRvbWFpbigpWzFdID4gMCA/IHZhbHVlUGFkZGluZyA6IDApIF0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHkucmFuZ2UoeVJhbmdlIHx8IFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICAgICAgICB5MCA9IHkwIHx8IGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbih5LmRvbWFpbigpKS5yYW5nZShbeSgwKSx5KDApXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aWJhckhvcml6b250YWwnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aWJhckhvcml6b250YWwnKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHZhciBncm91cHMgPSB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcbiAgICAgICAgICAgIGdyb3Vwcy5leGl0KCkud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXJob3Jpem9udGFsOiBleGl0IGdyb3VwcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGdyb3Vwc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWdyb3VwIG52LXNlcmllcy0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpeyByZXR1cm4gY29sb3IoZCwgaSkgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtdWx0aWJhcmhvcml6b250YWw6IGdyb3VwcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAuNzUpO1xuXG4gICAgICAgICAgICB2YXIgYmFycyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ2cubnYtYmFyJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcyB9KTtcbiAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB2YXIgYmFyc0VudGVyID0gYmFycy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB5MChzdGFja2VkID8gZC55MCA6IDApICsgJywnICsgKHN0YWNrZWQgPyAwIDogKGogKiB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGggKSArIHgoZ2V0WChkLGkpKSkgKyAnKSdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYmFyc0VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgeC5yYW5nZUJhbmQoKSAvIChzdGFja2VkID8gMSA6IGRhdGEubGVuZ3RoKSApXG5cbiAgICAgICAgICAgIGJhcnNcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkgeyAvL1RPRE86IGZpZ3VyZSBvdXQgd2h5IGogd29ya3MgYWJvdmUsIGJ1dCBub3QgaGVyZVxuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbIHkoZ2V0WShkLGkpICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpLCB4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChzdGFja2VkID8gZGF0YS5sZW5ndGggLyAyIDogZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCkgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChzdGFja2VkID8gZGF0YS5sZW5ndGggLyAyIDogZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCksIHkoZ2V0WShkLGkpICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnREYmxDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZ2V0WWVycihkYXRhWzBdLDApKSB7XG4gICAgICAgICAgICAgICAgYmFyc0VudGVyLmFwcGVuZCgncG9seWxpbmUnKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuc2VsZWN0KCdwb2x5bGluZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGVyciA9IGdldFllcnIoZCxpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgbWlkID0gMC44ICogeC5yYW5nZUJhbmQoKSAvICgoc3RhY2tlZCA/IDEgOiBkYXRhLmxlbmd0aCkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhlcnIgPSB4ZXJyLmxlbmd0aCA/IHhlcnIgOiBbLU1hdGguYWJzKHhlcnIpLCBNYXRoLmFicyh4ZXJyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB4ZXJyID0geGVyci5tYXAoZnVuY3Rpb24oZSkgeyByZXR1cm4geShlKSAtIHkoMCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbW3hlcnJbMF0sLW1pZF0sIFt4ZXJyWzBdLG1pZF0sIFt4ZXJyWzBdLDBdLCBbeGVyclsxXSwwXSwgW3hlcnJbMV0sLW1pZF0sIFt4ZXJyWzFdLG1pZF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoLmpvaW4oJywnKSB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaWQgPSB4LnJhbmdlQmFuZCgpIC8gKChzdGFja2VkID8gMSA6IGRhdGEubGVuZ3RoKSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChnZXRZKGQsaSkgPCAwID8gMCA6IHkoZ2V0WShkLGkpKSAtIHkoMCkpICsgJywgJyArIG1pZCArICcpJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFyc0VudGVyLmFwcGVuZCgndGV4dCcpO1xuXG4gICAgICAgICAgICBpZiAoc2hvd1ZhbHVlcyAmJiAhc3RhY2tlZCkge1xuICAgICAgICAgICAgICAgIGJhcnMuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ2VuZCcgOiAnc3RhcnQnIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeC5yYW5nZUJhbmQoKSAvIChkYXRhLmxlbmd0aCAqIDIpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjMyZW0nKVxuICAgICAgICAgICAgICAgICAgICAuaHRtbChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdmFsdWVGb3JtYXQoZ2V0WShkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgeWVyciA9IGdldFllcnIoZCxpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ZXJyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXllcnIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICsgJyZwbHVzbW47JyArIHZhbHVlRm9ybWF0KE1hdGguYWJzKHllcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICsgJysnICsgdmFsdWVGb3JtYXQoTWF0aC5hYnMoeWVyclsxXSkpICsgJy0nICsgdmFsdWVGb3JtYXQoTWF0aC5hYnMoeWVyclswXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYXJzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ211bHRpYmFyaG9yaXpvbnRhbDogYmFycycpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/IC00IDogeShnZXRZKGQsaSkpIC0geSgwKSArIDQgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3RBbGwoJ3RleHQnKS50ZXh0KCcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dCYXJMYWJlbHMgJiYgIXN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKCd0ZXh0JykuY2xhc3NlZCgnbnYtYmFyLWxhYmVsJyx0cnVlKTtcbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdCgndGV4dC5udi1iYXItbGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAnc3RhcnQnIDogJ2VuZCcgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB4LnJhbmdlQmFuZCgpIC8gKGRhdGEubGVuZ3RoICogMikpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMzJlbScpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WChkLGkpIH0pO1xuICAgICAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXJob3Jpem9udGFsOiBiYXJzJylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dC5udi1iYXItbGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/IHkoMCkgLSB5KGdldFkoZCxpKSkgKyA0IDogLTQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdEFsbCgndGV4dC5udi1iYXItbGFiZWwnKS50ZXh0KCcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZSd9KVxuXG4gICAgICAgICAgICBpZiAoYmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVkKSBkaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiBkMy5yZ2IoYmFyQ29sb3IoZCxpKSkuZGFya2VyKCAgZGlzYWJsZWQubWFwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKXsgcmV0dXJuICFkaXNhYmxlZFtpXSAgfSlbal0gICApLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIGQzLnJnYihiYXJDb2xvcihkLGkpKS5kYXJrZXIoICBkaXNhYmxlZC5tYXAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpeyByZXR1cm4gIWRpc2FibGVkW2ldICB9KVtqXSAgICkudG9TdHJpbmcoKTsgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGFja2VkKVxuICAgICAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXJob3Jpem9udGFsOiBiYXJzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHkoZC55MSkgKyAnLCcgKyB4KGdldFgoZCxpKSkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHkoZ2V0WShkLGkpICsgZC55MCkgLSB5KGQueTApKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgeC5yYW5nZUJhbmQoKSApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXJob3Jpem9udGFsOiBiYXJzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBzdGFja2VkIG11c3QgYmUgYWxsIHBvc2l0aXZlIG9yIGFsbCBuZWdhdGl2ZSwgbm90IGJvdGg/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2V0WShkLGkpIDwgMCA/IHkoZ2V0WShkLGkpKSA6IHkoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkLnNlcmllcyAqIHgucmFuZ2VCYW5kKCkgLyBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgoZ2V0WChkLGkpKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSwxKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICAgICAgICB4MCA9IHguY29weSgpO1xuICAgICAgICAgICAgeTAgPSB5LmNvcHkoKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ211bHRpYmFySG9yaXpvbnRhbCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHg6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYPV87fX0sXG4gICAgICAgIHk6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZPV87fX0sXG4gICAgICAgIHlFcnI6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFllcnI7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZZXJyPV87fX0sXG4gICAgICAgIHhTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHg7fSwgc2V0OiBmdW5jdGlvbihfKXt4PV87fX0sXG4gICAgICAgIHlTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHhEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt4RG9tYWluPV87fX0sXG4gICAgICAgIHlEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VZO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VZPV87fX0sXG4gICAgICAgIHN0YWNrZWQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YWNrZWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzdGFja2VkPV87fX0sXG4gICAgICAgIHNob3dWYWx1ZXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dWYWx1ZXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93VmFsdWVzPV87fX0sXG4gICAgICAgIC8vIHRoaXMgc2hvd3MgdGhlIGdyb3VwIG5hbWUsIHNlZW1zIHBvaW50bGVzcz9cbiAgICAgICAgLy9zaG93QmFyTGFiZWxzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93QmFyTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0JhckxhYmVscz1fO319LFxuICAgICAgICBkaXNhYmxlZDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRpc2FibGVkO30sIHNldDogZnVuY3Rpb24oXyl7ZGlzYWJsZWQ9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG4gICAgICAgIHZhbHVlRm9ybWF0OiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdmFsdWVGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt2YWx1ZUZvcm1hdD1fO319LFxuICAgICAgICB2YWx1ZVBhZGRpbmc6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHZhbHVlUGFkZGluZzt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3ZhbHVlUGFkZGluZz1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgYmFyQ29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgYmFyQ29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMubXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG11bHRpYmFyID0gbnYubW9kZWxzLm11bHRpQmFySG9yaXpvbnRhbCgpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpLmhlaWdodCgzMClcbiAgICAgICAgLCBjb250cm9scyA9IG52Lm1vZGVscy5sZWdlbmQoKS5oZWlnaHQoMzApXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDUwLCBsZWZ0OiA2MH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHNob3dDb250cm9scyA9IHRydWVcbiAgICAgICAgLCBjb250cm9sTGFiZWxzID0ge31cbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAgICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgICAgICwgc3RhY2tlZCA9IGZhbHNlXG4gICAgICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnIC0gJyArIHggKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJzwvcD4nXG4gICAgICAgIH1cbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9ICdObyBEYXRhIEF2YWlsYWJsZS4nXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCdyZW5kZXJFbmQnKVxuICAgICAgICAsIGNvbnRyb2xXaWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2hvd0NvbnRyb2xzID8gMTgwIDogMCB9XG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgO1xuXG4gICAgc3RhdGUuc3RhY2tlZCA9IGZhbHNlOyAvLyBERVBSRUNBVEVEIE1haW50YWluZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuICAgIG11bHRpYmFyXG4gICAgICAgIC5zdGFja2VkKHN0YWNrZWQpXG4gICAgO1xuICAgIHhBeGlzXG4gICAgICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgICAgICAudGlja1BhZGRpbmcoNSlcbiAgICAgICAgLmhpZ2hsaWdodFplcm8oZmFsc2UpXG4gICAgICAgIC5zaG93TWF4TWluKGZhbHNlKVxuICAgICAgICAudGlja0Zvcm1hdChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pXG4gICAgO1xuICAgIHlBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrRm9ybWF0KGQzLmZvcm1hdCgnLC4xZicpKVxuICAgIDtcblxuICAgIGNvbnRyb2xzLnVwZGF0ZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICB5ID0geUF4aXMudGlja0Zvcm1hdCgpKG11bHRpYmFyLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgZS52YWx1ZSA8IDAgPyAnZScgOiAndycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLFxuICAgICAgICAgICAgICAgIHN0YWNrZWQ6IHN0YWNrZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFja2VkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc3RhY2tlZCA9IHN0YXRlLnN0YWNrZWQ7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMobXVsdGliYXIpO1xuICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChjaGFydCkgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YWNrZWQgPSBtdWx0aWJhci5zdGFja2VkKCk7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gbXVsdGliYXIueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gbXVsdGliYXIueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aUJhckhvcml6b250YWxDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LW11bHRpQmFySG9yaXpvbnRhbENoYXJ0JykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi16ZXJvTGluZScpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRyb2xzV3JhcCcpO1xuXG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpYmFyLmJhckNvbG9yKCkpXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmNvbG9yID0gZDMucmdiKCcjY2NjJykuZGFya2VyKGkgKiAxLjUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgY29udHJvbFdpZHRoKCkgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb250cm9sc1xuICAgICAgICAgICAgaWYgKHNob3dDb250cm9scykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBjb250cm9sTGFiZWxzLmdyb3VwZWQgfHwgJ0dyb3VwZWQnLCBkaXNhYmxlZDogbXVsdGliYXIuc3RhY2tlZCgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBjb250cm9sTGFiZWxzLnN0YWNrZWQgfHwgJ1N0YWNrZWQnLCBkaXNhYmxlZDogIW11bHRpYmFyLnN0YWNrZWQoKSB9XG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2xzLndpZHRoKGNvbnRyb2xXaWR0aCgpKS5jb2xvcihbJyM0NDQnLCAnIzQ0NCcsICcjNDQ0J10pO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGNvbnRyb2xzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChjb250cm9scyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcbiAgICAgICAgICAgIG11bHRpYmFyXG4gICAgICAgICAgICAgICAgLmRpc2FibGVkKGRhdGEubWFwKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgdmFyIGJhcnNXcmFwID0gZy5zZWxlY3QoJy5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwobXVsdGliYXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMjQsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhUaWNrcyA9IGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuc2VsZWN0QWxsKCdnJyk7XG5cbiAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGluZSwgdGV4dCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgYXZhaWxhYmxlSGVpZ2h0ICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpLmNhbGwoeUF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBaZXJvIGxpbmVcbiAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXplcm9MaW5lIGxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHkoMCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB5KDApKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgMClcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIC1hdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRyb2xzLmRpc3BhdGNoLm9uKCdsZWdlbmRDbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGlmICghZC5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICBzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdHcm91cGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1N0YWNrZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGliYXIuc3RhY2tlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrZWQgPSBtdWx0aWJhci5zdGFja2VkKCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHN0YWNrZWQgPSBtdWx0aWJhci5zdGFja2VkKCk7XG5cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5zdGFja2VkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGUuc3RhY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrZWQgPSBlLnN0YWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWQgPSBlLnN0YWNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbXVsdGliYXIgaG9yaXpvbnRhbCBjaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubXVsdGliYXIgPSBtdWx0aWJhcjtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LnN0YXRlID0gc3RhdGU7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBzaG93Q29udHJvbHM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dDb250cm9sczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dDb250cm9scz1fO319LFxuICAgICAgICBjb250cm9sTGFiZWxzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb250cm9sTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7Y29udHJvbExhYmVscz1fO319LFxuICAgICAgICBzaG93WEF4aXM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBtdWx0aWJhci5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBtdWx0aWJhcik7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcbm52Lm1vZGVscy5tdWx0aUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDUwLCBsZWZ0OiA2MH0sXG4gICAgICAgIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKCksXG4gICAgICAgIHdpZHRoID0gbnVsbCxcbiAgICAgICAgaGVpZ2h0ID0gbnVsbCxcbiAgICAgICAgc2hvd0xlZ2VuZCA9IHRydWUsXG4gICAgICAgIHRvb2x0aXBzID0gdHJ1ZSxcbiAgICAgICAgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJyBhdCAnICsgeCArICc8L3A+J1xuICAgICAgICB9LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJyxcbiAgICAgICAgeURvbWFpbjEsXG4gICAgICAgIHlEb21haW4yLFxuICAgICAgICBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0sXG4gICAgICAgIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnl9LFxuICAgICAgICBpbnRlcnBvbGF0ZSA9ICdtb25vdG9uZSdcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpLFxuICAgICAgICB5U2NhbGUxID0gZDMuc2NhbGUubGluZWFyKCksXG4gICAgICAgIHlTY2FsZTIgPSBkMy5zY2FsZS5saW5lYXIoKSxcblxuICAgICAgICBsaW5lczEgPSBudi5tb2RlbHMubGluZSgpLnlTY2FsZSh5U2NhbGUxKSxcbiAgICAgICAgbGluZXMyID0gbnYubW9kZWxzLmxpbmUoKS55U2NhbGUoeVNjYWxlMiksXG5cbiAgICAgICAgYmFyczEgPSBudi5tb2RlbHMubXVsdGlCYXIoKS5zdGFja2VkKGZhbHNlKS55U2NhbGUoeVNjYWxlMSksXG4gICAgICAgIGJhcnMyID0gbnYubW9kZWxzLm11bHRpQmFyKCkuc3RhY2tlZChmYWxzZSkueVNjYWxlKHlTY2FsZTIpLFxuXG4gICAgICAgIHN0YWNrMSA9IG52Lm1vZGVscy5zdGFja2VkQXJlYSgpLnlTY2FsZSh5U2NhbGUxKSxcbiAgICAgICAgc3RhY2syID0gbnYubW9kZWxzLnN0YWNrZWRBcmVhKCkueVNjYWxlKHlTY2FsZTIpLFxuXG4gICAgICAgIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKS5zY2FsZSh4KS5vcmllbnQoJ2JvdHRvbScpLnRpY2tQYWRkaW5nKDUpLFxuICAgICAgICB5QXhpczEgPSBudi5tb2RlbHMuYXhpcygpLnNjYWxlKHlTY2FsZTEpLm9yaWVudCgnbGVmdCcpLFxuICAgICAgICB5QXhpczIgPSBudi5tb2RlbHMuYXhpcygpLnNjYWxlKHlTY2FsZTIpLm9yaWVudCgncmlnaHQnKSxcblxuICAgICAgICBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKCkuaGVpZ2h0KDMwKSxcbiAgICAgICAgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKTtcblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobGluZXMxLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHkgPSAoKGUuc2VyaWVzLnlBeGlzID09IDIpID8geUF4aXMyIDogeUF4aXMxKS50aWNrRm9ybWF0KCkobGluZXMxLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9mZnNldEVsZW1lbnQub2Zmc2V0UGFyZW50KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgdmFyIGRhdGFMaW5lczEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQudHlwZSA9PSAnbGluZScgJiYgZC55QXhpcyA9PSAxfSk7XG4gICAgICAgICAgICB2YXIgZGF0YUxpbmVzMiA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC50eXBlID09ICdsaW5lJyAmJiBkLnlBeGlzID09IDJ9KTtcbiAgICAgICAgICAgIHZhciBkYXRhQmFyczEgPSAgZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnR5cGUgPT0gJ2JhcicgICYmIGQueUF4aXMgPT0gMX0pO1xuICAgICAgICAgICAgdmFyIGRhdGFCYXJzMiA9ICBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQudHlwZSA9PSAnYmFyJyAgJiYgZC55QXhpcyA9PSAyfSk7XG4gICAgICAgICAgICB2YXIgZGF0YVN0YWNrMSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC50eXBlID09ICdhcmVhJyAmJiBkLnlBeGlzID09IDF9KTtcbiAgICAgICAgICAgIHZhciBkYXRhU3RhY2syID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnR5cGUgPT0gJ2FyZWEnICYmIGQueUF4aXMgPT0gMn0pO1xuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlcmllczEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuICFkLmRpc2FibGVkICYmIGQueUF4aXMgPT0gMX0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBkLngsIHk6IGQueSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXMyID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnlBeGlzID09IDJ9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZC54LCB5OiBkLnkgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4ICAgLmRvbWFpbihkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzMS5jb25jYXQoc2VyaWVzMikpLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSApKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLndyYXAubXVsdGlDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnd3JhcCBudmQzIG11bHRpQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3ggYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3kxIGF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd5MiBheGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbGluZXMxV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xpbmVzMldyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdiYXJzMVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdiYXJzMldyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdzdGFjazFXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc3RhY2syV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZFdyYXAnKTtcblxuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICB2YXIgY29sb3JfYXJyYXkgPSBkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtpXS5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcl9hcnJheSk7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKCBhdmFpbGFibGVXaWR0aCAvIDIgKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLm1hcChmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5vcmlnaW5hbEtleSA9IHNlcmllcy5vcmlnaW5hbEtleSA9PT0gdW5kZWZpbmVkID8gc2VyaWVzLmtleSA6IHNlcmllcy5vcmlnaW5hbEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5rZXkgPSBzZXJpZXMub3JpZ2luYWxLZXkgKyAoc2VyaWVzLnlBeGlzID09IDEgPyAnJyA6ICcgKHJpZ2h0IGF4aXMpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoIGF2YWlsYWJsZVdpZHRoIC8gMiApICsgJywnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZXMxXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAuY29sb3IoY29sb3JfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAxICYmIGRhdGFbaV0udHlwZSA9PSAnbGluZSd9KSk7XG4gICAgICAgICAgICBsaW5lczJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDIgJiYgZGF0YVtpXS50eXBlID09ICdsaW5lJ30pKTtcbiAgICAgICAgICAgIGJhcnMxXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDEgJiYgZGF0YVtpXS50eXBlID09ICdiYXInfSkpO1xuICAgICAgICAgICAgYmFyczJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGNvbG9yX2FycmF5LmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMiAmJiBkYXRhW2ldLnR5cGUgPT0gJ2Jhcid9KSk7XG4gICAgICAgICAgICBzdGFjazFcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGNvbG9yX2FycmF5LmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMSAmJiBkYXRhW2ldLnR5cGUgPT0gJ2FyZWEnfSkpO1xuICAgICAgICAgICAgc3RhY2syXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDIgJiYgZGF0YVtpXS50eXBlID09ICdhcmVhJ30pKTtcblxuICAgICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICB2YXIgbGluZXMxV3JhcCA9IGcuc2VsZWN0KCcubGluZXMxV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKFxuICAgICAgICAgICAgICAgICAgICBkYXRhTGluZXMxLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgYmFyczFXcmFwID0gZy5zZWxlY3QoJy5iYXJzMVdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShcbiAgICAgICAgICAgICAgICAgICAgZGF0YUJhcnMxLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgc3RhY2sxV3JhcCA9IGcuc2VsZWN0KCcuc3RhY2sxV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKFxuICAgICAgICAgICAgICAgICAgICBkYXRhU3RhY2sxLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lczJXcmFwID0gZy5zZWxlY3QoJy5saW5lczJXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oXG4gICAgICAgICAgICAgICAgICAgIGRhdGFMaW5lczIuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiAhZC5kaXNhYmxlZH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBiYXJzMldyYXAgPSBnLnNlbGVjdCgnLmJhcnMyV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKFxuICAgICAgICAgICAgICAgICAgICBkYXRhQmFyczIuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiAhZC5kaXNhYmxlZH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBzdGFjazJXcmFwID0gZy5zZWxlY3QoJy5zdGFjazJXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oXG4gICAgICAgICAgICAgICAgICAgIGRhdGFTdGFjazIuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiAhZC5kaXNhYmxlZH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIGV4dHJhVmFsdWUxID0gZGF0YVN0YWNrMS5sZW5ndGggPyBkYXRhU3RhY2sxLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZXN9KS5yZWR1Y2UoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5tYXAoZnVuY3Rpb24oYVZhbCxpKXtyZXR1cm4ge3g6IGFWYWwueCwgeTogYVZhbC55ICsgYltpXS55fX0pXG4gICAgICAgICAgICB9KS5jb25jYXQoW3t4OjAsIHk6MH1dKSA6IFtdXG4gICAgICAgICAgICB2YXIgZXh0cmFWYWx1ZTIgPSBkYXRhU3RhY2syLmxlbmd0aCA/IGRhdGFTdGFjazIubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlc30pLnJlZHVjZShmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBhLm1hcChmdW5jdGlvbihhVmFsLGkpe3JldHVybiB7eDogYVZhbC54LCB5OiBhVmFsLnkgKyBiW2ldLnl9fSlcbiAgICAgICAgICAgIH0pLmNvbmNhdChbe3g6MCwgeTowfV0pIDogW11cblxuICAgICAgICAgICAgeVNjYWxlMSAuZG9tYWluKHlEb21haW4xIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXMxKS5jb25jYXQoZXh0cmFWYWx1ZTEpLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSApKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXZhaWxhYmxlSGVpZ2h0XSlcblxuICAgICAgICAgICAgeVNjYWxlMiAuZG9tYWluKHlEb21haW4yIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXMyKS5jb25jYXQoZXh0cmFWYWx1ZTIpLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSApKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXZhaWxhYmxlSGVpZ2h0XSlcblxuICAgICAgICAgICAgbGluZXMxLnlEb21haW4oeVNjYWxlMS5kb21haW4oKSlcbiAgICAgICAgICAgIGJhcnMxLnlEb21haW4oeVNjYWxlMS5kb21haW4oKSlcbiAgICAgICAgICAgIHN0YWNrMS55RG9tYWluKHlTY2FsZTEuZG9tYWluKCkpXG5cbiAgICAgICAgICAgIGxpbmVzMi55RG9tYWluKHlTY2FsZTIuZG9tYWluKCkpXG4gICAgICAgICAgICBiYXJzMi55RG9tYWluKHlTY2FsZTIuZG9tYWluKCkpXG4gICAgICAgICAgICBzdGFjazIueURvbWFpbih5U2NhbGUyLmRvbWFpbigpKVxuXG4gICAgICAgICAgICBpZihkYXRhU3RhY2sxLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihzdGFjazFXcmFwKS5jYWxsKHN0YWNrMSk7fVxuICAgICAgICAgICAgaWYoZGF0YVN0YWNrMi5sZW5ndGgpe2QzLnRyYW5zaXRpb24oc3RhY2syV3JhcCkuY2FsbChzdGFjazIpO31cblxuICAgICAgICAgICAgaWYoZGF0YUJhcnMxLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihiYXJzMVdyYXApLmNhbGwoYmFyczEpO31cbiAgICAgICAgICAgIGlmKGRhdGFCYXJzMi5sZW5ndGgpe2QzLnRyYW5zaXRpb24oYmFyczJXcmFwKS5jYWxsKGJhcnMyKTt9XG5cbiAgICAgICAgICAgIGlmKGRhdGFMaW5lczEubGVuZ3RoKXtkMy50cmFuc2l0aW9uKGxpbmVzMVdyYXApLmNhbGwobGluZXMxKTt9XG4gICAgICAgICAgICBpZihkYXRhTGluZXMyLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihsaW5lczJXcmFwKS5jYWxsKGxpbmVzMik7fVxuXG4gICAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcueC5heGlzJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBhdmFpbGFibGVIZWlnaHQgKyAnKScpO1xuICAgICAgICAgICAgZDMudHJhbnNpdGlvbihnLnNlbGVjdCgnLnguYXhpcycpKVxuICAgICAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcblxuICAgICAgICAgICAgeUF4aXMxXG4gICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcueTEuYXhpcycpKVxuICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzMSk7XG5cbiAgICAgICAgICAgIHlBeGlzMlxuICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy55Mi5heGlzJykpXG4gICAgICAgICAgICAgICAgLmNhbGwoeUF4aXMyKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy55MS5heGlzJylcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbnYtZGlzYWJsZWQnLCBzZXJpZXMxLmxlbmd0aCA/IGZhbHNlIDogdHJ1ZSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeC5yYW5nZSgpWzBdICsgJywwKScpO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLnkyLmF4aXMnKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdudi1kaXNhYmxlZCcsIHNlcmllczIubGVuZ3RoID8gZmFsc2UgOiB0cnVlKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4LnJhbmdlKClbMV0gKyAnLDApJyk7XG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxpbmVzMS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIGxpbmVzMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIGJhcnMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGJhcnMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgc3RhY2sxLmRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy9kaXNhYmxlIHRvb2x0aXBzIHdoZW4gdmFsdWUgfj0gMFxuICAgICAgICAvLy8vIFRPRE86IGNvbnNpZGVyIHJlbW92aW5nIHBvaW50cyBmcm9tIHZvcm9ub2kgdGhhdCBoYXZlIDAgdmFsdWUgaW5zdGVhZCBvZiB0aGlzIGhhY2tcbiAgICAgICAgaWYgKCFNYXRoLnJvdW5kKHN0YWNrMS55KCkoZS5wb2ludCkgKiAxMDApKSB7ICAvLyAxMDAgd2lsbCBub3QgYmUgZ29vZCBmb3IgdmVyeSBzbWFsbCBudW1iZXJzLi4uIHdpbGwgaGF2ZSB0byB0aGluayBhYm91dCBtYWtpbmcgdGhpcyB2YWx1IGR5bmFtaWMsIGJhc2VkIG9uIGRhdGEgcmFuZ2VcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGQzLnNlbGVjdEFsbCgnLnBvaW50LmhvdmVyJykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSkgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBzdGFjazEuZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIHN0YWNrMi5kaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vZGlzYWJsZSB0b29sdGlwcyB3aGVuIHZhbHVlIH49IDBcbiAgICAgICAgLy8vLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyBwb2ludHMgZnJvbSB2b3Jvbm9pIHRoYXQgaGF2ZSAwIHZhbHVlIGluc3RlYWQgb2YgdGhpcyBoYWNrXG4gICAgICAgIGlmICghTWF0aC5yb3VuZChzdGFjazIueSgpKGUucG9pbnQpICogMTAwKSkgeyAgLy8gMTAwIHdpbGwgbm90IGJlIGdvb2QgZm9yIHZlcnkgc21hbGwgbnVtYmVycy4uLiB3aWxsIGhhdmUgdG8gdGhpbmsgYWJvdXQgbWFraW5nIHRoaXMgdmFsdSBkeW5hbWljLCBiYXNlZCBvbiBkYXRhIHJhbmdlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBkMy5zZWxlY3RBbGwoJy5wb2ludC5ob3ZlcicpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXSxcbiAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgc3RhY2syLmRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gR2xvYmFsIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5saW5lczEgPSBsaW5lczE7XG4gICAgY2hhcnQubGluZXMyID0gbGluZXMyO1xuICAgIGNoYXJ0LmJhcnMxID0gYmFyczE7XG4gICAgY2hhcnQuYmFyczIgPSBiYXJzMjtcbiAgICBjaGFydC5zdGFjazEgPSBzdGFjazE7XG4gICAgY2hhcnQuc3RhY2syID0gc3RhY2syO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMxID0geUF4aXMxO1xuICAgIGNoYXJ0LnlBeGlzMiA9IHlBeGlzMjtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHlEb21haW4xOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW4xO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbjE9Xzt9fSxcbiAgICAgICAgeURvbWFpbjI6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW4yO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbjI9Xzt9fSxcbiAgICAgICAgdG9vbHRpcHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBzO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcHM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcENvbnRlbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXA7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIGludGVycG9sYXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcnBvbGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVycG9sYXRlPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZ2V0WCA9IF87XG4gICAgICAgICAgICBsaW5lczEueChfKTtcbiAgICAgICAgICAgIGJhcnMxLngoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRZID0gXztcbiAgICAgICAgICAgIGxpbmVzMS55KF8pO1xuICAgICAgICAgICAgYmFyczEueShfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cblxubnYubW9kZWxzLm9obGNCYXIgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBnZXRPcGVuID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5vcGVuIH1cbiAgICAgICAgLCBnZXRDbG9zZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuY2xvc2UgfVxuICAgICAgICAsIGdldEhpZ2ggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhpZ2ggfVxuICAgICAgICAsIGdldExvdyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubG93IH1cbiAgICAgICAgLCBmb3JjZVggPSBbXVxuICAgICAgICAsIGZvcmNlWSA9IFtdXG4gICAgICAgICwgcGFkRGF0YSAgICAgPSBmYWxzZSAvLyBJZiB0cnVlLCBhZGRzIGhhbGYgYSBkYXRhIHBvaW50cyB3aWR0aCB0byBmcm9udCBhbmQgYmFjaywgZm9yIGxpbmluZyB1cCBhIGxpbmUgY2hhcnQgd2l0aCBhIGJhciBjaGFydFxuICAgICAgICAsIGNsaXBFZGdlID0gdHJ1ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBpbnRlcmFjdGl2ZSA9IGZhbHNlXG4gICAgICAgICwgeERvbWFpblxuICAgICAgICAsIHlEb21haW5cbiAgICAgICAgLCB4UmFuZ2VcbiAgICAgICAgLCB5UmFuZ2VcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnLCAnY2hhcnRDbGljaycsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeC5kb21haW4oeERvbWFpbiB8fCBkMy5leHRlbnQoZGF0YVswXS52YWx1ZXMubWFwKGdldFgpLmNvbmNhdChmb3JjZVgpICkpO1xuXG4gICAgICAgICAgICBpZiAocGFkRGF0YSlcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbYXZhaWxhYmxlV2lkdGggKiAuNSAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgYXZhaWxhYmxlV2lkdGggKiAoZGF0YVswXS52YWx1ZXMubGVuZ3RoIC0gLjUpICAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCBdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgeS5kb21haW4oeURvbWFpbiB8fCBbXG4gICAgICAgICAgICAgICAgICAgIGQzLm1pbihkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0TG93KS5jb25jYXQoZm9yY2VZKSksXG4gICAgICAgICAgICAgICAgICAgIGQzLm1heChkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0SGlnaCkuY29uY2F0KGZvcmNlWSkpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKS5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAgICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHguZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB4LmRvbWFpbihbeC5kb21haW4oKVswXSAtIHguZG9tYWluKClbMF0gKiAwLjAxLCB4LmRvbWFpbigpWzFdICsgeC5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHguZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIGlmICh5LmRvbWFpbigpWzBdID09PSB5LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHkuZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSArIHkuZG9tYWluKClbMF0gKiAwLjAxLCB5LmRvbWFpbigpWzFdIC0geS5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHkuZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1vaGxjQmFyJykuZGF0YShbZGF0YVswXS52YWx1ZXNdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LW9obGNCYXInKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtdGlja3MnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBjb250YWluZXJcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmNoYXJ0Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJyNudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkICsgJyByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgZyAgIC5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgIHZhciB0aWNrcyA9IHdyYXAuc2VsZWN0KCcubnYtdGlja3MnKS5zZWxlY3RBbGwoJy5udi10aWNrJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuICAgICAgICAgICAgdGlja3MuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB2YXIgdGlja3NFbnRlciA9IHRpY2tzLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gKGdldE9wZW4oZCxpKSA+IGdldENsb3NlKGQsaSkgPyAnbnYtdGljayBuZWdhdGl2ZScgOiAnbnYtdGljayBwb3NpdGl2ZScpICsgJyBudi10aWNrLScgKyBqICsgJy0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKGF2YWlsYWJsZVdpZHRoIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAqIC45O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ20wLDBsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldE9wZW4oZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHkoZ2V0SGlnaChkLGkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICAgICAgICArICgtdy8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAody8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldExvdyhkLGkpKSAtIHkoZ2V0T3BlbihkLGkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2wwLCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHkoZ2V0Q2xvc2UoZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHkoZ2V0TG93KGQsaSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHcvMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJywwbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKC13LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICArICcsMHonO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChnZXRYKGQsaSkpICsgJywnICsgeShnZXRIaWdoKGQsaSkpICsgJyknOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvclswXTsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvclswXTsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDAgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7ICByZXR1cm4geShNYXRoLm1heCgwLCBnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoMCkpIH0pO1xuXG4gICAgICAgICAgICAvLyB0aGUgYmFyIGNvbG9ycyBhcmUgY29udHJvbGxlZCBieSBDU1MgY3VycmVudGx5XG4gICAgICAgICAgICB0aWNrcy5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChnZXRPcGVuKGQsaSkgPiBnZXRDbG9zZShkLGkpID8gJ252LXRpY2sgbmVnYXRpdmUnIDogJ252LXRpY2sgcG9zaXRpdmUnKSArICcgbnYtdGljay0nICsgaiArICctJyArIGk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZDMudHJhbnNpdGlvbih0aWNrcylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGdldFgoZCxpKSkgKyAnLCcgKyB5KGdldEhpZ2goZCxpKSkgKyAnKSc7IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAoYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgpICogLjk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbTAsMGwwLCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHkoZ2V0T3BlbihkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0geShnZXRIaWdoKGQsaSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKC13LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICArICcsMGwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh3LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICArICcsMGwwLCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHkoZ2V0TG93KGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB5KGdldE9wZW4oZCxpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICArICdsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldENsb3NlKGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB5KGdldExvdyhkLGkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh3LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICArICcsMGwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICgtdy8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDB6JztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuXG4gICAgLy9DcmVhdGUgbWV0aG9kcyB0byBhbGxvdyBvdXRzaWRlIGZ1bmN0aW9ucyB0byBoaWdobGlnaHQgYSBzcGVjaWZpYyBiYXIuXG4gICAgY2hhcnQuaGlnaGxpZ2h0UG9pbnQgPSBmdW5jdGlvbihwb2ludEluZGV4LCBpc0hvdmVyT3Zlcikge1xuICAgICAgICBjaGFydC5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiLm52LW9obGNCYXIgLm52LXRpY2stMC1cIiArIHBvaW50SW5kZXgpXG4gICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGlzSG92ZXJPdmVyKVxuICAgICAgICA7XG4gICAgfTtcblxuICAgIGNoYXJ0LmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIubnYtb2hsY0JhciAubnYtdGljay5ob3ZlclwiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJob3ZlclwiLCBmYWxzZSlcbiAgICAgICAgO1xuICAgIH07XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB4U2NhbGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHhEb21haW46ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIGZvcmNlWDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVg7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVg9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWT1fO319LFxuICAgICAgICBwYWREYXRhOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcGFkRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BhZERhdGE9Xzt9fSxcbiAgICAgICAgY2xpcEVkZ2U6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBFZGdlO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcEVkZ2U9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgaW50ZXJhY3RpdmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGludGVyYWN0aXZlO30sIHNldDogZnVuY3Rpb24oXyl7aW50ZXJhY3RpdmU9Xzt9fSxcblxuICAgICAgICB4OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcbiAgICAgICAgeTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZPV87fX0sXG4gICAgICAgIG9wZW46ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRPcGVuKCk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRPcGVuPV87fX0sXG4gICAgICAgIGNsb3NlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRDbG9zZSgpO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0Q2xvc2U9Xzt9fSxcbiAgICAgICAgaGlnaDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldEhpZ2g7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRIaWdoPV87fX0sXG4gICAgICAgIGxvdzogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRMb3c7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRMb3c9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG4vLyBDb2RlIGFkYXB0ZWQgZnJvbSBKYXNvbiBEYXZpZXMnIFwiUGFyYWxsZWwgQ29vcmRpbmF0ZXNcIlxuLy8gaHR0cDovL2JsLm9ja3Mub3JnL2phc29uZGF2aWVzLzEzNDEyODFcblxubnYubW9kZWxzLnBhcmFsbGVsQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMTAsIGJvdHRvbTogMTAsIGxlZnQ6IDEwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCB4ID0gZDMuc2NhbGUub3JkaW5hbCgpXG4gICAgICAgICwgeSA9IHt9XG4gICAgICAgICwgZGltZW5zaW9ucyA9IFtdXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIGZpbHRlcnMgPSBbXVxuICAgICAgICAsIGFjdGl2ZSA9IFtdXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnYnJ1c2gnKVxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgYWN0aXZlID0gZGF0YTsgLy9zZXQgYWxsIGFjdGl2ZSBiZWZvcmUgZmlyc3QgYnJ1c2ggY2FsbFxuXG4gICAgICAgICAgICAvL1RoaXMgaXMgYSBwbGFjZWhvbGRlciB1bnRpbCB0aGlzIGNoYXJ0IGlzIG1hZGUgcmVzaXplYWJsZVxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IH07XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeC5yYW5nZVBvaW50cyhbMCwgYXZhaWxhYmxlV2lkdGhdLCAxKS5kb21haW4oZGltZW5zaW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGxpc3Qgb2YgZGltZW5zaW9ucyBhbmQgY3JlYXRlIGEgc2NhbGUgZm9yIGVhY2guXG4gICAgICAgICAgICBkaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHlbZF0gPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGQzLmV4dGVudChkYXRhLCBmdW5jdGlvbihwKSB7IHJldHVybiArcFtkXTsgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgICAgICAgICB5W2RdLmJydXNoID0gZDMuc3ZnLmJydXNoKCkueSh5W2RdKS5vbignYnJ1c2gnLCBicnVzaCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZCAhPSAnbmFtZSc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXBhcmFsbGVsQ29vcmRpbmF0ZXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1wYXJhbGxlbENvb3JkaW5hdGVzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGFyYWxsZWxDb29yZGluYXRlc1dyYXAnKTtcbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpLFxuICAgICAgICAgICAgICAgIGF4aXMgPSBkMy5zdmcuYXhpcygpLm9yaWVudCgnbGVmdCcpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZDtcblxuICAgICAgICAgICAgLy8gQWRkIGdyZXkgYmFja2dyb3VuZCBsaW5lcyBmb3IgY29udGV4dC5cbiAgICAgICAgICAgIGJhY2tncm91bmQgPSBnRW50ZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFja2dyb3VuZCcpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aClcbiAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgLy8gQWRkIGJsdWUgZm9yZWdyb3VuZCBsaW5lcyBmb3IgZm9jdXMuXG4gICAgICAgICAgICBmb3JlZ3JvdW5kID0gZ0VudGVyLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2ZvcmVncm91bmQnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNvbG9yKVxuICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAvLyBBZGQgYSBncm91cCBlbGVtZW50IGZvciBlYWNoIGRpbWVuc2lvbi5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpXG4gICAgICAgICAgICAgICAgLmRhdGEoZGltZW5zaW9ucylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkaW1lbnNpb24nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGQpICsgJywwKSc7IH0pO1xuXG4gICAgICAgICAgICAvLyBBZGQgYW4gYXhpcyBhbmQgdGl0bGUuXG4gICAgICAgICAgICBkaW1lbnNpb24uYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYXhpcycpXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkgeyBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlbZF0pKTsgfSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIC05KVxuICAgICAgICAgICAgICAgIC50ZXh0KFN0cmluZyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhbmQgc3RvcmUgYSBicnVzaCBmb3IgZWFjaCBheGlzLlxuICAgICAgICAgICAgZGltZW5zaW9uLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoJylcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkKSB7IGQzLnNlbGVjdCh0aGlzKS5jYWxsKHlbZF0uYnJ1c2gpOyB9KVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLTgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTYpO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm5zIHRoZSBwYXRoIGZvciBhIGdpdmVuIGRhdGEgcG9pbnQuXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXRoKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZShkaW1lbnNpb25zLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBbeChwKSwgeVtwXShkW3BdKV07IH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlcyBhIGJydXNoIGV2ZW50LCB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiBmb3JlZ3JvdW5kIGxpbmVzLlxuICAgICAgICAgICAgZnVuY3Rpb24gYnJ1c2goKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZXMgPSBkaW1lbnNpb25zLmZpbHRlcihmdW5jdGlvbihwKSB7IHJldHVybiAheVtwXS5icnVzaC5lbXB0eSgpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50cyA9IGFjdGl2ZXMubWFwKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHlbcF0uYnJ1c2guZXh0ZW50KCk7IH0pO1xuXG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IFtdOyAvL2VyYXNlIGN1cnJlbnQgZmlsdGVyc1xuICAgICAgICAgICAgICAgIGFjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogZXh0ZW50c1tpXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBhY3RpdmUgPSBbXTsgLy9lcmFzZSBjdXJyZW50IGFjdGl2ZSBsaXN0XG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZC5zdHlsZSgnZGlzcGxheScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gYWN0aXZlcy5ldmVyeShmdW5jdGlvbihwLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tpXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZSkgYWN0aXZlLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FjdGl2ZSA/IG51bGwgOiAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5icnVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogYWN0aXZlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgZGltZW5zaW9uczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGltZW5zaW9uczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RpbWVuc2lvbnM9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLnBpZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDUwMFxuICAgICAgICAsIGhlaWdodCA9IDUwMFxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgdmFsdWVGb3JtYXQgPSBkMy5mb3JtYXQoJywuMmYnKVxuICAgICAgICAsIGxhYmVsRm9ybWF0ID0gZDMuZm9ybWF0KCclJylcbiAgICAgICAgLCBzaG93TGFiZWxzID0gdHJ1ZVxuICAgICAgICAsIHBpZUxhYmVsc091dHNpZGUgPSB0cnVlXG4gICAgICAgICwgZG9udXRMYWJlbHNPdXRzaWRlID0gZmFsc2VcbiAgICAgICAgLCBsYWJlbFR5cGUgPSBcImtleVwiXG4gICAgICAgICwgbGFiZWxUaHJlc2hvbGQgPSAuMDIgLy9pZiBzbGljZSBwZXJjZW50YWdlIGlzIHVuZGVyIHRoaXMsIGRvbid0IHNob3cgbGFiZWxcbiAgICAgICAgLCBkb251dCA9IGZhbHNlXG4gICAgICAgICwgdGl0bGUgPSBmYWxzZVxuICAgICAgICAsIGdyb3dPbkhvdmVyID0gdHJ1ZVxuICAgICAgICAsIHRpdGxlT2Zmc2V0ID0gMFxuICAgICAgICAsIGxhYmVsU3VuYmVhbUxheW91dCA9IGZhbHNlXG4gICAgICAgICwgc3RhcnRBbmdsZSA9IGZhbHNlXG4gICAgICAgICwgcGFkQW5nbGUgPSBmYWxzZVxuICAgICAgICAsIGVuZEFuZ2xlID0gZmFsc2VcbiAgICAgICAgLCBjb3JuZXJSYWRpdXMgPSAwXG4gICAgICAgICwgZG9udXRSYXRpbyA9IDAuNVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnY2hhcnRDbGljaycsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBjaGFydCBmdW5jdGlvblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodFxuICAgICAgICAgICAgICAgICxhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbVxuICAgICAgICAgICAgICAgICxyYWRpdXMgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KSAvIDJcbiAgICAgICAgICAgICAgICAsYXJjUmFkaXVzID0gcmFkaXVzLShyYWRpdXMgLyA1KVxuICAgICAgICAgICAgICAgICxjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi13cmFwLm52LXBpZScpLmRhdGEoZGF0YSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywnbnZkMyBudi13cmFwIG52LXBpZSBudi1jaGFydC0nICsgaWQpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnX3BpZSA9IGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1waWUnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1waWVMYWJlbHMnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1waWUnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBhdmFpbGFibGVXaWR0aCAvIDIgKyAnLCcgKyBhdmFpbGFibGVIZWlnaHQgLyAyICsgJyknKTtcbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtcGllTGFiZWxzJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXZhaWxhYmxlV2lkdGggLyAyICsgJywnICsgYXZhaWxhYmxlSGVpZ2h0IC8gMiArICcpJyk7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjb250YWluZXIub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guY2hhcnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIHZhciBhcmMgPSBkMy5zdmcuYXJjKCkub3V0ZXJSYWRpdXMoYXJjUmFkaXVzKTtcbiAgICAgICAgICAgIHZhciBhcmNPdmVyID0gZDMuc3ZnLmFyYygpLm91dGVyUmFkaXVzKGFyY1JhZGl1cyArIDUpO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGFyYy5zdGFydEFuZ2xlKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgICAgIGFyY092ZXIuc3RhcnRBbmdsZShzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGFyYy5lbmRBbmdsZShlbmRBbmdsZSk7XG4gICAgICAgICAgICAgICAgYXJjT3Zlci5lbmRBbmdsZShlbmRBbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9udXQpIHtcbiAgICAgICAgICAgICAgICBhcmMuaW5uZXJSYWRpdXMocmFkaXVzICogZG9udXRSYXRpbyk7XG4gICAgICAgICAgICAgICAgYXJjT3Zlci5pbm5lclJhZGl1cyhyYWRpdXMgKiBkb251dFJhdGlvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgdGhlIFBpZSBjaGFydCBhbmQgY2hvb3NlIHRoZSBkYXRhIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBwaWUgPSBkMy5sYXlvdXQucGllKClcbiAgICAgICAgICAgICAgICAuc29ydChudWxsKVxuICAgICAgICAgICAgICAgIC52YWx1ZShmdW5jdGlvbihkKSB7IHJldHVybiBkLmRpc2FibGVkID8gMCA6IGdldFkoZCkgfSk7XG5cbiAgICAgICAgICAgIC8vIHBhZEFuZ2xlIGFkZGVkIGluIGQzIDMuNVxuICAgICAgICAgICAgaWYgKHBpZS5wYWRBbmdsZSAmJiBwYWRBbmdsZSkge1xuICAgICAgICAgICAgICAgIHBpZS5wYWRBbmdsZShwYWRBbmdsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcmMuY29ybmVyUmFkaXVzICYmIGNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgIGFyYy5jb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBhcmNPdmVyLmNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aXRsZSBpcyBzcGVjaWZpZWQgYW5kIGRvbnV0LCBwdXQgaXQgaW4gdGhlIG1pZGRsZVxuICAgICAgICAgICAgaWYgKGRvbnV0ICYmIHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlX2cgPSBnX3BpZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1waWUnKTtcblxuICAgICAgICAgICAgICAgIHRpdGxlX2cuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtcGllLXRpdGxlJylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjAuMzVlbVwiKSAvLyB0cmljayB0byB2ZXJ0aWNhbGx5IGNlbnRlciB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCAnKyB0aXRsZU9mZnNldCArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbGljZXMgPSB3cmFwLnNlbGVjdCgnLm52LXBpZScpLnNlbGVjdEFsbCgnLm52LXNsaWNlJykuZGF0YShwaWUpO1xuICAgICAgICAgICAgdmFyIHBpZUxhYmVscyA9IHdyYXAuc2VsZWN0KCcubnYtcGllTGFiZWxzJykuc2VsZWN0QWxsKCcubnYtbGFiZWwnKS5kYXRhKHBpZSk7XG5cbiAgICAgICAgICAgIHNsaWNlcy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICBwaWVMYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB2YXIgYWUgPSBzbGljZXMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgYWUuYXR0cignY2xhc3MnLCAnbnYtc2xpY2UnKVxuICAgICAgICAgICAgYWUub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3dPbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoXCJwYXRoXCIpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDcwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyY092ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZS5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3Jvd09uSG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdChcInBhdGhcIikudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNsaWNlcy5hdHRyKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKTsgfSlcbiAgICAgICAgICAgIHNsaWNlcy5hdHRyKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpOyB9KTtcblxuICAgICAgICAgICAgdmFyIHBhdGhzID0gYWUuYXBwZW5kKCdwYXRoJykuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGF0aHMub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXRocy5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0WChkLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNsaWNlcy5zZWxlY3QoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGFyYylcbiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgYXJjVHdlZW4pO1xuXG4gICAgICAgICAgICBpZiAoc2hvd0xhYmVscykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9lcyB0aGUgbm9ybWFsIGxhYmVsXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsc0FyYyA9IGQzLnN2Zy5hcmMoKS5pbm5lclJhZGl1cygwKTtcblxuICAgICAgICAgICAgICAgIGlmIChwaWVMYWJlbHNPdXRzaWRlKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsc0FyYyA9IGFyYztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9udXRMYWJlbHNPdXRzaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsc0FyYyA9IGQzLnN2Zy5hcmMoKS5vdXRlclJhZGl1cyhhcmMub3V0ZXJSYWRpdXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGllTGFiZWxzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5jbGFzc2VkKFwibnYtbGFiZWxcIix0cnVlKS5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsU3VuYmVhbUxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSBhcmNSYWRpdXMgKyAxMDsgLy8gU2V0IE91dGVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmlubmVyUmFkaXVzID0gYXJjUmFkaXVzICsgMTU7IC8vIFNldCBJbm5lciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZUFuZ2xlID0gKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGQuc3RhcnRBbmdsZStkLmVuZEFuZ2xlKS8yIDwgTWF0aC5QSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSAtPSA5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSArPSA5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGxhYmVsc0FyYy5jZW50cm9pZChkKSArICcpIHJvdGF0ZSgnICsgcm90YXRlQW5nbGUgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSByYWRpdXMgKyAxMDsgLy8gU2V0IE91dGVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmlubmVyUmFkaXVzID0gcmFkaXVzICsgMTU7IC8vIFNldCBJbm5lciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGxhYmVsc0FyYy5jZW50cm9pZChkKSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBncm91cC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnI2ZmZicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnI2ZmZicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJ4XCIsIDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJ5XCIsIDMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgbGFiZWxTdW5iZWFtTGF5b3V0ID8gKChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnKSA6ICdtaWRkbGUnKSAvL2NlbnRlciB0aGUgdGV4dCBvbiBpdCdzIG9yaWdpbiBvciBiZWdpbi9lbmQgaWYgb3J0aG9nb25hbCBhbGlnbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpXG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBsYWJlbExvY2F0aW9uSGFzaCA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBhdmdIZWlnaHQgPSAxNDtcbiAgICAgICAgICAgICAgICB2YXIgYXZnV2lkdGggPSAxNDA7XG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUhhc2hLZXkgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb29yZGluYXRlc1swXS9hdmdXaWR0aCkgKiBhdmdXaWR0aCArICcsJyArIE1hdGguZmxvb3IoY29vcmRpbmF0ZXNbMV0vYXZnSGVpZ2h0KSAqIGF2Z0hlaWdodDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcGllTGFiZWxzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwncGllIGxhYmVscycpLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsU3VuYmVhbUxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5vdXRlclJhZGl1cyA9IGFyY1JhZGl1cyArIDEwOyAvLyBTZXQgT3V0ZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZC5pbm5lclJhZGl1cyA9IGFyY1JhZGl1cyArIDE1OyAvLyBTZXQgSW5uZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZUFuZ2xlID0gKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZC5zdGFydEFuZ2xlK2QuZW5kQW5nbGUpLzIgPCBNYXRoLlBJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQW5nbGUgLT0gOTA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZUFuZ2xlICs9IDkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGxhYmVsc0FyYy5jZW50cm9pZChkKSArICcpIHJvdGF0ZSgnICsgcm90YXRlQW5nbGUgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLm91dGVyUmFkaXVzID0gcmFkaXVzICsgMTA7IC8vIFNldCBPdXRlciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBkLmlubmVyUmFkaXVzID0gcmFkaXVzICsgMTU7IC8vIFNldCBJbm5lciBDb29yZGluYXRlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgT3ZlcmxhcHBpbmcgcGllIGxhYmVscyBhcmUgbm90IGdvb2QuIFdoYXQgdGhpcyBhdHRlbXB0cyB0byBkbyBpcywgcHJldmVudCBvdmVybGFwcGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICBFYWNoIGxhYmVsIGxvY2F0aW9uIGlzIGhhc2hlZCwgYW5kIGlmIGEgaGFzaCBjb2xsaXNpb24gb2NjdXJzLCB3ZSBhc3N1bWUgYW4gb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICAgICAgICAgICBBZGp1c3QgdGhlIGxhYmVsJ3MgeS1wb3NpdGlvbiB0byByZW1vdmUgdGhlIG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBsYWJlbHNBcmMuY2VudHJvaWQoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkLnZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaEtleSA9IGNyZWF0ZUhhc2hLZXkoY2VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxMb2NhdGlvbkhhc2hbaGFzaEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyWzFdIC09IGF2Z0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxMb2NhdGlvbkhhc2hbY3JlYXRlSGFzaEtleShjZW50ZXIpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgY2VudGVyICsgJyknXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHBpZUxhYmVscy5zZWxlY3QoXCIubnYtbGFiZWwgdGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgbGFiZWxTdW5iZWFtTGF5b3V0ID8gKChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnKSA6ICdtaWRkbGUnKSAvL2NlbnRlciB0aGUgdGV4dCBvbiBpdCdzIG9yaWdpbiBvciBiZWdpbi9lbmQgaWYgb3J0aG9nb25hbCBhbGlnbmVkXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFR5cGVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCIgOiBnZXRYKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBnZXRZKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwZXJjZW50XCI6IGxhYmVsRm9ybWF0KHBlcmNlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChkLnZhbHVlICYmIHBlcmNlbnQgPiBsYWJlbFRocmVzaG9sZCkgPyBsYWJlbFR5cGVzW2xhYmVsVHlwZV0gOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGFuZ2xlIG9mIGFuIGFyYywgY29udmVydGluZyBmcm9tIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFuZ2xlKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAqIDkwIC8gTWF0aC5QSSAtIDkwO1xuICAgICAgICAgICAgICAgIHJldHVybiBhID4gOTAgPyBhIC0gMTgwIDogYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYXJjVHdlZW4oYSkge1xuICAgICAgICAgICAgICAgIGEuZW5kQW5nbGUgPSBpc05hTihhLmVuZEFuZ2xlKSA/IDAgOiBhLmVuZEFuZ2xlO1xuICAgICAgICAgICAgICAgIGEuc3RhcnRBbmdsZSA9IGlzTmFOKGEuc3RhcnRBbmdsZSkgPyAwIDogYS5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIGlmICghZG9udXQpIGEuaW5uZXJSYWRpdXMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBpID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgYSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGkoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyYyhpKHQpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3BpZSBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGFiZWxzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xhYmVscz1fO319LFxuICAgICAgICB0aXRsZTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0aXRsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3RpdGxlPV87fX0sXG4gICAgICAgIHRpdGxlT2Zmc2V0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0aXRsZU9mZnNldDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3RpdGxlT2Zmc2V0PV87fX0sXG4gICAgICAgIGxhYmVsVGhyZXNob2xkOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsYWJlbFRocmVzaG9sZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xhYmVsVGhyZXNob2xkPV87fX0sXG4gICAgICAgIGxhYmVsRm9ybWF0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsYWJlbEZvcm1hdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xhYmVsRm9ybWF0PV87fX0sXG4gICAgICAgIHZhbHVlRm9ybWF0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB2YWx1ZUZvcm1hdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3ZhbHVlRm9ybWF0PV87fX0sXG4gICAgICAgIHg6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYPV87fX0sXG4gICAgICAgIGlkOiAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgZW5kQW5nbGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZW5kQW5nbGU7fSwgc2V0OiBmdW5jdGlvbihfKXtlbmRBbmdsZT1fO319LFxuICAgICAgICBzdGFydEFuZ2xlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFydEFuZ2xlO30sIHNldDogZnVuY3Rpb24oXyl7c3RhcnRBbmdsZT1fO319LFxuICAgICAgICBwYWRBbmdsZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBwYWRBbmdsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BhZEFuZ2xlPV87fX0sXG4gICAgICAgIGNvcm5lclJhZGl1czoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29ybmVyUmFkaXVzO30sIHNldDogZnVuY3Rpb24oXyl7Y29ybmVyUmFkaXVzPV87fX0sXG4gICAgICAgIGRvbnV0UmF0aW86ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZG9udXRSYXRpbzt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RvbnV0UmF0aW89Xzt9fSxcbiAgICAgICAgcGllTGFiZWxzT3V0c2lkZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBwaWVMYWJlbHNPdXRzaWRlO30sIHNldDogZnVuY3Rpb24oXyl7cGllTGFiZWxzT3V0c2lkZT1fO319LFxuICAgICAgICBkb251dExhYmVsc091dHNpZGU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRvbnV0TGFiZWxzT3V0c2lkZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RvbnV0TGFiZWxzT3V0c2lkZT1fO319LFxuICAgICAgICBsYWJlbFN1bmJlYW1MYXlvdXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxhYmVsU3VuYmVhbUxheW91dDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xhYmVsU3VuYmVhbUxheW91dD1fO319LFxuICAgICAgICBkb251dDogICAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRvbnV0O30sIHNldDogZnVuY3Rpb24oXyl7ZG9udXQ9Xzt9fSxcbiAgICAgICAgZ3Jvd09uSG92ZXI6ICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBncm93T25Ib3Zlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dyb3dPbkhvdmVyPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGdldFk9ZDMuZnVuY3RvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3I9bnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBsYWJlbFR5cGU6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxhYmVsVHlwZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbGFiZWxUeXBlPSBfIHx8ICdrZXknO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMucGllQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHBpZSA9IG52Lm1vZGVscy5waWUoKTtcbiAgICB2YXIgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogMjAsIGxlZnQ6IDIwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDMgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAnXG4gICAgICAgICAgICAgICAgKyBlLmNvbG9yICsgJ1wiPicgKyBrZXkgKyAnPC9oMz4nXG4gICAgICAgICAgICAgICAgKyAnPHA+JyArICB5ICsgJzwvcD4nO1xuICAgICAgICB9XG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBwaWUueCgpKGUucG9pbnQpO1xuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCAob2Zmc2V0RWxlbWVudCAmJiBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQpIHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCAob2Zmc2V0RWxlbWVudCAmJiBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCkgfHwgMCksXG4gICAgICAgICAgICB5ID0gcGllLnZhbHVlRm9ybWF0KCkocGllLnkoKShlLnBvaW50KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcCh0b29sdGlwTGFiZWwsIHksIGUsIGNoYXJ0KVxuICAgICAgICAgICAgO1xuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gpO1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIENoYXJ0IGZ1bmN0aW9uXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMocGllKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpLCAxMCkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSwgMTApIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbVxuICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuY2FsbChjaGFydCk7IH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZS5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtcGllQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1waWVDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aCggYXZhaWxhYmxlV2lkdGggKS5rZXkocGllLngoKSk7XG5cbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICBwaWUud2lkdGgoYXZhaWxhYmxlV2lkdGgpLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHBpZVdyYXAgPSBnLnNlbGVjdCgnLm52LXBpZVdyYXAnKS5kYXR1bShbZGF0YV0pO1xuICAgICAgICAgICAgZDMudHJhbnNpdGlvbihwaWVXcmFwKS5jYWxsKHBpZSk7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGllLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgncGllQ2hhcnQgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcGllLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlKTtcbiAgICB9KTtcblxuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LnBpZSA9IHBpZTtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICAvLyB1c2UgT2JqZWN0IGdldC9zZXQgZnVuY3Rpb25hbGl0eSB0byBtYXAgYmV0d2VlbiB2YXJzIGFuZCBjaGFydCBmdW5jdGlvbnNcbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICBub0RhdGE6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sICAgICAgICAgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcbiAgICAgICAgdG9vbHRpcENvbnRlbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXA7fSwgICAgICAgIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICB0b29sdGlwczogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgICAgICAgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCAgICAgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgICBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIGNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBfO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIHBpZS5jb2xvcihjb2xvcik7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX1cbiAgICB9KTtcbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgcGllKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLnNjYXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiAgICAgICA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggICAgICAgID0gbnVsbFxuICAgICAgICAsIGhlaWdodCAgICAgICA9IG51bGxcbiAgICAgICAgLCBjb2xvciAgICAgICAgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKSAvLyBjaG9vc2VzIGNvbG9yXG4gICAgICAgICwgaWQgICAgICAgICAgID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbmNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCB4ICAgICAgICAgICAgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHkgICAgICAgICAgICA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgeiAgICAgICAgICAgID0gZDMuc2NhbGUubGluZWFyKCkgLy9saW5lYXIgYmVjYXVzZSBkMy5zdmcuc2hhcGUuc2l6ZSBpcyB0cmVhdGVkIGFzIGFyZWFcbiAgICAgICAgLCBnZXRYICAgICAgICAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHggdmFsdWVcbiAgICAgICAgLCBnZXRZICAgICAgICAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHkgdmFsdWVcbiAgICAgICAgLCBnZXRTaXplICAgICAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnNpemUgfHwgMX0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSBwb2ludCBzaXplXG4gICAgICAgICwgZ2V0U2hhcGUgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zaGFwZSB8fCAnY2lyY2xlJyB9IC8vIGFjY2Vzc29yIHRvIGdldCBwb2ludCBzaGFwZVxuICAgICAgICAsIGZvcmNlWCAgICAgICA9IFtdIC8vIExpc3Qgb2YgbnVtYmVycyB0byBGb3JjZSBpbnRvIHRoZSBYIHNjYWxlIChpZS4gMCwgb3IgYSBtYXggLyBtaW4sIGV0Yy4pXG4gICAgICAgICwgZm9yY2VZICAgICAgID0gW10gLy8gTGlzdCBvZiBudW1iZXJzIHRvIEZvcmNlIGludG8gdGhlIFkgc2NhbGVcbiAgICAgICAgLCBmb3JjZVNpemUgICAgPSBbXSAvLyBMaXN0IG9mIG51bWJlcnMgdG8gRm9yY2UgaW50byB0aGUgU2l6ZSBzY2FsZVxuICAgICAgICAsIGludGVyYWN0aXZlICA9IHRydWUgLy8gSWYgdHJ1ZSwgcGxvdHMgYSB2b3Jvbm9pIG92ZXJsYXkgZm9yIGFkdmFuY2VkIHBvaW50IGludGVyc2VjdGlvblxuICAgICAgICAsIHBvaW50QWN0aXZlICA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLm5vdEFjdGl2ZSB9IC8vIGFueSBwb2ludHMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBiZSBmaWx0ZXJlZCBvdXRcbiAgICAgICAgLCBwYWREYXRhICAgICAgPSBmYWxzZSAvLyBJZiB0cnVlLCBhZGRzIGhhbGYgYSBkYXRhIHBvaW50cyB3aWR0aCB0byBmcm9udCBhbmQgYmFjaywgZm9yIGxpbmluZyB1cCBhIGxpbmUgY2hhcnQgd2l0aCBhIGJhciBjaGFydFxuICAgICAgICAsIHBhZERhdGFPdXRlciA9IC4xIC8vb3V0ZXJQYWRkaW5nIHRvIGltaXRhdGUgb3JkaW5hbCBzY2FsZSBvdXRlciBwYWRkaW5nXG4gICAgICAgICwgY2xpcEVkZ2UgICAgID0gZmFsc2UgLy8gaWYgdHJ1ZSwgbWFza3MgcG9pbnRzIHdpdGhpbiB4IGFuZCB5IHNjYWxlXG4gICAgICAgICwgY2xpcFZvcm9ub2kgID0gdHJ1ZSAvLyBpZiB0cnVlLCBtYXNrcyBlYWNoIHBvaW50IHdpdGggYSBjaXJjbGUuLi4gY2FuIHR1cm4gb2ZmIHRvIHNsaWdodGx5IGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gICAgICAgICwgY2xpcFJhZGl1cyAgID0gZnVuY3Rpb24oKSB7IHJldHVybiAyNSB9IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgcmFkaXVzIGZvciB2b3Jvbm9pIHBvaW50IGNsaXBzXG4gICAgICAgICwgeERvbWFpbiAgICAgID0gbnVsbCAvLyBPdmVycmlkZSB4IGRvbWFpbiAoc2tpcHMgdGhlIGNhbGN1bGF0aW9uIGZyb20gZGF0YSlcbiAgICAgICAgLCB5RG9tYWluICAgICAgPSBudWxsIC8vIE92ZXJyaWRlIHkgZG9tYWluXG4gICAgICAgICwgeFJhbmdlICAgICAgID0gbnVsbCAvLyBPdmVycmlkZSB4IHJhbmdlXG4gICAgICAgICwgeVJhbmdlICAgICAgID0gbnVsbCAvLyBPdmVycmlkZSB5IHJhbmdlXG4gICAgICAgICwgc2l6ZURvbWFpbiAgID0gbnVsbCAvLyBPdmVycmlkZSBwb2ludCBzaXplIGRvbWFpblxuICAgICAgICAsIHNpemVSYW5nZSAgICA9IG51bGxcbiAgICAgICAgLCBzaW5nbGVQb2ludCAgPSBmYWxzZVxuICAgICAgICAsIGRpc3BhdGNoICAgICA9IGQzLmRpc3BhdGNoKCdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ3JlbmRlckVuZCcpXG4gICAgICAgICwgdXNlVm9yb25vaSAgID0gdHJ1ZVxuICAgICAgICAsIGR1cmF0aW9uICAgICA9IDI1MFxuICAgICAgICA7XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHgwLCB5MCwgejAgLy8gdXNlZCB0byBzdG9yZSBwcmV2aW91cyBzY2FsZXNcbiAgICAgICAgLCB0aW1lb3V0SURcbiAgICAgICAgLCBuZWVkc1VwZGF0ZSA9IGZhbHNlIC8vIEZsYWcgZm9yIHdoZW4gdGhlIHBvaW50cyBhcmUgdmlzdWFsbHkgdXBkYXRpbmcsIGJ1dCB0aGUgaW50ZXJhY3RpdmUgbGF5ZXIgaXMgYmVoaW5kLCB0byBkaXNhYmxlIHRvb2x0aXBzXG4gICAgICAgICwgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pXG4gICAgICAgIDtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy9hZGQgc2VyaWVzIGluZGV4IHRvIGVhY2ggZGF0YSBwb2ludCBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnNlcmllcyA9IGk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICAvLyByZW1hcCBhbmQgZmxhdHRlbiB0aGUgZGF0YSBmb3IgdXNlIGluIGNhbGN1bGF0aW5nIHRoZSBzY2FsZXMnIGRvbWFpbnNcbiAgICAgICAgICAgIHZhciBzZXJpZXNEYXRhID0gKHhEb21haW4gJiYgeURvbWFpbiAmJiBzaXplRG9tYWluKSA/IFtdIDogLy8gaWYgd2Uga25vdyB4RG9tYWluIGFuZCB5RG9tYWluIGFuZCBzaXplRG9tYWluLCBubyBuZWVkIHRvIGNhbGN1bGF0ZS4uLi4gaWYgU2l6ZSBpcyBjb25zdGFudCByZW1lbWJlciB0byBzZXQgc2l6ZURvbWFpbiB0byBzcGVlZCB1cCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIGQzLm1lcmdlKFxuICAgICAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpLCBzaXplOiBnZXRTaXplKGQsaSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB4ICAgLmRvbWFpbih4RG9tYWluIHx8IGQzLmV4dGVudChzZXJpZXNEYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pLmNvbmNhdChmb3JjZVgpKSlcblxuICAgICAgICAgICAgaWYgKHBhZERhdGEgJiYgZGF0YVswXSlcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbKGF2YWlsYWJsZVdpZHRoICogcGFkRGF0YU91dGVyICsgIGF2YWlsYWJsZVdpZHRoKSAvICgyICpkYXRhWzBdLnZhbHVlcy5sZW5ndGgpLCBhdmFpbGFibGVXaWR0aCAtIGF2YWlsYWJsZVdpZHRoICogKDEgKyBwYWREYXRhT3V0ZXIpIC8gKDIgKiBkYXRhWzBdLnZhbHVlcy5sZW5ndGgpICBdKTtcbiAgICAgICAgICAgIC8veC5yYW5nZShbYXZhaWxhYmxlV2lkdGggKiAuNSAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgYXZhaWxhYmxlV2lkdGggKiAoZGF0YVswXS52YWx1ZXMubGVuZ3RoIC0gLjUpICAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCBdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgeSAgIC5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0pLmNvbmNhdChmb3JjZVkpKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgeiAgIC5kb21haW4oc2l6ZURvbWFpbiB8fCBkMy5leHRlbnQoc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zaXplIH0pLmNvbmNhdChmb3JjZVNpemUpKSlcbiAgICAgICAgICAgICAgICAucmFuZ2Uoc2l6ZVJhbmdlIHx8IFsxNiwgMjU2XSk7XG5cbiAgICAgICAgICAgIC8vIElmIHNjYWxlJ3MgZG9tYWluIGRvbid0IGhhdmUgYSByYW5nZSwgc2xpZ2h0bHkgYWRqdXN0IHRvIG1ha2Ugb25lLi4uIHNvIGEgY2hhcnQgY2FuIHNob3cgYSBzaW5nbGUgZGF0YSBwb2ludFxuICAgICAgICAgICAgaWYgKHguZG9tYWluKClbMF0gPT09IHguZG9tYWluKClbMV0gfHwgeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSkgc2luZ2xlUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHguZG9tYWluKClbMF0gPT09IHguZG9tYWluKClbMV0pXG4gICAgICAgICAgICAgICAgeC5kb21haW4oKVswXSA/XG4gICAgICAgICAgICAgICAgICAgIHguZG9tYWluKFt4LmRvbWFpbigpWzBdIC0geC5kb21haW4oKVswXSAqIDAuMDEsIHguZG9tYWluKClbMV0gKyB4LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgICAgICAgICAgIDogeC5kb21haW4oWy0xLDFdKTtcblxuICAgICAgICAgICAgaWYgKHkuZG9tYWluKClbMF0gPT09IHkuZG9tYWluKClbMV0pXG4gICAgICAgICAgICAgICAgeS5kb21haW4oKVswXSA/XG4gICAgICAgICAgICAgICAgICAgIHkuZG9tYWluKFt5LmRvbWFpbigpWzBdIC0geS5kb21haW4oKVswXSAqIDAuMDEsIHkuZG9tYWluKClbMV0gKyB5LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgICAgICAgICAgIDogeS5kb21haW4oWy0xLDFdKTtcblxuICAgICAgICAgICAgaWYgKCBpc05hTih4LmRvbWFpbigpWzBdKSkge1xuICAgICAgICAgICAgICAgIHguZG9tYWluKFstMSwxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaXNOYU4oeS5kb21haW4oKVswXSkpIHtcbiAgICAgICAgICAgICAgICB5LmRvbWFpbihbLTEsMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICAgICAgICB5MCA9IHkwIHx8IHk7XG4gICAgICAgICAgICB6MCA9IHowIHx8IHo7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zY2F0dGVyJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc2NhdHRlciBudi1jaGFydC0nICsgaWQgKyAoc2luZ2xlUG9pbnQgPyAnIG52LXNpbmdsZS1wb2ludCcgOiAnJykpO1xuICAgICAgICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1wb2ludC1wYXRocycpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYtZWRnZS1jbGlwLScgKyBpZClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtZWRnZS1jbGlwLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChhdmFpbGFibGVIZWlnaHQgPiAwKSA/IGF2YWlsYWJsZUhlaWdodCA6IDApO1xuXG4gICAgICAgICAgICBnLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBpZCArICcpJyA6ICcnKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlSW50ZXJhY3RpdmVMYXllcigpIHtcblxuICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpdmUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHZhciBldmVudEVsZW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZDMubWVyZ2UoZGF0YS5tYXAoZnVuY3Rpb24oZ3JvdXAsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cC52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHBvaW50LCBwb2ludEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICpBZGRpbmcgbm9pc2UgdG8gbWFrZSBkdXBsaWNhdGVzIHZlcnkgdW5saWtlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKkluamVjdGluZyBzZXJpZXMgYW5kIHBvaW50IGluZGV4IGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogKkFkZGluZyBhICdqaXR0ZXInIHRvIHRoZSBwb2ludHMsIGJlY2F1c2UgdGhlcmUncyBhbiBpc3N1ZSBpbiBkMy5nZW9tLnZvcm9ub2kuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcFggPSBnZXRYKHBvaW50LHBvaW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcFkgPSBnZXRZKHBvaW50LHBvaW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbeChwWCkrIE1hdGgucmFuZG9tKCkgKiAxZS03LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkocFkpKyBNYXRoLnJhbmRvbSgpICogMWUtNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4LCBwb2ludF07IC8vdGVtcCBoYWNrIHRvIGFkZCBub2lzZSB1bnRpbGwgSSB0aGluayBvZiBhIGJldHRlciB3YXkgc28gdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocG9pbnRBcnJheSwgcG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRBY3RpdmUocG9pbnRBcnJheVs0XSwgcG9pbnRJbmRleCk7IC8vIElzc3VlICMyMzcuLiBtb3ZlIGZpbHRlciB0byBhZnRlciBtYXAsIHNvIHBvaW50SW5kZXggaXMgY29ycmVjdCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvL2luamVjdCBzZXJpZXMgYW5kIHBvaW50IGluZGV4IGZvciByZWZlcmVuY2UgaW50byB2b3Jvbm9pXG4gICAgICAgICAgICAgICAgaWYgKHVzZVZvcm9ub2kgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZih2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJc3N1ZSAjMjgzIC0gQWRkaW5nIDIgZHVtbXkgcG9pbnRzIHRvIHRoZSB2b3Jvbm9pIGIvYyB2b3Jvbm9pIHJlcXVpcmVzIG1pbiAzIHBvaW50cyB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4LnJhbmdlKClbMF0gLSAyMCwgeS5yYW5nZSgpWzBdIC0gMjAsIG51bGwsIG51bGxdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3gucmFuZ2UoKVsxXSArIDIwLCB5LnJhbmdlKClbMV0gKyAyMCwgbnVsbCwgbnVsbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMucHVzaChbeC5yYW5nZSgpWzBdIC0gMjAsIHkucmFuZ2UoKVswXSArIDIwLCBudWxsLCBudWxsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4LnJhbmdlKClbMV0gKyAyMCwgeS5yYW5nZSgpWzFdIC0gMjAsIG51bGwsIG51bGxdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdm9yb25vaSBzZWN0aW9ucyBmcm9tIGdvaW5nIG1vcmUgdGhhbiAxMCBvdXRzaWRlIG9mIGdyYXBoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIG92ZXJsYXAgd2l0aCBvdGhlciB0aGluZ3MgbGlrZSBsZWdlbmQgZXRjXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBkMy5nZW9tLnBvbHlnb24oW1xuICAgICAgICAgICAgICAgICAgICAgICAgWy0xMCwtMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgWy0xMCxoZWlnaHQgKyAxMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbd2lkdGggKyAxMCxoZWlnaHQgKyAxMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbd2lkdGggKyAxMCwtMTBdXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2b3Jvbm9pID0gZDMuZ2VvbS52b3Jvbm9pKHZlcnRpY2VzKS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IGJvdW5kcy5jbGlwKGQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJpZXMnOiB2ZXJ0aWNlc1tpXVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncG9pbnQnOiB2ZXJ0aWNlc1tpXVszXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBudWtlIGFsbCB2b3Jvbm9pIHBhdGhzIG9uIHJlbG9hZCBhbmQgcmVjcmVhdGUgdGhlbVxuICAgICAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LXBvaW50LXBhdGhzJykuc2VsZWN0QWxsKCdwYXRoJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludFBhdGhzID0gd3JhcC5zZWxlY3QoJy5udi1wb2ludC1wYXRocycpLnNlbGVjdEFsbCgncGF0aCcpLmRhdGEodm9yb25vaSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50UGF0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcInN2ZzpwYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZCB8fCAhZC5kYXRhIHx8IGQuZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnTSAwIDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgZC5kYXRhLmpvaW4oXCIsXCIpICsgXCJaXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJudi1wYXRoLVwiK2k7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsaXAtcGF0aFwiLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIFwidXJsKCNudi1jbGlwLVwiK2krXCIpXCI7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFpbiB0aGVzZSB0byBhYm92ZSB0byBzZWUgdGhlIHZvcm9ub2kgZWxlbWVudHMgKGdvb2QgZm9yIGRlYnVnZ2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwiZmlsbFwiLCBkMy5yZ2IoMjMwLCAyMzAsIDIzMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMC40KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8uc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwic3Ryb2tlXCIsIGQzLnJnYigyMDAsMjAwLDIwMCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwVm9yb25vaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdm9yb25vaSBzZWN0aW9ucyBhcmUgYWxyZWFkeSBzZXQgdG8gY2xpcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgY3JlYXRlIHRoZSBjaXJjbGVzIHdpdGggdGhlIElEcyB0aGV5IGV4cGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBzID0gd3JhcC5hcHBlbmQoXCJzdmc6Z1wiKS5hdHRyKFwiaWRcIiwgXCJudi1wb2ludC1jbGlwc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBzLnNlbGVjdEFsbChcImNsaXBQYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEodmVydGljZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwic3ZnOmNsaXBQYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcIm52LWNsaXAtXCIraTt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJzdmc6Y2lyY2xlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzFdOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgY2xpcFJhZGl1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VFdmVudENhbGxiYWNrID0gZnVuY3Rpb24oZCxtRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZGF0YVtkLnNlcmllc107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcmllcyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCAgPSBzZXJpZXMudmFsdWVzW2QucG9pbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtRGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgocG9pbnQsIGQucG9pbnQpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGQucG9pbnQpKSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBkLnBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludFBhdGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayhkLCBkaXNwYXRjaC5lbGVtZW50Q2xpY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VFdmVudENhbGxiYWNrKGQsIGRpc3BhdGNoLmVsZW1lbnREYmxDbGljayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VFdmVudENhbGxiYWNrKGQsIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VFdmVudENhbGxiYWNrKGQsIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAvLyBicmluZyBkYXRhIGluIGZvcm0gbmVlZGVkIGZvciBjbGljayBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFXaXRoUG9pbnRzID0gdmVydGljZXMubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IGQsXG4gICAgICAgICAgICAgICAgICAgICAnc2VyaWVzJzogdmVydGljZXNbaV1bMl0sXG4gICAgICAgICAgICAgICAgICAgICAncG9pbnQnOiB2ZXJ0aWNlc1tpXVszXVxuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBldmVudCBoYW5kbGVycyB0byBwb2ludHMgaW5zdGVhZCB2b3Jvbm9pIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcubnYtZ3JvdXBzJykuc2VsZWN0QWxsKCcubnYtZ3JvdXAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnLm52LXBvaW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLmRhdGEoZGF0YVdpdGhQb2ludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnYXV0bycpIC8vIHJlY2F0aXZhdGUgZXZlbnRzLCBkaXNhYmxlZCBieSBjc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL252LmxvZygndGVzdCcsIGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSB8fCAhZGF0YVtkLnNlcmllc10pIHJldHVybiAwOyAvL2NoZWNrIGlmIHRoaXMgaXMgYSBkdW1teSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgID0gc2VyaWVzLnZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChwb2ludCwgaSkpICsgbWFyZ2luLmxlZnQsIHkoZ2V0WShwb2ludCwgaSkpICsgbWFyZ2luLnRvcF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlIHx8ICFkYXRhW2Quc2VyaWVzXSkgcmV0dXJuIDA7IC8vY2hlY2sgaWYgdGhpcyBpcyBhIGR1bW15IHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCAgPSBzZXJpZXMudmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChwb2ludCwgaSkpICsgbWFyZ2luLmxlZnQsIHkoZ2V0WShwb2ludCwgaSkpICsgbWFyZ2luLnRvcF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUgfHwgIWRhdGFbZC5zZXJpZXNdKSByZXR1cm4gMDsgLy9jaGVjayBpZiB0aGlzIGlzIGEgZHVtbXkgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ICA9IHNlcmllcy52YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5IH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpO1xuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGdyb3Vwc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWdyb3VwIG52LXNlcmllcy0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSk7XG4gICAgICAgICAgICBncm91cHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnc2NhdHRlcjogZ3JvdXBzJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAuNSk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcG9pbnRzXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gZ3JvdXBzLnNlbGVjdEFsbCgncGF0aC5udi1wb2ludCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSk7XG4gICAgICAgICAgICBwb2ludHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkLGkpIHsgcmV0dXJuIGQuY29sb3IgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uIChkLGkpIHsgcmV0dXJuIGQuY29sb3IgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4MChnZXRYKGQsaSkpICsgJywnICsgeTAoZ2V0WShkLGkpKSArICcpJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLFxuICAgICAgICAgICAgICAgICAgICBudi51dGlscy5zeW1ib2woKVxuICAgICAgICAgICAgICAgICAgICAudHlwZShnZXRTaGFwZSlcbiAgICAgICAgICAgICAgICAgICAgLnNpemUoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB6KGdldFNpemUoZCxpKSkgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb2ludHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKS5zZWxlY3RBbGwoJ3BhdGgubnYtcG9pbnQnKVxuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdzY2F0dGVyIGV4aXQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsJyArIHkoZ2V0WShkLGkpKSArICcpJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgcG9pbnRzLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdudi1wb2ludCcsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdudi1wb2ludC0nICsgaSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJyxmYWxzZSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvaW50c1xuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdzY2F0dGVyIHBvaW50cycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAvL252LmxvZyhkLGksZ2V0WChkLGkpLCB4KGdldFgoZCxpKSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChnZXRYKGQsaSkpICsgJywnICsgeShnZXRZKGQsaSkpICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsXG4gICAgICAgICAgICAgICAgICAgIG52LnV0aWxzLnN5bWJvbCgpXG4gICAgICAgICAgICAgICAgICAgIC50eXBlKGdldFNoYXBlKVxuICAgICAgICAgICAgICAgICAgICAuc2l6ZShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHooZ2V0U2l6ZShkLGkpKSB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gRGVsYXkgdXBkYXRpbmcgdGhlIGludmlzaWJsZSBpbnRlcmFjdGl2ZSBsYXllciBmb3Igc21vb3RoZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTsgLy8gc3RvcCByZXBlYXQgY2FsbHMgdG8gdXBkYXRlSW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgdGltZW91dElEID0gc2V0VGltZW91dCh1cGRhdGVJbnRlcmFjdGl2ZUxheWVyLCAzMDApO1xuICAgICAgICAgICAgLy91cGRhdGVJbnRlcmFjdGl2ZUxheWVyKCk7XG5cbiAgICAgICAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgICAgICAgeDAgPSB4LmNvcHkoKTtcbiAgICAgICAgICAgIHkwID0geS5jb3B5KCk7XG4gICAgICAgICAgICB6MCA9IHouY29weSgpO1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3NjYXR0ZXIgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgLy8gdXRpbGl0eSBmdW5jdGlvbiBjYWxscyBwcm92aWRlZCBieSB0aGlzIGNoYXJ0XG4gICAgY2hhcnQuX2NhbGxzID0gbmV3IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbChcIi5udi1jaGFydC1cIiArIGlkICsgXCIgLm52LXBvaW50LmhvdmVyXCIpLmNsYXNzZWQoXCJob3ZlclwiLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRQb2ludCA9IGZ1bmN0aW9uIChzZXJpZXNJbmRleCwgcG9pbnRJbmRleCwgaXNIb3Zlck92ZXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIi5udi1jaGFydC1cIiArIGlkICsgXCIgLm52LXNlcmllcy1cIiArIHNlcmllc0luZGV4ICsgXCIgLm52LXBvaW50LVwiICsgcG9pbnRJbmRleClcbiAgICAgICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGlzSG92ZXJPdmVyKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZ2dlciBjYWxscyBmcm9tIGV2ZW50cyB0b29cbiAgICBkaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci5wb2ludCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaWYgKGludGVyYWN0aXZlKSBjaGFydC5fY2FsbHMuaGlnaGxpZ2h0UG9pbnQoZC5zZXJpZXNJbmRleCxkLnBvaW50SW5kZXgsdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnBvaW50JywgZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAoaW50ZXJhY3RpdmUpIGNoYXJ0Ll9jYWxscy5oaWdobGlnaHRQb2ludChkLnNlcmllc0luZGV4LGQucG9pbnRJbmRleCxmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4O30sIHNldDogZnVuY3Rpb24oXyl7eD1fO319LFxuICAgICAgICB5U2NhbGU6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHBvaW50U2NhbGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gejt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3o9Xzt9fSxcbiAgICAgICAgeERvbWFpbjogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHBvaW50RG9tYWluOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2l6ZURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3NpemVEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt4UmFuZ2U9Xzt9fSxcbiAgICAgICAgeVJhbmdlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgcG9pbnRSYW5nZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaXplUmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtzaXplUmFuZ2U9Xzt9fSxcbiAgICAgICAgZm9yY2VYOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVg7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVg9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVk9Xzt9fSxcbiAgICAgICAgZm9yY2VQb2ludDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVNpemU7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVNpemU9Xzt9fSxcbiAgICAgICAgaW50ZXJhY3RpdmU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcmFjdGl2ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVyYWN0aXZlPV87fX0sXG4gICAgICAgIHBvaW50QWN0aXZlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcG9pbnRBY3RpdmU7fSwgc2V0OiBmdW5jdGlvbihfKXtwb2ludEFjdGl2ZT1fO319LFxuICAgICAgICBwYWREYXRhT3V0ZXI6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBhZERhdGFPdXRlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BhZERhdGFPdXRlcj1fO319LFxuICAgICAgICBwYWREYXRhOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBhZERhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtwYWREYXRhPV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcEVkZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjbGlwRWRnZT1fO319LFxuICAgICAgICBjbGlwVm9yb25vaTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBWb3Jvbm9pO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcFZvcm9ub2k9Xzt9fSxcbiAgICAgICAgY2xpcFJhZGl1czogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwUmFkaXVzO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcFJhZGl1cz1fO319LFxuICAgICAgICBpZDogICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcblxuXG4gICAgICAgIC8vIHNpbXBsZSBmdW5jdG9yIG9wdGlvbnNcbiAgICAgICAgeDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYID0gZDMuZnVuY3RvcihfKTt9fSxcbiAgICAgICAgeTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZID0gZDMuZnVuY3RvcihfKTt9fSxcbiAgICAgICAgcG9pbnRTaXplOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRTaXplO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0U2l6ZSA9IGQzLmZ1bmN0b3IoXyk7fX0sXG4gICAgICAgIHBvaW50U2hhcGU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFNoYXBlO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0U2hhcGUgPSBkMy5mdW5jdG9yKF8pO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB1c2VWb3Jvbm9pOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB1c2VWb3Jvbm9pO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VWb3Jvbm9pID0gXztcbiAgICAgICAgICAgIGlmICh1c2VWb3Jvbm9pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNsaXBWb3Jvbm9pID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLnNjYXR0ZXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2NhdHRlciAgICAgID0gbnYubW9kZWxzLnNjYXR0ZXIoKVxuICAgICAgICAsIHhBeGlzICAgICAgICA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyAgICAgICAgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kICAgICAgID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgZGlzdFggICAgICAgID0gbnYubW9kZWxzLmRpc3RyaWJ1dGlvbigpXG4gICAgICAgICwgZGlzdFkgICAgICAgID0gbnYubW9kZWxzLmRpc3RyaWJ1dGlvbigpXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gICAgICAgPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDUwLCBsZWZ0OiA3NX1cbiAgICAgICAgLCB3aWR0aCAgICAgICAgPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ICAgICAgID0gbnVsbFxuICAgICAgICAsIGNvbG9yICAgICAgICA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgeCAgICAgICAgICAgID0gc2NhdHRlci54U2NhbGUoKVxuICAgICAgICAsIHkgICAgICAgICAgICA9IHNjYXR0ZXIueVNjYWxlKClcbiAgICAgICAgLCBzaG93RGlzdFggICAgPSBmYWxzZVxuICAgICAgICAsIHNob3dEaXN0WSAgICA9IGZhbHNlXG4gICAgICAgICwgc2hvd0xlZ2VuZCAgID0gdHJ1ZVxuICAgICAgICAsIHNob3dYQXhpcyAgICA9IHRydWVcbiAgICAgICAgLCBzaG93WUF4aXMgICAgPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAgICAgLCB0b29sdGlwcyAgICAgPSB0cnVlXG4gICAgICAgICwgdG9vbHRpcFggICAgID0gZnVuY3Rpb24oa2V5LCB4LCB5KSB7IHJldHVybiAnPHN0cm9uZz4nICsgeCArICc8L3N0cm9uZz4nIH1cbiAgICAgICAgLCB0b29sdGlwWSAgICAgPSBmdW5jdGlvbihrZXksIHgsIHkpIHsgcmV0dXJuICc8c3Ryb25nPicgKyB5ICsgJzwvc3Ryb25nPicgfVxuICAgICAgICAsIHRvb2x0aXAgICAgICA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZGF0ZSkgeyByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+J1xuICAgICAgICAgICAgKyAnPHA+JyArIGRhdGUgKyAnPC9wPicgfVxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIG5vRGF0YSAgICAgICA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICBzY2F0dGVyXG4gICAgICAgIC54U2NhbGUoeClcbiAgICAgICAgLnlTY2FsZSh5KVxuICAgIDtcbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1BhZGRpbmcoMTApXG4gICAgO1xuICAgIHlBeGlzXG4gICAgICAgIC5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgICAgICAudGlja1BhZGRpbmcoMTApXG4gICAgO1xuICAgIGRpc3RYXG4gICAgICAgIC5heGlzKCd4JylcbiAgICA7XG4gICAgZGlzdFlcbiAgICAgICAgLmF4aXMoJ3knKVxuICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHgwLCB5MFxuICAgICAgICAsIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgLy9UT0RPOiBtYWtlIHRvb2x0aXAgc3R5bGUgYW4gb3B0aW9uIGJldHdlZW4gc2luZ2xlIG9yIGR1YWwgb24gYXhlcyAobWF5YmUgb24gYWxsIGNoYXJ0cyB3aXRoIGF4ZXM/XG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICBsZWZ0WCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICAgICAgdG9wWCA9IHkucmFuZ2UoKVswXSArIG1hcmdpbi50b3AgKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgbGVmdFkgPSB4LnJhbmdlKClbMF0gKyBtYXJnaW4ubGVmdCArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcFkgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4VmFsID0geEF4aXMudGlja0Zvcm1hdCgpKHNjYXR0ZXIueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgeVZhbCA9IHlBeGlzLnRpY2tGb3JtYXQoKShzY2F0dGVyLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKTtcblxuICAgICAgICBpZiggdG9vbHRpcFggIT0gbnVsbCApXG4gICAgICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnRYLCB0b3BYXSwgdG9vbHRpcFgoZS5zZXJpZXMua2V5LCB4VmFsLCB5VmFsLCBlLCBjaGFydCksICduJywgMSwgb2Zmc2V0RWxlbWVudCwgJ3gtbnZ0b29sdGlwJyk7XG4gICAgICAgIGlmKCB0b29sdGlwWSAhPSBudWxsIClcbiAgICAgICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdFksIHRvcFldLCB0b29sdGlwWShlLnNlcmllcy5rZXksIHhWYWwsIHlWYWwsIGUsIGNoYXJ0KSwgJ2UnLCAxLCBvZmZzZXRFbGVtZW50LCAneS1udnRvb2x0aXAnKTtcbiAgICAgICAgaWYoIHRvb2x0aXAgIT0gbnVsbCApXG4gICAgICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4VmFsLCB5VmFsLCBlLnBvaW50LnRvb2x0aXAsIGUsIGNoYXJ0KSwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhzY2F0dGVyKTtcbiAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcbiAgICAgICAgaWYgKHNob3dEaXN0WCkgcmVuZGVyV2F0Y2gubW9kZWxzKGRpc3RYKTtcbiAgICAgICAgaWYgKHNob3dEaXN0WSkgcmVuZGVyV2F0Y2gubW9kZWxzKGRpc3RZKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgbm9EYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnc2NhdHRlciBpbW1lZGlhdGUnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBzY2F0dGVyLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IHNjYXR0ZXIueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zY2F0dGVyQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zY2F0dGVyQ2hhcnQgbnYtY2hhcnQtJyArIHNjYXR0ZXIuaWQoKSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICAvLyBiYWNrZ3JvdW5kIGZvciBwb2ludGVyIGV2ZW50c1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtYmFja2dyb3VuZCcpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIik7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zY2F0dGVyV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXJlZ3Jlc3Npb25MaW5lc1dyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1kaXN0V3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aCggYXZhaWxhYmxlV2lkdGggLyAyICk7XG5cbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoYXZhaWxhYmxlV2lkdGggLyAyKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICBzY2F0dGVyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpO1xuXG4gICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LXNjYXR0ZXJXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG4gICAgICAgICAgICAgICAgLmNhbGwoc2NhdHRlcik7XG5cblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1yZWdyZXNzaW9uTGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xpcC1wYXRoJywgJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkgKyAnKScpO1xuXG4gICAgICAgICAgICB2YXIgcmVnV3JhcCA9IHdyYXAuc2VsZWN0KCcubnYtcmVncmVzc2lvbkxpbmVzV3JhcCcpLnNlbGVjdEFsbCgnLm52LXJlZ0xpbmVzJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVnV3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXJlZ0xpbmVzJyk7XG5cbiAgICAgICAgICAgIHZhciByZWdMaW5lID0gcmVnV3JhcC5zZWxlY3RBbGwoJy5udi1yZWdMaW5lJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2RdXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlZ0xpbmUuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKS5hdHRyKCdjbGFzcycsICdudi1yZWdMaW5lJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMCk7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IGFkZCBsaW5lcyB1bmxlc3Mgd2UgaGF2ZSBzbG9wZSBhbmQgaW50ZXJjZXB0IHRvIHVzZVxuICAgICAgICAgICAgcmVnTGluZS5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmludGVyY2VwdCAmJiBkLnNsb3BlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnc2NhdHRlclBsdXNMaW5lQ2hhcnQ6IHJlZ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgucmFuZ2UoKVswXSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4LnJhbmdlKClbMV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoeC5kb21haW4oKVswXSAqIGQuc2xvcGUgKyBkLmludGVyY2VwdClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KHguZG9tYWluKClbMV0gKiBkLnNsb3BlICsgZC5pbnRlcmNlcHQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uIChkLCBpLCBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcihkLCBqKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZC5kaXNhYmxlZCB8fCB0eXBlb2YgZC5zbG9wZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGQuaW50ZXJjZXB0ID09PSAndW5kZWZpbmVkJykgPyAwIDogMVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggeEF4aXMudGlja3MoKSA/IHhBeGlzLnRpY2tzKCkgOiBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVIZWlnaHQgLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCB5QXhpcy50aWNrcygpID8geUF4aXMudGlja3MoKSA6IG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChzaG93RGlzdFgpIHtcbiAgICAgICAgICAgICAgICBkaXN0WFxuICAgICAgICAgICAgICAgICAgICAuZ2V0RGF0YShzY2F0dGVyLngoKSlcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcbiAgICAgICAgICAgICAgICBnRW50ZXIuc2VsZWN0KCcubnYtZGlzdFdyYXAnKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtZGlzdHJpYnV0aW9uWCcpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZGlzdHJpYnV0aW9uWCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChkaXN0WCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93RGlzdFkpIHtcbiAgICAgICAgICAgICAgICBkaXN0WVxuICAgICAgICAgICAgICAgICAgICAuZ2V0RGF0YShzY2F0dGVyLnkoKSlcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG4gICAgICAgICAgICAgICAgZ0VudGVyLnNlbGVjdCgnLm52LWRpc3RXcmFwJykuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWRpc3RyaWJ1dGlvblknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblknKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHJpZ2h0QWxpZ25ZQXhpcyA/IGF2YWlsYWJsZVdpZHRoIDogLWRpc3RZLnNpemUoKSApICsgJywwKScpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoZGlzdFkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHgtJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZS5wb3NbMV0gLSBhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkgKyAnIC5udi1zZXJpZXMtJyArIGUuc2VyaWVzSW5kZXggKyAnIC5udi1kaXN0eS0nICsgZS5wb2ludEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBlLnBvc1swXSArIGRpc3RYLnNpemUoKSk7XG5cbiAgICAgICAgICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICAgICAgICB4MCA9IHguY29weSgpO1xuICAgICAgICAgICAgeTAgPSB5LmNvcHkoKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3NjYXR0ZXIgd2l0aCBsaW5lIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcblxuICAgICAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHgtJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIDApO1xuICAgICAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHktJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIGRpc3RZLnNpemUoKSk7XG4gICAgfSk7XG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5zY2F0dGVyID0gc2NhdHRlcjtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LmRpc3RYID0gZGlzdFg7XG4gICAgY2hhcnQuZGlzdFkgPSBkaXN0WTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dEaXN0WDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dEaXN0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dEaXN0WD1fO319LFxuICAgICAgICBzaG93RGlzdFk6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93RGlzdFk7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93RGlzdFk9Xzt9fSxcbiAgICAgICAgc2hvd0xlZ2VuZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcbiAgICAgICAgc2hvd1hBeGlzOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICB0b29sdGlwczogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXA7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwPV87fX0sXG4gICAgICAgIHRvb2x0aXBYQ29udGVudDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBYO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcFg9Xzt9fSxcbiAgICAgICAgdG9vbHRpcFlDb250ZW50OiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcFk7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwWT1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIGR1cmF0aW9uOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7ZHVyYXRpb249Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCAoXykgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBkaXN0WC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBkaXN0WS5jb2xvcihjb2xvcik7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgc2NhdHRlcik7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zcGFya2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDIsIHJpZ2h0OiAwLCBib3R0b206IDIsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA0MDBcbiAgICAgICAgLCBoZWlnaHQgPSAzMlxuICAgICAgICAsIGFuaW1hdGUgPSB0cnVlXG4gICAgICAgICwgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihbJyMwMDAnXSlcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICA7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCAgIC5kb21haW4oeERvbWFpbiB8fCBkMy5leHRlbnQoZGF0YSwgZ2V0WCApKVxuICAgICAgICAgICAgICAgIC5yYW5nZSh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHkgICAuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGRhdGEsIGdldFkgKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXNwYXJrbGluZScpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXNwYXJrbGluZScpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpXG5cbiAgICAgICAgICAgIHZhciBwYXRocyA9IHdyYXAuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBbZF0gfSk7XG4gICAgICAgICAgICBwYXRocy5lbnRlcigpLmFwcGVuZCgncGF0aCcpO1xuICAgICAgICAgICAgcGF0aHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcGF0aHNcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHgoZ2V0WChkLGkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAueShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHkoZ2V0WShkLGkpKSB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogQWRkIENVUlJFTlQgZGF0YSBwb2ludCAoTmVlZCBNaW4sIE1hYywgQ3VycmVudCAvIE1vc3QgcmVjZW50KVxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHdyYXAuc2VsZWN0QWxsKCdjaXJjbGUubnYtcG9pbnQnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlWYWx1ZXMgPSBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7IHJldHVybiBnZXRZKGQsaSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwb2ludEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvaW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9pbnQgPSBwb2ludEluZGV4KHlWYWx1ZXMubGFzdEluZGV4T2YoeS5kb21haW4oKVsxXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluUG9pbnQgPSBwb2ludEluZGV4KHlWYWx1ZXMuaW5kZXhPZih5LmRvbWFpbigpWzBdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludEluZGV4KHlWYWx1ZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWluUG9pbnQsIG1heFBvaW50LCBjdXJyZW50UG9pbnRdLmZpbHRlcihmdW5jdGlvbiAoZCkge3JldHVybiBkICE9IG51bGw7fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2ludHMuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpO1xuICAgICAgICAgICAgcG9pbnRzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHBvaW50c1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geChnZXRYKGQsZC5wb2ludEluZGV4KSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHkoZ2V0WShkLGQucG9pbnRJbmRleCkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0WChkLCBkLnBvaW50SW5kZXgpID09IHguZG9tYWluKClbMV0gPyAnbnYtcG9pbnQgbnYtY3VycmVudFZhbHVlJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WShkLCBkLnBvaW50SW5kZXgpID09IHkuZG9tYWluKClbMF0gPyAnbnYtcG9pbnQgbnYtbWluVmFsdWUnIDogJ252LXBvaW50IG52LW1heFZhbHVlJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeERvbWFpbjogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eFJhbmdlPV87fX0sXG4gICAgICAgIHlSYW5nZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIHhTY2FsZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5O30sIHNldDogZnVuY3Rpb24oXyl7eT1fO319LFxuICAgICAgICBhbmltYXRlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGFuaW1hdGU7fSwgc2V0OiBmdW5jdGlvbihfKXthbmltYXRlPV87fX0sXG5cbiAgICAgICAgLy9mdW5jdG9yIG9wdGlvbnNcbiAgICAgICAgeDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9ZDMuZnVuY3RvcihfKTt9fSxcbiAgICAgICAgeToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFk9ZDMuZnVuY3RvcihfKTt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLnNwYXJrbGluZVBsdXMgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNwYXJrbGluZSA9IG52Lm1vZGVscy5zcGFya2xpbmUoKTtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAxNSwgcmlnaHQ6IDEwMCwgYm90dG9tOiAxMCwgbGVmdDogNTB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIHhcbiAgICAgICAgLCB5XG4gICAgICAgICwgaW5kZXggPSBbXVxuICAgICAgICAsIHBhdXNlZCA9IGZhbHNlXG4gICAgICAgICwgeFRpY2tGb3JtYXQgPSBkMy5mb3JtYXQoJyxyJylcbiAgICAgICAgLCB5VGlja0Zvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgICAgICwgc2hvd1ZhbHVlID0gdHJ1ZVxuICAgICAgICAsIGFsaWduVmFsdWUgPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnblZhbHVlID0gZmFsc2VcbiAgICAgICAgLCBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXG4gICAgICAgIDtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY2hhcnQoc2VsZWN0aW9uKSB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gc3BhcmtsaW5lLnkoKShkYXRhW2RhdGEubGVuZ3RoLTFdLCBkYXRhLmxlbmd0aC0xKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc3BhcmtsaW5lLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IHNwYXJrbGluZS55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXNwYXJrbGluZXBsdXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zcGFya2xpbmVwbHVzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc3BhcmtsaW5lV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXZhbHVlV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWhvdmVyQXJlYScpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICB2YXIgc3BhcmtsaW5lV3JhcCA9IGcuc2VsZWN0KCcubnYtc3BhcmtsaW5lV3JhcCcpO1xuXG4gICAgICAgICAgICBzcGFya2xpbmUud2lkdGgoYXZhaWxhYmxlV2lkdGgpLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICAgICAgc3BhcmtsaW5lV3JhcC5jYWxsKHNwYXJrbGluZSk7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZVdyYXAgPSBnLnNlbGVjdCgnLm52LXZhbHVlV3JhcCcpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVXcmFwLnNlbGVjdEFsbCgnLm52LWN1cnJlbnRWYWx1ZScpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2N1cnJlbnRWYWx1ZV0pO1xuXG4gICAgICAgICAgICB2YWx1ZS5lbnRlcigpLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LWN1cnJlbnRWYWx1ZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgcmlnaHRBbGlnblZhbHVlID8gLTggOiA4KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuOWVtJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcmlnaHRBbGlnblZhbHVlID8gJ2VuZCcgOiAnc3RhcnQnKTtcblxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGF2YWlsYWJsZVdpZHRoICsgKHJpZ2h0QWxpZ25WYWx1ZSA/IG1hcmdpbi5yaWdodCA6IDApKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYWxpZ25WYWx1ZSA/IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHkoZCkgfSA6IDApXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgc3BhcmtsaW5lLmNvbG9yKCkoZGF0YVtkYXRhLmxlbmd0aC0xXSwgZGF0YS5sZW5ndGgtMSkpXG4gICAgICAgICAgICAgICAgLnRleHQoeVRpY2tGb3JtYXQoY3VycmVudFZhbHVlKSk7XG5cbiAgICAgICAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1ob3ZlckFyZWEnKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgc3BhcmtsaW5lSG92ZXIpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBwYXVzZWQgPSAhcGF1c2VkIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkgeyBpbmRleCA9IFtdOyB1cGRhdGVWYWx1ZUxpbmUoKTsgfSk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtaG92ZXJBcmVhIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyAtbWFyZ2luLmxlZnQgKyAnLCcgKyAtbWFyZ2luLnRvcCArICcpJyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCArIG1hcmdpbi50b3ApO1xuXG4gICAgICAgICAgICAvL2luZGV4IGlzIGN1cnJlbnRseSBnbG9iYWwgKHdpdGhpbiB0aGUgY2hhcnQpLCBtYXkgb3IgbWF5IG5vdCBrZWVwIGl0IHRoYXQgd2F5XG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZUxpbmUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdXNlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhvdmVyVmFsdWUgPSBnLnNlbGVjdEFsbCgnLm52LWhvdmVyVmFsdWUnKS5kYXRhKGluZGV4KVxuXG4gICAgICAgICAgICAgICAgdmFyIGhvdmVyRW50ZXIgPSBob3ZlclZhbHVlLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWhvdmVyVmFsdWUnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAwKTtcblxuICAgICAgICAgICAgICAgIGhvdmVyVmFsdWUuZXhpdCgpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMjUwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAwKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBob3ZlclZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4KHNwYXJrbGluZS54KCkoZGF0YVtkXSxkKSkgKyAnLDApJyB9KVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDI1MClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4Lmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaG92ZXJFbnRlci5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAtbWFyZ2luLnRvcClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGhvdmVyRW50ZXIuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYteFZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtNilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtbWFyZ2luLnRvcClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuOWVtJylcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtaG92ZXJWYWx1ZSAubnYteFZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoeFRpY2tGb3JtYXQoc3BhcmtsaW5lLngoKShkYXRhW2luZGV4WzBdXSwgaW5kZXhbMF0pKSk7XG5cbiAgICAgICAgICAgICAgICBob3ZlckVudGVyLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LXlWYWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgNilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtbWFyZ2luLnRvcClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy45ZW0nKVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1ob3ZlclZhbHVlIC5udi15VmFsdWUnKVxuICAgICAgICAgICAgICAgICAgICAudGV4dCh5VGlja0Zvcm1hdChzcGFya2xpbmUueSgpKGRhdGFbaW5kZXhbMF1dLCBpbmRleFswXSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3BhcmtsaW5lSG92ZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdXNlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGQzLm1vdXNlKHRoaXMpWzBdIC0gbWFyZ2luLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRDbG9zZXN0SW5kZXgoZGF0YSwgeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhzcGFya2xpbmUueCgpKGRhdGFbMF0sIDApIC0geCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNwYXJrbGluZS54KCkoZGF0YVtpXSwgaSkgLSB4KSA8IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhzcGFya2xpbmUueCgpKGRhdGFbaV0sIGkpIC0geCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGluZGV4ID0gW2dldENsb3Nlc3RJbmRleChkYXRhLCBNYXRoLnJvdW5kKHguaW52ZXJ0KHBvcykpKV07XG4gICAgICAgICAgICAgICAgdXBkYXRlVmFsdWVMaW5lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5zcGFya2xpbmUgPSBzcGFya2xpbmU7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeFRpY2tGb3JtYXQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4VGlja0Zvcm1hdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hUaWNrRm9ybWF0PV87fX0sXG4gICAgICAgIHlUaWNrRm9ybWF0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVRpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt5VGlja0Zvcm1hdD1fO319LFxuICAgICAgICBzaG93VmFsdWU6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dWYWx1ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dWYWx1ZT1fO319LFxuICAgICAgICBhbGlnblZhbHVlOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGFsaWduVmFsdWU7fSwgc2V0OiBmdW5jdGlvbihfKXthbGlnblZhbHVlPV87fX0sXG4gICAgICAgIHJpZ2h0QWxpZ25WYWx1ZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnblZhbHVlO30sIHNldDogZnVuY3Rpb24oXyl7cmlnaHRBbGlnblZhbHVlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgc3BhcmtsaW5lKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMuc3RhY2tlZEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA5NjBcbiAgICAgICAgLCBoZWlnaHQgPSA1MDBcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpIC8vIGEgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGUgY29sb3JcbiAgICAgICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW5jYXNlIHVzZXIgZG9lc24ndCBzZWxldCBvbmVcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSB4IHZhbHVlIGZyb20gYSBkYXRhIHBvaW50XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeSB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICAgICAsIHN0eWxlID0gJ3N0YWNrJ1xuICAgICAgICAsIG9mZnNldCA9ICd6ZXJvJ1xuICAgICAgICAsIG9yZGVyID0gJ2RlZmF1bHQnXG4gICAgICAgICwgaW50ZXJwb2xhdGUgPSAnbGluZWFyJyAgLy8gY29udHJvbHMgdGhlIGxpbmUgaW50ZXJwb2xhdGlvblxuICAgICAgICAsIGNsaXBFZGdlID0gZmFsc2UgLy8gaWYgdHJ1ZSwgbWFza3MgbGluZXMgd2l0aGluIHggYW5kIHkgc2NhbGVcbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgc2NhdHRlciA9IG52Lm1vZGVscy5zY2F0dGVyKClcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGRpc3BhdGNoID0gIGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdhcmVhQ2xpY2snLCAnYXJlYU1vdXNlb3ZlcicsICdhcmVhTW91c2VvdXQnLCdyZW5kZXJFbmQnKVxuICAgICAgICA7XG5cbiAgICAvLyBzY2F0dGVyIGlzIGludGVyYWN0aXZlIGJ5IGRlZmF1bHQsIGJ1dCB0aGlzIGNoYXJ0IGlzbid0IHNvIG11c3QgZGlzYWJsZVxuICAgIHNjYXR0ZXIuaW50ZXJhY3RpdmUoZmFsc2UpO1xuXG4gICAgc2NhdHRlclxuICAgICAgICAucG9pbnRTaXplKDIuMikgLy8gZGVmYXVsdCBzaXplXG4gICAgICAgIC5wb2ludERvbWFpbihbMi4yLCAyLjJdKSAvLyBhbGwgdGhlIHNhbWUgc2l6ZSBieSBkZWZhdWx0XG4gICAgO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIG9mZnNldDpcbiAgICAgKiAgICd3aWdnbGUnIChzdHJlYW0pXG4gICAgICogICAnemVybycgKHN0YWNrZWQpXG4gICAgICogICAnZXhwYW5kJyAobm9ybWFsaXplIHRvIDEwMCUpXG4gICAgICogICAnc2lsaG91ZXR0ZScgKHNpbXBsZSBjZW50ZXJlZClcbiAgICAgKlxuICAgICAqIG9yZGVyOlxuICAgICAqICAgJ2luc2lkZS1vdXQnIChzdHJlYW0pXG4gICAgICogICAnZGVmYXVsdCcgKGlucHV0IG9yZGVyKVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhzY2F0dGVyKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCA9IHNjYXR0ZXIueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gc2NhdHRlci55U2NhbGUoKTtcblxuICAgICAgICAgICAgdmFyIGRhdGFSYXcgPSBkYXRhO1xuICAgICAgICAgICAgLy8gSW5qZWN0aW5nIHBvaW50IGluZGV4IGludG8gZWFjaCBwb2ludCBiZWNhdXNlIGQzLmxheW91dC5zdGFjaygpLm91dCBkb2VzIG5vdCBnaXZlIGluZGV4XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oYXNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgIGFzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGFzZXJpZXMudmFsdWVzID0gYXNlcmllcy52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsIGopIHtcbiAgICAgICAgICAgICAgICAgICAgZC5pbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGQuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZGF0YUZpbHRlcmVkID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGF0YSA9IGQzLmxheW91dC5zdGFjaygpXG4gICAgICAgICAgICAgICAgLm9yZGVyKG9yZGVyKVxuICAgICAgICAgICAgICAgIC5vZmZzZXQob2Zmc2V0KVxuICAgICAgICAgICAgICAgIC52YWx1ZXMoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSkgIC8vVE9ETzogbWFrZSB2YWx1ZXMgY3VzdG9taXplYWJsZSBpbiBFVkVSWSBtb2RlbCBpbiB0aGlzIGZhc2hpb25cbiAgICAgICAgICAgICAgICAueChnZXRYKVxuICAgICAgICAgICAgICAgIC55KGdldFkpXG4gICAgICAgICAgICAgICAgLm91dChmdW5jdGlvbihkLCB5MCwgeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUhlaWdodCA9IChnZXRZKGQpID09PSAwKSA/IDAgOiB5O1xuICAgICAgICAgICAgICAgICAgICBkLmRpc3BsYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTA6IHkwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIChkYXRhRmlsdGVyZWQpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc3RhY2tlZGFyZWEnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zdGFja2VkYXJlYScpO1xuICAgICAgICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1hcmVhV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXNjYXR0ZXJXcmFwJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgc2NhdHRlclxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAueChnZXRYKVxuICAgICAgICAgICAgICAgIC55KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZGlzcGxheS55ICsgZC5kaXNwbGF5LnkwIH0pXG4gICAgICAgICAgICAgICAgLmZvcmNlWShbMF0pXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBkLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHZhciBzY2F0dGVyV3JhcCA9IGcuc2VsZWN0KCcubnYtc2NhdHRlcldyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKTtcblxuICAgICAgICAgICAgc2NhdHRlcldyYXAuY2FsbChzY2F0dGVyKTtcblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1lZGdlLWNsaXAtJyArIGlkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJyNudi1lZGdlLWNsaXAtJyArIGlkICsgJyByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgZy5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgIHsgcmV0dXJuIHgoZ2V0WChkLGkpKSB9KVxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KGQuZGlzcGxheS55MClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KGQuZGlzcGxheS55ICsgZC5kaXNwbGF5LnkwKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKTtcblxuICAgICAgICAgICAgdmFyIHplcm9BcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgIHsgcmV0dXJuIHgoZ2V0WChkLGkpKSB9KVxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbihkKSB7IHJldHVybiB5KGQuZGlzcGxheS55MCkgfSlcbiAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24oZCkgeyByZXR1cm4geShkLmRpc3BsYXkueTApIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0aCA9IGcuc2VsZWN0KCcubnYtYXJlYVdyYXAnKS5zZWxlY3RBbGwoJ3BhdGgubnYtYXJlYScpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgcGF0aC5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtYXJlYSBudi1hcmVhLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gemVyb0FyZWEoZC52YWx1ZXMsIGQuc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmFyZWFNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllc0luZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmFyZWFNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFtkMy5ldmVudC5wYWdlWCwgZDMuZXZlbnQucGFnZVldLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guYXJlYUNsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXNJbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGF0aC5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICBwYXRoLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgZC5zZXJpZXNJbmRleClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgZC5zZXJpZXNJbmRleCkgfSk7XG4gICAgICAgICAgICBwYXRoLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwnc3RhY2tlZEFyZWEgcGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZWEoZC52YWx1ZXMsaSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci5hcmVhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY2hhcnQtJyArIGlkICsgJyAubnYtYXJlYS0nICsgZS5zZXJpZXNJbmRleCkuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LmFyZWEnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jaGFydC0nICsgaWQgKyAnIC5udi1hcmVhLScgKyBlLnNlcmllc0luZGV4KS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL1NwZWNpYWwgb2Zmc2V0IGZ1bmN0aW9uc1xuICAgICAgICAgICAgY2hhcnQuZDNfc3RhY2tlZE9mZnNldF9zdGFja1BlcmNlbnQgPSBmdW5jdGlvbihzdGFja0RhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrRGF0YS5sZW5ndGgsICAgIC8vSG93IG1hbnkgc2VyaWVzXG4gICAgICAgICAgICAgICAgICAgIG0gPSBzdGFja0RhdGFbMF0ubGVuZ3RoLCAgICAgLy9ob3cgbWFueSBwb2ludHMgcGVyIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICBrID0gMSAvIG4sXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgICAgIHkwID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7IC8vTG9vcGluZyB0aHJvdWdoIGFsbCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbyA9IDA7IGkgPCBkYXRhUmF3Lmxlbmd0aDsgaSsrKSB7IC8vbG9vcGluZyB0aHJvdWdoIHNlcmllcydcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gKz0gZ2V0WShkYXRhUmF3W2ldLnZhbHVlc1tqXSk7ICAgLy90b3RhbCB2YWx1ZSBvZiBhbGwgcG9pbnRzIGF0IGEgY2VydGlhbiBwb2ludCBpbiB0aW1lLlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrRGF0YVtpXVtqXVsxXSAvPSBvO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrRGF0YVtpXVtqXVsxXSA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeTBbal0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB5MDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdzdGFja2VkQXJlYSBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljay5hcmVhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC5hcmVhQ2xpY2soZSk7XG4gICAgfSk7XG4gICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG4gICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBHbG9iYWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LnNjYXR0ZXIgPSBzY2F0dGVyO1xuXG4gICAgY2hhcnQuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlO1xuICAgICAgICBpbnRlcnBvbGF0ZSA9IF87XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgc2NhdHRlci5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBjbGlwRWRnZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcEVkZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjbGlwRWRnZT1fO319LFxuICAgICAgICBvZmZzZXQ6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gb2Zmc2V0O30sIHNldDogZnVuY3Rpb24oXyl7b2Zmc2V0PV87fX0sXG4gICAgICAgIG9yZGVyOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBvcmRlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe29yZGVyPV87fX0sXG4gICAgICAgIGludGVycG9sYXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcnBvbGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVycG9sYXRlPV87fX0sXG5cbiAgICAgICAgLy8gc2ltcGxlIGZ1bmN0b3Igb3B0aW9uc1xuICAgICAgICB4OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFggPSBkMy5mdW5jdG9yKF8pO319LFxuICAgICAgICB5OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFkgPSBkMy5mdW5jdG9yKF8pO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHN0eWxlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdHlsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgc3R5bGUgPSBfO1xuICAgICAgICAgICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YWNrJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub2Zmc2V0KCd6ZXJvJyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9yZGVyKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmVhbSc6XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9mZnNldCgnd2lnZ2xlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9yZGVyKCdpbnNpZGUtb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmVhbS1jZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICBjaGFydC5vZmZzZXQoJ3NpbGhvdWV0dGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub3JkZXIoJ2luc2lkZS1vdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwYW5kJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub2Zmc2V0KCdleHBhbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub3JkZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhY2tfcGVyY2VudCc6XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9mZnNldChjaGFydC5kM19zdGFja2VkT2Zmc2V0X3N0YWNrUGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9yZGVyKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBzY2F0dGVyLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBzY2F0dGVyKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMuc3RhY2tlZEFyZWFDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc3RhY2tlZCA9IG52Lm1vZGVscy5zdGFja2VkQXJlYSgpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBpbnRlcmFjdGl2ZUxheWVyID0gbnYuaW50ZXJhY3RpdmVHdWlkZWxpbmUoKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyNSwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBmYWxzZVxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgb24gJyArIHggKyAnPC9wPidcbiAgICAgICAgfVxuICAgICAgICAsIHggLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnhTY2FsZSgpXG4gICAgICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAgICAgLCB5QXhpc1RpY2tGb3JtYXQgPSBkMy5mb3JtYXQoJywuMmYnKVxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJ1xuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywncmVuZGVyRW5kJylcbiAgICAgICAgLCBjb250cm9sV2lkdGggPSAyNTBcbiAgICAgICAgLCBjRGF0YSA9IFsnU3RhY2tlZCcsJ1N0cmVhbScsJ0V4cGFuZGVkJ11cbiAgICAgICAgLCBjb250cm9sTGFiZWxzID0ge31cbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICBzdGF0ZS5zdHlsZSA9IHN0YWNrZWQuc3R5bGUoKTtcbiAgICB4QXhpcy5vcmllbnQoJ2JvdHRvbScpLnRpY2tQYWRkaW5nKDcpO1xuICAgIHlBeGlzLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuXG4gICAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG4gICAgdmFyIHN0eWxlID0gc3RhY2tlZC5zdHlsZSgpO1xuXG4gICAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShzdGFja2VkLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkoc3RhY2tlZC55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3RhY2tlZC5zdHlsZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3R5bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoc3RhY2tlZCk7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgc2V0IHN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc3RhY2tlZC54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBzdGFja2VkLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc3RhY2tlZEFyZWFDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXN0YWNrZWRBcmVhQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZChcInJlY3RcIikuc3R5bGUoXCJvcGFjaXR5XCIsMCk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc3RhY2tlZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udHJvbHNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtaW50ZXJhY3RpdmUnKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoXCJyZWN0XCIpLmF0dHIoXCJ3aWR0aFwiLGF2YWlsYWJsZVdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRXaWR0aCA9IChzaG93Q29udHJvbHMpID8gYXZhaWxhYmxlV2lkdGggLSBjb250cm9sV2lkdGggOiBhdmFpbGFibGVXaWR0aDtcblxuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChsZWdlbmRXaWR0aCk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJykuZGF0dW0oZGF0YSkuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChhdmFpbGFibGVXaWR0aC1sZWdlbmRXaWR0aCkgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb250cm9sc1xuICAgICAgICAgICAgaWYgKHNob3dDb250cm9scykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29udHJvbExhYmVscy5zdGFja2VkIHx8ICdTdGFja2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6ICdTdGFja2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBzdGFja2VkLnN0eWxlKCkgIT0gJ3N0YWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnc3RhY2snXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29udHJvbExhYmVscy5zdHJlYW0gfHwgJ1N0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiAnU3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBzdGFja2VkLnN0eWxlKCkgIT0gJ3N0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3N0cmVhbSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjb250cm9sTGFiZWxzLmV4cGFuZGVkIHx8ICdFeHBhbmRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiAnRXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHN0YWNrZWQuc3R5bGUoKSAhPSAnZXhwYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZXhwYW5kJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGNvbnRyb2xMYWJlbHMuc3RhY2tfcGVyY2VudCB8fCAnU3RhY2sgJScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiAnU3RhY2tfUGVyY2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogc3RhY2tlZC5zdHlsZSgpICE9ICdzdGFja19wZXJjZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnc3RhY2tfcGVyY2VudCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBjb250cm9sV2lkdGggPSAoY0RhdGEubGVuZ3RoLzMpICogMjYwO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY0RhdGEuaW5kZXhPZihkLm1ldGFLZXkpICE9PSAtMTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aCggY29udHJvbFdpZHRoIClcbiAgICAgICAgICAgICAgICAgICAgLmNvbG9yKFsnIzQ0NCcsICcjNDQ0JywgJyM0NDQnXSk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBNYXRoLm1heChjb250cm9scy5oZWlnaHQoKSwgbGVnZW5kLmhlaWdodCgpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IE1hdGgubWF4KGNvbnRyb2xzLmhlaWdodCgpLCBsZWdlbmQuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NldCB1cCBpbnRlcmFjdGl2ZSBsYXllclxuICAgICAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHtsZWZ0OiBtYXJnaW4ubGVmdCwgdG9wOiBtYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLnN2Z0NvbnRhaW5lcihjb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC54U2NhbGUoeCk7XG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVcIikuY2FsbChpbnRlcmFjdGl2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhY2tlZFxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFja2VkV3JhcCA9IGcuc2VsZWN0KCcubnYtc3RhY2tlZFdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKTtcblxuICAgICAgICAgICAgc3RhY2tlZFdyYXAudHJhbnNpdGlvbigpLmNhbGwoc3RhY2tlZCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEF4ZXNcbiAgICAgICAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICB4QXhpcy5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGF2YWlsYWJsZUhlaWdodCArICcpJyk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMClcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXMuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKHN0YWNrZWQub2Zmc2V0KCkgPT0gJ3dpZ2dsZScgPyAwIDogbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVXaWR0aCwgMClcbiAgICAgICAgICAgICAgICAgICAgLnNldFRpY2tGb3JtYXQoIChzdGFja2VkLnN0eWxlKCkgPT0gJ2V4cGFuZCcgfHwgc3RhY2tlZC5zdHlsZSgpID09ICdzdGFja19wZXJjZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZDMuZm9ybWF0KCclJykgOiB5QXhpc1RpY2tGb3JtYXQpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgc3RhY2tlZC5kaXNwYXRjaC5vbignYXJlYUNsaWNrLnRvZ2dsZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSAoaSAhPSBlLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWQuZGlzYWJsZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICBzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgc3RhY2tlZC5zdHlsZShkLnN0eWxlKTtcblxuXG4gICAgICAgICAgICAgICAgc3RhdGUuc3R5bGUgPSBzdGFja2VkLnN0eWxlKCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzdGFja2VkLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgICAgIHZhciBzaW5nbGVQb2ludCwgcG9pbnRJbmRleCwgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4ID0gbnYuaW50ZXJhY3RpdmVCaXNlY3Qoc2VyaWVzLnZhbHVlcywgZS5wb2ludFhWYWx1ZSwgY2hhcnQueCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrZWQuaGlnaGxpZ2h0UG9pbnQoaSwgcG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlUG9pbnQgPT09ICd1bmRlZmluZWQnKSBzaW5nbGVQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFhMb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHBvaW50WExvY2F0aW9uID0gY2hhcnQueFNjYWxlKCkoY2hhcnQueCgpKHBvaW50LHBvaW50SW5kZXgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB3ZSBhcmUgaW4gJ2V4cGFuZCcgbW9kZSwgdXNlIHRoZSBzdGFja2VkIHBlcmNlbnQgdmFsdWUgaW5zdGVhZCBvZiByYXcgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9vbHRpcFZhbHVlID0gKHN0YWNrZWQuc3R5bGUoKSA9PSAnZXhwYW5kJykgPyBwb2ludC5kaXNwbGF5LnkgOiBjaGFydC55KCkocG9pbnQscG9pbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc2VyaWVzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9vbHRpcFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcihzZXJpZXMsc2VyaWVzLnNlcmllc0luZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkVmFsdWU6IHBvaW50LmRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGFsbERhdGEucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgLy9IaWdobGlnaHQgdGhlIHRvb2x0aXAgZW50cnkgYmFzZWQgb24gd2hpY2ggc3RhY2sgdGhlIG1vdXNlIGlzIGNsb3Nlc3QgdG8uXG4gICAgICAgICAgICAgICAgaWYgKGFsbERhdGEubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVZhbHVlID0gY2hhcnQueVNjYWxlKCkuaW52ZXJ0KGUubW91c2VZKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlEaXN0TWF4ID0gSW5maW5pdHksIGluZGV4VG9IaWdobGlnaHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UbyBoYW5kbGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBzdGFja2VkIGFyZWEgY2hhcnQgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gdXNlIGFic29sdXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy93aGVuIGNoZWNraW5nIGlmIHRoZSBtb3VzZSBZIHZhbHVlIGlzIHdpdGhpbiB0aGUgc3RhY2sgYXJlYS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHlWYWx1ZSA9IE1hdGguYWJzKHlWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZFkwID0gTWF0aC5hYnMoc2VyaWVzLnN0YWNrZWRWYWx1ZS55MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZFkgPSBNYXRoLmFicyhzZXJpZXMuc3RhY2tlZFZhbHVlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB5VmFsdWUgPj0gc3RhY2tlZFkwICYmIHlWYWx1ZSA8PSAoc3RhY2tlZFkgKyBzdGFja2VkWTApKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4VG9IaWdobGlnaHQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFRvSGlnaGxpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXRhW2luZGV4VG9IaWdobGlnaHRdLmhpZ2hsaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9IHhBeGlzLnRpY2tGb3JtYXQoKShjaGFydC54KCkoc2luZ2xlUG9pbnQscG9pbnRJbmRleCkpO1xuXG4gICAgICAgICAgICAgICAgLy9JZiB3ZSBhcmUgaW4gJ2V4cGFuZCcgbW9kZSwgZm9yY2UgdGhlIGZvcm1hdCB0byBiZSBhIHBlcmNlbnRhZ2UuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGVyID0gKHN0YWNrZWQuc3R5bGUoKSA9PSAnZXhwYW5kJykgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihkLGkpIHtyZXR1cm4gZDMuZm9ybWF0KFwiLjElXCIpKGQpO30gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihkLGkpIHtyZXR1cm4geUF4aXMudGlja0Zvcm1hdCgpKGQpOyB9O1xuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIudG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAucG9zaXRpb24oe2xlZnQ6IHBvaW50WExvY2F0aW9uICsgbWFyZ2luLmxlZnQsIHRvcDogZS5tb3VzZVkgKyBtYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLmNoYXJ0Q29udGFpbmVyKHRoYXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgLmVuYWJsZWQodG9vbHRpcHMpXG4gICAgICAgICAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcih2YWx1ZUZvcm1hdHRlcilcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkoKTtcblxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIucmVuZGVyR3VpZGVMaW5lKHBvaW50WExvY2F0aW9uKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oXCJlbGVtZW50TW91c2VvdXRcIixmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoKTtcbiAgICAgICAgICAgICAgICBzdGFja2VkLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhLmxlbmd0aCA9PT0gZS5kaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLnN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkLnN0eWxlKGUuc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IGUuc3R5bGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3N0YWNrZWQgQXJlYSBjaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzdGFja2VkLmRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBzdGFja2VkLmRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LnN0YWNrZWQgPSBzdGFja2VkO1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5pbnRlcmFjdGl2ZUxheWVyID0gaW50ZXJhY3RpdmVMYXllcjtcblxuICAgIHlBeGlzLnNldFRpY2tGb3JtYXQgPSB5QXhpcy50aWNrRm9ybWF0O1xuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBzaG93WEF4aXM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICBzaG93Q29udHJvbHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dDb250cm9sczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dDb250cm9scz1fO319LFxuICAgICAgICBjb250cm9sTGFiZWxzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb250cm9sTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7Y29udHJvbExhYmVscz1fO319LFxuICAgICAgICB5QXhpc1RpY2tGb3JtYXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlBeGlzVGlja0Zvcm1hdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lBeGlzVGlja0Zvcm1hdD1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBzdGFja2VkLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgc3RhY2tlZC5jb2xvcihjb2xvcik7XG4gICAgICAgIH19LFxuICAgICAgICByaWdodEFsaWduWUF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ25ZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICAgICAgICAgIHlBeGlzLm9yaWVudCggcmlnaHRBbGlnbllBeGlzID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIH19LFxuICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gISFfO1xuICAgICAgICAgICAgaWYgKF8pIHtcbiAgICAgICAgICAgICAgICBjaGFydC5pbnRlcmFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXNlVm9yb25vaShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgc3RhY2tlZCk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYudmVyc2lvbiA9IFwiMS43LjFcIjtcbn0pKCk7IiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG4vL2xvYWRpbmcgaGFja3NcbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLy9sb2FkaW5nIGpxdWVyeSBpcyBjb2xsaWRpbmcgaW4gR0lTIG1vZHVsZSwgc28gd2Ugb25seSBsb2FkIGl0IGlmXG4vL2l0IGlzIG5vdCBsb2FkZWQgb3IgaWYgdGhlcmUgaXMgYSBqcXVlcnkgbG9hZGVkIGJ1dCB2ZXJzaW9uIGlzIG9sZGVyIHRoYW4gMi54LnhcbmlmICh3aW5kb3cuJCA9PSB1bmRlZmluZWQgfHwgJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpWzBdIDwgMikge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBCYWNrYm9uZS4kID0galF1ZXJ5O1xufVxuXG52YXIgYm9vdHN0cmFwX2VuYWJsZWQgPSAodHlwZW9mICQoKS5tb2RhbCA9PSAnZnVuY3Rpb24nKTtcbmlmIChib290c3RyYXBfZW5hYmxlZCkge1xuXHRyZXF1aXJlKCdib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAnKTtcbn1cblxudmFyIEhlYWRlclZpZXcgPSByZXF1aXJlKCcuL3NyYy92aWV3cy9oZWFkZXItdmlldy5qcycpO1xudmFyIEZvb3RlclZpZXcgPSByZXF1aXJlKCcuL3NyYy92aWV3cy9mb290ZXItdmlldy5qcycpO1xudmFyIFRyYW5zbGF0b3IgPSByZXF1aXJlKCdhbXAtdHJhbnNsYXRlJyk7XG52YXIgTGF5b3V0TW9kZWwgPSByZXF1aXJlKCcuL3NyYy9tb2RlbHMvYW1wLWxheW91dC1tb2RlbC5qcycpO1xuXG4vKiBleGFtcGxlIG9mIHVzZVxuICogdGhpcy5tZW51cyA9IG5ldyBNZW51cyh7XG4gKiAgIHRyYW5zbGF0b3I6IHRoaXMudHJhbnNsYXRvcixcbiAqICAgY2FsbGVyOiAnR0lTJ1xuICogfSk7XG4gKi9cblxuZnVuY3Rpb24gV2lkZ2V0KCkge1xuXHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuXy5leHRlbmQoV2lkZ2V0LnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG5cdGxheW91dEZldGNoZWQgOiBuZXcgJC5EZWZlcnJlZCgpLFxuXHRpbml0aWFsaXplIDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcblx0XHRcdHNob3dGb290ZXJBZG1pbiA6IHRydWUsXG5cdFx0XHRzaG93REdGb290ZXIgOiB0cnVlLFxuXHRcdFx0c2hvd0xvZ2luIDogdHJ1ZSxcblx0XHRcdHVzZVNpbmdsZVJvd0hlYWRlciA6IGZhbHNlXG5cdFx0fSk7XG5cdFx0aWYgKF8uaGFzKG9wdGlvbnMsICdzeW5jJykpIHtcblx0XHRcdEJhY2tib25lLnN5bmMgPSBvcHRpb25zLnN5bmM7XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuY3JlYXRlVHJhbnNsYXRvcigpO1xuXHRcdHRoaXMuY3JlYXRlVmlld3Mob3B0aW9ucyk7XHRcdFxuXHRcdCBfLmJpbmRBbGwodGhpcywgJ2NyZWF0ZVRyYW5zbGF0b3InLCAnY3JlYXRlVmlld3MnLCdidWJibGVWaWV3RXZlbnRzJywnb25NZW51UmVuZGVyZWQnKTtcblx0fSxcblx0Y3JlYXRlVHJhbnNsYXRvciA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWZhdWx0S2V5cyA9IEpTT04ucGFyc2UoXCJ7XFxuXFxcImFtcC5jb21tb246Zm9vdGVyXFxcIjogXFxcIkRldmVsb3BlZCBpbiBwYXJ0bmVyc2hpcCB3aXRoIE9FQ0QsIFVORFAsIFdCLCBHb3Zlcm5tZW50IG9mIEV0aGlvcGlhIGFuZCBER1xcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGVcXFwiOiBcXFwiQU1QIFRvb2xiYXJcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWhlbHBcXFwiOiBcXFwiSGVscFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYW1wLWhlbHBcXFwiOiBcXFwiQU1QIEhlbHBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWdsb3NzYXJ5XFxcIjogXFxcIkdsb3NzYXJ5XFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1lbWFpbC1zdXBwb3J0LXRlYW1cXFwiOiBcXFwiRW1haWwgU3VwcG9ydCBUZWFtXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dvdXRcXFwiOiBcXFwiTG9nIE91dFxcXCIsXFxuXFxcImFtcC5jb21tb246cGxhdGZvcm1cXFwiOiBcXFwiQWlkIE1hbmFnZW1lbnQgUGxhdGZvcm0gKEFNUClcXFwiLFxcblxcXCJbdGl0bGVdYW1wLmNvbW1vbjpwbGF0Zm9ybVxcXCI6IFxcXCJBaWQgTWFuYWdlbWVudCBQbGF0Zm9ybVxcXCIsXFxuXFxcImFtcC5jb21tb246cGxhdGZvcm0tc2hvcnRcXFwiOiBcXFwiQU1QXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dpblxcXCI6IFxcXCJMb2dpblxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2xvc2VcXFwiOiBcXFwiQ2xvc2VcXFwiLFxcblxcXCJhbXAuYWJvdXQ6bW9kYWwudGl0bGVcXFwiOiBcXFwiQWJvdXQgQU1QXFxcIixcXG5cXFwiYW1wLmFib3V0OmNyZWRpdHNcXFwiOiBcXFwiRGV2ZWxvcGVkIGluIHBhcnRuZXJzaGlwIHdpdGggT0VDRCwgVU5EUCwgV0IsIEdvdmVybm1lbnQgb2YgRXRoaW9waWEgYW5kIERldmVsb3BtZW50IEdhdGV3YXkgRm91bmRhdGlvbi5cXFwiLFxcblxcXCJhbXAuYWJvdXQ6dHJhZGVtYXJrXFxcIjogXFxcIlRoZSBEZXZlbG9wbWVudCBHYXRld2F5IGFuZCB0aGUgVGhlIERldmVsb3BtZW50IEdhdGV3YXkgbG9nbyBhcmUgdHJhZGVtYXJrcyBmb3IgVGhlIERldmVsb3BtZW50IEdhdGV3YXkgRm91bmRhdGlvblxcXCIsXFxuXFxcImFtcC5hYm91dDpyaWdodHNcXFwiOiBcXFwiQWxsIFJpZ2h0cyBSZXNlcnZlZFxcXCIsXFxuXFxcImFtcC5hYm91dDp2ZXJzaW9uXFxcIjogXFxcIlZlcnNpb25cXFwiXFxufVxcblxcblwiKTtcblx0XHR0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcih7XG5cdFx0XHRkZWZhdWx0S2V5cyA6IGRlZmF1bHRLZXlzXG5cdFx0fSk7XG5cdH0sXG5cdGNyZWF0ZVZpZXdzIDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRvcHRpb25zLnRyYW5zbGF0b3IgPSB0aGlzLnRyYW5zbGF0b3I7XG5cdFx0dGhpcy5sYXlvdXRNb2RlbCA9IG5ldyBMYXlvdXRNb2RlbCgpO1x0XHRcblx0XHRvcHRpb25zLmxheW91dEZldGNoZWQgPSB0aGlzLmxheW91dEZldGNoZWQ7XG5cdFx0dGhpcy5sYXlvdXRNb2RlbC5mZXRjaCgpLnRoZW4oZnVuY3Rpb24obGF5b3V0KSB7XG5cdFx0XHRvcHRpb25zLm1vZGVsID0gbGF5b3V0O1xuXHRcdFx0d2luZG93LmJ1aWxkRGF0ZSA9IGxheW91dC5idWlsZERhdGU7XG5cdFx0XHR3aW5kb3cuYW1wVmVyc2lvbiA9IGxheW91dC5hbXBWZXJzaW9uO1xuXHRcdFx0c2VsZi5oZWFkZXIgPSBuZXcgSGVhZGVyVmlldyhvcHRpb25zKTtcdFx0XG5cdFx0XHRzZWxmLmZvb3RlciA9IG5ldyBGb290ZXJWaWV3KG9wdGlvbnMpO1xuXHRcdFx0c2VsZi5vbk1lbnVSZW5kZXJlZCgpO1xuXHRcdFx0c2VsZi5idWJibGVWaWV3RXZlbnRzKCk7XHRcdFx0XG5cdFx0XHRzZWxmLmxheW91dEZldGNoZWQucmVzb2x2ZSgpO1xuXHRcdH0pO1xuXHR9LFxuXHRidWJibGVWaWV3RXZlbnRzIDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLmZvb3RlciwgJ2FsbCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLmxpc3RlblRvKHRoaXMuaGVhZGVyLCAnYWxsJywgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9KTtcblx0fSxcblx0b25NZW51UmVuZGVyZWQ6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdCQud2hlbih0aGlzLmhlYWRlci5tZW51UmVuZGVyZWQsIHRoaXMubGF5b3V0RmV0Y2hlZCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYudHJhbnNsYXRvci50cmFuc2xhdGVET00oZG9jdW1lbnQpO1xuXHRcdFx0aWYgKCQuZm4uZHJvcGRvd24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQkKCcuZHJvcGRvd24tdG9nZ2xlJykuZHJvcGRvd24oKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVx0XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bGF5b3V0IDogV2lkZ2V0XG59O1xud2luZG93LmJvaWxlcnBsYXRlID0gV2lkZ2V0O1xuIiwiLyohXG4gKiBCb290c3RyYXAgdjMuMy4wIChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuXG5pZiAodHlwZW9mIGpRdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5Jylcbn1cblxuK2Z1bmN0aW9uICgkKSB7XG4gIHZhciB2ZXJzaW9uID0gJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpXG4gIGlmICgodmVyc2lvblswXSA8IDIgJiYgdmVyc2lvblsxXSA8IDkpIHx8ICh2ZXJzaW9uWzBdID09IDEgJiYgdmVyc2lvblsxXSA9PSA5ICYmIHZlcnNpb25bMl0gPCAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeSB2ZXJzaW9uIDEuOS4xIG9yIGhpZ2hlcicpXG4gIH1cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRyYW5zaXRpb24uanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0cmFuc2l0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKFNob3V0b3V0OiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vKVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpXG5cbiAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0VHJhbnNpdGlvbiA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgIE1velRyYW5zaXRpb24gICAgOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgIHRyYW5zaXRpb24gICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgaWYgKGVsLnN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kOiB0cmFuc0VuZEV2ZW50TmFtZXNbbmFtZV0gfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSAvLyBleHBsaWNpdCBmb3IgaWU4ICggIC5fLilcbiAgfVxuXG4gIC8vIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyICRlbCA9IHRoaXNcbiAgICAkKHRoaXMpLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlIH0pXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyBpZiAoIWNhbGxlZCkgJCgkZWwpLnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSB9XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgZHVyYXRpb24pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gICQoZnVuY3Rpb24gKCkge1xuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZCgpXG5cbiAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm5cblxuICAgICQuZXZlbnQuc3BlY2lhbC5ic1RyYW5zaXRpb25FbmQgPSB7XG4gICAgICBiaW5kVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgZGVsZWdhdGVUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGlzKSkgcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWxlcnQuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhbGVydHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBTEVSVCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgZGlzbWlzcyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gIHZhciBBbGVydCAgID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgJChlbCkub24oJ2NsaWNrJywgZGlzbWlzcywgdGhpcy5jbG9zZSlcbiAgfVxuXG4gIEFsZXJ0LlZFUlNJT04gPSAnMy4zLjAnXG5cbiAgQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSAkKHNlbGVjdG9yKVxuXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgJHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJy5hbGVydCcpXG4gICAgfVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZS5icy5hbGVydCcpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIHBhcmVudCwgZmlyZSBldmVudCB0aGVuIGNsZWFuIHVwIGRhdGFcbiAgICAgICRwYXJlbnQuZGV0YWNoKCkudHJpZ2dlcignY2xvc2VkLmJzLmFsZXJ0JykucmVtb3ZlKClcbiAgICB9XG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkcGFyZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHBhcmVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCByZW1vdmVFbGVtZW50KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gIC8vIEFMRVJUIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuYWxlcnQnKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JywgKGRhdGEgPSBuZXcgQWxlcnQodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hbGVydFxuXG4gICQuZm4uYWxlcnQgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hbGVydC5Db25zdHJ1Y3RvciA9IEFsZXJ0XG5cblxuICAvLyBBTEVSVCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWxlcnQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFsZXJ0ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUxFUlQgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuYWxlcnQuZGF0YS1hcGknLCBkaXNtaXNzLCBBbGVydC5wcm90b3R5cGUuY2xvc2UpXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGJ1dHRvbi5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2J1dHRvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBCVVRUT04gUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSAkLmV4dGVuZCh7fSwgQnV0dG9uLkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgfVxuXG4gIEJ1dHRvbi5WRVJTSU9OICA9ICczLjMuMCdcblxuICBCdXR0b24uREVGQVVMVFMgPSB7XG4gICAgbG9hZGluZ1RleHQ6ICdsb2FkaW5nLi4uJ1xuICB9XG5cbiAgQnV0dG9uLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBkICAgID0gJ2Rpc2FibGVkJ1xuICAgIHZhciAkZWwgID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciB2YWwgID0gJGVsLmlzKCdpbnB1dCcpID8gJ3ZhbCcgOiAnaHRtbCdcbiAgICB2YXIgZGF0YSA9ICRlbC5kYXRhKClcblxuICAgIHN0YXRlID0gc3RhdGUgKyAnVGV4dCdcblxuICAgIGlmIChkYXRhLnJlc2V0VGV4dCA9PSBudWxsKSAkZWwuZGF0YSgncmVzZXRUZXh0JywgJGVsW3ZhbF0oKSlcblxuICAgIC8vIHB1c2ggdG8gZXZlbnQgbG9vcCB0byBhbGxvdyBmb3JtcyB0byBzdWJtaXRcbiAgICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgJGVsW3ZhbF0oZGF0YVtzdGF0ZV0gPT0gbnVsbCA/IHRoaXMub3B0aW9uc1tzdGF0ZV0gOiBkYXRhW3N0YXRlXSlcblxuICAgICAgaWYgKHN0YXRlID09ICdsb2FkaW5nVGV4dCcpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlXG4gICAgICAgICRlbC5hZGRDbGFzcyhkKS5hdHRyKGQsIGQpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKGQpLnJlbW92ZUF0dHIoZClcbiAgICAgIH1cbiAgICB9LCB0aGlzKSwgMClcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZVxuICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJylcblxuICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgdmFyICRpbnB1dCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKVxuICAgICAgaWYgKCRpbnB1dC5wcm9wKCd0eXBlJykgPT0gJ3JhZGlvJykge1xuICAgICAgICBpZiAoJGlucHV0LnByb3AoJ2NoZWNrZWQnKSAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSkgY2hhbmdlZCA9IGZhbHNlXG4gICAgICAgIGVsc2UgJHBhcmVudC5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZCkgJGlucHV0LnByb3AoJ2NoZWNrZWQnLCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpLnRyaWdnZXIoJ2NoYW5nZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1wcmVzc2VkJywgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkKSB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICB9XG5cblxuICAvLyBCVVRUT04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmJ1dHRvbicpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuYnV0dG9uJywgKGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMsIG9wdGlvbnMpKSlcblxuICAgICAgaWYgKG9wdGlvbiA9PSAndG9nZ2xlJykgZGF0YS50b2dnbGUoKVxuICAgICAgZWxzZSBpZiAob3B0aW9uKSBkYXRhLnNldFN0YXRlKG9wdGlvbilcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYnV0dG9uXG5cbiAgJC5mbi5idXR0b24gICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5idXR0b24uQ29uc3RydWN0b3IgPSBCdXR0b25cblxuXG4gIC8vIEJVVFRPTiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmJ1dHRvbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYnV0dG9uID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQlVUVE9OIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5idXR0b24uZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgJGJ0biA9ICQoZS50YXJnZXQpXG4gICAgICBpZiAoISRidG4uaGFzQ2xhc3MoJ2J0bicpKSAkYnRuID0gJGJ0bi5jbG9zZXN0KCcuYnRuJylcbiAgICAgIFBsdWdpbi5jYWxsKCRidG4sICd0b2dnbGUnKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfSlcbiAgICAub24oJ2ZvY3VzLmJzLmJ1dHRvbi5kYXRhLWFwaSBibHVyLmJzLmJ1dHRvbi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5idG4nKS50b2dnbGVDbGFzcygnZm9jdXMnLCBlLnR5cGUgPT0gJ2ZvY3VzJylcbiAgICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjYXJvdXNlbC5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Nhcm91c2VsXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ0FST1VTRUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENhcm91c2VsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGluZGljYXRvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5jYXJvdXNlbC1pbmRpY2F0b3JzJylcbiAgICB0aGlzLm9wdGlvbnMgICAgID0gb3B0aW9uc1xuICAgIHRoaXMucGF1c2VkICAgICAgPVxuICAgIHRoaXMuc2xpZGluZyAgICAgPVxuICAgIHRoaXMuaW50ZXJ2YWwgICAgPVxuICAgIHRoaXMuJGFjdGl2ZSAgICAgPVxuICAgIHRoaXMuJGl0ZW1zICAgICAgPSBudWxsXG5cbiAgICB0aGlzLm9wdGlvbnMua2V5Ym9hcmQgJiYgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKSlcblxuICAgIHRoaXMub3B0aW9ucy5wYXVzZSA9PSAnaG92ZXInICYmICEoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSAmJiB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ21vdXNlZW50ZXIuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMucGF1c2UsIHRoaXMpKVxuICAgICAgLm9uKCdtb3VzZWxlYXZlLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmN5Y2xlLCB0aGlzKSlcbiAgfVxuXG4gIENhcm91c2VsLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDBcblxuICBDYXJvdXNlbC5ERUZBVUxUUyA9IHtcbiAgICBpbnRlcnZhbDogNTAwMCxcbiAgICBwYXVzZTogJ2hvdmVyJyxcbiAgICB3cmFwOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICBjYXNlIDM3OiB0aGlzLnByZXYoKTsgYnJlYWtcbiAgICAgIGNhc2UgMzk6IHRoaXMubmV4dCgpOyBicmVha1xuICAgICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuY3ljbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gZmFsc2UpXG5cbiAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcblxuICAgIHRoaXMub3B0aW9ucy5pbnRlcnZhbFxuICAgICAgJiYgIXRoaXMucGF1c2VkXG4gICAgICAmJiAodGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCQucHJveHkodGhpcy5uZXh0LCB0aGlzKSwgdGhpcy5vcHRpb25zLmludGVydmFsKSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLiRpdGVtcyA9IGl0ZW0ucGFyZW50KCkuY2hpbGRyZW4oJy5pdGVtJylcbiAgICByZXR1cm4gdGhpcy4kaXRlbXMuaW5kZXgoaXRlbSB8fCB0aGlzLiRhY3RpdmUpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUZvckRpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIGFjdGl2ZSkge1xuICAgIHZhciBkZWx0YSA9IGRpcmVjdGlvbiA9PSAncHJldicgPyAtMSA6IDFcbiAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLmdldEl0ZW1JbmRleChhY3RpdmUpXG4gICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuJGl0ZW1zLmxlbmd0aFxuICAgIHJldHVybiB0aGlzLiRpdGVtcy5lcShpdGVtSW5kZXgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIHRoYXQgICAgICAgID0gdGhpc1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJykpXG5cbiAgICBpZiAocG9zID4gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpIHx8IHBvcyA8IDApIHJldHVyblxuXG4gICAgaWYgKHRoaXMuc2xpZGluZykgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQub25lKCdzbGlkLmJzLmNhcm91c2VsJywgZnVuY3Rpb24gKCkgeyB0aGF0LnRvKHBvcykgfSkgLy8geWVzLCBcInNsaWRcIlxuICAgIGlmIChhY3RpdmVJbmRleCA9PSBwb3MpIHJldHVybiB0aGlzLnBhdXNlKCkuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUocG9zID4gYWN0aXZlSW5kZXggPyAnbmV4dCcgOiAncHJldicsIHRoaXMuJGl0ZW1zLmVxKHBvcykpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gdHJ1ZSlcblxuICAgIGlmICh0aGlzLiRlbGVtZW50LmZpbmQoJy5uZXh0LCAucHJldicpLmxlbmd0aCAmJiAkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZClcbiAgICAgIHRoaXMuY3ljbGUodHJ1ZSlcbiAgICB9XG5cbiAgICB0aGlzLmludGVydmFsID0gY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCduZXh0JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCdwcmV2JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5zbGlkZSA9IGZ1bmN0aW9uICh0eXBlLCBuZXh0KSB7XG4gICAgdmFyICRhY3RpdmUgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJylcbiAgICB2YXIgJG5leHQgICAgID0gbmV4dCB8fCB0aGlzLmdldEl0ZW1Gb3JEaXJlY3Rpb24odHlwZSwgJGFjdGl2ZSlcbiAgICB2YXIgaXNDeWNsaW5nID0gdGhpcy5pbnRlcnZhbFxuICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlID09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB2YXIgZmFsbGJhY2sgID0gdHlwZSA9PSAnbmV4dCcgPyAnZmlyc3QnIDogJ2xhc3QnXG4gICAgdmFyIHRoYXQgICAgICA9IHRoaXNcblxuICAgIGlmICghJG5leHQubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy53cmFwKSByZXR1cm5cbiAgICAgICRuZXh0ID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbScpW2ZhbGxiYWNrXSgpXG4gICAgfVxuXG4gICAgaWYgKCRuZXh0Lmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuICh0aGlzLnNsaWRpbmcgPSBmYWxzZSlcblxuICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gJG5leHRbMF1cbiAgICB2YXIgc2xpZGVFdmVudCA9ICQuRXZlbnQoJ3NsaWRlLmJzLmNhcm91c2VsJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSlcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZGVFdmVudClcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLnNsaWRpbmcgPSB0cnVlXG5cbiAgICBpc0N5Y2xpbmcgJiYgdGhpcy5wYXVzZSgpXG5cbiAgICBpZiAodGhpcy4kaW5kaWNhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJGluZGljYXRvcnMuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgdmFyICRuZXh0SW5kaWNhdG9yID0gJCh0aGlzLiRpbmRpY2F0b3JzLmNoaWxkcmVuKClbdGhpcy5nZXRJdGVtSW5kZXgoJG5leHQpXSlcbiAgICAgICRuZXh0SW5kaWNhdG9yICYmICRuZXh0SW5kaWNhdG9yLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIHZhciBzbGlkRXZlbnQgPSAkLkV2ZW50KCdzbGlkLmJzLmNhcm91c2VsJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3NsaWRlJykpIHtcbiAgICAgICRuZXh0LmFkZENsYXNzKHR5cGUpXG4gICAgICAkbmV4dFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgICRhY3RpdmUuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJG5leHQuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJG5leHQucmVtb3ZlQ2xhc3MoW3R5cGUsIGRpcmVjdGlvbl0uam9pbignICcpKS5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKFsnYWN0aXZlJywgZGlyZWN0aW9uXS5qb2luKCcgJykpXG4gICAgICAgICAgdGhhdC5zbGlkaW5nID0gZmFsc2VcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgfSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgfSBlbHNlIHtcbiAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAkbmV4dC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZEV2ZW50KVxuICAgIH1cblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLmN5Y2xlKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENhcm91c2VsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuICAgICAgdmFyIGFjdGlvbiAgPSB0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnID8gb3B0aW9uIDogb3B0aW9ucy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJywgKGRhdGEgPSBuZXcgQ2Fyb3VzZWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ251bWJlcicpIGRhdGEudG8ob3B0aW9uKVxuICAgICAgZWxzZSBpZiAoYWN0aW9uKSBkYXRhW2FjdGlvbl0oKVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5pbnRlcnZhbCkgZGF0YS5wYXVzZSgpLmN5Y2xlKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY2Fyb3VzZWxcblxuICAkLmZuLmNhcm91c2VsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBDYXJvdXNlbFxuXG5cbiAgLy8gQ0FST1VTRUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNhcm91c2VsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jYXJvdXNlbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGhyZWZcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiA9ICR0aGlzLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpIC8vIHN0cmlwIGZvciBpZTdcbiAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3MoJ2Nhcm91c2VsJykpIHJldHVyblxuICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG4gICAgdmFyIHNsaWRlSW5kZXggPSAkdGhpcy5hdHRyKCdkYXRhLXNsaWRlLXRvJylcbiAgICBpZiAoc2xpZGVJbmRleCkgb3B0aW9ucy5pbnRlcnZhbCA9IGZhbHNlXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb25zKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICR0YXJnZXQuZGF0YSgnYnMuY2Fyb3VzZWwnKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlLXRvXScsIGNsaWNrSGFuZGxlcilcblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGNhcm91c2VsID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGNvbGxhcHNlLmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jY29sbGFwc2VcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDT0xMQVBTRSBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBDb2xsYXBzZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgICAgICA9ICQuZXh0ZW5kKHt9LCBDb2xsYXBzZS5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLiR0cmlnZ2VyICAgICAgPSAkKHRoaXMub3B0aW9ucy50cmlnZ2VyKS5maWx0ZXIoJ1tocmVmPVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXSwgW2RhdGEtdGFyZ2V0PVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXScpXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gbnVsbFxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy4kZWxlbWVudCwgdGhpcy4kdHJpZ2dlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRvZ2dsZSkgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgQ29sbGFwc2UuVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTiA9IDM1MFxuXG4gIENvbGxhcHNlLkRFRkFVTFRTID0ge1xuICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICB0cmlnZ2VyOiAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNXaWR0aCA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3dpZHRoJylcbiAgICByZXR1cm4gaGFzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCdcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSkgcmV0dXJuXG5cbiAgICB2YXIgYWN0aXZlc0RhdGFcbiAgICB2YXIgYWN0aXZlcyA9IHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuZmluZCgnPiAucGFuZWwnKS5jaGlsZHJlbignLmluLCAuY29sbGFwc2luZycpXG5cbiAgICBpZiAoYWN0aXZlcyAmJiBhY3RpdmVzLmxlbmd0aCkge1xuICAgICAgYWN0aXZlc0RhdGEgPSBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS50cmFuc2l0aW9uaW5nKSByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMuY29sbGFwc2UnKVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBQbHVnaW4uY2FsbChhY3RpdmVzLCAnaGlkZScpXG4gICAgICBhY3RpdmVzRGF0YSB8fCBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJywgbnVsbClcbiAgICB9XG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVtkaW1lbnNpb25dKDApXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAxXG5cbiAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UgaW4nKVtkaW1lbnNpb25dKCcnKVxuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAudHJpZ2dlcignc2hvd24uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB2YXIgc2Nyb2xsU2l6ZSA9ICQuY2FtZWxDYXNlKFsnc2Nyb2xsJywgZGltZW5zaW9uXS5qb2luKCctJykpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbMF1bc2Nyb2xsU2l6ZV0pXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uaW5nIHx8ICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSByZXR1cm5cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uKClcblxuICAgIHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSh0aGlzLiRlbGVtZW50W2RpbWVuc2lvbl0oKSlbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZSBpbicpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy4kdHJpZ2dlclxuICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZWQnKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDBcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICBbZGltZW5zaW9uXSgwKVxuICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eShjb21wbGV0ZSwgdGhpcykpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpc1t0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpID8gJ2hpZGUnIDogJ3Nob3cnXSgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkKHRoaXMub3B0aW9ucy5wYXJlbnQpXG4gICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCInICsgdGhpcy5vcHRpb25zLnBhcmVudCArICdcIl0nKVxuICAgICAgLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgICAgIHRoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGdldFRhcmdldEZyb21UcmlnZ2VyKCRlbGVtZW50KSwgJGVsZW1lbnQpXG4gICAgICB9LCB0aGlzKSlcbiAgICAgIC5lbmQoKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uICgkZWxlbWVudCwgJHRyaWdnZXIpIHtcbiAgICB2YXIgaXNPcGVuID0gJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJylcblxuICAgICRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gICAgJHRyaWdnZXJcbiAgICAgIC50b2dnbGVDbGFzcygnY29sbGFwc2VkJywgIWlzT3BlbilcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRyaWdnZXIpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciB0YXJnZXQgPSAkdHJpZ2dlci5hdHRyKCdkYXRhLXRhcmdldCcpXG4gICAgICB8fCAoaHJlZiA9ICR0cmlnZ2VyLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuXG4gICAgcmV0dXJuICQodGFyZ2V0KVxuICB9XG5cblxuICAvLyBDT0xMQVBTRSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBDb2xsYXBzZS5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbnMudG9nZ2xlICYmIG9wdGlvbiA9PSAnc2hvdycpIG9wdGlvbnMudG9nZ2xlID0gZmFsc2VcbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuY29sbGFwc2UnLCAoZGF0YSA9IG5ldyBDb2xsYXBzZSh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY29sbGFwc2VcblxuICAkLmZuLmNvbGxhcHNlICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY29sbGFwc2UuQ29uc3RydWN0b3IgPSBDb2xsYXBzZVxuXG5cbiAgLy8gQ09MTEFQU0UgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNvbGxhcHNlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jb2xsYXBzZSA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmNvbGxhcHNlLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcblxuICAgIGlmICghJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICB2YXIgJHRhcmdldCA9IGdldFRhcmdldEZyb21UcmlnZ2VyKCR0aGlzKVxuICAgIHZhciBkYXRhICAgID0gJHRhcmdldC5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgdmFyIG9wdGlvbiAgPSBkYXRhID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7fSwgJHRoaXMuZGF0YSgpLCB7IHRyaWdnZXI6IHRoaXMgfSlcblxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbilcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogZHJvcGRvd24uanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNkcm9wZG93bnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBEUk9QRE9XTiBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgYmFja2Ryb3AgPSAnLmRyb3Bkb3duLWJhY2tkcm9wJ1xuICB2YXIgdG9nZ2xlICAgPSAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nXG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgJChlbGVtZW50KS5vbignY2xpY2suYnMuZHJvcGRvd24nLCB0aGlzLnRvZ2dsZSlcbiAgfVxuXG4gIERyb3Bkb3duLlZFUlNJT04gPSAnMy4zLjAnXG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuXG4gICAgaWYgKCR0aGlzLmlzKCcuZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICAgIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgICB2YXIgaXNBY3RpdmUgPSAkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJylcblxuICAgIGNsZWFyTWVudXMoKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhJHBhcmVudC5jbG9zZXN0KCcubmF2YmFyLW5hdicpLmxlbmd0aCkge1xuICAgICAgICAvLyBpZiBtb2JpbGUgd2UgdXNlIGEgYmFja2Ryb3AgYmVjYXVzZSBjbGljayBldmVudHMgZG9uJ3QgZGVsZWdhdGVcbiAgICAgICAgJCgnPGRpdiBjbGFzcz1cImRyb3Bkb3duLWJhY2tkcm9wXCIvPicpLmluc2VydEFmdGVyKCQodGhpcykpLm9uKCdjbGljaycsIGNsZWFyTWVudXMpXG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnc2hvdy5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzXG4gICAgICAgIC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKVxuXG4gICAgICAkcGFyZW50XG4gICAgICAgIC50b2dnbGVDbGFzcygnb3BlbicpXG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCEvKDM4fDQwfDI3fDMyKS8udGVzdChlLndoaWNoKSkgcmV0dXJuXG5cbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgaWYgKCghaXNBY3RpdmUgJiYgZS53aGljaCAhPSAyNykgfHwgKGlzQWN0aXZlICYmIGUud2hpY2ggPT0gMjcpKSB7XG4gICAgICBpZiAoZS53aGljaCA9PSAyNykgJHBhcmVudC5maW5kKHRvZ2dsZSkudHJpZ2dlcignZm9jdXMnKVxuICAgICAgcmV0dXJuICR0aGlzLnRyaWdnZXIoJ2NsaWNrJylcbiAgICB9XG5cbiAgICB2YXIgZGVzYyA9ICcgbGk6bm90KC5kaXZpZGVyKTp2aXNpYmxlIGEnXG4gICAgdmFyICRpdGVtcyA9ICRwYXJlbnQuZmluZCgnW3JvbGU9XCJtZW51XCJdJyArIGRlc2MgKyAnLCBbcm9sZT1cImxpc3Rib3hcIl0nICsgZGVzYylcblxuICAgIGlmICghJGl0ZW1zLmxlbmd0aCkgcmV0dXJuXG5cbiAgICB2YXIgaW5kZXggPSAkaXRlbXMuaW5kZXgoZS50YXJnZXQpXG5cbiAgICBpZiAoZS53aGljaCA9PSAzOCAmJiBpbmRleCA+IDApICAgICAgICAgICAgICAgICBpbmRleC0tICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBcbiAgICBpZiAoZS53aGljaCA9PSA0MCAmJiBpbmRleCA8ICRpdGVtcy5sZW5ndGggLSAxKSBpbmRleCsrICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93blxuICAgIGlmICghfmluZGV4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwXG5cbiAgICAkaXRlbXMuZXEoaW5kZXgpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTWVudXMoZSkge1xuICAgIGlmIChlICYmIGUud2hpY2ggPT09IDMpIHJldHVyblxuICAgICQoYmFja2Ryb3ApLnJlbW92ZSgpXG4gICAgJCh0b2dnbGUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgICAgICAgPSAkKHRoaXMpXG4gICAgICB2YXIgJHBhcmVudCAgICAgICA9IGdldFBhcmVudCgkdGhpcylcbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cblxuICAgICAgaWYgKCEkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJykpIHJldHVyblxuXG4gICAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ2hpZGUuYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICAkdGhpcy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJylcbiAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ29wZW4nKS50cmlnZ2VyKCdoaWRkZW4uYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoJHRoaXMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiAvI1tBLVphLXpdLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gc2VsZWN0b3IgJiYgJChzZWxlY3RvcilcblxuICAgIHJldHVybiAkcGFyZW50ICYmICRwYXJlbnQubGVuZ3RoID8gJHBhcmVudCA6ICR0aGlzLnBhcmVudCgpXG4gIH1cblxuXG4gIC8vIERST1BET1dOIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmRyb3Bkb3duJywgKGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5kcm9wZG93blxuXG4gICQuZm4uZHJvcGRvd24gICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3RvciA9IERyb3Bkb3duXG5cblxuICAvLyBEUk9QRE9XTiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uZHJvcGRvd24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmRyb3Bkb3duID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQVBQTFkgVE8gU1RBTkRBUkQgRFJPUERPV04gRUxFTUVOVFNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBjbGVhck1lbnVzKVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnLmRyb3Bkb3duIGZvcm0nLCBmdW5jdGlvbiAoZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpIH0pXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLnRvZ2dsZSlcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICdbcm9sZT1cIm1lbnVcIl0nLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnW3JvbGU9XCJsaXN0Ym94XCJdJywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IG1vZGFsLmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jbW9kYWxzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgID0gb3B0aW9uc1xuICAgIHRoaXMuJGJvZHkgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kZWxlbWVudCAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRiYWNrZHJvcCAgICAgID1cbiAgICB0aGlzLmlzU2hvd24gICAgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSAwXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbW90ZSkge1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICAubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2xvYWRlZC5icy5tb2RhbCcpXG4gICAgICAgIH0sIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04gPSAzMDBcbiAgTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIE1vZGFsLkRFRkFVTFRTID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHNob3c6IHRydWVcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBlICAgID0gJC5FdmVudCgnc2hvdy5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKHRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuY2hlY2tTY3JvbGxiYXIoKVxuICAgIHRoaXMuJGJvZHkuYWRkQ2xhc3MoJ21vZGFsLW9wZW4nKVxuXG4gICAgdGhpcy5zZXRTY3JvbGxiYXIoKVxuICAgIHRoaXMuZXNjYXBlKClcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgJC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpKVxuXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoYXQuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnQuYXBwZW5kVG8odGhhdC4kYm9keSkgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuc2Nyb2xsVG9wKDApXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdpbicpXG4gICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKVxuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKSAvLyB3YWl0IGZvciBtb2RhbCB0byBzbGlkZSBpblxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgZSA9ICQuRXZlbnQoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlXG5cbiAgICB0aGlzLmVzY2FwZSgpXG5cbiAgICAkKGRvY3VtZW50KS5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdpbicpXG4gICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKVxuICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KHRoaXMuaGlkZU1vZGFsLCB0aGlzKSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHRoaXMuaGlkZU1vZGFsKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lbmZvcmNlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJChkb2N1bWVudClcbiAgICAgIC5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKSAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbignZm9jdXNpbi5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gIT09IGUudGFyZ2V0ICYmICF0aGlzLiRlbGVtZW50LmhhcyhlLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdGhpcy4kZWxlbWVudC5oaWRlKClcbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxuICAgICAgdGhhdC5yZXNldFNjcm9sbGJhcigpXG4gICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGRlbi5icy5tb2RhbCcpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcCAmJiB0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKVxuICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmJhY2tkcm9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGFuaW1hdGUgPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgPyAnZmFkZScgOiAnJ1xuXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIHZhciBkb0FuaW1hdGUgPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiBhbmltYXRlXG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJCgnPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlICsgJ1wiIC8+JylcbiAgICAgICAgLnByZXBlbmRUbyh0aGlzLiRlbGVtZW50KVxuICAgICAgICAub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxuICAgICAgICAgIHRoaXMub3B0aW9ucy5iYWNrZHJvcCA9PSAnc3RhdGljJ1xuICAgICAgICAgICAgPyB0aGlzLiRlbGVtZW50WzBdLmZvY3VzLmNhbGwodGhpcy4kZWxlbWVudFswXSlcbiAgICAgICAgICAgIDogdGhpcy5oaWRlLmNhbGwodGhpcylcbiAgICAgICAgfSwgdGhpcykpXG5cbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuXG4gICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm5cblxuICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFjaylcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gdGhpcy5tZWFzdXJlU2Nyb2xsYmFyKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludCgodGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwKSwgMTApXG4gICAgaWYgKHRoaXMuc2Nyb2xsYmFyV2lkdGgpIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYm9keVBhZCArIHRoaXMuc2Nyb2xsYmFyV2lkdGgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCAnJylcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5tZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkgeyAvLyB0aHggd2Fsc2hcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCA+PSB3aW5kb3cuaW5uZXJXaWR0aCkgcmV0dXJuIDBcbiAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJ1xuICAgIHRoaXMuJGJvZHkuYXBwZW5kKHNjcm9sbERpdilcbiAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGhcbiAgICB0aGlzLiRib2R5WzBdLnJlbW92ZUNoaWxkKHNjcm9sbERpdilcbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhcbiAgfVxuXG5cbiAgLy8gTU9EQUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uLCBfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLm1vZGFsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIE1vZGFsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLm1vZGFsJywgKGRhdGEgPSBuZXcgTW9kYWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXShfcmVsYXRlZFRhcmdldClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvdykgZGF0YS5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5tb2RhbFxuXG4gICQuZm4ubW9kYWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5tb2RhbC5Db25zdHJ1Y3RvciA9IE1vZGFsXG5cblxuICAvLyBNT0RBTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ubW9kYWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLm1vZGFsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gTU9EQUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMubW9kYWwuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciBocmVmICAgID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgdmFyICR0YXJnZXQgPSAkKCR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHwgKGhyZWYgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgdmFyIG9wdGlvbiAgPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHsgcmVtb3RlOiAhLyMvLnRlc3QoaHJlZikgJiYgaHJlZiB9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxuXG4gICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgJHRhcmdldC5vbmUoJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm4gLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHRoaXMuaXMoJzp2aXNpYmxlJykgJiYgJHRoaXMudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfSlcbiAgICB9KVxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbiwgdGhpcylcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdG9vbHRpcC5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3Rvb2x0aXBcbiAqIEluc3BpcmVkIGJ5IHRoZSBvcmlnaW5hbCBqUXVlcnkudGlwc3kgYnkgSmFzb24gRnJhbWVcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBUT09MVElQIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlICAgICAgID1cbiAgICB0aGlzLm9wdGlvbnMgICAgPVxuICAgIHRoaXMuZW5hYmxlZCAgICA9XG4gICAgdGhpcy50aW1lb3V0ICAgID1cbiAgICB0aGlzLmhvdmVyU3RhdGUgPVxuICAgIHRoaXMuJGVsZW1lbnQgICA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgndG9vbHRpcCcsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBUb29sdGlwLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRvb2x0aXAuREVGQVVMVFMgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkICAgPSB0cnVlXG4gICAgdGhpcy50eXBlICAgICAgPSB0eXBlXG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLiR2aWV3cG9ydCA9IHRoaXMub3B0aW9ucy52aWV3cG9ydCAmJiAkKHRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMudmlld3BvcnQpXG5cbiAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLm9wdGlvbnMudHJpZ2dlci5zcGxpdCgnICcpXG5cbiAgICBmb3IgKHZhciBpID0gdHJpZ2dlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgdHJpZ2dlciA9IHRyaWdnZXJzW2ldXG5cbiAgICAgIGlmICh0cmlnZ2VyID09ICdjbGljaycpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMudG9nZ2xlLCB0aGlzKSlcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPSAnbWFudWFsJykge1xuICAgICAgICB2YXIgZXZlbnRJbiAgPSB0cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VlbnRlcicgOiAnZm9jdXNpbidcbiAgICAgICAgdmFyIGV2ZW50T3V0ID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlbGVhdmUnIDogJ2ZvY3Vzb3V0J1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRJbiAgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmVudGVyLCB0aGlzKSlcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudE91dCArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMubGVhdmUsIHRoaXMpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA/XG4gICAgICAodGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHsgdHJpZ2dlcjogJ21hbnVhbCcsIHNlbGVjdG9yOiAnJyB9KSkgOlxuICAgICAgdGhpcy5maXhUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVG9vbHRpcC5ERUZBVUxUU1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLmdldERlZmF1bHRzKCksIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgPT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IG9wdGlvbnMuZGVsYXksXG4gICAgICAgIGhpZGU6IG9wdGlvbnMuZGVsYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVsZWdhdGVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zICA9IHt9XG4gICAgdmFyIGRlZmF1bHRzID0gdGhpcy5nZXREZWZhdWx0cygpXG5cbiAgICB0aGlzLl9vcHRpb25zICYmICQuZWFjaCh0aGlzLl9vcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGRlZmF1bHRzW2tleV0gIT0gdmFsdWUpIG9wdGlvbnNba2V5XSA9IHZhbHVlXG4gICAgfSlcblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgP1xuICAgICAgb2JqIDogJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmIChzZWxmICYmIHNlbGYuJHRpcCAmJiBzZWxmLiR0aXAuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc2VsZikge1xuICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG9iai5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ2luJ1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5zaG93KSByZXR1cm4gc2VsZi5zaG93KClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSBzZWxmLnNob3coKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5zaG93KVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcblxuICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdvdXQnXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpIHJldHVybiBzZWxmLmhpZGUoKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdvdXQnKSBzZWxmLmhpZGUoKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5oaWRlKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3cuYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmICh0aGlzLmhhc0NvbnRlbnQoKSAmJiB0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICB2YXIgaW5Eb20gPSAkLmNvbnRhaW5zKHRoaXMuJGVsZW1lbnRbMF0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuJGVsZW1lbnRbMF0pXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaW5Eb20pIHJldHVyblxuICAgICAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuXG4gICAgICB2YXIgdGlwSWQgPSB0aGlzLmdldFVJRCh0aGlzLnR5cGUpXG5cbiAgICAgIHRoaXMuc2V0Q29udGVudCgpXG4gICAgICAkdGlwLmF0dHIoJ2lkJywgdGlwSWQpXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZClcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pICR0aXAuYWRkQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICB2YXIgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnRcblxuICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2lcbiAgICAgIHZhciBhdXRvUGxhY2UgPSBhdXRvVG9rZW4udGVzdChwbGFjZW1lbnQpXG4gICAgICBpZiAoYXV0b1BsYWNlKSBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJ1xuXG4gICAgICAkdGlwXG4gICAgICAgIC5kZXRhY2goKVxuICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pXG4gICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICAgIC5kYXRhKCdicy4nICsgdGhpcy50eXBlLCB0aGlzKVxuXG4gICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID8gJHRpcC5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSA6ICR0aXAuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudClcblxuICAgICAgdmFyIHBvcyAgICAgICAgICA9IHRoaXMuZ2V0UG9zaXRpb24oKVxuICAgICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgICBpZiAoYXV0b1BsYWNlKSB7XG4gICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRcbiAgICAgICAgdmFyICRjb250YWluZXIgICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPyAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpIDogdGhpcy4kZWxlbWVudC5wYXJlbnQoKVxuICAgICAgICB2YXIgY29udGFpbmVyRGltID0gdGhpcy5nZXRQb3NpdGlvbigkY29udGFpbmVyKVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PSAnYm90dG9tJyAmJiBwb3MuYm90dG9tICsgYWN0dWFsSGVpZ2h0ID4gY29udGFpbmVyRGltLmJvdHRvbSA/ICd0b3AnICAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgICYmIHBvcy50b3AgICAgLSBhY3R1YWxIZWlnaHQgPCBjb250YWluZXJEaW0udG9wICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAgJiYgcG9zLnJpZ2h0ICArIGFjdHVhbFdpZHRoICA+IGNvbnRhaW5lckRpbS53aWR0aCAgPyAnbGVmdCcgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICAmJiBwb3MubGVmdCAgIC0gYWN0dWFsV2lkdGggIDwgY29udGFpbmVyRGltLmxlZnQgICA/ICdyaWdodCcgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50XG5cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGN1bGF0ZWRPZmZzZXQgPSB0aGlzLmdldENhbGN1bGF0ZWRPZmZzZXQocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpXG5cbiAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KVxuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IHRoYXQuaG92ZXJTdGF0ZVxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3duLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICAgIHRoYXQuaG92ZXJTdGF0ZSA9IG51bGxcblxuICAgICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT0gJ291dCcpIHRoYXQubGVhdmUodGhhdClcbiAgICAgIH1cblxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kdGlwLmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgICAkdGlwXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY29tcGxldGUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjb21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuYXBwbHlQbGFjZW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0LCBwbGFjZW1lbnQpIHtcbiAgICB2YXIgJHRpcCAgID0gdGhpcy50aXAoKVxuICAgIHZhciB3aWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgdmFyIGhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAvLyBtYW51YWxseSByZWFkIG1hcmdpbnMgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaW5jbHVkZXMgZGlmZmVyZW5jZVxuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLXRvcCcpLCAxMClcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlSW50KCR0aXAuY3NzKCdtYXJnaW4tbGVmdCcpLCAxMClcblxuICAgIC8vIHdlIG11c3QgY2hlY2sgZm9yIE5hTiBmb3IgaWUgOC85XG4gICAgaWYgKGlzTmFOKG1hcmdpblRvcCkpICBtYXJnaW5Ub3AgID0gMFxuICAgIGlmIChpc05hTihtYXJnaW5MZWZ0KSkgbWFyZ2luTGVmdCA9IDBcblxuICAgIG9mZnNldC50b3AgID0gb2Zmc2V0LnRvcCAgKyBtYXJnaW5Ub3BcbiAgICBvZmZzZXQubGVmdCA9IG9mZnNldC5sZWZ0ICsgbWFyZ2luTGVmdFxuXG4gICAgLy8gJC5mbi5vZmZzZXQgZG9lc24ndCByb3VuZCBwaXhlbCB2YWx1ZXNcbiAgICAvLyBzbyB3ZSB1c2Ugc2V0T2Zmc2V0IGRpcmVjdGx5IHdpdGggb3VyIG93biBmdW5jdGlvbiBCLTBcbiAgICAkLm9mZnNldC5zZXRPZmZzZXQoJHRpcFswXSwgJC5leHRlbmQoe1xuICAgICAgdXNpbmc6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAkdGlwLmNzcyh7XG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKHByb3BzLnRvcCksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChwcm9wcy5sZWZ0KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIG9mZnNldCksIDApXG5cbiAgICAkdGlwLmFkZENsYXNzKCdpbicpXG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgcGxhY2luZyB0aXAgaW4gbmV3IG9mZnNldCBjYXVzZWQgdGhlIHRpcCB0byByZXNpemUgaXRzZWxmXG4gICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIGlmIChwbGFjZW1lbnQgPT0gJ3RvcCcgJiYgYWN0dWFsSGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgb2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBoZWlnaHQgLSBhY3R1YWxIZWlnaHRcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YShwbGFjZW1lbnQsIG9mZnNldCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgIGlmIChkZWx0YS5sZWZ0KSBvZmZzZXQubGVmdCArPSBkZWx0YS5sZWZ0XG4gICAgZWxzZSBvZmZzZXQudG9wICs9IGRlbHRhLnRvcFxuXG4gICAgdmFyIGlzVmVydGljYWwgICAgICAgICAgPSAvdG9wfGJvdHRvbS8udGVzdChwbGFjZW1lbnQpXG4gICAgdmFyIGFycm93RGVsdGEgICAgICAgICAgPSBpc1ZlcnRpY2FsID8gZGVsdGEubGVmdCAqIDIgLSB3aWR0aCArIGFjdHVhbFdpZHRoIDogZGVsdGEudG9wICogMiAtIGhlaWdodCArIGFjdHVhbEhlaWdodFxuICAgIHZhciBhcnJvd09mZnNldFBvc2l0aW9uID0gaXNWZXJ0aWNhbCA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J1xuXG4gICAgJHRpcC5vZmZzZXQob2Zmc2V0KVxuICAgIHRoaXMucmVwbGFjZUFycm93KGFycm93RGVsdGEsICR0aXBbMF1bYXJyb3dPZmZzZXRQb3NpdGlvbl0sIGlzVmVydGljYWwpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5yZXBsYWNlQXJyb3cgPSBmdW5jdGlvbiAoZGVsdGEsIGRpbWVuc2lvbiwgaXNIb3Jpem9udGFsKSB7XG4gICAgdGhpcy5hcnJvdygpXG4gICAgICAuY3NzKGlzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnLCA1MCAqICgxIC0gZGVsdGEgLyBkaW1lbnNpb24pICsgJyUnKVxuICAgICAgLmNzcyhpc0hvcml6b250YWwgPyAndG9wJyA6ICdsZWZ0JywgJycpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFRpdGxlKClcblxuICAgICR0aXAuZmluZCgnLnRvb2x0aXAtaW5uZXInKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHQnKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuICAgIHZhciBlICAgID0gJC5FdmVudCgnaGlkZS5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICBpZiAodGhhdC5ob3ZlclN0YXRlICE9ICdpbicpICR0aXAuZGV0YWNoKClcbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgICAudHJpZ2dlcignaGlkZGVuLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkdGlwXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBjb21wbGV0ZSgpXG5cbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZml4VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIGlmICgkZS5hdHRyKCd0aXRsZScpIHx8IHR5cGVvZiAoJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScpKSAhPSAnc3RyaW5nJykge1xuICAgICAgJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsICRlLmF0dHIoJ3RpdGxlJykgfHwgJycpLmF0dHIoJ3RpdGxlJywgJycpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICRlbGVtZW50ICAgPSAkZWxlbWVudCB8fCB0aGlzLiRlbGVtZW50XG5cbiAgICB2YXIgZWwgICAgID0gJGVsZW1lbnRbMF1cbiAgICB2YXIgaXNCb2R5ID0gZWwudGFnTmFtZSA9PSAnQk9EWSdcblxuICAgIHZhciBlbFJlY3QgICAgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGlmIChlbFJlY3Qud2lkdGggPT0gbnVsbCkge1xuICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBhcmUgbWlzc2luZyBpbiBJRTgsIHNvIGNvbXB1dGUgdGhlbSBtYW51YWxseTsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMTQwOTNcbiAgICAgIGVsUmVjdCA9ICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHsgd2lkdGg6IGVsUmVjdC5yaWdodCAtIGVsUmVjdC5sZWZ0LCBoZWlnaHQ6IGVsUmVjdC5ib3R0b20gLSBlbFJlY3QudG9wIH0pXG4gICAgfVxuICAgIHZhciBlbE9mZnNldCAgPSBpc0JvZHkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgc2Nyb2xsICAgID0geyBzY3JvbGw6IGlzQm9keSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgOiAkZWxlbWVudC5zY3JvbGxUb3AoKSB9XG4gICAgdmFyIG91dGVyRGltcyA9IGlzQm9keSA/IHsgd2lkdGg6ICQod2luZG93KS53aWR0aCgpLCBoZWlnaHQ6ICQod2luZG93KS5oZWlnaHQoKSB9IDogbnVsbFxuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHNjcm9sbCwgb3V0ZXJEaW1zLCBlbE9mZnNldClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50ID09ICdib3R0b20nID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0LCAgIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiAgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICA/IHsgdG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgIH0gOlxuICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgPyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgLSBhY3R1YWxXaWR0aCB9IDpcbiAgICAgICAgLyogcGxhY2VtZW50ID09ICdyaWdodCcgKi8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoICAgfVxuXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHRvcDogMCwgbGVmdDogMCB9XG4gICAgaWYgKCF0aGlzLiR2aWV3cG9ydCkgcmV0dXJuIGRlbHRhXG5cbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmIHRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nIHx8IDBcbiAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydClcblxuICAgIGlmICgvcmlnaHR8bGVmdC8udGVzdChwbGFjZW1lbnQpKSB7XG4gICAgICB2YXIgdG9wRWRnZU9mZnNldCAgICA9IHBvcy50b3AgLSB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsXG4gICAgICB2YXIgYm90dG9tRWRnZU9mZnNldCA9IHBvcy50b3AgKyB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsICsgYWN0dWFsSGVpZ2h0XG4gICAgICBpZiAodG9wRWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy50b3ApIHsgLy8gdG9wIG92ZXJmbG93XG4gICAgICAgIGRlbHRhLnRvcCA9IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgLSB0b3BFZGdlT2Zmc2V0XG4gICAgICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkgeyAvLyBib3R0b20gb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCArIHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLSBib3R0b21FZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0RWRnZU9mZnNldCAgPSBwb3MubGVmdCAtIHZpZXdwb3J0UGFkZGluZ1xuICAgICAgdmFyIHJpZ2h0RWRnZU9mZnNldCA9IHBvcy5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nICsgYWN0dWFsV2lkdGhcbiAgICAgIGlmIChsZWZ0RWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0KSB7IC8vIGxlZnQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0IC0gbGVmdEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFZGdlT2Zmc2V0ID4gdmlld3BvcnREaW1lbnNpb25zLndpZHRoKSB7IC8vIHJpZ2h0IG92ZXJmbG93XG4gICAgICAgIGRlbHRhLmxlZnQgPSB2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCAtIHJpZ2h0RWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpdGxlXG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGl0bGUgPSAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRVSUQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgZG8gcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKVxuICAgIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJHRpcCA9IHRoaXMuJHRpcCB8fCAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcudG9vbHRpcC1hcnJvdycpKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoZSkge1xuICAgICAgc2VsZiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihlLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYudGlwKCkuaGFzQ2xhc3MoJ2luJykgPyBzZWxmLmxlYXZlKHNlbGYpIDogc2VsZi5lbnRlcihzZWxmKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9mZignLicgKyB0aGF0LnR5cGUpLnJlbW92ZURhdGEoJ2JzLicgKyB0aGF0LnR5cGUpXG4gICAgfSlcbiAgfVxuXG5cbiAgLy8gVE9PTFRJUCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgID0gJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcpXG4gICAgICB2YXIgb3B0aW9ucyAgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuICAgICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlbGVjdG9yXG5cbiAgICAgIGlmICghZGF0YSAmJiBvcHRpb24gPT0gJ2Rlc3Ryb3knKSByZXR1cm5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnLCAoZGF0YSA9IHt9KSlcbiAgICAgICAgaWYgKCFkYXRhW3NlbGVjdG9yXSkgZGF0YVtzZWxlY3Rvcl0gPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50b29sdGlwJywgKGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udG9vbHRpcFxuXG4gICQuZm4udG9vbHRpcCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IgPSBUb29sdGlwXG5cblxuICAvLyBUT09MVElQIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnRvb2x0aXAubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRvb2x0aXAgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHBvcG92ZXIuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNwb3BvdmVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFBPUE9WRVIgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXQoJ3BvcG92ZXInLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEkLmZuLnRvb2x0aXApIHRocm93IG5ldyBFcnJvcignUG9wb3ZlciByZXF1aXJlcyB0b29sdGlwLmpzJylcblxuICBQb3BvdmVyLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIFBvcG92ZXIuREVGQVVMVFMgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiPjwvZGl2PjwvZGl2PidcbiAgfSlcblxuXG4gIC8vIE5PVEU6IFBPUE9WRVIgRVhURU5EUyB0b29sdGlwLmpzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSlcblxuICBQb3BvdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wb3Zlci5ERUZBVUxUU1xuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRpcCAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgICA9IHRoaXMuZ2V0VGl0bGUoKVxuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KClcblxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci1jb250ZW50JykuY2hpbGRyZW4oKS5kZXRhY2goKS5lbmQoKVsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgICAgdGhpcy5vcHRpb25zLmh0bWwgPyAodHlwZW9mIGNvbnRlbnQgPT0gJ3N0cmluZycgPyAnaHRtbCcgOiAnYXBwZW5kJykgOiAndGV4dCdcbiAgICBdKGNvbnRlbnQpXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpbicpXG5cbiAgICAvLyBJRTggZG9lc24ndCBhY2NlcHQgaGlkaW5nIHZpYSB0aGUgYDplbXB0eWAgcHNldWRvIHNlbGVjdG9yLCB3ZSBoYXZlIHRvIGRvXG4gICAgLy8gdGhpcyBtYW51YWxseSBieSBjaGVja2luZyB0aGUgY29udGVudHMuXG4gICAgaWYgKCEkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaHRtbCgpKSAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaGlkZSgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5nZXRDb250ZW50KClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgcmV0dXJuICRlLmF0dHIoJ2RhdGEtY29udGVudCcpXG4gICAgICB8fCAodHlwZW9mIG8uY29udGVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIG8uY29udGVudC5jYWxsKCRlWzBdKSA6XG4gICAgICAgICAgICBvLmNvbnRlbnQpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcuYXJyb3cnKSlcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJHRpcCkgdGhpcy4kdGlwID0gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgcmV0dXJuIHRoaXMuJHRpcFxuICB9XG5cblxuICAvLyBQT1BPVkVSIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICAgPSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJylcbiAgICAgIHZhciBvcHRpb25zICA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG4gICAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3JcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbiA9PSAnZGVzdHJveScpIHJldHVyblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicsIChkYXRhID0ge30pKVxuICAgICAgICBpZiAoIWRhdGFbc2VsZWN0b3JdKSBkYXRhW3NlbGVjdG9yXSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInLCAoZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5wb3BvdmVyXG5cbiAgJC5mbi5wb3BvdmVyICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ucG9wb3Zlci5Db25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuXG4gIC8vIFBPUE9WRVIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ucG9wb3Zlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ucG9wb3ZlciA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogc2Nyb2xsc3B5LmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jc2Nyb2xsc3B5XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU0NST0xMU1BZIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBwcm9jZXNzICA9ICQucHJveHkodGhpcy5wcm9jZXNzLCB0aGlzKVxuXG4gICAgdGhpcy4kYm9keSAgICAgICAgICA9ICQoJ2JvZHknKVxuICAgIHRoaXMuJHNjcm9sbEVsZW1lbnQgPSAkKGVsZW1lbnQpLmlzKCdib2R5JykgPyAkKHdpbmRvdykgOiAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgICA9ICQuZXh0ZW5kKHt9LCBTY3JvbGxTcHkuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5zZWxlY3RvciAgICAgICA9ICh0aGlzLm9wdGlvbnMudGFyZ2V0IHx8ICcnKSArICcgLm5hdiBsaSA+IGEnXG4gICAgdGhpcy5vZmZzZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbEhlaWdodCAgID0gMFxuXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudC5vbignc2Nyb2xsLmJzLnNjcm9sbHNweScsIHByb2Nlc3MpXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgICB0aGlzLnByb2Nlc3MoKVxuICB9XG5cbiAgU2Nyb2xsU3B5LlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIFNjcm9sbFNweS5ERUZBVUxUUyA9IHtcbiAgICBvZmZzZXQ6IDEwXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kc2Nyb2xsRWxlbWVudFswXS5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgodGhpcy4kYm9keVswXS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9mZnNldE1ldGhvZCA9ICdvZmZzZXQnXG4gICAgdmFyIG9mZnNldEJhc2UgICA9IDBcblxuICAgIGlmICghJC5pc1dpbmRvdyh0aGlzLiRzY3JvbGxFbGVtZW50WzBdKSkge1xuICAgICAgb2Zmc2V0TWV0aG9kID0gJ3Bvc2l0aW9uJ1xuICAgICAgb2Zmc2V0QmFzZSAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKVxuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0cyA9IFtdXG4gICAgdGhpcy50YXJnZXRzID0gW11cbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcblxuICAgIHZhciBzZWxmICAgICA9IHRoaXNcblxuICAgIHRoaXMuJGJvZHlcbiAgICAgIC5maW5kKHRoaXMuc2VsZWN0b3IpXG4gICAgICAubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbCAgID0gJCh0aGlzKVxuICAgICAgICB2YXIgaHJlZiAgPSAkZWwuZGF0YSgndGFyZ2V0JykgfHwgJGVsLmF0dHIoJ2hyZWYnKVxuICAgICAgICB2YXIgJGhyZWYgPSAvXiMuLy50ZXN0KGhyZWYpICYmICQoaHJlZilcblxuICAgICAgICByZXR1cm4gKCRocmVmXG4gICAgICAgICAgJiYgJGhyZWYubGVuZ3RoXG4gICAgICAgICAgJiYgJGhyZWYuaXMoJzp2aXNpYmxlJylcbiAgICAgICAgICAmJiBbWyRocmVmW29mZnNldE1ldGhvZF0oKS50b3AgKyBvZmZzZXRCYXNlLCBocmVmXV0pIHx8IG51bGxcbiAgICAgIH0pXG4gICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF0gfSlcbiAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vZmZzZXRzLnB1c2godGhpc1swXSlcbiAgICAgICAgc2VsZi50YXJnZXRzLnB1c2godGhpc1sxXSlcbiAgICAgIH0pXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkgKyB0aGlzLm9wdGlvbnMub2Zmc2V0XG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcbiAgICB2YXIgbWF4U2Nyb2xsICAgID0gdGhpcy5vcHRpb25zLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuJHNjcm9sbEVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0cyAgICAgID0gdGhpcy5vZmZzZXRzXG4gICAgdmFyIHRhcmdldHMgICAgICA9IHRoaXMudGFyZ2V0c1xuICAgIHZhciBhY3RpdmVUYXJnZXQgPSB0aGlzLmFjdGl2ZVRhcmdldFxuICAgIHZhciBpXG5cbiAgICBpZiAodGhpcy5zY3JvbGxIZWlnaHQgIT0gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlZnJlc2goKVxuICAgIH1cblxuICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICByZXR1cm4gYWN0aXZlVGFyZ2V0ICE9IChpID0gdGFyZ2V0c1t0YXJnZXRzLmxlbmd0aCAtIDFdKSAmJiB0aGlzLmFjdGl2YXRlKGkpXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZVRhcmdldCAmJiBzY3JvbGxUb3AgPCBvZmZzZXRzWzBdKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhcmdldCA9IG51bGxcbiAgICAgIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgYWN0aXZlVGFyZ2V0ICE9IHRhcmdldHNbaV1cbiAgICAgICAgJiYgc2Nyb2xsVG9wID49IG9mZnNldHNbaV1cbiAgICAgICAgJiYgKCFvZmZzZXRzW2kgKyAxXSB8fCBzY3JvbGxUb3AgPD0gb2Zmc2V0c1tpICsgMV0pXG4gICAgICAgICYmIHRoaXMuYWN0aXZhdGUodGFyZ2V0c1tpXSlcbiAgICB9XG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICB0aGlzLmNsZWFyKClcblxuICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgK1xuICAgICAgICAnW2RhdGEtdGFyZ2V0PVwiJyArIHRhcmdldCArICdcIl0sJyArXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgKyAnW2hyZWY9XCInICsgdGFyZ2V0ICsgJ1wiXSdcblxuICAgIHZhciBhY3RpdmUgPSAkKHNlbGVjdG9yKVxuICAgICAgLnBhcmVudHMoJ2xpJylcbiAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcblxuICAgIGlmIChhY3RpdmUucGFyZW50KCcuZHJvcGRvd24tbWVudScpLmxlbmd0aCkge1xuICAgICAgYWN0aXZlID0gYWN0aXZlXG4gICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgICBhY3RpdmUudHJpZ2dlcignYWN0aXZhdGUuYnMuc2Nyb2xsc3B5JylcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCh0aGlzLnNlbGVjdG9yKVxuICAgICAgLnBhcmVudHNVbnRpbCh0aGlzLm9wdGlvbnMudGFyZ2V0LCAnLmFjdGl2ZScpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuc2Nyb2xsc3B5JylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5zY3JvbGxzcHknLCAoZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnNjcm9sbHNweVxuXG4gICQuZm4uc2Nyb2xsc3B5ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uc2Nyb2xsc3B5LkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5XG5cblxuICAvLyBTQ1JPTExTUFkgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5zY3JvbGxzcHkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnNjcm9sbHNweSA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICAkKHdpbmRvdykub24oJ2xvYWQuYnMuc2Nyb2xsc3B5LmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXNweT1cInNjcm9sbFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkc3B5LCAkc3B5LmRhdGEoKSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0YWIuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVEFCIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVGFiID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gIH1cblxuICBUYWIuVkVSU0lPTiA9ICczLjMuMCdcblxuICBUYWIuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRhYi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRoaXMgICAgPSB0aGlzLmVsZW1lbnRcbiAgICB2YXIgJHVsICAgICAgPSAkdGhpcy5jbG9zZXN0KCd1bDpub3QoLmRyb3Bkb3duLW1lbnUpJylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5kYXRhKCd0YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICBpZiAoJHRoaXMucGFyZW50KCdsaScpLmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHByZXZpb3VzID0gJHVsLmZpbmQoJy5hY3RpdmU6bGFzdCBhJylcbiAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy50YWInLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiAkdGhpc1swXVxuICAgIH0pXG4gICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMudGFiJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogJHByZXZpb3VzWzBdXG4gICAgfSlcblxuICAgICRwcmV2aW91cy50cmlnZ2VyKGhpZGVFdmVudClcbiAgICAkdGhpcy50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHZhciAkdGFyZ2V0ID0gJChzZWxlY3RvcilcblxuICAgIHRoaXMuYWN0aXZhdGUoJHRoaXMuY2xvc2VzdCgnbGknKSwgJHVsKVxuICAgIHRoaXMuYWN0aXZhdGUoJHRhcmdldCwgJHRhcmdldC5wYXJlbnQoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgJHByZXZpb3VzLnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnaGlkZGVuLmJzLnRhYicsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICR0aGlzWzBdXG4gICAgICB9KVxuICAgICAgJHRoaXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdzaG93bi5icy50YWInLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiAkcHJldmlvdXNbMF1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFRhYi5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHZhciAkYWN0aXZlICAgID0gY29udGFpbmVyLmZpbmQoJz4gLmFjdGl2ZScpXG4gICAgdmFyIHRyYW5zaXRpb24gPSBjYWxsYmFja1xuICAgICAgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb25cbiAgICAgICYmICgoJGFjdGl2ZS5sZW5ndGggJiYgJGFjdGl2ZS5oYXNDbGFzcygnZmFkZScpKSB8fCAhIWNvbnRhaW5lci5maW5kKCc+IC5mYWRlJykubGVuZ3RoKVxuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICRhY3RpdmVcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmUnKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmVuZCgpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICAgIGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gcmVmbG93IGZvciB0cmFuc2l0aW9uXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2ZhZGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykpIHtcbiAgICAgICAgZWxlbWVudFxuICAgICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICAkYWN0aXZlLmxlbmd0aCAmJiB0cmFuc2l0aW9uID9cbiAgICAgICRhY3RpdmVcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgbmV4dClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRhYi5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBuZXh0KClcblxuICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2luJylcbiAgfVxuXG5cbiAgLy8gVEFCIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLnRhYicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMudGFiJywgKGRhdGEgPSBuZXcgVGFiKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi50YWJcblxuICAkLmZuLnRhYiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRhYi5Db25zdHJ1Y3RvciA9IFRhYlxuXG5cbiAgLy8gVEFCIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PVxuXG4gICQuZm4udGFiLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi50YWIgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBUQUIgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgUGx1Z2luLmNhbGwoJCh0aGlzKSwgJ3Nob3cnKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLnRhYi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nLCBjbGlja0hhbmRsZXIpXG4gICAgLm9uKCdjbGljay5icy50YWIuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsIGNsaWNrSGFuZGxlcilcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWZmaXguanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhZmZpeFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEFGRklYIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBBZmZpeCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEFmZml4LkRFRkFVTFRTLCBvcHRpb25zKVxuXG4gICAgdGhpcy4kdGFyZ2V0ID0gJCh0aGlzLm9wdGlvbnMudGFyZ2V0KVxuICAgICAgLm9uKCdzY3JvbGwuYnMuYWZmaXguZGF0YS1hcGknLCAkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbiwgdGhpcykpXG4gICAgICAub24oJ2NsaWNrLmJzLmFmZml4LmRhdGEtYXBpJywgICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcCwgdGhpcykpXG5cbiAgICB0aGlzLiRlbGVtZW50ICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLmFmZml4ZWQgICAgICA9XG4gICAgdGhpcy51bnBpbiAgICAgICAgPVxuICAgIHRoaXMucGlubmVkT2Zmc2V0ID0gbnVsbFxuXG4gICAgdGhpcy5jaGVja1Bvc2l0aW9uKClcbiAgfVxuXG4gIEFmZml4LlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIEFmZml4LlJFU0VUICAgID0gJ2FmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b20nXG5cbiAgQWZmaXguREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHRhcmdldDogd2luZG93XG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgICAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRoaXMuJHRhcmdldC5oZWlnaHQoKVxuXG4gICAgaWYgKG9mZnNldFRvcCAhPSBudWxsICYmIHRoaXMuYWZmaXhlZCA9PSAndG9wJykgcmV0dXJuIHNjcm9sbFRvcCA8IG9mZnNldFRvcCA/ICd0b3AnIDogZmFsc2VcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgPT0gJ2JvdHRvbScpIHtcbiAgICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCkgcmV0dXJuIChzY3JvbGxUb3AgKyB0aGlzLnVucGluIDw9IHBvc2l0aW9uLnRvcCkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgICByZXR1cm4gKHNjcm9sbFRvcCArIHRhcmdldEhlaWdodCA8PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pID8gZmFsc2UgOiAnYm90dG9tJ1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsaXppbmcgICA9IHRoaXMuYWZmaXhlZCA9PSBudWxsXG4gICAgdmFyIGNvbGxpZGVyVG9wICAgID0gaW5pdGlhbGl6aW5nID8gc2Nyb2xsVG9wIDogcG9zaXRpb24udG9wXG4gICAgdmFyIGNvbGxpZGVySGVpZ2h0ID0gaW5pdGlhbGl6aW5nID8gdGFyZ2V0SGVpZ2h0IDogaGVpZ2h0XG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgY29sbGlkZXJUb3AgPD0gb2Zmc2V0VG9wKSByZXR1cm4gJ3RvcCdcbiAgICBpZiAob2Zmc2V0Qm90dG9tICE9IG51bGwgJiYgKGNvbGxpZGVyVG9wICsgY29sbGlkZXJIZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0Qm90dG9tKSkgcmV0dXJuICdib3R0b20nXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5nZXRQaW5uZWRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGlubmVkT2Zmc2V0KSByZXR1cm4gdGhpcy5waW5uZWRPZmZzZXRcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKS5hZGRDbGFzcygnYWZmaXgnKVxuICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKClcbiAgICB2YXIgcG9zaXRpb24gID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVxuICAgIHJldHVybiAodGhpcy5waW5uZWRPZmZzZXQgPSBwb3NpdGlvbi50b3AgLSBzY3JvbGxUb3ApXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dCgkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbiwgdGhpcyksIDEpXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHJldHVyblxuXG4gICAgdmFyIGhlaWdodCAgICAgICA9IHRoaXMuJGVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0ICAgICAgID0gdGhpcy5vcHRpb25zLm9mZnNldFxuICAgIHZhciBvZmZzZXRUb3AgICAgPSBvZmZzZXQudG9wXG4gICAgdmFyIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b21cbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gJCgnYm9keScpLmhlaWdodCgpXG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCAhPSAnb2JqZWN0JykgICAgICAgICBvZmZzZXRCb3R0b20gPSBvZmZzZXRUb3AgPSBvZmZzZXRcbiAgICBpZiAodHlwZW9mIG9mZnNldFRvcCA9PSAnZnVuY3Rpb24nKSAgICBvZmZzZXRUb3AgICAgPSBvZmZzZXQudG9wKHRoaXMuJGVsZW1lbnQpXG4gICAgaWYgKHR5cGVvZiBvZmZzZXRCb3R0b20gPT0gJ2Z1bmN0aW9uJykgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0LmJvdHRvbSh0aGlzLiRlbGVtZW50KVxuXG4gICAgdmFyIGFmZml4ID0gdGhpcy5nZXRTdGF0ZShzY3JvbGxIZWlnaHQsIGhlaWdodCwgb2Zmc2V0VG9wLCBvZmZzZXRCb3R0b20pXG5cbiAgICBpZiAodGhpcy5hZmZpeGVkICE9IGFmZml4KSB7XG4gICAgICBpZiAodGhpcy51bnBpbiAhPSBudWxsKSB0aGlzLiRlbGVtZW50LmNzcygndG9wJywgJycpXG5cbiAgICAgIHZhciBhZmZpeFR5cGUgPSAnYWZmaXgnICsgKGFmZml4ID8gJy0nICsgYWZmaXggOiAnJylcbiAgICAgIHZhciBlICAgICAgICAgPSAkLkV2ZW50KGFmZml4VHlwZSArICcuYnMuYWZmaXgnKVxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICB0aGlzLmFmZml4ZWQgPSBhZmZpeFxuICAgICAgdGhpcy51bnBpbiA9IGFmZml4ID09ICdib3R0b20nID8gdGhpcy5nZXRQaW5uZWRPZmZzZXQoKSA6IG51bGxcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoQWZmaXguUkVTRVQpXG4gICAgICAgIC5hZGRDbGFzcyhhZmZpeFR5cGUpXG4gICAgICAgIC50cmlnZ2VyKGFmZml4VHlwZS5yZXBsYWNlKCdhZmZpeCcsICdhZmZpeGVkJykgKyAnLmJzLmFmZml4JylcbiAgICB9XG5cbiAgICBpZiAoYWZmaXggPT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2Zmc2V0KHtcbiAgICAgICAgdG9wOiBzY3JvbGxIZWlnaHQgLSBoZWlnaHQgLSBvZmZzZXRCb3R0b21cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cblxuICAvLyBBRkZJWCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5hZmZpeCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuYWZmaXgnLCAoZGF0YSA9IG5ldyBBZmZpeCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYWZmaXhcblxuICAkLmZuLmFmZml4ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYWZmaXguQ29uc3RydWN0b3IgPSBBZmZpeFxuXG5cbiAgLy8gQUZGSVggTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmFmZml4Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5hZmZpeCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFGRklYIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJCh3aW5kb3cpLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXNweT1cImFmZml4XCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHNweSA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhID0gJHNweS5kYXRhKClcblxuICAgICAgZGF0YS5vZmZzZXQgPSBkYXRhLm9mZnNldCB8fCB7fVxuXG4gICAgICBpZiAoZGF0YS5vZmZzZXRCb3R0b20gIT0gbnVsbCkgZGF0YS5vZmZzZXQuYm90dG9tID0gZGF0YS5vZmZzZXRCb3R0b21cbiAgICAgIGlmIChkYXRhLm9mZnNldFRvcCAgICAhPSBudWxsKSBkYXRhLm9mZnNldC50b3AgICAgPSBkYXRhLm9mZnNldFRvcFxuXG4gICAgICBQbHVnaW4uY2FsbCgkc3B5LCBkYXRhKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgTWVudU1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2FtcC1tZW51cy1tb2RlbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgdXJsOiAnL3Jlc3Qvc2VjdXJpdHkvbWVudXMnLFxuICBtb2RlbDogTWVudU1vZGVsLFxuXG4gIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jYWNoZSA9IGZhbHNlO1xuICAgIHJldHVybiBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG59KTtcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbm1vZHVsZS5leHBvcnRzICA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuXHR1cmw6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICcvcmVzdC90cmFuc2xhdGlvbnMvbGFuZ3VhZ2VzJ1xyXG5cdH1cclxufSk7IiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICB1cmw6ICcvcmVzdC9zZWN1cml0eS9sYXlvdXQnLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW1haWw6IHVuZGVmaW5lZFxuICB9LFxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2FjaGUgPSBmYWxzZTtcbiAgICByZXR1cm4gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIHVybDogJy9yZXN0L3NlY3VyaXR5L21lbnVzJyxcblxuICBkZWZhdWx0czoge1xuICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9LFxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2FjaGUgPSBmYWxzZTtcbiAgICByZXR1cm4gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG5cdHVybDogJy9yZXN0L2FtcC9zZXR0aW5ncydcbn0pOyIsIlxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIFRlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlXFxcIiBpZD1cXFwiYWJvdXQtcG9wdXBcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIm15TW9kYWxMYWJlbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPlxcclxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCI+XFxyXFxuIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRlbnRcXFwiPlxcclxcbiA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+PHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L3NwYW4+PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNsb3NlXFxcIiBjbGFzcz1cXFwic3Itb25seVxcXCI+Q2xvc2U8L3NwYW4+PC9idXR0b24+XFxyXFxuICAgICAgICA8aDQgY2xhc3M9XFxcIm1vZGFsLXRpdGxlIHRleHQtcHJpbWFyeVxcXCIgZGF0YS1pMThuPVxcXCJhbXAuYWJvdXQ6bW9kYWwudGl0bGVcXFwiPkFib3V0IEFNUDwvaDQ+XFxyXFxuIDwvZGl2Plxcclxcbjx0YWJsZSB3aWR0aD1cXFwiNDc0XFxcIiBib3JkZXI9XFxcIjBcXFwiIHN0eWxlPVxcXCJtYXJnaW46MTVweDtcXFwiPlxcclxcblxcdDx0Ym9keT48dHI+XFxyXFxuXFx0XFx0PHRkIHdpZHRoPVxcXCIyNTdcXFwiPlxcclxcblxcdFxcdDxwIGFsaWduPVxcXCJjZW50ZXJcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6IDE2cHg7XFxcIj48c3Ryb25nPiZuYnNwOzxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjpwbGF0Zm9ybVxcXCI+QWlkIE1hbmFnZW1lbnQgUGxhdGZvcm0gKEFNUCk8L3NwYW4+PC9zdHJvbmc+PC9wPlxcclxcblxcdFxcdDxwIGFsaWduPVxcXCJjZW50ZXJcXFwiPiBWZXJzaW9uIDwlPSBhbXBWZXJzaW9uICU+PC9wPlxcclxcblxcdFxcdDwvdGQ+XFxyXFxuXFx0XFx0PHRkIHdpZHRoPVxcXCIyMjBcXFwiPjxpbWcgd2lkdGg9XFxcIjIyMFxcXCIgaGVpZ2h0PVxcXCIxMDBcXFwiIHNyYz1cXFwiL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2ltZ18yL2xvZ28tZGV2ZWxvcG1lbnQtZ2F0ZXdheS5wbmdcXFwiPjwvdGQ+XFxyXFxuXFx0PC90cj5cXHJcXG5cXHQ8dHI+XFxyXFxuXFx0XFx0PHRkIGNvbHNwYW49XFxcIjJcXFwiPlxcclxcblxcdFxcdDxwICBzdHlsZT1cXFwiZm9udC1zaXplOiAxMnB4O1xcXCI+Jm5ic3A7PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnBsYXRmb3JtXFxcIj5BaWQgTWFuYWdlbWVudCBQbGF0Zm9ybSAoQU1QKTwvc3Bhbj5cXHJcXG5cXHRcXHQgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuYWJvdXQ6dmVyc2lvblxcXCI+VmVyc2lvbjwvc3Bhbj4gPCU9IGFtcFZlcnNpb24gJT4gPCU9IGJ1aWxkRGF0ZSAlPlxcclxcblxcdFxcdDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmFib3V0OmNyZWRpdHNcXFwiPkRldmVsb3BlZCBpbiBwYXJ0bmVyc2hpcCB3aXRoIE9FQ0QsIFVORFAsIFdCLCBHb3Zlcm5tZW50IG9mIEV0aGlvcGlhIGFuZCBEZXZlbG9wbWVudCBHYXRld2F5IEZvdW5kYXRpb248L3NwYW4+LlxcclxcblxcdFxcdDwvcD5cXHJcXG5cXHRcXHQ8L3RkPlxcclxcblxcdDwvdHI+XFxyXFxuXFx0PHRyPlxcclxcblxcdFxcdDx0ZCBjb2xzcGFuPVxcXCIyXFxcIj5cXHJcXG5cXHRcXHQ8cCBzdHlsZT1cXFwiZm9udC1zaXplOiAxMnB4O1xcXCI+XFxyXFxuXFx0XFx0PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuYWJvdXQ6dHJhZGVtYXJrXFxcIj5UaGUgRGV2ZWxvcG1lbnQgR2F0ZXdheSBhbmQgdGhlIFRoZSBEZXZlbG9wbWVudCBHYXRld2F5IGxvZ28gYXJlIHRyYWRlbWFya3MgZm9yIFRoZSBEZXZlbG9wbWVudCBHYXRld2F5IEZvdW5kYXRpb248L3NwYW4+LjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmFib3V0OnJpZ2h0c1xcXCI+QWxsIFJpZ2h0cyBSZXNlcnZlZDwvc3Bhbj4uPC9wPlxcclxcblxcdFxcdDwvdGQ+XFxyXFxuXFx0PC90cj5cXHJcXG48L3Rib2R5PjwvdGFibGU+XFxyXFxuPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuPC9kaXY+XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXHJcbiAgaWQ6ICdhYm91dE1vZGFsJywgIFxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHQgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XHJcbiAgICBfLmJpbmRBbGwodGhpcywgJ3JlbmRlcicpO1xyXG5cclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHRfLmRlZmF1bHRzKHdpbmRvdywge2FtcFZlcnNpb246IFwiMFwiLCBidWlsZERhdGU6IFwiMFwifSk7XHJcbiAgICB0aGlzLiRlbC5odG1sKHNlbGYudGVtcGxhdGUoe1xyXG4gICAgICBhbXBWZXJzaW9uOiB3aW5kb3cuYW1wVmVyc2lvbixcclxuICAgICAgYnVpbGREYXRlOiB3aW5kb3cuYnVpbGREYXRlXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgXHJcbn0pO1xyXG5cclxuIiwiXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5yZXF1aXJlKCdib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAnKTtcblxudmFyIFRlbXBsYXRlID0gXCI8c3R5bGU+XFxyXFxuICAgIC5mb290ZXJUZXh0IHtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgZm9udC1mYW1pbHk6IGFyaWFsO1xcclxcbiAgICBmb250LXNpemU6IDExcHg7XFxyXFxuICAgIGJvcmRlcjogMHB4O1xcclxcbiAgICB9XFxyXFxuICAgIC5mb290ZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOEI4QjhCO1xcclxcbiAgICBjb2xvcjogI0ZGRjtcXHJcXG4gICAgbWFyZ2luLXRvcDogMDtcXHJcXG4gICAgcGFkZGluZy1ib3R0b206IDEwcHg7XFxyXFxuICAgIHBhZGRpbmctdG9wOiAxMHB4O1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIH1cXHJcXG4gICAgLmRnZl9mb290ZXIge1xcclxcbiAgICBjb2xvcjogIzhCOEI4QjtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDE4cHg7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtcXHJcXG4gICAgcGFkZGluZy10b3A6MTBweDtcXHJcXG4gICAgfVxcclxcbiAgICAuZGdmX2Zvb3RlciBpbWcge1xcclxcbiAgICBsaW5lLWhlaWdodDogMThweDtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcclxcbiAgICB9XFxyXFxuICAgIC5sb2FkaW5neyAgIFxcclxcbiAgICAgIG1hcmdpbjogMTBweCAyMHB4IDEwcHggMjBweDtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG48L3N0eWxlPlxcclxcblxcclxcbjxkaXYgY2xhc3M9XFxcImZvb3RlciBmb290ZXJUZXh0XFxcIj5cXHJcXG4gICAgQU1QIDxiPjwlPSAgcHJvcGVydGllcy5hbXBWZXJzaW9uICU+PC9iPiBidWlsZCA8Yj48JT0gIHByb3BlcnRpZXMuYnVpbGREYXRlICU+PC9iPiAtIDwlPSBwcm9wZXJ0aWVzLmZvb3RlclRleHQgJT5cXHJcXG4gICAgPCUgaWYoc2hvd0FkbWluTGlua3MgPT0gdHJ1ZSAgJiYgcHJvcGVydGllcy5hZG1pbkxpbmtzICE9IHVuZGVmaW5lZCkgeyAlPlxcclxcbiAgICA8YSBocmVmPSc8JT0gIHByb3BlcnRpZXMuYWRtaW5MaW5rc1swXS51cmwgJT4nPjwlPSAgcHJvcGVydGllcy5hZG1pbkxpbmtzWzBdLm5hbWUgJT48L2E+XFxyXFxuICAgIDwlIH0gJT5cXHJcXG48L2Rpdj5cXHJcXG48JSBpZihzaG93REdGb290ZXIgPT0gdHJ1ZSkgIHsgJT5cXHJcXG48ZGl2IGNsYXNzPVxcXCJkZ2ZfZm9vdGVyIGZvb3RlclRleHRcXFwiPlxcclxcbiAgICA8aW1nIHNyYz1cXFwiL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2ltZ18yL2RnZl9sb2dvX2JvdHRvbS5naWZcXFwiIGNsYXNzPVxcXCJkZ2ZfbG9nb19mb290ZXJcXFwiPlxcclxcbiAgICA8YnIvPlxcclxcbiAgICBEZXZlbG9wbWVudCBHYXRld2F5XFxyXFxuICAgIDxici8+XFxyXFxuICAgIDExMTAgVmVybW9udCBBdmUsIE5XLCBTdWl0ZSA1MDBcXHJcXG4gICAgPGJyLz5cXHJcXG4gICAgV2FzaGluZ3RvbiwgREMgMjAwMDUgVVNBXFxyXFxuICAgIDxici8+XFxyXFxuICAgIGluZm9AZGV2ZWxvcG1lbnRnYXRld2F5Lm9yZywgVGVsOiArMS4yMDIuNTcyLjkyMDBcXHJcXG48L2Rpdj5cXHJcXG48JSB9ICU+XFxyXFxuXFxyXFxuPCUgaWYocHJvcGVydGllcy50cmFja2luZ0VuYWJsZWQgPT09IHRydWUpIHsgJT5cXHJcXG48IS0tIFBpd2lrXFxyXFxuU2l0ZSBpZCBjYW4gYmUgY2hlY2tlZCBoZXJlOiBodHRwOi8vc3RhdHMuYW1wc2l0ZS5uZXQvaW5kZXgucGhwP21vZHVsZT1TaXRlc01hbmFnZXImYWN0aW9uPWluZGV4JmlkU2l0ZT0xJnBlcmlvZD1yYW5nZSZkYXRlPWxhc3QzMFxcclxcbkFsc28sdGhlIHdpa2kgZm9yIHBpd2lrOiBodHRwczovL3dpa2kuZGdmb3VuZGF0aW9uLm9yZy9kaXNwbGF5L0FNUERPQy9JbnRlZ3JhdGluZytBTVArd2l0aCtQaXdpa1xcclxcbi0tPlxcclxcbjxzY3JpcHQgdHlwZT1cXFwidGV4dC9qYXZhc2NyaXB0XFxcIj5cXHJcXG5cXHQgIHZhciBfcGFxID0gX3BhcSB8fCBbXTtcXHJcXG4gICAgaWYgKHdpbmRvdy5QaXdpa0FscmVhZHlGZXRjaGVkID09PSB1bmRlZmluZWQgKSB7XFxyXFxuICAgICAgX3BhcS5wdXNoKFsnc2V0VXNlcklkJywgXFxcIjwlPSBwcm9wZXJ0aWVzLmVtYWlsICU+XFxcIl0pO1xcclxcbiAgICAgIF9wYXEucHVzaChbJ3NldEN1c3RvbVZhcmlhYmxlJyxcXHJcXG4gICAgICAgICAgMSxcXHJcXG4gICAgICAgICAgXFxcIldvcmtzcGFjZXxXSURcXFwiLFxcclxcbiAgICAgICAgICBcXFwiPCU9IHByb3BlcnRpZXMud29ya3NwYWNlICU+fDwlPSBwcm9wZXJ0aWVzLndvcmtzcGFjZUlkICU+XFxcIixcXHJcXG4gICAgICAgICAgXFxcInBhZ2VcXFwiXSk7XFxyXFxuICBcXHQgIF9wYXEucHVzaChbXFxcInRyYWNrUGFnZVZpZXdcXFwiXSk7XFxyXFxuICBcXHQgIF9wYXEucHVzaChbXFxcImVuYWJsZUxpbmtUcmFja2luZ1xcXCJdKTtcXHJcXG5cXHJcXG4gICAgICAvKiBUREs6IGtlZXAgdHJhY2sgb2Ygd2hldGhlciB3ZSBwdXQgdGhlIHNjcmlwdCBET00gbm9kZSBvbiB0aGUgcGFnZSBhbHJlYWR5XFxyXFxuICAgICAgICogICBpbiBjYXNlIHRoZSBwYWdlIHJlcGFyc2VzIHRoaXMgamF2YXNjcmlwdCBvbiBhbm90aGVyIG1vZGlmaWNhdGlvbi5cXHJcXG4gICAgICAgKi9cXHJcXG4gICAgICB3aW5kb3cuUGl3aWtBbHJlYWR5RmV0Y2hlZCA9IHRydWU7XFxyXFxuXFxyXFxuICAgICAgLyogU3RvY2sgUGl3aWsgY29kZTogKi9cXHJcXG4gIFxcdCAgKGZ1bmN0aW9uKCkge1xcclxcbiAgXFx0ICAgIHZhciB1PVxcXCI8JT0gIHByb3BlcnRpZXMudHJhY2tpbmdVcmwgJT5cXFwiO1xcclxcbiAgXFx0ICAgIF9wYXEucHVzaChbXFxcInNldFRyYWNrZXJVcmxcXFwiLCB1K1xcXCJwaXdpay5waHBcXFwiXSk7XFxyXFxuICBcXHQgICAgX3BhcS5wdXNoKFtcXFwic2V0U2l0ZUlkXFxcIiwgXFxcIjwlPXByb3BlcnRpZXMuc2l0ZUlkICU+XFxcIl0pO1xcclxcbiAgXFx0ICAgIHZhciBkPWRvY3VtZW50LCBnPWQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIiksIHM9ZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwic2NyaXB0XFxcIilbMF07IGcudHlwZT1cXFwidGV4dC9qYXZhc2NyaXB0XFxcIjtcXHJcXG4gIFxcdCAgICBnLmRlZmVyPXRydWU7IGcuYXN5bmM9dHJ1ZTsgZy5zcmM9dStcXFwicGl3aWsuanNcXFwiOyBzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGcscyk7XFxyXFxuICBcXHQgIH0pKCk7XFxyXFxuICAgIH1cXHJcXG5cXHQ8L3NjcmlwdD5cXHJcXG48IS0tIEVuZCBQaXdpayBDb2RlIC0tPlxcclxcbjwlIH0gJT5cXHJcXG5cIjtcbnZhciBMYXlvdXRNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9hbXAtbGF5b3V0LW1vZGVsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBtb2RlbDogbnVsbCxcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxuICBlbDogJyNhbXAtZm9vdGVyJyxcbiAgbGF5b3V0RmV0Y2hlZDogbmV3ICQuRGVmZXJyZWQoKSxcbiAgc2hvd0FkbWluRm9vdGVyOiB0cnVlLFxuICBzaG93REdGb290ZXI6IHRydWUsICBcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuc2hvd0FkbWluRm9vdGVyID0gb3B0aW9ucy5zaG93QWRtaW5Gb290ZXI7XG4gICAgdGhpcy5zaG93REdGb290ZXIgPSBvcHRpb25zLnNob3dER0Zvb3RlcjtcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB0aGlzLnJlbmRlcigpOyAgICBcbiAgICBfLmJpbmRBbGwodGhpcywgJ3JlbmRlcicpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe1xuICAgICAgICBwcm9wZXJ0aWVzOiBzZWxmLm1vZGVsLFxuICAgICAgICBzaG93QWRtaW5MaW5rczogc2VsZi5zaG93QWRtaW5Gb290ZXIsXG4gICAgICAgIHNob3dER0Zvb3Rlcjogc2VsZi5zaG93REdGb290ZXJcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gIFxuXG59KTtcbiIsIlxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnJlcXVpcmUoJ2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgVGVtcGxhdGUgPSBcIjxsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvc3JjL2Nzcy9tYWluLmNzc1xcXCI+XFxuPCUgaWYoY3VycmVudExhbmd1YWdlLmdldChcXFwibHRyLWRpcmVjdGlvblxcXCIpID09PSBmYWxzZSkgeyAlPlxcbiAgPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCIvVEVNUExBVEUvYW1wVGVtcGxhdGUvY3NzXzIvYW1wLXJ0bC5jc3NcXFwiPlxcbiAgPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCIvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9zcmMvY3NzL2JvaWxlcnBsYXRlLXJ0bC5jc3NcXFwiPlxcbjwlIH0gJT5cXG48c2NyaXB0IHR5cGU9XFxcInRleHQvamF2YXNjcmlwdFxcXCI+XFxuICBmdW5jdGlvbiBzd2l0Y2hUcmFuc2xhdGlvbiAodXJsKSB7XFxuICAgICQoJyNiYWNrVXJsJykudmFsKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpO1xcbiAgICBkb2N1bWVudC5tb2RlU3dpdGNoRm9ybS5hY3Rpb24gPSB1cmw7XFxuICAgIGRvY3VtZW50Lm1vZGVTd2l0Y2hGb3JtLnN1Ym1pdCgpO1xcbiAgfVxcbjwvc2NyaXB0Plxcbjxmb3JtIG5hbWU9XFxcIm1vZGVTd2l0Y2hGb3JtXFxcIiBtZXRob2Q9XFxcInBvc3RcXFwiIGFjdGlvbj1cXFwiL3RyYW5zbGF0aW9uL3N3aXRjaE1vZGUuZG9cXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcImJhY2tVcmxcXFwiIGlkPVxcXCJiYWNrVXJsXFxcIiB2YWx1ZT1cXFwiXFxcIj5cXG48L2Zvcm0+XFxuPCVcXG4vKioqXFxuICogU2luZ2xlIFJvdyBIZWFkZXIgRGVzaWduICh1c2VkIHdoZW4gb3B0aW9uYWxseSByZXF1ZXN0ZWQ6IG9uIEdJUylcXG4gKiBVc2VmdWwgZm9yIGZpeGVkIGhlaWdodCBhcHBzLlxcbiAqXFxuICogQ29udGFpbmVyLWZsdWlkIHN0cnVjdHVyZTpcXG4gKiByb3dcXG4gKiAgY29sdW1uIG5hdmJhci1icmFuZCAobG9nbylcXG4gKiAgY29sdW1uIG5hdmJhci1jb2xsYXBzZVxcbiAqICAgIG5lc3RlZCByb3c6XFxuICogICAgICBjb2x1bW5zIEFtcE1lbnVzIChwdWJsaWMgb3IgaW50ZXJuYWwgbWVudXMgc2hvd24gYXMgcHJvdmlkZWQgYnkgQVBJKVxcbiAqICAgICAgbmVzdGVkIHJvdyBhbXBVc2VyTG9nZ2VkSW5NZW51cyAoc2hvd24gd2hlbiBsb2dnZWQgaW4sIGluY2w6IHdvcmtzcGFjZSwgdXNlciwgbG9nb3V0KTpcXG4gKiAgICAgICAgMyBjb2x1bW5zXFxuICogIGxvZ2luX2hlcmUgKGlnbm9yZXMgYm9vdHN0cmFwIGNvbnRhaW5lciBzdHJ1Y3R1cmU7IHNob3duIHdoZW4gbG9nZ2VkIG91dClcXG4gKiAgZGl2I2xvZ2luY29udGFpbmVyOiBpbnNlcnRlZCBieSBqUXVlcnkgKyByZW5kZXJlZCBieSBKU1BcXG4gKioqL1xcblxcbiAgaWYgKHVzZVNpbmdsZVJvd0hlYWRlcikge1xcbiAlPlxcbjxuYXYgY2xhc3M9XFxcIm5hdmJhciBuYXZiYXItZGVmYXVsdCBzaW5nbGUtcm93XFxcIiByb2xlPVxcXCJuYXZpZ2F0aW9uXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mbHVpZCA8JT0gcHJvcGVydGllcy5sb2dnZWQgPT09IHRydWUgPyAnYW1wVXNlckxvZ2dlZEluJyA6ICcnICU+XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93IG5vLWd1dHRlcnNcXFwiPlxcbiAgICAgIDwhLS0gLmFtcFVzZXJMb2dnZWRJbiBoaWRlcyBwdWJsaWMgdmVyc2lvbi0tPlxcblxcbiAgICAgIDwhLS0gQnJhbmQgYW5kIHRvZ2dsZSBnZXQgZ3JvdXBlZCBmb3IgYmV0dGVyIG1vYmlsZSBkaXNwbGF5IC0tPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1oZWFkZXIgY29sLXNtLTFcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJuYXZiYXItdG9nZ2xlXFxcIiBkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiIGRhdGEtdGFyZ2V0PVxcXCIjYnMtZXhhbXBsZS1uYXZiYXItY29sbGFwc2UtMVxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8YSBpZD1cXFwiaGVhZGVyVXJsXFxcIiBjbGFzcz1cXFwibmF2YmFyLWJyYW5kXFxcIiBocmVmPVxcXCI8JT0gcHJvcGVydGllcy5sb2dnZWQgPT09IHRydWUgPyAnL2FpbScgOiAnLycgJT5cXFwiIGRhdGEtaTE4bj1cXFwiW3RpdGxlXWFtcC5jb21tb246cGxhdGZvcm1cXFwiPlxcbiAgICAgICAgICA8c3Bhbj5cXG4gICAgICAgICAgICA8aW1nIGNsYXNzPVxcXCJmbGFnXFxcIiBzcmM9XFxcIi9haW0vZGVmYXVsdC9kaXNwbGF5RmxhZy5kb1xcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgd2lkdGg9XFxcIjMwXFxcIj5cXG4gICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5jb21tb246cGxhdGZvcm0tc2hvcnRcXFwiPkFNUDwvc3Bhbj48L2E+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTExXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZSByb3cgbm8tZ3V0dGVyc1xcXCIgaWQ9XFxcImJzLWV4YW1wbGUtbmF2YmFyLWNvbGxhcHNlLTFcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOCBjb2wtc20tMTBcXFwiPlxcbiAgICAgICAgICAgIDx1bCBpZD1cXFwiQW1wTWVudXNcXFwiIGNsYXNzPVxcXCJuYXYgbmF2YmFyLW5hdiBtZW51c1xcXCI+XFxuXFxuICAgICAgICAgICAgICA8IS0tIEZpbGUgLS0+XFxuXFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNCBjb2wtc20tMlxcXCI+XFxuICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcInJvdyBuby1ndXR0ZXJzIG5hdiBuYXZiYXItbmF2IGFtcFVzZXJMb2dnZWRJbiBhbXBMb2dnZWRJbk1lbnVzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGlkPVxcXCJoZWFkZXItd29ya3NwYWNlLWxpXFxcIiBjbGFzcz1cXFwiY29sLXNtLTkgY29sLW1kLTZcXFwiPjxhIHRpdGxlPVxcXCJXb3Jrc3BhY2VcXFwiIGNsYXNzPVxcXCJ3b3Jrc3BhY2UtbmFtZVxcXCIgaWQ9XFxcImhlYWRlci13b3Jrc3BhY2VcXFwiIHRpdGxlPVxcXCI8JT0gcHJvcGVydGllcy53b3Jrc3BhY2UgPyBwcm9wZXJ0aWVzLndvcmtzcGFjZSA6ICcnICU+XFxcIj48JT0gcHJvcGVydGllcy53b3Jrc3BhY2UgPyBwcm9wZXJ0aWVzLndvcmtzcGFjZSA6IFxcXCIgXFxcIiAlPjwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1uYW1lXFxcIiBjbGFzcz1cXFwiaGlkZGVuLXhzIGhpZGRlbi1zbSBjb2wtbWQtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInVzZXItdXJsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPVxcXCJoZWFkZXItZmlyc3QtbmFtZVxcXCI+PCU9IHByb3BlcnRpZXMuZmlyc3ROYW1lID8gcHJvcGVydGllcy5maXJzdE5hbWUgOiBcXFwiIFxcXCIgICU+PC9zcGFuPiZuYnNwOzxzcGFuIGlkPVxcXCJoZWFkZXItbGFzdC1uYW1lXFxcIj48JT0gcHJvcGVydGllcy5sYXN0TmFtZSA/IHByb3BlcnRpZXMubGFzdE5hbWUgOiBcXFwiIFxcXCIgJT48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1sb2dvdXRcXFwiIGNsYXNzPVxcXCJjb2wtc20tMlxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ291dFxcXCIgaHJlZj1cXFwiL2FpbS9qX3NwcmluZ19sb2dvdXRcXFwiID5Mb2dvdXQ8L2E+PC9saT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICA8JSBpZihzaG93TG9naW4pIHsgJT5cXG4gICAgICAgICAgICAgICAgPCUgaWYobG9naW5Ecm9wZG93bil7ICU+XFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibG9naW5faGVyZVxcXCIgaWQ9XFxcInNob3dfbG9naW5fcG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luX2hlcmVfY29udFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgIDxhIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dpblxcXCIgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIj5Mb2dpbjwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXYgYW1wUHVibGljIG5hdmJhci1yaWdodFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1sb2dpblxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ2luXFxcIiBocmVmPVxcXCIvbG9naW4uZG9cXFwiID5Mb2dpbjwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwhLS0gZGl2I2xvZ2luY29udGFpbmVyIHdpdGggYW5jaG9ycyBnZXRzIGFwcGVuZGVkIGhlcmUgLS0+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgIDwvZGl2PlxcbiAgICA8IS0tIENvbGxlY3QgdGhlIG5hdiBsaW5rcywgZm9ybXMsIGFuZCBvdGhlciBjb250ZW50IGZvciB0b2dnbGluZyAtLT5cXG4gIDwvZGl2PjwhLS0gLy5jb250YWluZXItZmx1aWQgLS0+XFxuPC9uYXY+XFxuIDwlIH0gZWxzZSB7ICU+XFxuXFxuPCUgLyoqKlxcbiAqIERvdWJsZSBSb3cgSGVhZGVyIERlc2lnbiAodXNlZCBieSBkZWZhdWx0KVxcbiAqXFxuICogQ29udGFpbmVyLUZsdWlkIHN0cnVjdHVyZTpcXG4gKiByb3dcXG4gKiAgY29sdW1uIG5hdmJhci1icmFuZCAobG9nbylcXG4gKiAgY29sdW1uIG5hdmJhci1jb2xsYXBzZVxcbiAqICAgIG5lc3RlZCByb3c6XFxuICogICAgICAgIG5lc3RlZCByb3cgYW1wVXNlckxvZ2dlZEluTWVudXMgKHNob3duIHdoZW4gbG9nZ2VkIGluLCBpbmNsOiB3b3Jrc3BhY2UsIHVzZXIsIGxvZ291dCk6XFxuICAgICAgICAgICAgMyBjb2x1bW5zXFxuICogcm93XFxuICogICAgY29sdW1ucyBBbXBNZW51cyAocHVibGljIG9yIGludGVybmFsIG1lbnVzIHNob3duIGFzIHByb3ZpZGVkIGJ5IEFQSSlcXG4gKiAgbG9naW5faGVyZSAoaWdub3JlcyBib290c3RyYXAgY29udGFpbmVyIHN0cnVjdHVyZSwgc2hvd24gd2hlbiBsb2dnZWQgb3V0KVxcbiAqICBkaXYjbG9naW5jb250YWluZXI6IGluc2VydGVkIGJ5IGpRdWVyeSArIHJlbmRlcmVkIGJ5IEpTUFxcbiAqKiovICU+XFxuPG5hdiBjbGFzcz1cXFwibmF2YmFyIG5hdmJhci1kZWZhdWx0IGRvdWJsZS1yb3dcXFwiIHJvbGU9XFxcIm5hdmlnYXRpb25cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWZsdWlkIG5vLWd1dHRlcnMgPCU9IHByb3BlcnRpZXMubG9nZ2VkID09PSB0cnVlID8gJ2FtcFVzZXJMb2dnZWRJbicgOiAnJyAlPlxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvdyBuby1ndXR0ZXJzXFxcIj5cXG4gICAgICA8IS0tIC5hbXBVc2VyTG9nZ2VkSW4gaGlkZXMgcHVibGljIHZlcnNpb24tLT5cXG5cXG4gICAgICA8IS0tIEJyYW5kIGFuZCB0b2dnbGUgZ2V0IGdyb3VwZWQgZm9yIGJldHRlciBtb2JpbGUgZGlzcGxheSAtLT5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaGVhZGVyIGNvbC1zbS0xIGNvbC1zbS1vZmZzZXQtMVxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm5hdmJhci10b2dnbGVcXFwiIGRhdGEtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCIgZGF0YS10YXJnZXQ9XFxcIiNicy1leGFtcGxlLW5hdmJhci1jb2xsYXBzZS0xXFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPlRvZ2dsZSBuYXZpZ2F0aW9uPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxhIGlkPVxcXCJoZWFkZXJVcmxcXFwiIGNsYXNzPVxcXCJuYXZiYXItYnJhbmRcXFwiIGhyZWY9XFxcIjwlPSBwcm9wZXJ0aWVzLmxvZ2dlZCA9PT0gdHJ1ZSA/ICcvYWltJyA6ICcvJyAlPlxcXCIgZGF0YS1pMThuPVxcXCJbdGl0bGVdYW1wLmNvbW1vbjpwbGF0Zm9ybVxcXCI+XFxuICAgICAgICAgIDxzcGFuPlxcbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcImZsYWdcXFwiIHNyYz1cXFwiL2FpbS9kZWZhdWx0L2Rpc3BsYXlGbGFnLmRvXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB3aWR0aD1cXFwiMzBcXFwiPlxcbiAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjpwbGF0Zm9ybS1zaG9ydFxcXCI+QU1QPC9zcGFuPjwvYT5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tOVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2Ugcm93IG5vLWd1dHRlcnNcXFwiIGlkPVxcXCJicy1leGFtcGxlLW5hdmJhci1jb2xsYXBzZS0xXFxcIj5cXG4gICAgICAgICAgPCEtLSBUbyBjaGFuZ2Ugd29ya3NwYWNlL3VzZXIgdHJ1bmNhdGlvbiBsZW5ndGgsIGVkaXQgdGhlIG9mZnNldCBhbmQgZ3JpZCBudW1iZXIgYmVsb3c6LS0+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS1vZmZzZXQtNSBjb2wtc20tN1xcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJyb3cgbm8tZ3V0dGVycyBuYXYgbmF2YmFyLW5hdiBhbXBVc2VyTG9nZ2VkSW4gYW1wTG9nZ2VkSW5NZW51c1xcXCI+XFxuICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci13b3Jrc3BhY2UtbGlcXFwiIGNsYXNzPVxcXCJjb2wtc20tOSBjb2wtbWQtNlxcXCI+PGEgdGl0bGU9XFxcIldvcmtzcGFjZVxcXCIgY2xhc3M9XFxcIndvcmtzcGFjZS1uYW1lXFxcIiBpZD1cXFwiaGVhZGVyLXdvcmtzcGFjZVxcXCIgdGl0bGU9XFxcIjwlPSBwcm9wZXJ0aWVzLndvcmtzcGFjZSA/IHByb3BlcnRpZXMud29ya3NwYWNlIDogJycgJT5cXFwiPjwlPSBwcm9wZXJ0aWVzLndvcmtzcGFjZSA/IHByb3BlcnRpZXMud29ya3NwYWNlIDogXFxcIiBcXFwiICU+PC9hPjwvbGk+XFxuICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1uYW1lXFxcIiBjbGFzcz1cXFwiaGlkZGVuLXhzIGhpZGRlbi1zbSBjb2wtbWQtNFxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJ1c2VyLXVybFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9XFxcImhlYWRlci1maXJzdC1uYW1lXFxcIj48JT0gcHJvcGVydGllcy5maXJzdE5hbWUgPyBwcm9wZXJ0aWVzLmZpcnN0TmFtZSA6IFxcXCIgXFxcIiAgJT48L3NwYW4+Jm5ic3A7PHNwYW4gaWQ9XFxcImhlYWRlci1sYXN0LW5hbWVcXFwiPjwlPSBwcm9wZXJ0aWVzLmxhc3ROYW1lID8gcHJvcGVydGllcy5sYXN0TmFtZSA6IFxcXCIgXFxcIiAlPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDxsaSBpZD1cXFwiaGVhZGVyLWxvZ291dFxcXCIgY2xhc3M9XFxcImNvbC1zbS0yXFxcIj48YSBkYXRhLWkxOG49XFxcImFtcC5jb21tb246dGl0bGUtbG9nb3V0XFxcIiBocmVmPVxcXCIvYWltL2pfc3ByaW5nX2xvZ291dFxcXCIgPkxvZ291dDwvYT48L2xpPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPCUgaWYoc2hvd0xvZ2luKSB7ICU+XFxuICAgICAgICAgICAgICA8JSBpZihsb2dpbkRyb3Bkb3duKXsgJT5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibG9naW5faGVyZVxcXCIgaWQ9XFxcInNob3dfbG9naW5fcG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbl9oZXJlX2NvbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ2luXFxcIiBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiPkxvZ2luPC9hPlxcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXYgYW1wUHVibGljIG5hdmJhci1yaWdodFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGxpIGlkPVxcXCJoZWFkZXItbG9naW5cXFwiPjxhIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dpblxcXCIgaHJlZj1cXFwiL2xvZ2luLmRvXFxcIiA+TG9naW48L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPCEtLSBkaXYjbG9naW5jb250YWluZXIgd2l0aCBhbmNob3JzIGdldHMgYXBwZW5kZWQgaGVyZSAtLT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvdyBuby1ndXR0ZXJzXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTEgY29sLXNtLW9mZnNldC0xXFxcIj5cXG4gICAgICAgIDx1bCBpZD1cXFwiQW1wTWVudXNcXFwiIGNsYXNzPVxcXCJuYXYgbmF2YmFyLW5hdiBtZW51c1xcXCI+XFxuXFxuICAgICAgICAgIDwhLS0gRmlsZSAtLT5cXG5cXG4gICAgICAgIDwvdWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8IS0tIENvbGxlY3QgdGhlIG5hdiBsaW5rcywgZm9ybXMsIGFuZCBvdGhlciBjb250ZW50IGZvciB0b2dnbGluZyAtLT5cXG4gIDwvZGl2PjwhLS0gLy5jb250YWluZXItZmx1aWQgLS0+XFxuPC9uYXY+XFxuXFxuPCVcXG4gIH0gJT5cXG5cIjtcbnZhciBNZW51Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL2FtcC1tZW51cy1jb2xsZWN0aW9uLmpzJyk7XG52YXIgTWVudU1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2FtcC1tZW51cy1tb2RlbC5qcycpO1xudmFyIFN1Ym1lbnVWaWV3ID0gcmVxdWlyZSgnLi9zdWJtZW51LWNvbXBvc2l0ZXZpZXcuanMnKTtcbnZhciBBYm91dFZpZXcgPSByZXF1aXJlKCcuL2Fib3V0LXZpZXcuanMnKTtcbnZhciBVc2VyUHJvZmlsZVZpZXcgPSByZXF1aXJlKCcuL3VzZXItcHJvZmlsZS12aWV3LmpzJyk7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuLi9tb2RlbHMvc2V0dGluZ3MnKTtcbnZhciBMYW5ndWFnZXMgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9sYW5ndWFnZS1jb2xsZWN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBlbDogJyNhbXAtaGVhZGVyJyxcbiAgYXBwZW5kRWw6ICcjQW1wTWVudXMnLFxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG4gIG1lbnVSZW5kZXJlZDogbmV3ICQuRGVmZXJyZWQoKSwgIFxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgI3Nob3dfbG9naW5fcG9wJzogJ29wZW5Mb2dpbkJveCcsXG4gICAgJ2NsaWNrIC51c2VyLXVybCcgOiAnc2hvd1VzZXJQcm9maWxlJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbGxlY3Rpb24gPSBuZXcgTWVudUNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3I7XG4gICAgdGhpcy5zaG93TG9naW4gPSBvcHRpb25zLnNob3dMb2dpbjtcbiAgICB0aGlzLnVzZVNpbmdsZVJvd0hlYWRlciA9IG9wdGlvbnMudXNlU2luZ2xlUm93SGVhZGVyO1xuICAgIHRoaXMubG9naW5Ecm9wZG93biA9ICEhb3B0aW9ucy5sb2dpbkRyb3Bkb3duO1xuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICB0aGlzLmxhbmd1YWdlcyA9IG5ldyBMYW5ndWFnZXMoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7ICAgICBcbiAgICAkLndoZW4uYXBwbHkoJCwgW3RoaXMuc2V0dGluZ3MuZmV0Y2goKSwgdGhpcy5jb2xsZWN0aW9uLmZldGNoKCksIHRoaXMubGFuZ3VhZ2VzLmZldGNoKCldKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBcdHNlbGYucmVuZGVyKCk7XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5maXJzdFJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5hYm91dCA9IG5ldyBBYm91dFZpZXcob3B0aW9ucyk7XG4gICAgdGhpcy51c2VyUHJvZmlsZSA9IG5ldyBVc2VyUHJvZmlsZVZpZXcob3B0aW9ucyk7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdhZGRPbmUnLCAnYWRkQWxsJywgJ3Nob3dBYm91dCcsICdzaG93VXNlclByb2ZpbGUnKTtcblxuICB9LFxuXG4gIGFkZEFsbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uLmVhY2godGhpcy5hZGRPbmUpO1xuICAgIHRoaXMubWVudVJlbmRlcmVkLnJlc29sdmUoKTtcbiAgfSxcblxuICBhZGRPbmU6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgdmlldyA9IG5ldyBTdWJtZW51Vmlldyh7XG4gICAgICBtb2RlbDogbW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlblRvKHZpZXcsICdzaG93QWJvdXQnLCB0aGlzLnNob3dBYm91dCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ3N3aXRjaExhbmd1YWdlJywgZnVuY3Rpb24obG5nKSB7XG4gICAgICBzZWxmLnRyYW5zbGF0b3Iuc2V0TGFuZ3VhZ2UobG5nLmxhbmd1YWdlKS5hbHdheXMoZnVuY3Rpb24oZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICBcdCAgaWYgKHRleHRTdGF0dXMgIT09IFwiZXJyb3JcIikge1xuICAgIFx0XHQgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIFx0ICB9IGVsc2Uge1xuICAgIFx0XHQgIC8vIEFNUC0yMTcxNDogRm9yIHNvbWUgdW5rbm93biByZWFzb24gdGhlcmUgYXJlIDIgYXN5bmMgY2FsbHMgdG8gdGhlIGVuZHBvaW50IGFuZCBGRiBzb21ldGltZXMgdGFrZXMgdGhlIGVycm9yIGZyb20gdGhlIDFzdCBjYWxsLlxuICAgICAgICBcdCAgc2VsZi50cmFuc2xhdG9yLnNldExhbmd1YWdlKGxuZy5sYW5ndWFnZSkuYWx3YXlzKGZ1bmN0aW9uKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgXHRcdFx0ICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICBcdFx0ICB9KTtcbiAgICBcdCAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmlldy5yZW5kZXIoKTtcbiAgICAkKHRoaXMuYXBwZW5kRWwpLmFwcGVuZCh2aWV3LmVsKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudExhbmd1YWdlID0gdGhpcy5sYW5ndWFnZXMuZmluZFdoZXJlKHtcImlkXCI6IHRoaXMuc2V0dGluZ3MuZ2V0KCdsYW5ndWFnZScpfSk7XG4gICAgaWYgKHRoaXMuZmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh7XG4gICAgICAgIHNob3dMb2dpbjogc2VsZi5zaG93TG9naW4sXG4gICAgICAgIGxvZ2luRHJvcGRvd246IHNlbGYubG9naW5Ecm9wZG93bixcbiAgICAgICAgdXNlU2luZ2xlUm93SGVhZGVyOiBzZWxmLnVzZVNpbmdsZVJvd0hlYWRlcixcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5tb2RlbCxcbiAgICAgICAgY3VycmVudExhbmd1YWdlOiBjdXJyZW50TGFuZ3VhZ2VcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuYWRkQWxsKCk7XG4gICAgICB0aGlzLmZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgICAvL0FzaGFtZWQgc3RpbGwsIEknbSBmb3JjZWQgdG8gdGhpcywgYmVjYXVzZSB0aGUgZm9ybSBjb21lcyBmcm9tIGBsb2dpbldpZGdldDMuanNgIGFuZCBJJ20gdG9vIGFmcmFpZCB0byB0b3VjaCBpdFxuICAgICAgJCgnI3Nob3dfbG9naW5fcG9wX2JveCcpLmluc2VydEJlZm9yZSgnI3Nob3dfbG9naW5fcG9wJyk7XG4gICAgICAkKCcjbG9naW5jb250YWluZXInKS5pbnNlcnRBZnRlcignI3Nob3dfbG9naW5fcG9wJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2hvd0Fib3V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoJCgnI2Fib3V0LXBvcHVwJykubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuJGVsLnBhcmVudCgpLmFwcGVuZCh0aGlzLmFib3V0LnJlbmRlcigpLmVsKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAkKCkubW9kYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICQubm9Db25mbGljdCgpO1xuICAgIH1cbiAgICAkKCcjYWJvdXQtcG9wdXAnKS5tb2RhbCh7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKCcjYWJvdXQtcG9wdXAnKVswXSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIG9wZW5Mb2dpbkJveDogZnVuY3Rpb24oKSB7XG4gICAgJChcImRpdiNzaG93X2xvZ2luX3BvcF9ib3hcIikuc2hvdygpO1xuICAgICQoXCIjal91c2VybmFtZVwiKS5mb2N1cygpO1xuICB9LFxuICBcbiAgc2hvd1VzZXJQcm9maWxlOiBmdW5jdGlvbigpe1xuXHQgIGlmICgkKCcjdXNlci1wcm9maWxlJykubGVuZ3RoID09IDApIHtcblx0ICAgICAgdGhpcy4kZWwucGFyZW50KCkuYXBwZW5kKHRoaXMudXNlclByb2ZpbGUucmVuZGVyKCkuZWwpO1xuXHQgIH1cblx0ICB0aGlzLnVzZXJQcm9maWxlLnNob3dVc2VyUHJvZmlsZSgpO1xufVxufSk7XG4iLCJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBUZW1wbGF0ZSA9IFwiPCVcXG4gIC8qIFByZXBhcmUgdGhlIEEgdGFnIGF0IHRvcCBsZXZlbCBtZW51cyAqL1xcbiAgaWYgKCFvYmoudXJsKSB7XFxuICAgICAgb2JqLnVybCA9ICcjJztcXG4gICAgICBvYmouY2xhc3NOYW1lID0gJ2Ryb3Bkb3duLXRvZ2dsZSc7XFxuICAgICAgb2JqLmRhdGFUb2dnbGUgPSAnZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIic7XFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgb2JqLmNsYXNzTmFtZSA9ICcnO1xcbiAgICAgIG9iai5kYXRhVG9nZ2xlID0gJyc7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9iai50YWIpIHtcXG4gICAgICBvYmoudGFiVGFyZ2V0ID0gJ3RhcmdldD1cXFwiX2JsYW5rXFxcIic7XFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgb2JqLnRhYlRhcmdldCA9ICcnO1xcbiAgICB9XFxuICAgICU+XFxuPCVcXG4vKiBUT0RPIGVzY2FwZSB0aGUgY29kZSBpbiBIVE1MICovXFxuJT5cXG48YSBocmVmPVxcXCI8JT0gdXJsICU+XFxcIiBjbGFzcz1cXFwiPCU9IGNsYXNzTmFtZSAlPlxcXCIgPCU9IGRhdGFUb2dnbGUgJT4gPCU9IG9iai50YWJUYXJnZXQgJT4gPlxcbiAgPHNwYW4gY2xhc3M9XFxcImRyb3Bkb3duLXRleHRcXFwiIHRpdGxlPVxcXCI8JT0gb2JqLm5hbWUudHJpbSgpICU+XFxcIj48JT0gb2JqLm5hbWUudHJpbSgpICU+Jm5ic3A7PC9zcGFuPjwlIGlmIChvYmouY2hpbGRyZW4gJiYgb2JqLmNoaWxkcmVuLmxlbmd0aCA+IDApIHsgJT48c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj48JSB9ICU+XFxuPC9hPlxcbjwlIGlmIChvYmouY2hpbGRyZW4gJiYgb2JqLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgeyAlPlxcbiAgPHVsIGNsYXNzPVxcXCJjaGlsZHJlbiBkcm9wZG93bi1tZW51XFxcIiByb2xlPVxcXCJtZW51XFxcIj5cXG4gIDwlIF8uZWFjaChvYmouY2hpbGRyZW4sIGZ1bmN0aW9uKG1vZGVsKSB7ICU+XFxuXFxuICAgIDwlXFxuICAgICAgLyogUHJlcGFyZSB0aGUgQSB0YWcgYXQgc2Vjb25kIGxldmVsIG1lbnVzICovXFxuICAgICAgaWYgKG1vZGVsLmNoaWxkcmVuICYmIG1vZGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xcbiAgICAgICAgbW9kZWwuZHJvcGRvd25TdWJtZW51ID0gJ2Ryb3Bkb3duLXN1Ym1lbnUnO1xcbiAgICAgICB9O1xcblxcbiAgICAgICBpZiAoIW1vZGVsLnRvb2x0aXApIHtcXG4gICAgICAgICBtb2RlbC50b29sdGlwID0gJyc7XFxuICAgICAgIH07XFxuICAgICAgIHZhciBlbGVtZW50Q2xhc3MgPSAnMm5kLWxldmVsLWl0ZW0nO1xcbiAgICAgICBpZiAobW9kZWwubGFuZ3VhZ2UpIHtcXG5cXHRcXHRcXHQgZWxlbWVudENsYXNzID0gZWxlbWVudENsYXNzKyAnIGxhbmd1YWdlJztcXG5cXHQgICB9XFxuICAgICAgIGlmIChtb2RlbC5wb3B1cCkge1xcbiAgICAgICBcXHQgZWxlbWVudENsYXNzID0gZWxlbWVudENsYXNzICsgJyBwb3B1cCc7XFxuICAgICAgIH1cXG4gICAgICAgaWYgKG1vZGVsLnRhYikge1xcbiAgICAgICAgIG1vZGVsLnRhYlRhcmdldCA9ICd0YXJnZXQ9XFxcIl9ibGFua1xcXCInO1xcbiAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgIG1vZGVsLnRhYlRhcmdldCA9ICcnO1xcbiAgICAgICB9XFxuICAgICAgIHZhciBlbGVtZW50VXJsID0gbW9kZWwudXJsO1xcbiAgICAgICBpZiAobW9kZWwucG9zdCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgIGVsZW1lbnRVcmwgPSAnamF2YXNjcmlwdDpzd2l0Y2hUcmFuc2xhdGlvbiAoXFxcIicrZWxlbWVudFVybCsnXFxcIiknO1xcblxcbiAgICAgICB9XFxuICAgICAgIGlmICghbW9kZWwudXJsKSB7XFxuICAgICAgICBlbGVtZW50VXJsID0gJ2phdmFzY3JpcHQ6Oyc7XFxuICAgICAgIH1cXG4gICAgICAgLyogaWYgaXQgZG9lc24ndCBoYXZlIGNoaWxkcmVuLCBub3IgdXJsLiB0aGVuIGl0IGlzIHRoZSBBYm91dCAqL1xcbiAgICAgICBpZiAoIW1vZGVsLnVybCAmJiAhbW9kZWwuY2hpbGRyZW4pIHtcXG4gICAgICAgZWxlbWVudENsYXNzID0gZWxlbWVudENsYXNzICsgJyBhYm91dC1hbXAnO1xcbiAgICAgICB9XFxuICAgICU+XFxuXFxuICAgIDxsaSBjbGFzcz0nZHJvcGRvd24gPCU9IG1vZGVsLmRyb3Bkb3duU3VibWVudSAlPicgPlxcbiAgICA8YSBocmVmPSc8JT0gIGVsZW1lbnRVcmwgJT4nIHRpdGxlPVxcXCI8JT0gbW9kZWwudG9vbHRpcCAlPlxcXCIgb25jbGljaz1cXFwicmV0dXJuIGNhbkV4aXQoKVxcXCIgY2xhc3M9XFxcIjwlPSBlbGVtZW50Q2xhc3MgJT5cXFwiIDwlPSBtb2RlbC50YWJUYXJnZXQgJT4gPjwlPSBtb2RlbC5uYW1lICU+PC9hPlxcblxcbiAgICA8JVxcbiAgICAgIGlmIChtb2RlbC5jaGlsZHJlbiAmJiBtb2RlbC5jaGlsZHJlbi5sZW5ndGggIT09IDApIHtcXG4gICAgICU+XFxuXFxuICAgICAgPHVsIGNsYXNzPVxcXCJjaGlsZHJlbiBkcm9wZG93bi1tZW51IHNjcm9sbGFibGUtbWVudVxcXCIgcm9sZT1cXFwibWVudVxcXCI+XFxuICAgICAgPCUgXy5lYWNoKG1vZGVsLmNoaWxkcmVuLCBmdW5jdGlvbihzdWJtb2RlbCkgeyAlPlxcblxcbiAgICAgICAgPCVcXG4gICAgICAgICAgLyogUHJlcGFyZSB0aGUgQSB0YWcgYXQgdGhpcmQgbGV2ZWwgbWVudXMgKi9cXG4gICAgICAgICAgaWYgKCFzdWJtb2RlbC51cmwpIHtcXG4gICAgICAgICAgICBzdWJtb2RlbC51cmwgPSAnIyc7XFxuICAgICAgICAgIH07XFxuXFx0XFx0ICB2YXIgaXRlbUNsYXNzID0gJzNyZC1sZXZlbC1pdGVtJztcXG5cXHRcXHQgIGlmIChzdWJtb2RlbC5sYW5ndWFnZSkge1xcblxcdFxcdFxcdCBpdGVtQ2xhc3MgPSBpdGVtQ2xhc3MrICcgbGFuZ3VhZ2UnO1xcblxcdFxcdCAgIH1cXG5cXHRcXHQgIGlmICghc3VibW9kZWwudG9vbHRpcCkge1xcbiAgICAgICAgICAgIHN1Ym1vZGVsLnRvb2x0aXAgPSAnJztcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgaWYgKHN1Ym1vZGVsLnRhYikge1xcbiAgICAgICAgICAgIHN1Ym1vZGVsLnRhYlRhcmdldD0ndGFyZ2V0PVxcXCJfYmxhbmtcXFwiJztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzdWJtb2RlbC50YWJUYXJnZXQgPSAnJztcXG4gICAgICAgICAgfTtcXG4gICAgICAgICU+XFxuXFxuICAgICAgICA8bGkgY2xhc3M9XFxcIm1lbnUtaXRlbVxcXCI+PGEgaHJlZj1cXFwiPCU9IHN1Ym1vZGVsLnVybCAlPlxcXCIgb25jbGljaz1cXFwicmV0dXJuIGNhbkV4aXQoKVxcXCIgY2xhc3M9XFxcIjwlPSBpdGVtQ2xhc3MgJT5cXFwiIDwlPSBzdWJtb2RlbC50YWJUYXJnZXQgJT4gdGl0bGU9XFxcIjwlPSBzdWJtb2RlbC50b29sdGlwICU+XFxcIj48JT0gc3VibW9kZWwubmFtZSAlPjwvYT48L2xpPlxcblxcbiAgICAgIDwlIH0pICU+XFxuICAgICAgPC91bD5cXG4gICAgPCUgfSAlPlxcblxcbiAgICA8L2xpPlxcblxcbiAgPCUgfSk7ICU+XFxuICA8L3VsPlxcbjwlIH0lPlxcbjwhLS1cXG48bGkgY2xhc3M9XFxcIm1lbnUtaXRlbSBkcm9wZG93biBkcm9wZG93bi1zdWJtZW51XFxcIj48YSBjbGFzcz1cXFwiZHJvcGRvd24tdG9nZ2xlXFxcIiBkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiPlxcbjx1bCBjbGFzcz1cXFwiY2hpbGRyZW4gZHJvcGRvd24tbWVudSBzY3JvbGxhYmxlLW1lbnVcXFwiIHJvbGU9XFxcIm1lbnVcXFwiPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwibWVudS1pdGVtIGZpcnN0LW9mLXR5cGVcXFwiIGlkPVxcXCJ5dWktZ2VuNFxcXCIgZ3JvdXBpbmRleD1cXFwiMFxcXCIgaW5kZXg9XFxcIjBcXFwiPlxcbiAgPGEgY2xhc3M9XFxcInl1aWFtcG1lbnVpdGVtbGFiZWwgeXVpbWVudWl0ZW1sYWJlbFxcXCIgaHJlZj1cXFwiL3NlbGVjdFRlYW0uZG8/aWQ9NjgwXFxcIiBvbmNsaWNrPVxcXCJyZXR1cm4gY2FuRXhpdCgpXFxcIj5cXG4gICAgQWNhZGVteSBvZiBTY2llbmNlc1xcbiAgPC9hPlxcbjwvbGk+LS0hPlxcblwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICB0YWdOYW1lOiAnbGknLFxuICBjbGFzc05hbWU6ICdkcm9wZG93bicsXG4gIGV2ZW50czoge1xuICAgICdjbGljayAubGFuZ3VhZ2UnOiAnc3dpdGNoTGFuZ3VhZ2UnLFxuICAgICdjbGljayAucG9wdXAnOiAnb3BlblBvcHVwJyxcbiAgICAnY2xpY2sgLmFib3V0LWFtcCc6ICdhYm91dCdcbiAgfSxcblxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdyZW5kZXInLCdzd2l0Y2hMYW5ndWFnZScsJ2Fib3V0Jyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZShzZWxmLm1vZGVsLmF0dHJpYnV0ZXMpKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgIHN3aXRjaExhbmd1YWdlOmZ1bmN0aW9uIChldmVudCkge1xuXHQgICB2YXIgaW5kZXggPSBldmVudC5jdXJyZW50VGFyZ2V0LmhyZWYubGFzdEluZGV4T2YgKCcvJyk7XG5cdCAgIHZhciBsbmcgPSBldmVudC5jdXJyZW50VGFyZ2V0LmhyZWYuc3Vic3RyIChpbmRleCArMSk7XG5cdCAgIC8vaWYgdGhlIFN3aXRoTGFuZ3VhZ2VNZW51IGV4aXN0cywgbGV0IHRoZSBqc3AgaGFuZGxlIGhvdyB0byBjaGFuZ2UgbGFuZ3VhZ2UuXG5cdCAgIC8vVE9ETyB0cmlnZ2VyIGFuIGV2ZW50IGFuZCBoYW5kbGUgb24gdGhlIGpzcFxuXHQgICBpZiAodHlwZW9mIFN3aXRjaExhbmd1YWdlTWVudSAhPT0gJ3VuZGVmaW5lZCcgJiYgJC5pc0Z1bmN0aW9uKFN3aXRjaExhbmd1YWdlTWVudSkpIHtcblx0XHQgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdCAgIHZhciB1cmwgPSBcIi90cmFuc2xhdGlvbi9zd2l0Y2hMYW5ndWFnZS5kbz9jb2RlPVwiK2xuZytcIiZyZnI9XCI7XG5cdFx0ICAgU3dpdGNoTGFuZ3VhZ2VNZW51ICh1cmwpO1xuXHQgICB9XG5cdCAgIGVsc2Uge1xuXHRcdCAgIHRoaXMudHJpZ2dlciAoJ3N3aXRjaExhbmd1YWdlJyx7bGFuZ3VhZ2U6bG5nfSk7XG5cdCAgIH1cblx0ICAgLyp2YXIgc2VsZiA9IHRoaXM7XG5cdCAgIHRoaXMuVHJhbnNsYXRvci5zZXRMYW5ndWFnZShsbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0ICAgc2VsZi5UcmFuc2xhdG9yLnRyYW5zbGF0ZURPTShkb2N1bWVudCk7IFxuICAgICAgIH0pOyovXG5cdCAgXG4gICB9LFxuICAgb3BlblBvcHVwOmZ1bmN0aW9uIChldmVudCkge1xuXHQgICB3aW5kb3cubmFtZSA9IFwib3BlbmVyXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0ICAgdmFyIHduZFdpZHRoID0gNzY4OyBcblx0ICAgdmFyIHduZEhlaWdodCA9IDEwMjQ7XG5cdCAgIHZhciB0ID0gKChzY3JlZW4ud2lkdGgpLTc2OCkvMjtcblx0ICAgdmFyIGwgPSAoKHNjcmVlbi5oZWlnaHQpLTEwMjQpLzI7XG5cdCAgIHZhciB3cGFyYW1zID0gXCJoZWlnaHQ9XCIgKyB3bmRIZWlnaHQgKyBcIix3aWR0aD1cIiArIHduZFdpZHRoICsgXCIsdG9wPVwiICsgbCArIFwiLGxlZnQ9XCIgKyB0ICtcIixtZW51YmFyPW5vLHNjcm9sbGJhcnM9eWVzXCI7XG5cdCAgIHBvcHVwUG9pbnRlciA9IHdpbmRvdy5vcGVuKGV2ZW50LmN1cnJlbnRUYXJnZXQuaHJlZiwgXCJmb3J1bVBvcHVwXCIsIHdwYXJhbXMpO1xuXHQgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICByZXR1cm4gcG9wdXBQb2ludGVyO1xuICAgfSxcbiAgIGFib3V0OmZ1bmN0aW9uIChldmVudCkge1xuXHQgICB0aGlzLnRyaWdnZXIgKCdzaG93QWJvdXQnLHt9KTtcblx0ICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuXG59KTtcblxuIiwiXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5yZXF1aXJlKCdib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAnKTtcbnZhciBUZW1wbGF0ZSA9IFwiPGRpdiBpZD1cXFwidXNlci1wcm9maWxlXFxcIiBjbGFzcz1cXFwibW9kYWwgZmFkZVxcXCIgIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIm15TW9kYWxMYWJlbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPlxcclxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCI+XFxyXFxuIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRlbnRcXFwiPlxcclxcbiA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+PHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L3NwYW4+PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNsb3NlXFxcIiBjbGFzcz1cXFwic3Itb25seVxcXCI+Q2xvc2U8L3NwYW4+PC9idXR0b24+XFxyXFxuICAgICAgICA8aDQgY2xhc3M9XFxcIm1vZGFsLXRpdGxlIHRleHQtcHJpbWFyeVxcXCIgZGF0YS1pMThuPVxcXCJhbXAucHJvZmlsZTptb2RhbC50aXRsZVxcXCI+TWVtYmVyIERldGFpbHM8L2g0PlxcclxcbiA8L2Rpdj5cXHJcXG4gPGRpdiBjbGFzcz1cXFwidXNlci1wcm9maWxlLWNvbnRlbnRcXFwiPlxcclxcbiAgIDxkaXYgY2xhc3M9J2xvYWRpbmcnIGRhdGEtaTE4bj1cXFwiYW1wLnByb2ZpbGU6bW9kYWwubG9hZGluZ1xcXCI+TG9hZGluZy4uLjwvZGl2PlxcclxcbiA8L2Rpdj4gXFxyXFxuIDwvZGl2PlxcclxcbiA8L2Rpdj5cXHJcXG4gPC9kaXY+XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBtb2RlbDogbnVsbCxcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxuICBpZDogJ3VzZXJQcm9maWxlTW9kYWwnLCAgXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIF8uYmluZEFsbCh0aGlzLCAncmVuZGVyJyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh7XG4gICAgICAgIHByb3BlcnRpZXM6IHNlbGYubW9kZWxcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNob3dVc2VyUHJvZmlsZTogZnVuY3Rpb24oKXtcblx0ICBpZiAodGhpcy5tb2RlbC5lbWFpbCkge1xuXHRcdCAgdmFyIHVybCA9ICcvYWltL2RlZmF1bHQvdXNlclByb2ZpbGUuZG9+ZWRpdD10cnVlfmlkPScgKyB0aGlzLm1vZGVsLnVzZXJJZDsgICAgICAgXG5cdFx0ICBpZighdGhpcy5wcm9maWxlTG9hZGVkICl7ICAgIFx0ICBcblx0XHRcdCAgdGhpcy4kKCcudXNlci1wcm9maWxlLWNvbnRlbnQnKS5sb2FkKHVybCk7ICBcblx0XHRcdCAgdGhpcy5wcm9maWxlTG9hZGVkID0gdHJ1ZTtcblx0XHQgIH0gICAgICAgICAgICBcblx0XHQgIGlmICh0eXBlb2YgJCgpLm1vZGFsICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQgICQubm9Db25mbGljdCgpO1xuXHRcdCAgfSAgIFxuXHRcdCAgdGhpcy4kKCcjdXNlci1wcm9maWxlJykubW9kYWwoe1xuXHRcdFx0ICBzaG93OiB0cnVlLFxuXHRcdFx0ICBiYWNrZHJvcDogZmFsc2Vcblx0XHQgIH0pO1xuXHQgIH1cbiAgfVxufSk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIENvcmUgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHJ1bmlxdWVJZCA9IC9edWktaWQtXFxkKyQvO1xuXG4vLyAkLnVpIG1pZ2h0IGV4aXN0IGZyb20gY29tcG9uZW50cyB3aXRoIG5vIGRlcGVuZGVuY2llcywgZS5nLiwgJC51aS5wb3NpdGlvblxuJC51aSA9ICQudWkgfHwge307XG5cbiQuZXh0ZW5kKCAkLnVpLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cblx0a2V5Q29kZToge1xuXHRcdEJBQ0tTUEFDRTogOCxcblx0XHRDT01NQTogMTg4LFxuXHRcdERFTEVURTogNDYsXG5cdFx0RE9XTjogNDAsXG5cdFx0RU5EOiAzNSxcblx0XHRFTlRFUjogMTMsXG5cdFx0RVNDQVBFOiAyNyxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUOiAzNyxcblx0XHROVU1QQURfQUREOiAxMDcsXG5cdFx0TlVNUEFEX0RFQ0lNQUw6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0TlVNUEFEX0VOVEVSOiAxMDgsXG5cdFx0TlVNUEFEX01VTFRJUExZOiAxMDYsXG5cdFx0TlVNUEFEX1NVQlRSQUNUOiAxMDksXG5cdFx0UEFHRV9ET1dOOiAzNCxcblx0XHRQQUdFX1VQOiAzMyxcblx0XHRQRVJJT0Q6IDE5MCxcblx0XHRSSUdIVDogMzksXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFRBQjogOSxcblx0XHRVUDogMzhcblx0fVxufSk7XG5cbi8vIHBsdWdpbnNcbiQuZm4uZXh0ZW5kKHtcblx0Zm9jdXM6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGRlbGF5LCBmbiApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQkKCBlbGVtICkuZm9jdXMoKTtcblx0XHRcdFx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoIGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBkZWxheSApO1xuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0pKCAkLmZuLmZvY3VzICksXG5cblx0c2Nyb2xsUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50O1xuXHRcdGlmICgoJC51aS5pZSAmJiAoLyhzdGF0aWN8cmVsYXRpdmUpLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSkgfHwgKC9hYnNvbHV0ZS8pLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKHJlbGF0aXZlfGFic29sdXRlfGZpeGVkKS8pLnRlc3QoJC5jc3ModGhpcyxcInBvc2l0aW9uXCIpKSAmJiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJvdmVyZmxvd1wiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteVwiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteFwiKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLFwib3ZlcmZsb3dcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXlcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXhcIikpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvZml4ZWQvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XG5cdH0sXG5cblx0ekluZGV4OiBmdW5jdGlvbiggekluZGV4ICkge1xuXHRcdGlmICggekluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jc3MoIFwiekluZGV4XCIsIHpJbmRleCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXNbIDAgXSApLCBwb3NpdGlvbiwgdmFsdWU7XG5cdFx0XHR3aGlsZSAoIGVsZW0ubGVuZ3RoICYmIGVsZW1bIDAgXSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdC8vIElnbm9yZSB6LWluZGV4IGlmIHBvc2l0aW9uIGlzIHNldCB0byBhIHZhbHVlIHdoZXJlIHotaW5kZXggaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlclxuXHRcdFx0XHQvLyBUaGlzIG1ha2VzIGJlaGF2aW9yIG9mIHRoaXMgZnVuY3Rpb24gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnNcblx0XHRcdFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxuXHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHQvLyBJRSByZXR1cm5zIDAgd2hlbiB6SW5kZXggaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0XHRcdC8vIG90aGVyIGJyb3dzZXJzIHJldHVybiBhIHN0cmluZ1xuXHRcdFx0XHRcdC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG5cdFx0XHRcdFx0Ly8gPGRpdiBzdHlsZT1cInotaW5kZXg6IC0xMDtcIj48ZGl2IHN0eWxlPVwiei1pbmRleDogMDtcIj48L2Rpdj48L2Rpdj5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KCBlbGVtLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApO1xuXHRcdFx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZSApICYmIHZhbHVlICE9PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtID0gZWxlbS5wYXJlbnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHR1bmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMuaWQgKSB7XG5cdFx0XHRcdHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKCsrdXVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlVW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bmlxdWVJZC50ZXN0KCB0aGlzLmlkICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVBdHRyKCBcImlkXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIHNlbGVjdG9yc1xuZnVuY3Rpb24gZm9jdXNhYmxlKCBlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOICkge1xuXHR2YXIgbWFwLCBtYXBOYW1lLCBpbWcsXG5cdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmICggXCJhcmVhXCIgPT09IG5vZGVOYW1lICkge1xuXHRcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRtYXBOYW1lID0gbWFwLm5hbWU7XG5cdFx0aWYgKCAhZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1hcFwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpbWcgPSAkKCBcImltZ1t1c2VtYXA9I1wiICsgbWFwTmFtZSArIFwiXVwiIClbMF07XG5cdFx0cmV0dXJuICEhaW1nICYmIHZpc2libGUoIGltZyApO1xuXHR9XG5cdHJldHVybiAoIC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdCggbm9kZU5hbWUgKSA/XG5cdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFwiYVwiID09PSBub2RlTmFtZSA/XG5cdFx0XHRlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdFx0XHRpc1RhYkluZGV4Tm90TmFOKSAmJlxuXHRcdC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcblx0XHR2aXNpYmxlKCBlbGVtZW50ICk7XG59XG5cbmZ1bmN0aW9uIHZpc2libGUoIGVsZW1lbnQgKSB7XG5cdHJldHVybiAkLmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtZW50ICkgJiZcblx0XHQhJCggZWxlbWVudCApLnBhcmVudHMoKS5hZGRCYWNrKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQuY3NzKCB0aGlzLCBcInZpc2liaWxpdHlcIiApID09PSBcImhpZGRlblwiO1xuXHRcdH0pLmxlbmd0aDtcbn1cblxuJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHRkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID9cblx0XHQkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKCBkYXRhTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBkYXRhTmFtZSApO1xuXHRcdFx0fTtcblx0XHR9KSA6XG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIG1hdGNoWyAzIF0gKTtcblx0XHR9LFxuXG5cdGZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzTmFOKCAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApICkgKTtcblx0fSxcblxuXHR0YWJiYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRhYkluZGV4ID0gJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSxcblx0XHRcdGlzVGFiSW5kZXhOYU4gPSBpc05hTiggdGFiSW5kZXggKTtcblx0XHRyZXR1cm4gKCBpc1RhYkluZGV4TmFOIHx8IHRhYkluZGV4ID49IDAgKSAmJiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc1RhYkluZGV4TmFOICk7XG5cdH1cbn0pO1xuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJCggXCI8YT5cIiApLm91dGVyV2lkdGgoIDEgKS5qcXVlcnkgKSB7XG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cblx0XHQkLmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJpbm5lclwiICsgbmFtZSBdLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCBzaXplLCBtYXJnaW4gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJvdXRlclwiICsgbmFtZSBdLmNhbGwoIHRoaXMsIHNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcykuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQuZm4uYWRkQmFjayApIHtcblx0JC5mbi5hZGRCYWNrID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDEuNi4xLCAxLjYuMiAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxMylcbmlmICggJCggXCI8YT5cIiApLmRhdGEoIFwiYS1iXCIsIFwiYVwiICkucmVtb3ZlRGF0YSggXCJhLWJcIiApLmRhdGEoIFwiYS1iXCIgKSApIHtcblx0JC5mbi5yZW1vdmVEYXRhID0gKGZ1bmN0aW9uKCByZW1vdmVEYXRhICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzLCAkLmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVEYXRhICk7XG59XG5cblxuXG5cblxuLy8gZGVwcmVjYXRlZFxuJC51aS5pZSA9ICEhL21zaWUgW1xcdy5dKy8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICk7XG5cbiQuc3VwcG9ydC5zZWxlY3RzdGFydCA9IFwib25zZWxlY3RzdGFydFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcbiQuZm4uZXh0ZW5kKHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmluZCggKCAkLnN1cHBvcnQuc2VsZWN0c3RhcnQgPyBcInNlbGVjdHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiICkgK1xuXHRcdFx0XCIudWktZGlzYWJsZVNlbGVjdGlvblwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHRlbmFibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVuYmluZCggXCIudWktZGlzYWJsZVNlbGVjdGlvblwiICk7XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aSwge1xuXHQvLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiBVc2UgJC53aWRnZXQoKSBleHRlbnNpb25zIGluc3RlYWQuXG5cdHBsdWdpbjoge1xuXHRcdGFkZDogZnVuY3Rpb24oIG1vZHVsZSwgb3B0aW9uLCBzZXQgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0cHJvdG8gPSAkLnVpWyBtb2R1bGUgXS5wcm90b3R5cGU7XG5cdFx0XHRmb3IgKCBpIGluIHNldCApIHtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0XHRwcm90by5wbHVnaW5zWyBpIF0ucHVzaCggWyBvcHRpb24sIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgbmFtZSwgYXJncyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzZXQgPSBpbnN0YW5jZS5wbHVnaW5zWyBuYW1lIF07XG5cdFx0XHRpZiAoICFzZXQgfHwgIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8IGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdFx0c2V0WyBpIF1bIDEgXS5hcHBseSggaW5zdGFuY2UuZWxlbWVudCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIG9ubHkgdXNlZCBieSByZXNpemFibGVcblx0aGFzU2Nyb2xsOiBmdW5jdGlvbiggZWwsIGEgKSB7XG5cblx0XHQvL0lmIG92ZXJmbG93IGlzIGhpZGRlbiwgdGhlIGVsZW1lbnQgbWlnaHQgaGF2ZSBleHRyYSBjb250ZW50LCBidXQgdGhlIHVzZXIgd2FudHMgdG8gaGlkZSBpdFxuXHRcdGlmICggJCggZWwgKS5jc3MoIFwib3ZlcmZsb3dcIiApID09PSBcImhpZGRlblwiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHNjcm9sbCA9ICggYSAmJiBhID09PSBcImxlZnRcIiApID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiLFxuXHRcdFx0aGFzID0gZmFsc2U7XG5cblx0XHRpZiAoIGVsWyBzY3JvbGwgXSA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBkZXRlcm1pbmUgd2hpY2ggY2FzZXMgYWN0dWFsbHkgY2F1c2UgdGhpcyB0byBoYXBwZW5cblx0XHQvLyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgdGhlIHNjcm9sbCBzZXQsIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvXG5cdFx0Ly8gc2V0IHRoZSBzY3JvbGxcblx0XHRlbFsgc2Nyb2xsIF0gPSAxO1xuXHRcdGhhcyA9ICggZWxbIHNjcm9sbCBdID4gMCApO1xuXHRcdGVsWyBzY3JvbGwgXSA9IDA7XG5cdFx0cmV0dXJuIGhhcztcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBEYXRlcGlja2VyIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kYXRlcGlja2VyL1xuICpcbiAqIERlcGVuZHM6XG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZXh0ZW5kKCQudWksIHsgZGF0ZXBpY2tlcjogeyB2ZXJzaW9uOiBcIjEuMTAuNFwiIH0gfSk7XG5cbnZhciBQUk9QX05BTUUgPSBcImRhdGVwaWNrZXJcIixcblx0aW5zdEFjdGl2ZTtcblxuLyogRGF0ZSBwaWNrZXIgbWFuYWdlci5cbiAgIFVzZSB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MsICQuZGF0ZXBpY2tlciwgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZGF0ZSBwaWNrZXIuXG4gICBTZXR0aW5ncyBmb3IgKGdyb3VwcyBvZikgZGF0ZSBwaWNrZXJzIGFyZSBtYWludGFpbmVkIGluIGFuIGluc3RhbmNlIG9iamVjdCxcbiAgIGFsbG93aW5nIG11bHRpcGxlIGRpZmZlcmVudCBzZXR0aW5ncyBvbiB0aGUgc2FtZSBwYWdlLiAqL1xuXG5mdW5jdGlvbiBEYXRlcGlja2VyKCkge1xuXHR0aGlzLl9jdXJJbnN0ID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgaW5zdGFuY2UgaW4gdXNlXG5cdHRoaXMuX2tleUV2ZW50ID0gZmFsc2U7IC8vIElmIHRoZSBsYXN0IGV2ZW50IHdhcyBhIGtleSBldmVudFxuXHR0aGlzLl9kaXNhYmxlZElucHV0cyA9IFtdOyAvLyBMaXN0IG9mIGRhdGUgcGlja2VyIGlucHV0cyB0aGF0IGhhdmUgYmVlbiBkaXNhYmxlZFxuXHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBwb3B1cCBwaWNrZXIgaXMgc2hvd2luZyAsIGZhbHNlIGlmIG5vdFxuXHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHNob3dpbmcgd2l0aGluIGEgXCJkaWFsb2dcIiwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX21haW5EaXZJZCA9IFwidWktZGF0ZXBpY2tlci1kaXZcIjsgLy8gVGhlIElEIG9mIHRoZSBtYWluIGRhdGVwaWNrZXIgZGl2aXNpb25cblx0dGhpcy5faW5saW5lQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItaW5saW5lXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2FwcGVuZENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWFwcGVuZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgYXBwZW5kIG1hcmtlciBjbGFzc1xuXHR0aGlzLl90cmlnZ2VyQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdHJpZ2dlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlhbG9nQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItZGlhbG9nXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaWFsb2cgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2Rpc2FibGVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaXNhYmxlZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGlzYWJsZWQgY292ZXJpbmcgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLXVuc2VsZWN0YWJsZVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdW5zZWxlY3RhYmxlIGNlbGwgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2N1cnJlbnRDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1jdXJyZW50LWRheVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBkYXkgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2RheU92ZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kYXlzLWNlbGwtb3ZlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGF5IGhvdmVyIG1hcmtlciBjbGFzc1xuXHR0aGlzLnJlZ2lvbmFsID0gW107IC8vIEF2YWlsYWJsZSByZWdpb25hbCBzZXR0aW5ncywgaW5kZXhlZCBieSBsYW5ndWFnZSBjb2RlXG5cdHRoaXMucmVnaW9uYWxbXCJcIl0gPSB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3Ncblx0XHRjbG9zZVRleHQ6IFwiRG9uZVwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGNsb3NlIGxpbmtcblx0XHRwcmV2VGV4dDogXCJQcmV2XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgcHJldmlvdXMgbW9udGggbGlua1xuXHRcdG5leHRUZXh0OiBcIk5leHRcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBuZXh0IG1vbnRoIGxpbmtcblx0XHRjdXJyZW50VGV4dDogXCJUb2RheVwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGN1cnJlbnQgbW9udGggbGlua1xuXHRcdG1vbnRoTmFtZXM6IFtcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFxuXHRcdFx0XCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdLCAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xuXHRcdG1vbnRoTmFtZXNTaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSwgLy8gRm9yIGZvcm1hdHRpbmdcblx0XHRkYXlOYW1lc1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNNaW46IFtcIlN1XCIsXCJNb1wiLFwiVHVcIixcIldlXCIsXCJUaFwiLFwiRnJcIixcIlNhXCJdLCAvLyBDb2x1bW4gaGVhZGluZ3MgZm9yIGRheXMgc3RhcnRpbmcgYXQgU3VuZGF5XG5cdFx0d2Vla0hlYWRlcjogXCJXa1wiLCAvLyBDb2x1bW4gaGVhZGVyIGZvciB3ZWVrIG9mIHRoZSB5ZWFyXG5cdFx0ZGF0ZUZvcm1hdDogXCJtbS9kZC95eVwiLCAvLyBTZWUgZm9ybWF0IG9wdGlvbnMgb24gcGFyc2VEYXRlXG5cdFx0Zmlyc3REYXk6IDAsIC8vIFRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWssIFN1biA9IDAsIE1vbiA9IDEsIC4uLlxuXHRcdGlzUlRMOiBmYWxzZSwgLy8gVHJ1ZSBpZiByaWdodC10by1sZWZ0IGxhbmd1YWdlLCBmYWxzZSBpZiBsZWZ0LXRvLXJpZ2h0XG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB0aGUgeWVhciBzZWxlY3QgcHJlY2VkZXMgbW9udGgsIGZhbHNlIGZvciBtb250aCB0aGVuIHllYXJcblx0XHR5ZWFyU3VmZml4OiBcIlwiIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIG1vbnRoIGhlYWRlcnNcblx0fTtcblx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRlIHBpY2tlciBpbnN0YW5jZXNcblx0XHRzaG93T246IFwiZm9jdXNcIiwgLy8gXCJmb2N1c1wiIGZvciBwb3B1cCBvbiBmb2N1cyxcblx0XHRcdC8vIFwiYnV0dG9uXCIgZm9yIHRyaWdnZXIgYnV0dG9uLCBvciBcImJvdGhcIiBmb3IgZWl0aGVyXG5cdFx0c2hvd0FuaW06IFwiZmFkZUluXCIsIC8vIE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXBcblx0XHRzaG93T3B0aW9uczoge30sIC8vIE9wdGlvbnMgZm9yIGVuaGFuY2VkIGFuaW1hdGlvbnNcblx0XHRkZWZhdWx0RGF0ZTogbnVsbCwgLy8gVXNlZCB3aGVuIGZpZWxkIGlzIGJsYW5rOiBhY3R1YWwgZGF0ZSxcblx0XHRcdC8vICsvLW51bWJlciBmb3Igb2Zmc2V0IGZyb20gdG9kYXksIG51bGwgZm9yIHRvZGF5XG5cdFx0YXBwZW5kVGV4dDogXCJcIiwgLy8gRGlzcGxheSB0ZXh0IGZvbGxvd2luZyB0aGUgaW5wdXQgYm94LCBlLmcuIHNob3dpbmcgdGhlIGZvcm1hdFxuXHRcdGJ1dHRvblRleHQ6IFwiLi4uXCIsIC8vIFRleHQgZm9yIHRyaWdnZXIgYnV0dG9uXG5cdFx0YnV0dG9uSW1hZ2U6IFwiXCIsIC8vIFVSTCBmb3IgdHJpZ2dlciBidXR0b24gaW1hZ2Vcblx0XHRidXR0b25JbWFnZU9ubHk6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSBpbWFnZSBhcHBlYXJzIGFsb25lLCBmYWxzZSBpZiBpdCBhcHBlYXJzIG9uIGEgYnV0dG9uXG5cdFx0aGlkZUlmTm9QcmV2TmV4dDogZmFsc2UsIC8vIFRydWUgdG8gaGlkZSBuZXh0L3ByZXZpb3VzIG1vbnRoIGxpbmtzXG5cdFx0XHQvLyBpZiBub3QgYXBwbGljYWJsZSwgZmFsc2UgdG8ganVzdCBkaXNhYmxlIHRoZW1cblx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0OiBmYWxzZSwgLy8gVHJ1ZSBpZiBkYXRlIGZvcm1hdHRpbmcgYXBwbGllZCB0byBwcmV2L3RvZGF5L25leHQgbGlua3Ncblx0XHRnb3RvQ3VycmVudDogZmFsc2UsIC8vIFRydWUgaWYgdG9kYXkgbGluayBnb2VzIGJhY2sgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5zdGVhZFxuXHRcdGNoYW5nZU1vbnRoOiBmYWxzZSwgLy8gVHJ1ZSBpZiBtb250aCBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0Y2hhbmdlWWVhcjogZmFsc2UsIC8vIFRydWUgaWYgeWVhciBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0eWVhclJhbmdlOiBcImMtMTA6YysxMFwiLCAvLyBSYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5IGluIGRyb3AtZG93bixcblx0XHRcdC8vIGVpdGhlciByZWxhdGl2ZSB0byB0b2RheSdzIHllYXIgKC1ubjorbm4pLCByZWxhdGl2ZSB0byBjdXJyZW50bHkgZGlzcGxheWVkIHllYXJcblx0XHRcdC8vIChjLW5uOmMrbm4pLCBhYnNvbHV0ZSAobm5ubjpubm5uKSwgb3IgYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUgKG5ubm46LW4pXG5cdFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgdG8gbGVhdmUgYmxhbmtcblx0XHRzZWxlY3RPdGhlck1vbnRoczogZmFsc2UsIC8vIFRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgZm9yIHVuc2VsZWN0YWJsZVxuXHRcdHNob3dXZWVrOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IHdlZWsgb2YgdGhlIHllYXIsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0Y2FsY3VsYXRlV2VlazogdGhpcy5pc284NjAxV2VlaywgLy8gSG93IHRvIGNhbGN1bGF0ZSB0aGUgd2VlayBvZiB0aGUgeWVhcixcblx0XHRcdC8vIHRha2VzIGEgRGF0ZSBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIGZvciBpdFxuXHRcdHNob3J0WWVhckN1dG9mZjogXCIrMTBcIiwgLy8gU2hvcnQgeWVhciB2YWx1ZXMgPCB0aGlzIGFyZSBpbiB0aGUgY3VycmVudCBjZW50dXJ5LFxuXHRcdFx0Ly8gPiB0aGlzIGFyZSBpbiB0aGUgcHJldmlvdXMgY2VudHVyeSxcblx0XHRcdC8vIHN0cmluZyB2YWx1ZSBzdGFydGluZyB3aXRoIFwiK1wiIGZvciBjdXJyZW50IHllYXIgKyB2YWx1ZVxuXHRcdG1pbkRhdGU6IG51bGwsIC8vIFRoZSBlYXJsaWVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0bWF4RGF0ZTogbnVsbCwgLy8gVGhlIGxhdGVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0ZHVyYXRpb246IFwiZmFzdFwiLCAvLyBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmVcblx0XHRiZWZvcmVTaG93RGF5OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGEgZGF0ZSBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoXG5cdFx0XHQvLyBbMF0gPSB0cnVlIGlmIHNlbGVjdGFibGUsIGZhbHNlIGlmIG5vdCwgWzFdID0gY3VzdG9tIENTUyBjbGFzcyBuYW1lKHMpIG9yIFwiXCIsXG5cdFx0XHQvLyBbMl0gPSBjZWxsIHRpdGxlIChvcHRpb25hbCksIGUuZy4gJC5kYXRlcGlja2VyLm5vV2Vla2VuZHNcblx0XHRiZWZvcmVTaG93OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGlucHV0IGZpZWxkIGFuZFxuXHRcdFx0Ly8gcmV0dXJucyBhIHNldCBvZiBjdXN0b20gc2V0dGluZ3MgZm9yIHRoZSBkYXRlIHBpY2tlclxuXHRcdG9uU2VsZWN0OiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZFxuXHRcdG9uQ2hhbmdlTW9udGhZZWFyOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBtb250aCBvciB5ZWFyIGlzIGNoYW5nZWRcblx0XHRvbkNsb3NlOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkYXRlcGlja2VyIGlzIGNsb3NlZFxuXHRcdG51bWJlck9mTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHNob3cgYXQgYSB0aW1lXG5cdFx0c2hvd0N1cnJlbnRBdFBvczogMCwgLy8gVGhlIHBvc2l0aW9uIGluIG11bHRpcGUgbW9udGhzIGF0IHdoaWNoIHRvIHNob3cgdGhlIGN1cnJlbnQgbW9udGggKHN0YXJ0aW5nIGF0IDApXG5cdFx0c3RlcE1vbnRoczogMSwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzdGVwIGJhY2svZm9yd2FyZFxuXHRcdHN0ZXBCaWdNb250aHM6IDEyLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkIGZvciB0aGUgYmlnIGxpbmtzXG5cdFx0YWx0RmllbGQ6IFwiXCIsIC8vIFNlbGVjdG9yIGZvciBhbiBhbHRlcm5hdGUgZmllbGQgdG8gc3RvcmUgc2VsZWN0ZWQgZGF0ZXMgaW50b1xuXHRcdGFsdEZvcm1hdDogXCJcIiwgLy8gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSBmb3IgdGhlIGFsdGVybmF0ZSBmaWVsZFxuXHRcdGNvbnN0cmFpbklucHV0OiB0cnVlLCAvLyBUaGUgaW5wdXQgaXMgY29uc3RyYWluZWQgYnkgdGhlIGN1cnJlbnQgZGF0ZSBmb3JtYXRcblx0XHRzaG93QnV0dG9uUGFuZWw6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgYnV0dG9uIHBhbmVsLCBmYWxzZSB0byBub3Qgc2hvdyBpdFxuXHRcdGF1dG9TaXplOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaXplIHRoZSBpbnB1dCBmb3IgdGhlIGRhdGUgZm9ybWF0LCBmYWxzZSB0byBsZWF2ZSBhcyBpc1xuXHRcdGRpc2FibGVkOiBmYWxzZSAvLyBUaGUgaW5pdGlhbCBkaXNhYmxlZCBzdGF0ZVxuXHR9O1xuXHQkLmV4dGVuZCh0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFtcIlwiXSk7XG5cdHRoaXMuZHBEaXYgPSBiaW5kSG92ZXIoJChcIjxkaXYgaWQ9J1wiICsgdGhpcy5fbWFpbkRpdklkICsgXCInIGNsYXNzPSd1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XCIpKTtcbn1cblxuJC5leHRlbmQoRGF0ZXBpY2tlci5wcm90b3R5cGUsIHtcblx0LyogQ2xhc3MgbmFtZSBhZGRlZCB0byBlbGVtZW50cyB0byBpbmRpY2F0ZSBhbHJlYWR5IGNvbmZpZ3VyZWQgd2l0aCBhIGRhdGUgcGlja2VyLiAqL1xuXHRtYXJrZXJDbGFzc05hbWU6IFwiaGFzRGF0ZXBpY2tlclwiLFxuXG5cdC8vS2VlcCB0cmFjayBvZiB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgKHNlZSAjNzA0Mylcblx0bWF4Um93czogNCxcblxuXHQvLyBUT0RPIHJlbmFtZSB0byBcIndpZGdldFwiIHdoZW4gc3dpdGNoaW5nIHRvIHdpZGdldCBmYWN0b3J5XG5cdF93aWRnZXREYXRlcGlja2VyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kcERpdjtcblx0fSxcblxuXHQvKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGUgZGF0ZSBwaWNrZXIuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGFzIGRlZmF1bHRzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHQgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxuXHQgKi9cblx0c2V0RGVmYXVsdHM6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG5cdFx0ZXh0ZW5kUmVtb3ZlKHRoaXMuX2RlZmF1bHRzLCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGZvciB0aGlzIGRhdGUgcGlja2VyIGluc3RhbmNlIChhbm9ueW1vdXMpXG5cdCAqL1xuXHRfYXR0YWNoRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBzZXR0aW5ncykge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLCBpbnN0O1xuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aW5saW5lID0gKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIik7XG5cdFx0aWYgKCF0YXJnZXQuaWQpIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0dGFyZ2V0LmlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdH1cblx0XHRpbnN0ID0gdGhpcy5fbmV3SW5zdCgkKHRhcmdldCksIGlubGluZSk7XG5cdFx0aW5zdC5zZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRoaXMuX2Nvbm5lY3REYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XG5cdFx0fSBlbHNlIGlmIChpbmxpbmUpIHtcblx0XHRcdHRoaXMuX2lubGluZURhdGVwaWNrZXIodGFyZ2V0LCBpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9iamVjdC4gKi9cblx0X25ld0luc3Q6IGZ1bmN0aW9uKHRhcmdldCwgaW5saW5lKSB7XG5cdFx0dmFyIGlkID0gdGFyZ2V0WzBdLmlkLnJlcGxhY2UoLyhbXkEtWmEtejAtOV9cXC1dKS9nLCBcIlxcXFxcXFxcJDFcIik7IC8vIGVzY2FwZSBqUXVlcnkgbWV0YSBjaGFyc1xuXHRcdHJldHVybiB7aWQ6IGlkLCBpbnB1dDogdGFyZ2V0LCAvLyBhc3NvY2lhdGVkIHRhcmdldFxuXHRcdFx0c2VsZWN0ZWREYXk6IDAsIHNlbGVjdGVkTW9udGg6IDAsIHNlbGVjdGVkWWVhcjogMCwgLy8gY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdGRyYXdNb250aDogMCwgZHJhd1llYXI6IDAsIC8vIG1vbnRoIGJlaW5nIGRyYXduXG5cdFx0XHRpbmxpbmU6IGlubGluZSwgLy8gaXMgZGF0ZXBpY2tlciBpbmxpbmUgb3Igbm90XG5cdFx0XHRkcERpdjogKCFpbmxpbmUgPyB0aGlzLmRwRGl2IDogLy8gcHJlc2VudGF0aW9uIGRpdlxuXHRcdFx0YmluZEhvdmVyKCQoXCI8ZGl2IGNsYXNzPSdcIiArIHRoaXMuX2lubGluZUNsYXNzICsgXCIgdWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGwnPjwvZGl2PlwiKSkpfTtcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGFuIGlucHV0IGZpZWxkLiAqL1xuXHRfY29ubmVjdERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5zdCkge1xuXHRcdHZhciBpbnB1dCA9ICQodGFyZ2V0KTtcblx0XHRpbnN0LmFwcGVuZCA9ICQoW10pO1xuXHRcdGluc3QudHJpZ2dlciA9ICQoW10pO1xuXHRcdGlmIChpbnB1dC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYXR0YWNobWVudHMoaW5wdXQsIGluc3QpO1xuXHRcdGlucHV0LmFkZENsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5rZXlkb3duKHRoaXMuX2RvS2V5RG93bikuXG5cdFx0XHRrZXlwcmVzcyh0aGlzLl9kb0tleVByZXNzKS5rZXl1cCh0aGlzLl9kb0tleVVwKTtcblx0XHR0aGlzLl9hdXRvU2l6ZShpbnN0KTtcblx0XHQkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgb25jZSBpdCBoYXMgYmVlbiBhdHRhY2hlZCB0byB0aGUgaW5wdXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIE1ha2UgYXR0YWNobWVudHMgYmFzZWQgb24gc2V0dGluZ3MuICovXG5cdF9hdHRhY2htZW50czogZnVuY3Rpb24oaW5wdXQsIGluc3QpIHtcblx0XHR2YXIgc2hvd09uLCBidXR0b25UZXh0LCBidXR0b25JbWFnZSxcblx0XHRcdGFwcGVuZFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhcHBlbmRUZXh0XCIpLFxuXHRcdFx0aXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKTtcblxuXHRcdGlmIChpbnN0LmFwcGVuZCkge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmIChhcHBlbmRUZXh0KSB7XG5cdFx0XHRpbnN0LmFwcGVuZCA9ICQoXCI8c3BhbiBjbGFzcz0nXCIgKyB0aGlzLl9hcHBlbmRDbGFzcyArIFwiJz5cIiArIGFwcGVuZFRleHQgKyBcIjwvc3Bhbj5cIik7XG5cdFx0XHRpbnB1dFtpc1JUTCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCJdKGluc3QuYXBwZW5kKTtcblx0XHR9XG5cblx0XHRpbnB1dC51bmJpbmQoXCJmb2N1c1wiLCB0aGlzLl9zaG93RGF0ZXBpY2tlcik7XG5cblx0XHRpZiAoaW5zdC50cmlnZ2VyKSB7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0c2hvd09uID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd09uXCIpO1xuXHRcdGlmIChzaG93T24gPT09IFwiZm9jdXNcIiB8fCBzaG93T24gPT09IFwiYm90aFwiKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGluIHRoZSBtYXJrZWQgZmllbGRcblx0XHRcdGlucHV0LmZvY3VzKHRoaXMuX3Nob3dEYXRlcGlja2VyKTtcblx0XHR9XG5cdFx0aWYgKHNob3dPbiA9PT0gXCJidXR0b25cIiB8fCBzaG93T24gPT09IFwiYm90aFwiKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGJ1dHRvbiBjbGlja2VkXG5cdFx0XHRidXR0b25UZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uVGV4dFwiKTtcblx0XHRcdGJ1dHRvbkltYWdlID0gdGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uSW1hZ2VcIik7XG5cdFx0XHRpbnN0LnRyaWdnZXIgPSAkKHRoaXMuX2dldChpbnN0LCBcImJ1dHRvbkltYWdlT25seVwiKSA/XG5cdFx0XHRcdCQoXCI8aW1nLz5cIikuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKS5cblx0XHRcdFx0XHRhdHRyKHsgc3JjOiBidXR0b25JbWFnZSwgYWx0OiBidXR0b25UZXh0LCB0aXRsZTogYnV0dG9uVGV4dCB9KSA6XG5cdFx0XHRcdCQoXCI8YnV0dG9uIHR5cGU9J2J1dHRvbic+PC9idXR0b24+XCIpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuXG5cdFx0XHRcdFx0aHRtbCghYnV0dG9uSW1hZ2UgPyBidXR0b25UZXh0IDogJChcIjxpbWcvPlwiKS5hdHRyKFxuXHRcdFx0XHRcdHsgc3JjOmJ1dHRvbkltYWdlLCBhbHQ6YnV0dG9uVGV4dCwgdGl0bGU6YnV0dG9uVGV4dCB9KSkpO1xuXHRcdFx0aW5wdXRbaXNSVEwgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiXShpbnN0LnRyaWdnZXIpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXRbMF0pIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCAhPT0gaW5wdXRbMF0pIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFwcGx5IHRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfYXV0b1NpemU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRpZiAodGhpcy5fZ2V0KGluc3QsIFwiYXV0b1NpemVcIikgJiYgIWluc3QuaW5saW5lKSB7XG5cdFx0XHR2YXIgZmluZE1heCwgbWF4LCBtYXhJLCBpLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoMjAwOSwgMTIgLSAxLCAyMCksIC8vIEVuc3VyZSBkb3VibGUgZGlnaXRzXG5cdFx0XHRcdGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpO1xuXG5cdFx0XHRpZiAoZGF0ZUZvcm1hdC5tYXRjaCgvW0RNXS8pKSB7XG5cdFx0XHRcdGZpbmRNYXggPSBmdW5jdGlvbihuYW1lcykge1xuXHRcdFx0XHRcdG1heCA9IDA7XG5cdFx0XHRcdFx0bWF4SSA9IDA7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAobmFtZXNbaV0ubGVuZ3RoID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IG5hbWVzW2ldLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bWF4SSA9IGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXhJO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRkYXRlLnNldE1vbnRoKGZpbmRNYXgodGhpcy5fZ2V0KGluc3QsIChkYXRlRm9ybWF0Lm1hdGNoKC9NTS8pID9cblx0XHRcdFx0XHRcIm1vbnRoTmFtZXNcIiA6IFwibW9udGhOYW1lc1Nob3J0XCIpKSkpO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgKGRhdGVGb3JtYXQubWF0Y2goL0RELykgP1xuXHRcdFx0XHRcdFwiZGF5TmFtZXNcIiA6IFwiZGF5TmFtZXNTaG9ydFwiKSkpICsgMjAgLSBkYXRlLmdldERheSgpKTtcblx0XHRcdH1cblx0XHRcdGluc3QuaW5wdXQuYXR0cihcInNpemVcIiwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKS5sZW5ndGgpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBBdHRhY2ggYW4gaW5saW5lIGRhdGUgcGlja2VyIHRvIGEgZGl2LiAqL1xuXHRfaW5saW5lRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBpbnN0KSB7XG5cdFx0dmFyIGRpdlNwYW4gPSAkKHRhcmdldCk7XG5cdFx0aWYgKGRpdlNwYW4uaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGRpdlNwYW4uYWRkQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmFwcGVuZChpbnN0LmRwRGl2KTtcblx0XHQkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdHRoaXMuX3NldERhdGUoaW5zdCwgdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgYmVmb3JlIHNob3dpbmcgaXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHRcdC8vIFNldCBkaXNwbGF5OmJsb2NrIGluIHBsYWNlIG9mIGluc3QuZHBEaXYuc2hvdygpIHdoaWNoIHdvbid0IHdvcmsgb24gZGlzY29ubmVjdGVkIGVsZW1lbnRzXG5cdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5dWkuY29tL3RpY2tldC83NTUyIC0gQSBEYXRlcGlja2VyIGNyZWF0ZWQgb24gYSBkZXRhY2hlZCBkaXYgaGFzIHplcm8gaGVpZ2h0XG5cdFx0aW5zdC5kcERpdi5jc3MoIFwiZGlzcGxheVwiLCBcImJsb2NrXCIgKTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGluIGEgXCJkaWFsb2dcIiBib3guXG5cdCAqIEBwYXJhbSAgaW5wdXQgZWxlbWVudCAtIGlnbm9yZWRcblx0ICogQHBhcmFtICBkYXRlXHRzdHJpbmcgb3IgRGF0ZSAtIHRoZSBpbml0aWFsIGRhdGUgdG8gZGlzcGxheVxuXHQgKiBAcGFyYW0gIG9uU2VsZWN0ICBmdW5jdGlvbiAtIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHVwZGF0ZSB0aGUgZGlhbG9nIGRhdGUgcGlja2VyIGluc3RhbmNlJ3Mgc2V0dGluZ3MgKGFub255bW91cyBvYmplY3QpXG5cdCAqIEBwYXJhbSAgcG9zIGludFsyXSAtIGNvb3JkaW5hdGVzIGZvciB0aGUgZGlhbG9nJ3MgcG9zaXRpb24gd2l0aGluIHRoZSBzY3JlZW4gb3Jcblx0ICpcdFx0XHRcdFx0ZXZlbnQgLSB3aXRoIHgveSBjb29yZGluYXRlcyBvclxuXHQgKlx0XHRcdFx0XHRsZWF2ZSBlbXB0eSBmb3IgZGVmYXVsdCAoc2NyZWVuIGNlbnRyZSlcblx0ICogQHJldHVybiB0aGUgbWFuYWdlciBvYmplY3Rcblx0ICovXG5cdF9kaWFsb2dEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCwgZGF0ZSwgb25TZWxlY3QsIHNldHRpbmdzLCBwb3MpIHtcblx0XHR2YXIgaWQsIGJyb3dzZXJXaWR0aCwgYnJvd3NlckhlaWdodCwgc2Nyb2xsWCwgc2Nyb2xsWSxcblx0XHRcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0OyAvLyBpbnRlcm5hbCBpbnN0YW5jZVxuXG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHR0aGlzLnV1aWQgKz0gMTtcblx0XHRcdGlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQgPSAkKFwiPGlucHV0IHR5cGU9J3RleHQnIGlkPSdcIiArIGlkICtcblx0XHRcdFx0XCInIHN0eWxlPSdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMHB4OyB3aWR0aDogMHB4OycvPlwiKTtcblx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmtleWRvd24odGhpcy5fZG9LZXlEb3duKTtcblx0XHRcdCQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLl9kaWFsb2dJbnB1dCk7XG5cdFx0XHRpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdCA9IHRoaXMuX25ld0luc3QodGhpcy5fZGlhbG9nSW5wdXQsIGZhbHNlKTtcblx0XHRcdGluc3Quc2V0dGluZ3MgPSB7fTtcblx0XHRcdCQuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHR9XG5cdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRkYXRlID0gKGRhdGUgJiYgZGF0ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgZGF0ZSkgOiBkYXRlKTtcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC52YWwoZGF0ZSk7XG5cblx0XHR0aGlzLl9wb3MgPSAocG9zID8gKHBvcy5sZW5ndGggPyBwb3MgOiBbcG9zLnBhZ2VYLCBwb3MucGFnZVldKSA6IG51bGwpO1xuXHRcdGlmICghdGhpcy5fcG9zKSB7XG5cdFx0XHRicm93c2VyV2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0XHRicm93c2VySGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblx0XHRcdHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcblx0XHRcdHRoaXMuX3BvcyA9IC8vIHNob3VsZCB1c2UgYWN0dWFsIHdpZHRoL2hlaWdodCBiZWxvd1xuXHRcdFx0XHRbKGJyb3dzZXJXaWR0aCAvIDIpIC0gMTAwICsgc2Nyb2xsWCwgKGJyb3dzZXJIZWlnaHQgLyAyKSAtIDE1MCArIHNjcm9sbFldO1xuXHRcdH1cblxuXHRcdC8vIG1vdmUgaW5wdXQgb24gc2NyZWVuIGZvciBmb2N1cywgYnV0IGhpZGRlbiBiZWhpbmQgZGlhbG9nXG5cdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKFwibGVmdFwiLCAodGhpcy5fcG9zWzBdICsgMjApICsgXCJweFwiKS5jc3MoXCJ0b3BcIiwgdGhpcy5fcG9zWzFdICsgXCJweFwiKTtcblx0XHRpbnN0LnNldHRpbmdzLm9uU2VsZWN0ID0gb25TZWxlY3Q7XG5cdFx0dGhpcy5faW5EaWFsb2cgPSB0cnVlO1xuXHRcdHRoaXMuZHBEaXYuYWRkQ2xhc3ModGhpcy5fZGlhbG9nQ2xhc3MpO1xuXHRcdHRoaXMuX3Nob3dEYXRlcGlja2VyKHRoaXMuX2RpYWxvZ0lucHV0WzBdKTtcblx0XHRpZiAoJC5ibG9ja1VJKSB7XG5cdFx0XHQkLmJsb2NrVUkodGhpcy5kcERpdik7XG5cdFx0fVxuXHRcdCQuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBEZXRhY2ggYSBkYXRlcGlja2VyIGZyb20gaXRzIGNvbnRyb2wuXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZGVzdHJveURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSxcblx0XHRcdCR0YXJnZXQgPSAkKHRhcmdldCksXG5cdFx0XHRpbnN0ID0gJC5kYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblxuXHRcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdCQucmVtb3ZlRGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdGluc3QuYXBwZW5kLnJlbW92ZSgpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuXG5cdFx0XHRcdHVuYmluZChcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyKS5cblx0XHRcdFx0dW5iaW5kKFwia2V5ZG93blwiLCB0aGlzLl9kb0tleURvd24pLlxuXHRcdFx0XHR1bmJpbmQoXCJrZXlwcmVzc1wiLCB0aGlzLl9kb0tleVByZXNzKS5cblx0XHRcdFx0dW5iaW5kKFwia2V5dXBcIiwgdGhpcy5fZG9LZXlVcCk7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIpIHtcblx0XHRcdCR0YXJnZXQucmVtb3ZlQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmVtcHR5KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEVuYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldFx0ZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKi9cblx0X2VuYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcihcImJ1dHRvblwiKS5cblx0XHRcdFx0ZWFjaChmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IGZhbHNlOyB9KS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKFwiaW1nXCIpLmNzcyh7b3BhY2l0eTogXCIxLjBcIiwgY3Vyc29yOiBcIlwifSk7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIpIHtcblx0XHRcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oXCIuXCIgKyB0aGlzLl9pbmxpbmVDbGFzcyk7XG5cdFx0XHRpbmxpbmUuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWRpc2FibGVkXCIpO1xuXHRcdFx0aW5saW5lLmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclwiKS5cblx0XHRcdFx0cHJvcChcImRpc2FibGVkXCIsIGZhbHNlKTtcblx0XHR9XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBkZWxldGUgZW50cnlcblx0fSxcblxuXHQvKiBEaXNhYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZGlzYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKFwiYnV0dG9uXCIpLlxuXHRcdFx0XHRlYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLmRpc2FibGVkID0gdHJ1ZTsgfSkuZW5kKCkuXG5cdFx0XHRcdGZpbHRlcihcImltZ1wiKS5jc3Moe29wYWNpdHk6IFwiMC41XCIsIGN1cnNvcjogXCJkZWZhdWx0XCJ9KTtcblx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIikge1xuXHRcdFx0aW5saW5lID0gJHRhcmdldC5jaGlsZHJlbihcIi5cIiArIHRoaXMuX2lubGluZUNsYXNzKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLmFkZENsYXNzKFwidWktc3RhdGUtZGlzYWJsZWRcIik7XG5cdFx0XHRpbmxpbmUuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLlxuXHRcdFx0XHRwcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAodGhpcy5fZGlzYWJsZWRJbnB1dHMsXG5cdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSB0YXJnZXQgPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gZGVsZXRlIGVudHJ5XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHNbdGhpcy5fZGlzYWJsZWRJbnB1dHMubGVuZ3RoXSA9IHRhcmdldDtcblx0fSxcblxuXHQvKiBJcyB0aGUgZmlyc3QgZmllbGQgaW4gYSBqUXVlcnkgY29sbGVjdGlvbiBkaXNhYmxlZCBhcyBhIGRhdGVwaWNrZXI/XG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEByZXR1cm4gYm9vbGVhbiAtIHRydWUgaWYgZGlzYWJsZWQsIGZhbHNlIGlmIGVuYWJsZWRcblx0ICovXG5cdF9pc0Rpc2FibGVkRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2Rpc2FibGVkSW5wdXRzW2ldID09PSB0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxuXHQgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcmV0dXJuICBvYmplY3QgLSB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZSBkYXRhXG5cdCAqIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhXG5cdCAqL1xuXHRfZ2V0SW5zdDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHR0aHJvdyBcIk1pc3NpbmcgaW5zdGFuY2UgZGF0YSBmb3IgdGhpcyBkYXRlcGlja2VyXCI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBvciByZXRyaWV2ZSB0aGUgc2V0dGluZ3MgZm9yIGEgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgbmFtZVx0b2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1cGRhdGUgb3Jcblx0ICpcdFx0XHRcdHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nIHRvIGNoYW5nZSBvciByZXRyaWV2ZSxcblx0ICpcdFx0XHRcdHdoZW4gcmV0cmlldmluZyBhbHNvIFwiYWxsXCIgZm9yIGFsbCBpbnN0YW5jZSBzZXR0aW5ncyBvclxuXHQgKlx0XHRcdFx0XCJkZWZhdWx0c1wiIGZvciBhbGwgZ2xvYmFsIGRlZmF1bHRzXG5cdCAqIEBwYXJhbSAgdmFsdWUgICBhbnkgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZ1xuXHQgKlx0XHRcdFx0KG9taXQgaWYgYWJvdmUgaXMgYW4gb2JqZWN0IG9yIHRvIHJldHJpZXZlIGEgdmFsdWUpXG5cdCAqL1xuXHRfb3B0aW9uRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBzZXR0aW5ncywgZGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0cmV0dXJuIChuYW1lID09PSBcImRlZmF1bHRzXCIgPyAkLmV4dGVuZCh7fSwgJC5kYXRlcGlja2VyLl9kZWZhdWx0cykgOlxuXHRcdFx0XHQoaW5zdCA/IChuYW1lID09PSBcImFsbFwiID8gJC5leHRlbmQoe30sIGluc3Quc2V0dGluZ3MpIDpcblx0XHRcdFx0dGhpcy5fZ2V0KGluc3QsIG5hbWUpKSA6IG51bGwpKTtcblx0XHR9XG5cblx0XHRzZXR0aW5ncyA9IG5hbWUgfHwge307XG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRzZXR0aW5ncyA9IHt9O1xuXHRcdFx0c2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoaW5zdCkge1xuXHRcdFx0aWYgKHRoaXMuX2N1ckluc3QgPT09IGluc3QpIHtcblx0XHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0ZGF0ZSA9IHRoaXMuX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgdHJ1ZSk7XG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKTtcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpO1xuXHRcdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzKTtcblx0XHRcdC8vIHJlZm9ybWF0IHRoZSBvbGQgbWluRGF0ZS9tYXhEYXRlIHZhbHVlcyBpZiBkYXRlRm9ybWF0IGNoYW5nZXMgYW5kIGEgbmV3IG1pbkRhdGUvbWF4RGF0ZSBpc24ndCBwcm92aWRlZFxuXHRcdFx0aWYgKG1pbkRhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1pbkRhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGluc3QsIG1pbkRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1heERhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1heERhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGluc3QsIG1heERhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBcImRpc2FibGVkXCIgaW4gc2V0dGluZ3MgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVEYXRlcGlja2VyKHRhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2F0dGFjaG1lbnRzKCQodGFyZ2V0KSwgaW5zdCk7XG5cdFx0XHR0aGlzLl9hdXRvU2l6ZShpbnN0KTtcblx0XHRcdHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XG5cdFx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBjaGFuZ2UgbWV0aG9kIGRlcHJlY2F0ZWRcblx0X2NoYW5nZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLl9vcHRpb25EYXRlcGlja2VyKHRhcmdldCwgbmFtZSwgdmFsdWUpO1xuXHR9LFxuXG5cdC8qIFJlZHJhdyB0aGUgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfcmVmcmVzaERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGVzIGZvciBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0IGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBkYXRlXHREYXRlIC0gdGhlIG5ldyBkYXRlXG5cdCAqL1xuXHRfc2V0RGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgZGF0ZSkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHR0aGlzLl9zZXREYXRlKGluc3QsIGRhdGUpO1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogR2V0IHRoZSBkYXRlKHMpIGZvciB0aGUgZmlyc3QgZW50cnkgaW4gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldCBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgbm9EZWZhdWx0IGJvb2xlYW4gLSB0cnVlIGlmIG5vIGRlZmF1bHQgZGF0ZSBpcyB0byBiZSB1c2VkXG5cdCAqIEByZXR1cm4gRGF0ZSAtIHRoZSBjdXJyZW50IGRhdGVcblx0ICovXG5cdF9nZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBub0RlZmF1bHQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoaW5zdCAmJiAhaW5zdC5pbmxpbmUpIHtcblx0XHRcdHRoaXMuX3NldERhdGVGcm9tRmllbGQoaW5zdCwgbm9EZWZhdWx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIChpbnN0ID8gdGhpcy5fZ2V0RGF0ZShpbnN0KSA6IG51bGwpO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBrZXlzdHJva2VzLiAqL1xuXHRfZG9LZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBvblNlbGVjdCwgZGF0ZVN0ciwgc2VsLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpLFxuXHRcdFx0aGFuZGxlZCA9IHRydWUsXG5cdFx0XHRpc1JUTCA9IGluc3QuZHBEaXYuaXMoXCIudWktZGF0ZXBpY2tlci1ydGxcIik7XG5cblx0XHRpbnN0Ll9rZXlFdmVudCA9IHRydWU7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcpIHtcblx0XHRcdHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuXHRcdFx0XHRjYXNlIDk6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIHRhYiBvdXRcblx0XHRcdFx0Y2FzZSAxMzogc2VsID0gJChcInRkLlwiICsgJC5kYXRlcGlja2VyLl9kYXlPdmVyQ2xhc3MgKyBcIjpub3QoLlwiICtcblx0XHRcdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY3VycmVudENsYXNzICsgXCIpXCIsIGluc3QuZHBEaXYpO1xuXHRcdFx0XHRcdFx0aWYgKHNlbFswXSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheShldmVudC50YXJnZXQsIGluc3Quc2VsZWN0ZWRNb250aCwgaW5zdC5zZWxlY3RlZFllYXIsIHNlbFswXSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9uU2VsZWN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJvblNlbGVjdFwiKTtcblx0XHRcdFx0XHRcdGlmIChvblNlbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRkYXRlU3RyID0gJC5kYXRlcGlja2VyLl9mb3JtYXREYXRlKGluc3QpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGRvbid0IHN1Ym1pdCB0aGUgZm9ybVxuXHRcdFx0XHRjYXNlIDI3OiAkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gaGlkZSBvbiBlc2NhcGVcblx0XHRcdFx0Y2FzZSAzMzogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSksIFwiTVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBwcmV2aW91cyBtb250aC95ZWFyIG9uIHBhZ2UgdXAvKyBjdHJsXG5cdFx0XHRcdGNhc2UgMzQ6ICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcEJpZ01vbnRoc1wiKSA6XG5cdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNTogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2NsZWFyRGF0ZShldmVudC50YXJnZXQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBjbGVhciBvbiBjdHJsIG9yIGNvbW1hbmQgK2VuZFxuXHRcdFx0XHRjYXNlIDM2OiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGN1cnJlbnQgb24gY3RybCBvciBjb21tYW5kICtob21lXG5cdFx0XHRcdGNhc2UgMzc6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gKzEgOiAtMSksIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHQvLyAtMSBkYXkgb24gY3RybCBvciBjb21tYW5kICtsZWZ0XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBCaWdNb250aHNcIikgOlxuXHRcdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBuZXh0IG1vbnRoL3llYXIgb24gYWx0ICtsZWZ0IG9uIE1hY1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzg6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgLTcsIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gLTEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK3VwXG5cdFx0XHRcdGNhc2UgMzk6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gLTEgOiArMSksIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHQvLyArMSBkYXkgb24gY3RybCBvciBjb21tYW5kICtyaWdodFxuXHRcdFx0XHRcdFx0aWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpKSwgXCJNXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArcmlnaHRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQwOiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsICs3LCBcIkRcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vICsxIHdlZWsgb24gY3RybCBvciBjb21tYW5kICtkb3duXG5cdFx0XHRcdGRlZmF1bHQ6IGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM2ICYmIGV2ZW50LmN0cmxLZXkpIHsgLy8gZGlzcGxheSB0aGUgZGF0ZSBwaWNrZXIgb24gY3RybCtob21lXG5cdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoYW5kbGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRmlsdGVyIGVudGVyZWQgY2hhcmFjdGVycyAtIGJhc2VkIG9uIGRhdGUgZm9ybWF0LiAqL1xuXHRfZG9LZXlQcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgY2hhcnMsIGNocixcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImNvbnN0cmFpbklucHV0XCIpKSB7XG5cdFx0XHRjaGFycyA9ICQuZGF0ZXBpY2tlci5fcG9zc2libGVDaGFycygkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIikpO1xuXHRcdFx0Y2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PSBudWxsID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcblx0XHRcdHJldHVybiBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgKGNociA8IFwiIFwiIHx8ICFjaGFycyB8fCBjaGFycy5pbmRleE9mKGNocikgPiAtMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFN5bmNocm9uaXNlIG1hbnVhbCBlbnRyeSBhbmQgZmllbGQvYWx0ZXJuYXRlIGZpZWxkLiAqL1xuXHRfZG9LZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblxuXHRcdGlmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSxcblx0XHRcdFx0XHQoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsKSxcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cblx0XHRcdFx0aWYgKGRhdGUpIHsgLy8gb25seSBpZiB2YWxpZFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyogUG9wLXVwIHRoZSBkYXRlIHBpY2tlciBmb3IgYSBnaXZlbiBpbnB1dCBmaWVsZC5cblx0ICogSWYgZmFsc2UgcmV0dXJuZWQgZnJvbSBiZWZvcmVTaG93IGV2ZW50IGhhbmRsZXIgZG8gbm90IHNob3cuXG5cdCAqIEBwYXJhbSAgaW5wdXQgIGVsZW1lbnQgLSB0aGUgaW5wdXQgZmllbGQgYXR0YWNoZWQgdG8gdGhlIGRhdGUgcGlja2VyIG9yXG5cdCAqXHRcdFx0XHRcdGV2ZW50IC0gaWYgdHJpZ2dlcmVkIGJ5IGZvY3VzXG5cdCAqL1xuXHRfc2hvd0RhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0aW5wdXQgPSBpbnB1dC50YXJnZXQgfHwgaW5wdXQ7XG5cdFx0aWYgKGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiaW5wdXRcIikgeyAvLyBmaW5kIGZyb20gYnV0dG9uL2ltYWdlIHRyaWdnZXJcblx0XHRcdGlucHV0ID0gJChcImlucHV0XCIsIGlucHV0LnBhcmVudE5vZGUpWzBdO1xuXHRcdH1cblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKGlucHV0KSB8fCAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXQpIHsgLy8gYWxyZWFkeSBoZXJlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluc3QsIGJlZm9yZVNob3csIGJlZm9yZVNob3dTZXR0aW5ncywgaXNGaXhlZCxcblx0XHRcdG9mZnNldCwgc2hvd0FuaW0sIGR1cmF0aW9uO1xuXG5cdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChpbnB1dCk7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT09IGluc3QpIHtcblx0XHRcdCQuZGF0ZXBpY2tlci5fY3VySW5zdC5kcERpdi5zdG9wKHRydWUsIHRydWUpO1xuXHRcdFx0aWYgKCBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoICQuZGF0ZXBpY2tlci5fY3VySW5zdC5pbnB1dFswXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJlZm9yZVNob3cgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImJlZm9yZVNob3dcIik7XG5cdFx0YmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoaW5wdXQsIFtpbnB1dCwgaW5zdF0pIDoge307XG5cdFx0aWYoYmVmb3JlU2hvd1NldHRpbmdzID09PSBmYWxzZSl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGV4dGVuZFJlbW92ZShpbnN0LnNldHRpbmdzLCBiZWZvcmVTaG93U2V0dGluZ3MpO1xuXG5cdFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcblx0XHQkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9IGlucHV0O1xuXHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nKSB7IC8vIGhpZGUgY3Vyc29yXG5cdFx0XHRpbnB1dC52YWx1ZSA9IFwiXCI7XG5cdFx0fVxuXHRcdGlmICghJC5kYXRlcGlja2VyLl9wb3MpIHsgLy8gcG9zaXRpb24gYmVsb3cgaW5wdXRcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zID0gJC5kYXRlcGlja2VyLl9maW5kUG9zKGlucHV0KTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zWzFdICs9IGlucHV0Lm9mZnNldEhlaWdodDsgLy8gYWRkIHRoZSBoZWlnaHRcblx0XHR9XG5cblx0XHRpc0ZpeGVkID0gZmFsc2U7XG5cdFx0JChpbnB1dCkucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpc0ZpeGVkIHw9ICQodGhpcykuY3NzKFwicG9zaXRpb25cIikgPT09IFwiZml4ZWRcIjtcblx0XHRcdHJldHVybiAhaXNGaXhlZDtcblx0XHR9KTtcblxuXHRcdG9mZnNldCA9IHtsZWZ0OiAkLmRhdGVwaWNrZXIuX3Bvc1swXSwgdG9wOiAkLmRhdGVwaWNrZXIuX3Bvc1sxXX07XG5cdFx0JC5kYXRlcGlja2VyLl9wb3MgPSBudWxsO1xuXHRcdC8vdG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94XG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpO1xuXHRcdC8vIGRldGVybWluZSBzaXppbmcgb2Zmc2NyZWVuXG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiwgdG9wOiBcIi0xMDAwcHhcIn0pO1xuXHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHQvLyBmaXggd2lkdGggZm9yIGR5bmFtaWMgbnVtYmVyIG9mIGRhdGUgcGlja2Vyc1xuXHRcdC8vIGFuZCBhZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcblx0XHRvZmZzZXQgPSAkLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KGluc3QsIG9mZnNldCwgaXNGaXhlZCk7XG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiAoJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkgP1xuXHRcdFx0XCJzdGF0aWNcIiA6IChpc0ZpeGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiKSksIGRpc3BsYXk6IFwibm9uZVwiLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgKyBcInB4XCIsIHRvcDogb2Zmc2V0LnRvcCArIFwicHhcIn0pO1xuXG5cdFx0aWYgKCFpbnN0LmlubGluZSkge1xuXHRcdFx0c2hvd0FuaW0gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dBbmltXCIpO1xuXHRcdFx0ZHVyYXRpb24gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImR1cmF0aW9uXCIpO1xuXHRcdFx0aW5zdC5kcERpdi56SW5kZXgoJChpbnB1dCkuekluZGV4KCkrMSk7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSApIHtcblx0XHRcdFx0aW5zdC5kcERpdi5zaG93KHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dPcHRpb25zXCIpLCBkdXJhdGlvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnN0LmRwRGl2W3Nob3dBbmltIHx8IFwic2hvd1wiXShzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KCBpbnN0ICkgKSB7XG5cdFx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0ID0gaW5zdDtcblx0XHR9XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIGRhdGUgcGlja2VyIGNvbnRlbnQuICovXG5cdF91cGRhdGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dGhpcy5tYXhSb3dzID0gNDsgLy9SZXNldCB0aGUgbWF4IG51bWJlciBvZiByb3dzIGJlaW5nIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRcdGluc3RBY3RpdmUgPSBpbnN0OyAvLyBmb3IgZGVsZWdhdGUgaG92ZXIgZXZlbnRzXG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpLmFwcGVuZCh0aGlzLl9nZW5lcmF0ZUhUTUwoaW5zdCkpO1xuXHRcdHRoaXMuX2F0dGFjaEhhbmRsZXJzKGluc3QpO1xuXHRcdGluc3QuZHBEaXYuZmluZChcIi5cIiArIHRoaXMuX2RheU92ZXJDbGFzcyArIFwiIGFcIikubW91c2VvdmVyKCk7XG5cblx0XHR2YXIgb3JpZ3llYXJzaHRtbCxcblx0XHRcdG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0Y29scyA9IG51bU1vbnRoc1sxXSxcblx0XHRcdHdpZHRoID0gMTc7XG5cblx0XHRpbnN0LmRwRGl2LnJlbW92ZUNsYXNzKFwidWktZGF0ZXBpY2tlci1tdWx0aS0yIHVpLWRhdGVwaWNrZXItbXVsdGktMyB1aS1kYXRlcGlja2VyLW11bHRpLTRcIikud2lkdGgoXCJcIik7XG5cdFx0aWYgKGNvbHMgPiAxKSB7XG5cdFx0XHRpbnN0LmRwRGl2LmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1tdWx0aS1cIiArIGNvbHMpLmNzcyhcIndpZHRoXCIsICh3aWR0aCAqIGNvbHMpICsgXCJlbVwiKTtcblx0XHR9XG5cdFx0aW5zdC5kcERpdlsobnVtTW9udGhzWzBdICE9PSAxIHx8IG51bU1vbnRoc1sxXSAhPT0gMSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArXG5cdFx0XHRcIkNsYXNzXCJdKFwidWktZGF0ZXBpY2tlci1tdWx0aVwiKTtcblx0XHRpbnN0LmRwRGl2Wyh0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArXG5cdFx0XHRcIkNsYXNzXCJdKFwidWktZGF0ZXBpY2tlci1ydGxcIik7XG5cblx0XHRpZiAoaW5zdCA9PT0gJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KCBpbnN0ICkgKSB7XG5cdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZGVmZmVyZWQgcmVuZGVyIG9mIHRoZSB5ZWFycyBzZWxlY3QgKHRvIGF2b2lkIGZsYXNoZXMgb24gRmlyZWZveClcblx0XHRpZiggaW5zdC55ZWFyc2h0bWwgKXtcblx0XHRcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly9hc3N1cmUgdGhhdCBpbnN0LnllYXJzaHRtbCBkaWRuJ3QgY2hhbmdlLlxuXHRcdFx0XHRpZiggb3JpZ3llYXJzaHRtbCA9PT0gaW5zdC55ZWFyc2h0bWwgJiYgaW5zdC55ZWFyc2h0bWwgKXtcblx0XHRcdFx0XHRpbnN0LmRwRGl2LmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyOmZpcnN0XCIpLnJlcGxhY2VXaXRoKGluc3QueWVhcnNodG1sKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vICM2Njk0IC0gZG9uJ3QgZm9jdXMgdGhlIGlucHV0IGlmIGl0J3MgYWxyZWFkeSBmb2N1c2VkXG5cdC8vIHRoaXMgYnJlYWtzIHRoZSBjaGFuZ2UgZXZlbnQgaW4gSUVcblx0Ly8gU3VwcG9ydDogSUUgYW5kIGpRdWVyeSA8MS45XG5cdF9zaG91bGRGb2N1c0lucHV0OiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHRyZXR1cm4gaW5zdC5pbnB1dCAmJiBpbnN0LmlucHV0LmlzKCBcIjp2aXNpYmxlXCIgKSAmJiAhaW5zdC5pbnB1dC5pcyggXCI6ZGlzYWJsZWRcIiApICYmICFpbnN0LmlucHV0LmlzKCBcIjpmb2N1c1wiICk7XG5cdH0sXG5cblx0LyogQ2hlY2sgcG9zaXRpb25pbmcgdG8gcmVtYWluIG9uIHNjcmVlbi4gKi9cblx0X2NoZWNrT2Zmc2V0OiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIGlzRml4ZWQpIHtcblx0XHR2YXIgZHBXaWR0aCA9IGluc3QuZHBEaXYub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZHBIZWlnaHQgPSBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRpbnB1dFdpZHRoID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJXaWR0aCgpIDogMCxcblx0XHRcdGlucHV0SGVpZ2h0ID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJIZWlnaHQoKSA6IDAsXG5cdFx0XHR2aWV3V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpLFxuXHRcdFx0dmlld0hlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSk7XG5cblx0XHRvZmZzZXQubGVmdCAtPSAodGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIikgPyAoZHBXaWR0aCAtIGlucHV0V2lkdGgpIDogMCk7XG5cdFx0b2Zmc2V0LmxlZnQgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LmxlZnQgPT09IGluc3QuaW5wdXQub2Zmc2V0KCkubGVmdCkgPyAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgOiAwO1xuXHRcdG9mZnNldC50b3AgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LnRvcCA9PT0gKGluc3QuaW5wdXQub2Zmc2V0KCkudG9wICsgaW5wdXRIZWlnaHQpKSA/ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDogMDtcblxuXHRcdC8vIG5vdyBjaGVjayBpZiBkYXRlcGlja2VyIGlzIHNob3dpbmcgb3V0c2lkZSB3aW5kb3cgdmlld3BvcnQgLSBtb3ZlIHRvIGEgYmV0dGVyIHBsYWNlIGlmIHNvLlxuXHRcdG9mZnNldC5sZWZ0IC09IE1hdGgubWluKG9mZnNldC5sZWZ0LCAob2Zmc2V0LmxlZnQgKyBkcFdpZHRoID4gdmlld1dpZHRoICYmIHZpZXdXaWR0aCA+IGRwV2lkdGgpID9cblx0XHRcdE1hdGguYWJzKG9mZnNldC5sZWZ0ICsgZHBXaWR0aCAtIHZpZXdXaWR0aCkgOiAwKTtcblx0XHRvZmZzZXQudG9wIC09IE1hdGgubWluKG9mZnNldC50b3AsIChvZmZzZXQudG9wICsgZHBIZWlnaHQgPiB2aWV3SGVpZ2h0ICYmIHZpZXdIZWlnaHQgPiBkcEhlaWdodCkgP1xuXHRcdFx0TWF0aC5hYnMoZHBIZWlnaHQgKyBpbnB1dEhlaWdodCkgOiAwKTtcblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH0sXG5cblx0LyogRmluZCBhbiBvYmplY3QncyBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuLiAqL1xuXHRfZmluZFBvczogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIHBvc2l0aW9uLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3Qob2JqKSxcblx0XHRcdGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIik7XG5cblx0XHR3aGlsZSAob2JqICYmIChvYmoudHlwZSA9PT0gXCJoaWRkZW5cIiB8fCBvYmoubm9kZVR5cGUgIT09IDEgfHwgJC5leHByLmZpbHRlcnMuaGlkZGVuKG9iaikpKSB7XG5cdFx0XHRvYmogPSBvYmpbaXNSVEwgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiXTtcblx0XHR9XG5cblx0XHRwb3NpdGlvbiA9ICQob2JqKS5vZmZzZXQoKTtcblx0XHRyZXR1cm4gW3Bvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcF07XG5cdH0sXG5cblx0LyogSGlkZSB0aGUgZGF0ZSBwaWNrZXIgZnJvbSB2aWV3LlxuXHQgKiBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlclxuXHQgKi9cblx0X2hpZGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdHZhciBzaG93QW5pbSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzLCBvbkNsb3NlLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2N1ckluc3Q7XG5cblx0XHRpZiAoIWluc3QgfHwgKGlucHV0ICYmIGluc3QgIT09ICQuZGF0YShpbnB1dCwgUFJPUF9OQU1FKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fZGF0ZXBpY2tlclNob3dpbmcpIHtcblx0XHRcdHNob3dBbmltID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0FuaW1cIik7XG5cdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2dldChpbnN0LCBcImR1cmF0aW9uXCIpO1xuXHRcdFx0cG9zdFByb2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl90aWR5RGlhbG9nKGluc3QpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gREVQUkVDQVRFRDogYWZ0ZXIgQkMgZm9yIDEuOC54ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSBpcyBub3QgbmVlZGVkXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAoICQuZWZmZWN0cy5lZmZlY3RbIHNob3dBbmltIF0gfHwgJC5lZmZlY3RzWyBzaG93QW5pbSBdICkgKSB7XG5cdFx0XHRcdGluc3QuZHBEaXYuaGlkZShzaG93QW5pbSwgJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzaG93T3B0aW9uc1wiKSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc3QuZHBEaXZbKHNob3dBbmltID09PSBcInNsaWRlRG93blwiID8gXCJzbGlkZVVwXCIgOlxuXHRcdFx0XHRcdChzaG93QW5pbSA9PT0gXCJmYWRlSW5cIiA/IFwiZmFkZU91dFwiIDogXCJoaWRlXCIpKV0oKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsKSwgcG9zdFByb2Nlc3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNob3dBbmltKSB7XG5cdFx0XHRcdHBvc3RQcm9jZXNzKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlO1xuXG5cdFx0XHRvbkNsb3NlID0gdGhpcy5fZ2V0KGluc3QsIFwib25DbG9zZVwiKTtcblx0XHRcdGlmIChvbkNsb3NlKSB7XG5cdFx0XHRcdG9uQ2xvc2UuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFsoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBcIlwiKSwgaW5zdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMuX2luRGlhbG9nKSB7XG5cdFx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmNzcyh7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IFwiMFwiLCB0b3A6IFwiLTEwMHB4XCIgfSk7XG5cdFx0XHRcdGlmICgkLmJsb2NrVUkpIHtcblx0XHRcdFx0XHQkLnVuYmxvY2tVSSgpO1xuXHRcdFx0XHRcdCQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLmRwRGl2KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5faW5EaWFsb2cgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0LyogVGlkeSB1cCBhZnRlciBhIGRpYWxvZyBkaXNwbGF5LiAqL1xuXHRfdGlkeURpYWxvZzogZnVuY3Rpb24oaW5zdCkge1xuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3ModGhpcy5fZGlhbG9nQ2xhc3MpLnVuYmluZChcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIpO1xuXHR9LFxuXG5cdC8qIENsb3NlIGRhdGUgcGlja2VyIGlmIGNsaWNrZWQgZWxzZXdoZXJlLiAqL1xuXHRfY2hlY2tFeHRlcm5hbENsaWNrOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghJC5kYXRlcGlja2VyLl9jdXJJbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyICR0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCR0YXJnZXRbMF0pO1xuXG5cdFx0aWYgKCAoICggJHRhcmdldFswXS5pZCAhPT0gJC5kYXRlcGlja2VyLl9tYWluRGl2SWQgJiZcblx0XHRcdFx0JHRhcmdldC5wYXJlbnRzKFwiI1wiICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQpLmxlbmd0aCA9PT0gMCAmJlxuXHRcdFx0XHQhJHRhcmdldC5oYXNDbGFzcygkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lKSAmJlxuXHRcdFx0XHQhJHRhcmdldC5jbG9zZXN0KFwiLlwiICsgJC5kYXRlcGlja2VyLl90cmlnZ2VyQ2xhc3MpLmxlbmd0aCAmJlxuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICEoJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkpICkgKSB8fFxuXHRcdFx0KCAkdGFyZ2V0Lmhhc0NsYXNzKCQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCApICkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdERhdGU6IGZ1bmN0aW9uKGlkLCBvZmZzZXQsIHBlcmlvZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cblx0XHRpZiAodGhpcy5faXNEaXNhYmxlZERhdGVwaWNrZXIodGFyZ2V0WzBdKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZShpbnN0LCBvZmZzZXQgK1xuXHRcdFx0KHBlcmlvZCA9PT0gXCJNXCIgPyB0aGlzLl9nZXQoaW5zdCwgXCJzaG93Q3VycmVudEF0UG9zXCIpIDogMCksIC8vIHVuZG8gcG9zaXRpb25pbmdcblx0XHRcdHBlcmlvZCk7XG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIGN1cnJlbnQgbGluay4gKi9cblx0X2dvdG9Ub2RheTogZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGlmICh0aGlzLl9nZXQoaW5zdCwgXCJnb3RvQ3VycmVudFwiKSAmJiBpbnN0LmN1cnJlbnREYXkpIHtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHR9XG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdHRoaXMuX2FkanVzdERhdGUodGFyZ2V0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIG5ldyBtb250aC95ZWFyLiAqL1xuXHRfc2VsZWN0TW9udGhZZWFyOiBmdW5jdGlvbihpZCwgc2VsZWN0LCBwZXJpb2QpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXG5cdFx0aW5zdFtcInNlbGVjdGVkXCIgKyAocGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiKV0gPVxuXHRcdGluc3RbXCJkcmF3XCIgKyAocGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiKV0gPVxuXHRcdFx0cGFyc2VJbnQoc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdLnZhbHVlLDEwKTtcblxuXHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR0aGlzLl9hZGp1c3REYXRlKHRhcmdldCk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBkYXkuICovXG5cdF9zZWxlY3REYXk6IGZ1bmN0aW9uKGlkLCBtb250aCwgeWVhciwgdGQpIHtcblx0XHR2YXIgaW5zdCxcblx0XHRcdHRhcmdldCA9ICQoaWQpO1xuXG5cdFx0aWYgKCQodGQpLmhhc0NsYXNzKHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzKSB8fCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gJChcImFcIiwgdGQpLmh0bWwoKTtcblx0XHRpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG1vbnRoO1xuXHRcdGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhciA9IHllYXI7XG5cdFx0dGhpcy5fc2VsZWN0RGF0ZShpZCwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LFxuXHRcdFx0aW5zdC5jdXJyZW50RGF5LCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50WWVhcikpO1xuXHR9LFxuXG5cdC8qIEVyYXNlIHRoZSBpbnB1dCBmaWVsZCBhbmQgaGlkZSB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9jbGVhckRhdGU6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUodGFyZ2V0LCBcIlwiKTtcblx0fSxcblxuXHQvKiBVcGRhdGUgdGhlIGlucHV0IGZpZWxkIHdpdGggdGhlIHNlbGVjdGVkIGRhdGUuICovXG5cdF9zZWxlY3REYXRlOiBmdW5jdGlvbihpZCwgZGF0ZVN0cikge1xuXHRcdHZhciBvblNlbGVjdCxcblx0XHRcdHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGRhdGVTdHIgPSAoZGF0ZVN0ciAhPSBudWxsID8gZGF0ZVN0ciA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdGlmIChpbnN0LmlucHV0KSB7XG5cdFx0XHRpbnN0LmlucHV0LnZhbChkYXRlU3RyKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXG5cdFx0b25TZWxlY3QgPSB0aGlzLl9nZXQoaW5zdCwgXCJvblNlbGVjdFwiKTtcblx0XHRpZiAob25TZWxlY3QpIHtcblx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pOyAgLy8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHR9IGVsc2UgaWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudHJpZ2dlcihcImNoYW5nZVwiKTsgLy8gZmlyZSB0aGUgY2hhbmdlIGV2ZW50XG5cdFx0fVxuXG5cdFx0aWYgKGluc3QuaW5saW5lKXtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBpbnN0LmlucHV0WzBdO1xuXHRcdFx0aWYgKHR5cGVvZihpbnN0LmlucHV0WzBdKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7IC8vIHJlc3RvcmUgZm9jdXNcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBhbnkgYWx0ZXJuYXRlIGZpZWxkIHRvIHN5bmNocm9uaXNlIHdpdGggdGhlIG1haW4gZmllbGQuICovXG5cdF91cGRhdGVBbHRlcm5hdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgYWx0Rm9ybWF0LCBkYXRlLCBkYXRlU3RyLFxuXHRcdFx0YWx0RmllbGQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhbHRGaWVsZFwiKTtcblxuXHRcdGlmIChhbHRGaWVsZCkgeyAvLyB1cGRhdGUgYWx0ZXJuYXRlIGZpZWxkIHRvb1xuXHRcdFx0YWx0Rm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwiYWx0Rm9ybWF0XCIpIHx8IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIik7XG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZShpbnN0KTtcblx0XHRcdGRhdGVTdHIgPSB0aGlzLmZvcm1hdERhdGUoYWx0Rm9ybWF0LCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xuXHRcdFx0JChhbHRGaWVsZCkuZWFjaChmdW5jdGlvbigpIHsgJCh0aGlzKS52YWwoZGF0ZVN0cik7IH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgYXMgYmVmb3JlU2hvd0RheSBmdW5jdGlvbiB0byBwcmV2ZW50IHNlbGVjdGlvbiBvZiB3ZWVrZW5kcy5cblx0ICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gY3VzdG9taXNlXG5cdCAqIEByZXR1cm4gW2Jvb2xlYW4sIHN0cmluZ10gLSBpcyB0aGlzIGRhdGUgc2VsZWN0YWJsZT8sIHdoYXQgaXMgaXRzIENTUyBjbGFzcz9cblx0ICovXG5cdG5vV2Vla2VuZHM6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblx0XHRyZXR1cm4gWyhkYXkgPiAwICYmIGRheSA8IDYpLCBcIlwiXTtcblx0fSxcblxuXHQvKiBTZXQgYXMgY2FsY3VsYXRlV2VlayB0byBkZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgYmFzZWQgb24gdGhlIElTTyA4NjAxIGRlZmluaXRpb24uXG5cdCAqIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGdldCB0aGUgd2VlayBmb3Jcblx0ICogQHJldHVybiAgbnVtYmVyIC0gdGhlIG51bWJlciBvZiB0aGUgd2VlayB3aXRoaW4gdGhlIHllYXIgdGhhdCBjb250YWlucyB0aGlzIGRhdGVcblx0ICovXG5cdGlzbzg2MDFXZWVrOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHRpbWUsXG5cdFx0XHRjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG5cblx0XHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcblx0XHRjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtIChjaGVja0RhdGUuZ2V0RGF5KCkgfHwgNykpO1xuXG5cdFx0dGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG5cdFx0Y2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcblx0XHRjaGVja0RhdGUuc2V0RGF0ZSgxKTtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcblx0fSxcblxuXHQvKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXG5cdCAqIFNlZSBmb3JtYXREYXRlIGJlbG93IGZvciB0aGUgcG9zc2libGUgZm9ybWF0cy5cblx0ICpcblx0ICogQHBhcmFtICBmb3JtYXQgc3RyaW5nIC0gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxuXHQgKiBAcGFyYW0gIHZhbHVlIHN0cmluZyAtIHRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdHNob3J0WWVhckN1dG9mZiAgbnVtYmVyIC0gdGhlIGN1dG9mZiB5ZWFyIGZvciBkZXRlcm1pbmluZyB0aGUgY2VudHVyeSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgRGF0ZSAtIHRoZSBleHRyYWN0ZWQgZGF0ZSB2YWx1ZSBvciBudWxsIGlmIHZhbHVlIGlzIGJsYW5rXG5cdCAqL1xuXHRwYXJzZURhdGU6IGZ1bmN0aW9uIChmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xuXHRcdGlmIChmb3JtYXQgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgYXJndW1lbnRzXCI7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlICsgXCJcIik7XG5cdFx0aWYgKHZhbHVlID09PSBcIlwiKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgaUZvcm1hdCwgZGltLCBleHRyYSxcblx0XHRcdGlWYWx1ZSA9IDAsXG5cdFx0XHRzaG9ydFllYXJDdXRvZmZUZW1wID0gKHNldHRpbmdzID8gc2V0dGluZ3Muc2hvcnRZZWFyQ3V0b2ZmIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuc2hvcnRZZWFyQ3V0b2ZmLFxuXHRcdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmZUZW1wICE9PSBcInN0cmluZ1wiID8gc2hvcnRZZWFyQ3V0b2ZmVGVtcCA6XG5cdFx0XHRcdG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZlRlbXAsIDEwKSksXG5cdFx0XHRkYXlOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXG5cdFx0XHRkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQsXG5cdFx0XHRtb250aE5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXG5cdFx0XHR5ZWFyID0gLTEsXG5cdFx0XHRtb250aCA9IC0xLFxuXHRcdFx0ZGF5ID0gLTEsXG5cdFx0XHRkb3kgPSAtMSxcblx0XHRcdGxpdGVyYWwgPSBmYWxzZSxcblx0XHRcdGRhdGUsXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdGdldE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdHZhciBpc0RvdWJsZWQgPSBsb29rQWhlYWQobWF0Y2gpLFxuXHRcdFx0XHRcdHNpemUgPSAobWF0Y2ggPT09IFwiQFwiID8gMTQgOiAobWF0Y2ggPT09IFwiIVwiID8gMjAgOlxuXHRcdFx0XHRcdChtYXRjaCA9PT0gXCJ5XCIgJiYgaXNEb3VibGVkID8gNCA6IChtYXRjaCA9PT0gXCJvXCIgPyAzIDogMikpKSksXG5cdFx0XHRcdFx0ZGlnaXRzID0gbmV3IFJlZ0V4cChcIl5cXFxcZHsxLFwiICsgc2l6ZSArIFwifVwiKSxcblx0XHRcdFx0XHRudW0gPSB2YWx1ZS5zdWJzdHJpbmcoaVZhbHVlKS5tYXRjaChkaWdpdHMpO1xuXHRcdFx0XHRpZiAoIW51bSkge1xuXHRcdFx0XHRcdHRocm93IFwiTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aVZhbHVlICs9IG51bVswXS5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBwYXJzZUludChudW1bMF0sIDEwKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBFeHRyYWN0IGEgbmFtZSBmcm9tIHRoZSBzdHJpbmcgdmFsdWUgYW5kIGNvbnZlcnQgdG8gYW4gaW5kZXhcblx0XHRcdGdldE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IC0xLFxuXHRcdFx0XHRcdG5hbWVzID0gJC5tYXAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lcyA6IHNob3J0TmFtZXMsIGZ1bmN0aW9uICh2LCBrKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBbaywgdl0gXTtcblx0XHRcdFx0XHR9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLShhWzFdLmxlbmd0aCAtIGJbMV0ubGVuZ3RoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHQkLmVhY2gobmFtZXMsIGZ1bmN0aW9uIChpLCBwYWlyKSB7XG5cdFx0XHRcdFx0dmFyIG5hbWUgPSBwYWlyWzFdO1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5zdWJzdHIoaVZhbHVlLCBuYW1lLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHBhaXJbMF07XG5cdFx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBDb25maXJtIHRoYXQgYSBsaXRlcmFsIGNoYXJhY3RlciBtYXRjaGVzIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodmFsdWUuY2hhckF0KGlWYWx1ZSkgIT09IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVuZXhwZWN0ZWQgbGl0ZXJhbCBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUrKztcblx0XHRcdH07XG5cblx0XHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRpZiAobGl0ZXJhbCkge1xuXHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdFx0XHRkYXkgPSBnZXROdW1iZXIoXCJkXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0XHRcdGdldE5hbWUoXCJEXCIsIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRkb3kgPSBnZXROdW1iZXIoXCJvXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdFx0XHRcdG1vbnRoID0gZ2V0TnVtYmVyKFwibVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRtb250aCA9IGdldE5hbWUoXCJNXCIsIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHRcdFx0eWVhciA9IGdldE51bWJlcihcInlcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKGdldE51bWJlcihcIkBcIikpO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIiFcIjpcblx0XHRcdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgoZ2V0TnVtYmVyKFwiIVwiKSAtIHRoaXMuX3RpY2tzVG8xOTcwKSAvIDEwMDAwKTtcblx0XHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG5cdFx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSl7XG5cdFx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKXtcblx0XHRcdGV4dHJhID0gdmFsdWUuc3Vic3RyKGlWYWx1ZSk7XG5cdFx0XHRpZiAoIS9eXFxzKy8udGVzdChleHRyYSkpIHtcblx0XHRcdFx0dGhyb3cgXCJFeHRyYS91bnBhcnNlZCBjaGFyYWN0ZXJzIGZvdW5kIGluIGRhdGU6IFwiICsgZXh0cmE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHllYXIgPT09IC0xKSB7XG5cdFx0XHR5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdH0gZWxzZSBpZiAoeWVhciA8IDEwMCkge1xuXHRcdFx0eWVhciArPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgK1xuXHRcdFx0XHQoeWVhciA8PSBzaG9ydFllYXJDdXRvZmYgPyAwIDogLTEwMCk7XG5cdFx0fVxuXG5cdFx0aWYgKGRveSA+IC0xKSB7XG5cdFx0XHRtb250aCA9IDE7XG5cdFx0XHRkYXkgPSBkb3k7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGRpbSA9IHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoIC0gMSk7XG5cdFx0XHRcdGlmIChkYXkgPD0gZGltKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bW9udGgrKztcblx0XHRcdFx0ZGF5IC09IGRpbTtcblx0XHRcdH0gd2hpbGUgKHRydWUpO1xuXHRcdH1cblxuXHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXHRcdGlmIChkYXRlLmdldEZ1bGxZZWFyKCkgIT09IHllYXIgfHwgZGF0ZS5nZXRNb250aCgpICsgMSAhPT0gbW9udGggfHwgZGF0ZS5nZXREYXRlKCkgIT09IGRheSkge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIGRhdGVcIjsgLy8gRS5nLiAzMS8wMi8wMFxuXHRcdH1cblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTdGFuZGFyZCBkYXRlIGZvcm1hdHMuICovXG5cdEFUT006IFwieXktbW0tZGRcIiwgLy8gUkZDIDMzMzkgKElTTyA4NjAxKVxuXHRDT09LSUU6IFwiRCwgZGQgTSB5eVwiLFxuXHRJU09fODYwMTogXCJ5eS1tbS1kZFwiLFxuXHRSRkNfODIyOiBcIkQsIGQgTSB5XCIsXG5cdFJGQ184NTA6IFwiREQsIGRkLU0teVwiLFxuXHRSRkNfMTAzNjogXCJELCBkIE0geVwiLFxuXHRSRkNfMTEyMzogXCJELCBkIE0geXlcIixcblx0UkZDXzI4MjI6IFwiRCwgZCBNIHl5XCIsXG5cdFJTUzogXCJELCBkIE0geVwiLCAvLyBSRkMgODIyXG5cdFRJQ0tTOiBcIiFcIixcblx0VElNRVNUQU1QOiBcIkBcIixcblx0VzNDOiBcInl5LW1tLWRkXCIsIC8vIElTTyA4NjAxXG5cblx0X3RpY2tzVG8xOTcwOiAoKCgxOTcwIC0gMSkgKiAzNjUgKyBNYXRoLmZsb29yKDE5NzAgLyA0KSAtIE1hdGguZmxvb3IoMTk3MCAvIDEwMCkgK1xuXHRcdE1hdGguZmxvb3IoMTk3MCAvIDQwMCkpICogMjQgKiA2MCAqIDYwICogMTAwMDAwMDApLFxuXG5cdC8qIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXG5cdCAqIFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxuXHQgKiBkICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKVxuXHQgKiBkZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KVxuXHQgKiBvICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKVxuXHQgKiBvbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdClcblx0ICogRCAgLSBkYXkgbmFtZSBzaG9ydFxuXHQgKiBERCAtIGRheSBuYW1lIGxvbmdcblx0ICogbSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pXG5cdCAqIG1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KVxuXHQgKiBNICAtIG1vbnRoIG5hbWUgc2hvcnRcblx0ICogTU0gLSBtb250aCBuYW1lIGxvbmdcblx0ICogeSAgLSB5ZWFyICh0d28gZGlnaXQpXG5cdCAqIHl5IC0geWVhciAoZm91ciBkaWdpdClcblx0ICogQCAtIFVuaXggdGltZXN0YW1wIChtcyBzaW5jZSAwMS8wMS8xOTcwKVxuXHQgKiAhIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSlcblx0ICogXCIuLi5cIiAtIGxpdGVyYWwgdGV4dFxuXHQgKiAnJyAtIHNpbmdsZSBxdW90ZVxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZGVzaXJlZCBmb3JtYXQgb2YgdGhlIGRhdGVcblx0ICogQHBhcmFtICBkYXRlIERhdGUgLSB0aGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKi9cblx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24gKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcblx0XHRpZiAoIWRhdGUpIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0ZGF5TmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxuXHRcdFx0ZGF5TmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzLFxuXHRcdFx0bW9udGhOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lc1Nob3J0LFxuXHRcdFx0bW9udGhOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaCk7XG5cdFx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEZvcm1hdCBhIG51bWJlciwgd2l0aCBsZWFkaW5nIHplcm8gaWYgbmVjZXNzYXJ5XG5cdFx0XHRmb3JtYXROdW1iZXIgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIGxlbikge1xuXHRcdFx0XHR2YXIgbnVtID0gXCJcIiArIHZhbHVlO1xuXHRcdFx0XHRpZiAobG9va0FoZWFkKG1hdGNoKSkge1xuXHRcdFx0XHRcdHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKSB7XG5cdFx0XHRcdFx0XHRudW0gPSBcIjBcIiArIG51bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bTtcblx0XHRcdH0sXG5cdFx0XHQvLyBGb3JtYXQgYSBuYW1lLCBzaG9ydCBvciBsb25nIGFzIHJlcXVlc3RlZFxuXHRcdFx0Zm9ybWF0TmFtZSA9IGZ1bmN0aW9uKG1hdGNoLCB2YWx1ZSwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XG5cdFx0XHRcdHJldHVybiAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lc1t2YWx1ZV0gOiBzaG9ydE5hbWVzW3ZhbHVlXSk7XG5cdFx0XHR9LFxuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblxuXHRcdGlmIChkYXRlKSB7XG5cdFx0XHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJkXCIsIGRhdGUuZ2V0RGF0ZSgpLCAyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TmFtZShcIkRcIiwgZGF0ZS5nZXREYXkoKSwgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJvXCIsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZCgobmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApLmdldFRpbWUoKSkgLyA4NjQwMDAwMCksIDMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJtXCIsIGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROYW1lKFwiTVwiLCBkYXRlLmdldE1vbnRoKCksIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcInlcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IChsb29rQWhlYWQoXCJ5XCIpID8gZGF0ZS5nZXRGdWxsWWVhcigpIDpcblx0XHRcdFx0XHRcdFx0XHQoZGF0ZS5nZXRZZWFyKCkgJSAxMDAgPCAxMCA/IFwiMFwiIDogXCJcIikgKyBkYXRlLmdldFllYXIoKSAlIDEwMCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCIhXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmdldFRpbWUoKSAqIDEwMDAwICsgdGhpcy5fdGlja3NUbzE5NzA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdFx0aWYgKGxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fSxcblxuXHQvKiBFeHRyYWN0IGFsbCBwb3NzaWJsZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfcG9zc2libGVDaGFyczogZnVuY3Rpb24gKGZvcm1hdCkge1xuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0Y2hhcnMgPSBcIlwiLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlLFxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaCk7XG5cdFx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhbG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGFycyArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRjYXNlIFwiZFwiOiBjYXNlIFwibVwiOiBjYXNlIFwieVwiOiBjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCIwMTIzNDU2Nzg5XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiRFwiOiBjYXNlIFwiTVwiOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0XHRjaGFycyArPSBcIidcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNoYXJzO1xuXHR9LFxuXG5cdC8qIEdldCBhIHNldHRpbmcgdmFsdWUsIGRlZmF1bHRpbmcgaWYgbmVjZXNzYXJ5LiAqL1xuXHRfZ2V0OiBmdW5jdGlvbihpbnN0LCBuYW1lKSB7XG5cdFx0cmV0dXJuIGluc3Quc2V0dGluZ3NbbmFtZV0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRpbnN0LnNldHRpbmdzW25hbWVdIDogdGhpcy5fZGVmYXVsdHNbbmFtZV07XG5cdH0sXG5cblx0LyogUGFyc2UgZXhpc3RpbmcgZGF0ZSBhbmQgaW5pdGlhbGlzZSBkYXRlIHBpY2tlci4gKi9cblx0X3NldERhdGVGcm9tRmllbGQ6IGZ1bmN0aW9uKGluc3QsIG5vRGVmYXVsdCkge1xuXHRcdGlmIChpbnN0LmlucHV0LnZhbCgpID09PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksXG5cdFx0XHRkYXRlcyA9IGluc3QubGFzdFZhbCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCxcblx0XHRcdGRlZmF1bHREYXRlID0gdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksXG5cdFx0XHRkYXRlID0gZGVmYXVsdERhdGUsXG5cdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRkYXRlID0gdGhpcy5wYXJzZURhdGUoZGF0ZUZvcm1hdCwgZGF0ZXMsIHNldHRpbmdzKSB8fCBkZWZhdWx0RGF0ZTtcblx0XHR9IGNhdGNoIChldmVudCkge1xuXHRcdFx0ZGF0ZXMgPSAobm9EZWZhdWx0ID8gXCJcIiA6IGRhdGVzKTtcblx0XHR9XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpbnN0LmN1cnJlbnREYXkgPSAoZGF0ZXMgPyBkYXRlLmdldERhdGUoKSA6IDApO1xuXHRcdGluc3QuY3VycmVudE1vbnRoID0gKGRhdGVzID8gZGF0ZS5nZXRNb250aCgpIDogMCk7XG5cdFx0aW5zdC5jdXJyZW50WWVhciA9IChkYXRlcyA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6IDApO1xuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QpO1xuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkZWZhdWx0IGRhdGUgc2hvd24gb24gb3BlbmluZy4gKi9cblx0X2dldERlZmF1bHREYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsXG5cdFx0XHR0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIHRoaXMuX2dldChpbnN0LCBcImRlZmF1bHREYXRlXCIpLCBuZXcgRGF0ZSgpKSk7XG5cdH0sXG5cblx0LyogQSBkYXRlIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gZXhhY3QgdmFsdWUgb3IgYSByZWxhdGl2ZSBvbmUuICovXG5cdF9kZXRlcm1pbmVEYXRlOiBmdW5jdGlvbihpbnN0LCBkYXRlLCBkZWZhdWx0RGF0ZSkge1xuXHRcdHZhciBvZmZzZXROdW1lcmljID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0ZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcblx0XHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0XHR9LFxuXHRcdFx0b2Zmc2V0U3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpLFxuXHRcdFx0XHRcdFx0b2Zmc2V0LCAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBJZ25vcmVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRlID0gKG9mZnNldC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eYy8pID9cblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dldERhdGUoaW5zdCkgOiBudWxsKSB8fCBuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCksXG5cdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCksXG5cdFx0XHRcdFx0cGF0dGVybiA9IC8oWytcXC1dP1swLTldKylcXHMqKGR8RHx3fFd8bXxNfHl8WSk/L2csXG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXG5cdFx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0c3dpdGNoIChtYXRjaGVzWzJdIHx8IFwiZFwiKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZFwiIDogY2FzZSBcIkRcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwid1wiIDogY2FzZSBcIldcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKSAqIDc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm1cIiA6IGNhc2UgXCJNXCIgOlxuXHRcdFx0XHRcdFx0XHRtb250aCArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTtcblx0XHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcInlcIjogY2FzZSBcIllcIiA6XG5cdFx0XHRcdFx0XHRcdHllYXIgKz0gcGFyc2VJbnQobWF0Y2hlc1sxXSwxMCk7XG5cdFx0XHRcdFx0XHRcdGRheSA9IE1hdGgubWluKGRheSwgJC5kYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHRcdH0sXG5cdFx0XHRuZXdEYXRlID0gKGRhdGUgPT0gbnVsbCB8fCBkYXRlID09PSBcIlwiID8gZGVmYXVsdERhdGUgOiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIgPyBvZmZzZXRTdHJpbmcoZGF0ZSkgOlxuXHRcdFx0XHQodHlwZW9mIGRhdGUgPT09IFwibnVtYmVyXCIgPyAoaXNOYU4oZGF0ZSkgPyBkZWZhdWx0RGF0ZSA6IG9mZnNldE51bWVyaWMoZGF0ZSkpIDogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKSkpO1xuXG5cdFx0bmV3RGF0ZSA9IChuZXdEYXRlICYmIG5ld0RhdGUudG9TdHJpbmcoKSA9PT0gXCJJbnZhbGlkIERhdGVcIiA/IGRlZmF1bHREYXRlIDogbmV3RGF0ZSk7XG5cdFx0aWYgKG5ld0RhdGUpIHtcblx0XHRcdG5ld0RhdGUuc2V0SG91cnMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbnV0ZXMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldFNlY29uZHMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ld0RhdGUpO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBzd2l0Y2ggdG8vZnJvbSBkYXlsaWdodCBzYXZpbmcuXG5cdCAqIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XG5cdCAqID4gMTIgd2hlbiBtaWRuaWdodCBjaGFuZ2VvdmVyLCBidXQgdGhlbiBjYW5ub3QgZ2VuZXJhdGVcblx0ICogbWlkbmlnaHQgZGF0ZXRpbWUsIHNvIGp1bXAgdG8gMUFNLCBvdGhlcndpc2UgcmVzZXQuXG5cdCAqIEBwYXJhbSAgZGF0ZSAgKERhdGUpIHRoZSBkYXRlIHRvIGNoZWNrXG5cdCAqIEByZXR1cm4gIChEYXRlKSB0aGUgY29ycmVjdGVkIGRhdGVcblx0ICovXG5cdF9kYXlsaWdodFNhdmluZ0FkanVzdDogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdGlmICghZGF0ZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpID4gMTIgPyBkYXRlLmdldEhvdXJzKCkgKyAyIDogMCk7XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfc2V0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF0ZSwgbm9DaGFuZ2UpIHtcblx0XHR2YXIgY2xlYXIgPSAhZGF0ZSxcblx0XHRcdG9yaWdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCxcblx0XHRcdG9yaWdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIsXG5cdFx0XHRuZXdEYXRlID0gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCwgdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCBkYXRlLCBuZXcgRGF0ZSgpKSk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gbmV3RGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0gbmV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmICgob3JpZ01vbnRoICE9PSBpbnN0LnNlbGVjdGVkTW9udGggfHwgb3JpZ1llYXIgIT09IGluc3Quc2VsZWN0ZWRZZWFyKSAmJiAhbm9DaGFuZ2UpIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR9XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XG5cdFx0aWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKGNsZWFyID8gXCJcIiA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgZGF0ZShzKSBkaXJlY3RseS4gKi9cblx0X2dldERhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc3RhcnREYXRlID0gKCFpbnN0LmN1cnJlbnRZZWFyIHx8IChpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQudmFsKCkgPT09IFwiXCIpID8gbnVsbCA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShcblx0XHRcdGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSk7XG5cdFx0XHRyZXR1cm4gc3RhcnREYXRlO1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgb254eHggaGFuZGxlcnMuICBUaGVzZSBhcmUgZGVjbGFyZWQgc3RhdGljYWxseSBzb1xuXHQgKiB0aGV5IHdvcmsgd2l0aCBzdGF0aWMgY29kZSB0cmFuc2Zvcm1lcnMgbGlrZSBDYWphLlxuXHQgKi9cblx0X2F0dGFjaEhhbmRsZXJzOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpLFxuXHRcdFx0aWQgPSBcIiNcIiArIGluc3QuaWQucmVwbGFjZSggL1xcXFxcXFxcL2csIFwiXFxcXFwiICk7XG5cdFx0aW5zdC5kcERpdi5maW5kKFwiW2RhdGEtaGFuZGxlcl1cIikubWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBoYW5kbGVyID0ge1xuXHRcdFx0XHRwcmV2OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCAtc3RlcE1vbnRocywgXCJNXCIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCArc3RlcE1vbnRocywgXCJNXCIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b2RheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGlkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0RGF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXkoaWQsICt0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtbW9udGhcIiksICt0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEteWVhclwiKSwgdGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RNb250aDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0TW9udGhZZWFyKGlkLCB0aGlzLCBcIk1cIik7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RZZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoaWQsIHRoaXMsIFwiWVwiKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHQkKHRoaXMpLmJpbmQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWV2ZW50XCIpLCBoYW5kbGVyW3RoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1oYW5kbGVyXCIpXSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIEhUTUwgZm9yIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0X2dlbmVyYXRlSFRNTDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBtYXhEcmF3LCBwcmV2VGV4dCwgcHJldiwgbmV4dFRleHQsIG5leHQsIGN1cnJlbnRUZXh0LCBnb3RvRGF0ZSxcblx0XHRcdGNvbnRyb2xzLCBidXR0b25QYW5lbCwgZmlyc3REYXksIHNob3dXZWVrLCBkYXlOYW1lcywgZGF5TmFtZXNNaW4sXG5cdFx0XHRtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQsIGJlZm9yZVNob3dEYXksIHNob3dPdGhlck1vbnRocyxcblx0XHRcdHNlbGVjdE90aGVyTW9udGhzLCBkZWZhdWx0RGF0ZSwgaHRtbCwgZG93LCByb3csIGdyb3VwLCBjb2wsIHNlbGVjdGVkRGF0ZSxcblx0XHRcdGNvcm5lckNsYXNzLCBjYWxlbmRlciwgdGhlYWQsIGRheSwgZGF5c0luTW9udGgsIGxlYWREYXlzLCBjdXJSb3dzLCBudW1Sb3dzLFxuXHRcdFx0cHJpbnREYXRlLCBkUm93LCB0Ym9keSwgZGF5U2V0dGluZ3MsIG90aGVyTW9udGgsIHVuc2VsZWN0YWJsZSxcblx0XHRcdHRlbXBEYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdHRvZGF5ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoXG5cdFx0XHRcdG5ldyBEYXRlKHRlbXBEYXRlLmdldEZ1bGxZZWFyKCksIHRlbXBEYXRlLmdldE1vbnRoKCksIHRlbXBEYXRlLmdldERhdGUoKSkpLCAvLyBjbGVhciB0aW1lXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldChpbnN0LCBcImlzUlRMXCIpLFxuXHRcdFx0c2hvd0J1dHRvblBhbmVsID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0J1dHRvblBhbmVsXCIpLFxuXHRcdFx0aGlkZUlmTm9QcmV2TmV4dCA9IHRoaXMuX2dldChpbnN0LCBcImhpZGVJZk5vUHJldk5leHRcIiksXG5cdFx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwibmF2aWdhdGlvbkFzRGF0ZUZvcm1hdFwiKSxcblx0XHRcdG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0c2hvd0N1cnJlbnRBdFBvcyA9IHRoaXMuX2dldChpbnN0LCBcInNob3dDdXJyZW50QXRQb3NcIiksXG5cdFx0XHRzdGVwTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSxcblx0XHRcdGlzTXVsdGlNb250aCA9IChudW1Nb250aHNbMF0gIT09IDEgfHwgbnVtTW9udGhzWzFdICE9PSAxKSxcblx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoKCFpbnN0LmN1cnJlbnREYXkgPyBuZXcgRGF0ZSg5OTk5LCA5LCA5KSA6XG5cdFx0XHRcdG5ldyBEYXRlKGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSksXG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpLFxuXHRcdFx0ZHJhd01vbnRoID0gaW5zdC5kcmF3TW9udGggLSBzaG93Q3VycmVudEF0UG9zLFxuXHRcdFx0ZHJhd1llYXIgPSBpbnN0LmRyYXdZZWFyO1xuXG5cdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdGRyYXdNb250aCArPSAxMjtcblx0XHRcdGRyYXdZZWFyLS07XG5cdFx0fVxuXHRcdGlmIChtYXhEYXRlKSB7XG5cdFx0XHRtYXhEcmF3ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobWF4RGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRtYXhEYXRlLmdldE1vbnRoKCkgLSAobnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdKSArIDEsIG1heERhdGUuZ2V0RGF0ZSgpKSk7XG5cdFx0XHRtYXhEcmF3ID0gKG1pbkRhdGUgJiYgbWF4RHJhdyA8IG1pbkRhdGUgPyBtaW5EYXRlIDogbWF4RHJhdyk7XG5cdFx0XHR3aGlsZSAodGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSkpID4gbWF4RHJhdykge1xuXHRcdFx0XHRkcmF3TW9udGgtLTtcblx0XHRcdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAxMTtcblx0XHRcdFx0XHRkcmF3WWVhci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGluc3QuZHJhd01vbnRoID0gZHJhd01vbnRoO1xuXHRcdGluc3QuZHJhd1llYXIgPSBkcmF3WWVhcjtcblxuXHRcdHByZXZUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwicHJldlRleHRcIik7XG5cdFx0cHJldlRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBwcmV2VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShwcmV2VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggLSBzdGVwTW9udGhzLCAxKSksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdHByZXYgPSAodGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgLTEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID9cblx0XHRcdFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItcHJldiB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3ByZXYnIGRhdGEtZXZlbnQ9J2NsaWNrJ1wiICtcblx0XHRcdFwiIHRpdGxlPSdcIiArIHByZXZUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwiZVwiIDogXCJ3XCIpICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KGhpZGVJZk5vUHJldk5leHQgPyBcIlwiIDogXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcIisgcHJldlRleHQgK1wiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcImVcIiA6IFwid1wiKSArIFwiJz5cIiArIHByZXZUZXh0ICsgXCI8L3NwYW4+PC9hPlwiKSk7XG5cblx0XHRuZXh0VGV4dCA9IHRoaXMuX2dldChpbnN0LCBcIm5leHRUZXh0XCIpO1xuXHRcdG5leHRUZXh0ID0gKCFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gbmV4dFRleHQgOiB0aGlzLmZvcm1hdERhdGUobmV4dFRleHQsXG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoICsgc3RlcE1vbnRocywgMSkpLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKSk7XG5cblx0XHRuZXh0ID0gKHRoaXMuX2NhbkFkanVzdE1vbnRoKGluc3QsICsxLCBkcmF3WWVhciwgZHJhd01vbnRoKSA/XG5cdFx0XHRcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLW5leHQgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSduZXh0JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIiB0aXRsZT0nXCIgKyBuZXh0VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcIndcIiA6IFwiZVwiKSArIFwiJz5cIiArIG5leHRUZXh0ICsgXCI8L3NwYW4+PC9hPlwiIDpcblx0XHRcdChoaWRlSWZOb1ByZXZOZXh0ID8gXCJcIiA6IFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkJyB0aXRsZT0nXCIrIG5leHRUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwid1wiIDogXCJlXCIpICsgXCInPlwiICsgbmV4dFRleHQgKyBcIjwvc3Bhbj48L2E+XCIpKTtcblxuXHRcdGN1cnJlbnRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiY3VycmVudFRleHRcIik7XG5cdFx0Z290b0RhdGUgPSAodGhpcy5fZ2V0KGluc3QsIFwiZ290b0N1cnJlbnRcIikgJiYgaW5zdC5jdXJyZW50RGF5ID8gY3VycmVudERhdGUgOiB0b2RheSk7XG5cdFx0Y3VycmVudFRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBjdXJyZW50VGV4dCA6XG5cdFx0XHR0aGlzLmZvcm1hdERhdGUoY3VycmVudFRleHQsIGdvdG9EYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdGNvbnRyb2xzID0gKCFpbnN0LmlubGluZSA/IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNsb3NlIHVpLXN0YXRlLWRlZmF1bHQgdWktcHJpb3JpdHktcHJpbWFyeSB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J2hpZGUnIGRhdGEtZXZlbnQ9J2NsaWNrJz5cIiArXG5cdFx0XHR0aGlzLl9nZXQoaW5zdCwgXCJjbG9zZVRleHRcIikgKyBcIjwvYnV0dG9uPlwiIDogXCJcIik7XG5cblx0XHRidXR0b25QYW5lbCA9IChzaG93QnV0dG9uUGFuZWwpID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQnPlwiICsgKGlzUlRMID8gY29udHJvbHMgOiBcIlwiKSArXG5cdFx0XHQodGhpcy5faXNJblJhbmdlKGluc3QsIGdvdG9EYXRlKSA/IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWN1cnJlbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1zZWNvbmRhcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSd0b2RheScgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCI+XCIgKyBjdXJyZW50VGV4dCArIFwiPC9idXR0b24+XCIgOiBcIlwiKSArIChpc1JUTCA/IFwiXCIgOiBjb250cm9scykgKyBcIjwvZGl2PlwiIDogXCJcIjtcblxuXHRcdGZpcnN0RGF5ID0gcGFyc2VJbnQodGhpcy5fZ2V0KGluc3QsIFwiZmlyc3REYXlcIiksMTApO1xuXHRcdGZpcnN0RGF5ID0gKGlzTmFOKGZpcnN0RGF5KSA/IDAgOiBmaXJzdERheSk7XG5cblx0XHRzaG93V2VlayA9IHRoaXMuX2dldChpbnN0LCBcInNob3dXZWVrXCIpO1xuXHRcdGRheU5hbWVzID0gdGhpcy5fZ2V0KGluc3QsIFwiZGF5TmFtZXNcIik7XG5cdFx0ZGF5TmFtZXNNaW4gPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc01pblwiKTtcblx0XHRtb250aE5hbWVzID0gdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1wiKTtcblx0XHRtb250aE5hbWVzU2hvcnQgPSB0aGlzLl9nZXQoaW5zdCwgXCJtb250aE5hbWVzU2hvcnRcIik7XG5cdFx0YmVmb3JlU2hvd0RheSA9IHRoaXMuX2dldChpbnN0LCBcImJlZm9yZVNob3dEYXlcIik7XG5cdFx0c2hvd090aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd090aGVyTW9udGhzXCIpO1xuXHRcdHNlbGVjdE90aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic2VsZWN0T3RoZXJNb250aHNcIik7XG5cdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KTtcblx0XHRodG1sID0gXCJcIjtcblx0XHRkb3c7XG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCBudW1Nb250aHNbMF07IHJvdysrKSB7XG5cdFx0XHRncm91cCA9IFwiXCI7XG5cdFx0XHR0aGlzLm1heFJvd3MgPSA0O1xuXHRcdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCBudW1Nb250aHNbMV07IGNvbCsrKSB7XG5cdFx0XHRcdHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIGluc3Quc2VsZWN0ZWREYXkpKTtcblx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItYWxsXCI7XG5cdFx0XHRcdGNhbGVuZGVyID0gXCJcIjtcblx0XHRcdFx0aWYgKGlzTXVsdGlNb250aCkge1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1ncm91cFwiO1xuXHRcdFx0XHRcdGlmIChudW1Nb250aHNbMV0gPiAxKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGNvbCkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIDA6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtZmlyc3RcIjtcblx0XHRcdFx0XHRcdFx0XHRjb3JuZXJDbGFzcyA9IFwiIHVpLWNvcm5lci1cIiArIChpc1JUTCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgbnVtTW9udGhzWzFdLTE6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtbGFzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKGlzUlRMID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpOyBicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1taWRkbGVcIjsgY29ybmVyQ2xhc3MgPSBcIlwiOyBicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gXCInPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1oZWFkZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXhcIiArIGNvcm5lckNsYXNzICsgXCInPlwiICtcblx0XHRcdFx0XHQoL2FsbHxsZWZ0Ly50ZXN0KGNvcm5lckNsYXNzKSAmJiByb3cgPT09IDAgPyAoaXNSVEwgPyBuZXh0IDogcHJldikgOiBcIlwiKSArXG5cdFx0XHRcdFx0KC9hbGx8cmlnaHQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PT0gMCA/IChpc1JUTCA/IHByZXYgOiBuZXh0KSA6IFwiXCIpICtcblx0XHRcdFx0XHR0aGlzLl9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcihpbnN0LCBkcmF3TW9udGgsIGRyYXdZZWFyLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0XHRcdHJvdyA+IDAgfHwgY29sID4gMCwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSArIC8vIGRyYXcgbW9udGggaGVhZGVyc1xuXHRcdFx0XHRcdFwiPC9kaXY+PHRhYmxlIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNhbGVuZGFyJz48dGhlYWQ+XCIgK1xuXHRcdFx0XHRcdFwiPHRyPlwiO1xuXHRcdFx0XHR0aGVhZCA9IChzaG93V2VlayA/IFwiPHRoIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstY29sJz5cIiArIHRoaXMuX2dldChpbnN0LCBcIndlZWtIZWFkZXJcIikgKyBcIjwvdGg+XCIgOiBcIlwiKTtcblx0XHRcdFx0Zm9yIChkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykgeyAvLyBkYXlzIG9mIHRoZSB3ZWVrXG5cdFx0XHRcdFx0ZGF5ID0gKGRvdyArIGZpcnN0RGF5KSAlIDc7XG5cdFx0XHRcdFx0dGhlYWQgKz0gXCI8dGhcIiArICgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/IFwiIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstZW5kJ1wiIDogXCJcIikgKyBcIj5cIiArXG5cdFx0XHRcdFx0XHRcIjxzcGFuIHRpdGxlPSdcIiArIGRheU5hbWVzW2RheV0gKyBcIic+XCIgKyBkYXlOYW1lc01pbltkYXldICsgXCI8L3NwYW4+PC90aD5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSB0aGVhZCArIFwiPC90cj48L3RoZWFkPjx0Ym9keT5cIjtcblx0XHRcdFx0ZGF5c0luTW9udGggPSB0aGlzLl9nZXREYXlzSW5Nb250aChkcmF3WWVhciwgZHJhd01vbnRoKTtcblx0XHRcdFx0aWYgKGRyYXdZZWFyID09PSBpbnN0LnNlbGVjdGVkWWVhciAmJiBkcmF3TW9udGggPT09IGluc3Quc2VsZWN0ZWRNb250aCkge1xuXHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBNYXRoLm1pbihpbnN0LnNlbGVjdGVkRGF5LCBkYXlzSW5Nb250aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVhZERheXMgPSAodGhpcy5fZ2V0Rmlyc3REYXlPZk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpIC0gZmlyc3REYXkgKyA3KSAlIDc7XG5cdFx0XHRcdGN1clJvd3MgPSBNYXRoLmNlaWwoKGxlYWREYXlzICsgZGF5c0luTW9udGgpIC8gNyk7IC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gZ2VuZXJhdGVcblx0XHRcdFx0bnVtUm93cyA9IChpc011bHRpTW9udGggPyB0aGlzLm1heFJvd3MgPiBjdXJSb3dzID8gdGhpcy5tYXhSb3dzIDogY3VyUm93cyA6IGN1clJvd3MpOyAvL0lmIG11bHRpcGxlIG1vbnRocywgdXNlIHRoZSBoaWdoZXIgbnVtYmVyIG9mIHJvd3MgKHNlZSAjNzA0Mylcblx0XHRcdFx0dGhpcy5tYXhSb3dzID0gbnVtUm93cztcblx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSAtIGxlYWREYXlzKSk7XG5cdFx0XHRcdGZvciAoZFJvdyA9IDA7IGRSb3cgPCBudW1Sb3dzOyBkUm93KyspIHsgLy8gY3JlYXRlIGRhdGUgcGlja2VyIHJvd3Ncblx0XHRcdFx0XHRjYWxlbmRlciArPSBcIjx0cj5cIjtcblx0XHRcdFx0XHR0Ym9keSA9ICghc2hvd1dlZWsgPyBcIlwiIDogXCI8dGQgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICtcblx0XHRcdFx0XHRcdHRoaXMuX2dldChpbnN0LCBcImNhbGN1bGF0ZVdlZWtcIikocHJpbnREYXRlKSArIFwiPC90ZD5cIik7XG5cdFx0XHRcdFx0Zm9yIChkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgZGF5c1xuXHRcdFx0XHRcdFx0ZGF5U2V0dGluZ3MgPSAoYmVmb3JlU2hvd0RheSA/XG5cdFx0XHRcdFx0XHRcdGJlZm9yZVNob3dEYXkuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtwcmludERhdGVdKSA6IFt0cnVlLCBcIlwiXSk7XG5cdFx0XHRcdFx0XHRvdGhlck1vbnRoID0gKHByaW50RGF0ZS5nZXRNb250aCgpICE9PSBkcmF3TW9udGgpO1xuXHRcdFx0XHRcdFx0dW5zZWxlY3RhYmxlID0gKG90aGVyTW9udGggJiYgIXNlbGVjdE90aGVyTW9udGhzKSB8fCAhZGF5U2V0dGluZ3NbMF0gfHxcblx0XHRcdFx0XHRcdFx0KG1pbkRhdGUgJiYgcHJpbnREYXRlIDwgbWluRGF0ZSkgfHwgKG1heERhdGUgJiYgcHJpbnREYXRlID4gbWF4RGF0ZSk7XG5cdFx0XHRcdFx0XHR0Ym9keSArPSBcIjx0ZCBjbGFzcz0nXCIgK1xuXHRcdFx0XHRcdFx0XHQoKGRvdyArIGZpcnN0RGF5ICsgNikgJSA3ID49IDUgPyBcIiB1aS1kYXRlcGlja2VyLXdlZWstZW5kXCIgOiBcIlwiKSArIC8vIGhpZ2hsaWdodCB3ZWVrZW5kc1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCA/IFwiIHVpLWRhdGVwaWNrZXItb3RoZXItbW9udGhcIiA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IGRheXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KChwcmludERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoICYmIGluc3QuX2tleUV2ZW50KSB8fCAvLyB1c2VyIHByZXNzZWQga2V5XG5cdFx0XHRcdFx0XHRcdChkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHByaW50RGF0ZS5nZXRUaW1lKCkgJiYgZGVmYXVsdERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpKSA/XG5cdFx0XHRcdFx0XHRcdC8vIG9yIGRlZmF1bHREYXRlIGlzIGN1cnJlbnQgcHJpbnRlZERhdGUgYW5kIGRlZmF1bHREYXRlIGlzIHNlbGVjdGVkRGF0ZVxuXHRcdFx0XHRcdFx0XHRcIiBcIiArIHRoaXMuX2RheU92ZXJDbGFzcyA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQodW5zZWxlY3RhYmxlID8gXCIgXCIgKyB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyArIFwiIHVpLXN0YXRlLWRpc2FibGVkXCI6IFwiXCIpICsgIC8vIGhpZ2hsaWdodCB1bnNlbGVjdGFibGUgZGF5c1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gXCJcIiA6IFwiIFwiICsgZGF5U2V0dGluZ3NbMV0gKyAvLyBoaWdobGlnaHQgY3VzdG9tIGRhdGVzXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyBcIiBcIiArIHRoaXMuX2N1cnJlbnRDbGFzcyA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQocHJpbnREYXRlLmdldFRpbWUoKSA9PT0gdG9kYXkuZ2V0VGltZSgpID8gXCIgdWktZGF0ZXBpY2tlci10b2RheVwiIDogXCJcIikpICsgXCInXCIgKyAvLyBoaWdobGlnaHQgdG9kYXkgKGlmIGRpZmZlcmVudClcblx0XHRcdFx0XHRcdFx0KCghb3RoZXJNb250aCB8fCBzaG93T3RoZXJNb250aHMpICYmIGRheVNldHRpbmdzWzJdID8gXCIgdGl0bGU9J1wiICsgZGF5U2V0dGluZ3NbMl0ucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpICsgXCInXCIgOiBcIlwiKSArIC8vIGNlbGwgdGl0bGVcblx0XHRcdFx0XHRcdFx0KHVuc2VsZWN0YWJsZSA/IFwiXCIgOiBcIiBkYXRhLWhhbmRsZXI9J3NlbGVjdERheScgZGF0YS1ldmVudD0nY2xpY2snIGRhdGEtbW9udGg9J1wiICsgcHJpbnREYXRlLmdldE1vbnRoKCkgKyBcIicgZGF0YS15ZWFyPSdcIiArIHByaW50RGF0ZS5nZXRGdWxsWWVhcigpICsgXCInXCIpICsgXCI+XCIgKyAvLyBhY3Rpb25zXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcIiYjeGEwO1wiIDogLy8gZGlzcGxheSBmb3Igb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyBcIjxzcGFuIGNsYXNzPSd1aS1zdGF0ZS1kZWZhdWx0Jz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvc3Bhbj5cIiA6IFwiPGEgY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHRcIiArXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1zdGF0ZS1oaWdobGlnaHRcIiA6IFwiXCIpICtcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIHVpLXN0YXRlLWFjdGl2ZVwiIDogXCJcIikgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoID8gXCIgdWktcHJpb3JpdHktc2Vjb25kYXJ5XCIgOiBcIlwiKSArIC8vIGRpc3Rpbmd1aXNoIGRhdGVzIGZyb20gb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdFwiJyBocmVmPScjJz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvYT5cIikpICsgXCI8L3RkPlwiOyAvLyBkaXNwbGF5IHNlbGVjdGFibGUgZGF0ZVxuXHRcdFx0XHRcdFx0cHJpbnREYXRlLnNldERhdGUocHJpbnREYXRlLmdldERhdGUoKSArIDEpO1xuXHRcdFx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QocHJpbnREYXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gdGJvZHkgKyBcIjwvdHI+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHJhd01vbnRoKys7XG5cdFx0XHRcdGlmIChkcmF3TW9udGggPiAxMSkge1xuXHRcdFx0XHRcdGRyYXdNb250aCA9IDA7XG5cdFx0XHRcdFx0ZHJhd1llYXIrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSBcIjwvdGJvZHk+PC90YWJsZT5cIiArIChpc011bHRpTW9udGggPyBcIjwvZGl2PlwiICtcblx0XHRcdFx0XHRcdFx0KChudW1Nb250aHNbMF0gPiAwICYmIGNvbCA9PT0gbnVtTW9udGhzWzFdLTEpID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLXJvdy1icmVhayc+PC9kaXY+XCIgOiBcIlwiKSA6IFwiXCIpO1xuXHRcdFx0XHRncm91cCArPSBjYWxlbmRlcjtcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gZ3JvdXA7XG5cdFx0fVxuXHRcdGh0bWwgKz0gYnV0dG9uUGFuZWw7XG5cdFx0aW5zdC5fa2V5RXZlbnQgPSBmYWxzZTtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgbW9udGggYW5kIHllYXIgaGVhZGVyLiAqL1xuXHRfZ2VuZXJhdGVNb250aFllYXJIZWFkZXI6IGZ1bmN0aW9uKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRzZWNvbmRhcnksIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCkge1xuXG5cdFx0dmFyIGluTWluWWVhciwgaW5NYXhZZWFyLCBtb250aCwgeWVhcnMsIHRoaXNZZWFyLCBkZXRlcm1pbmVZZWFyLCB5ZWFyLCBlbmRZZWFyLFxuXHRcdFx0Y2hhbmdlTW9udGggPSB0aGlzLl9nZXQoaW5zdCwgXCJjaGFuZ2VNb250aFwiKSxcblx0XHRcdGNoYW5nZVllYXIgPSB0aGlzLl9nZXQoaW5zdCwgXCJjaGFuZ2VZZWFyXCIpLFxuXHRcdFx0c2hvd01vbnRoQWZ0ZXJZZWFyID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd01vbnRoQWZ0ZXJZZWFyXCIpLFxuXHRcdFx0aHRtbCA9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci10aXRsZSc+XCIsXG5cdFx0XHRtb250aEh0bWwgPSBcIlwiO1xuXG5cdFx0Ly8gbW9udGggc2VsZWN0aW9uXG5cdFx0aWYgKHNlY29uZGFyeSB8fCAhY2hhbmdlTW9udGgpIHtcblx0XHRcdG1vbnRoSHRtbCArPSBcIjxzcGFuIGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJz5cIiArIG1vbnRoTmFtZXNbZHJhd01vbnRoXSArIFwiPC9zcGFuPlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbk1pblllYXIgPSAobWluRGF0ZSAmJiBtaW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyKTtcblx0XHRcdGluTWF4WWVhciA9IChtYXhEYXRlICYmIG1heERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXIpO1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNlbGVjdCBjbGFzcz0ndWktZGF0ZXBpY2tlci1tb250aCcgZGF0YS1oYW5kbGVyPSdzZWxlY3RNb250aCcgZGF0YS1ldmVudD0nY2hhbmdlJz5cIjtcblx0XHRcdGZvciAoIG1vbnRoID0gMDsgbW9udGggPCAxMjsgbW9udGgrKykge1xuXHRcdFx0XHRpZiAoKCFpbk1pblllYXIgfHwgbW9udGggPj0gbWluRGF0ZS5nZXRNb250aCgpKSAmJiAoIWluTWF4WWVhciB8fCBtb250aCA8PSBtYXhEYXRlLmdldE1vbnRoKCkpKSB7XG5cdFx0XHRcdFx0bW9udGhIdG1sICs9IFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyBtb250aCArIFwiJ1wiICtcblx0XHRcdFx0XHRcdChtb250aCA9PT0gZHJhd01vbnRoID8gXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIikgK1xuXHRcdFx0XHRcdFx0XCI+XCIgKyBtb250aE5hbWVzU2hvcnRbbW9udGhdICsgXCI8L29wdGlvbj5cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bW9udGhIdG1sICs9IFwiPC9zZWxlY3Q+XCI7XG5cdFx0fVxuXG5cdFx0aWYgKCFzaG93TW9udGhBZnRlclllYXIpIHtcblx0XHRcdGh0bWwgKz0gbW9udGhIdG1sICsgKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gXCImI3hhMDtcIiA6IFwiXCIpO1xuXHRcdH1cblxuXHRcdC8vIHllYXIgc2VsZWN0aW9uXG5cdFx0aWYgKCAhaW5zdC55ZWFyc2h0bWwgKSB7XG5cdFx0XHRpbnN0LnllYXJzaHRtbCA9IFwiXCI7XG5cdFx0XHRpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VZZWFyKSB7XG5cdFx0XHRcdGh0bWwgKz0gXCI8c3BhbiBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJz5cIiArIGRyYXdZZWFyICsgXCI8L3NwYW4+XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgcmFuZ2Ugb2YgeWVhcnMgdG8gZGlzcGxheVxuXHRcdFx0XHR5ZWFycyA9IHRoaXMuX2dldChpbnN0LCBcInllYXJSYW5nZVwiKS5zcGxpdChcIjpcIik7XG5cdFx0XHRcdHRoaXNZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRkZXRlcm1pbmVZZWFyID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgeWVhciA9ICh2YWx1ZS5tYXRjaCgvY1srXFwtXS4qLykgPyBkcmF3WWVhciArIHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxKSwgMTApIDpcblx0XHRcdFx0XHRcdCh2YWx1ZS5tYXRjaCgvWytcXC1dLiovKSA/IHRoaXNZZWFyICsgcGFyc2VJbnQodmFsdWUsIDEwKSA6XG5cdFx0XHRcdFx0XHRwYXJzZUludCh2YWx1ZSwgMTApKSk7XG5cdFx0XHRcdFx0cmV0dXJuIChpc05hTih5ZWFyKSA/IHRoaXNZZWFyIDogeWVhcik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHllYXIgPSBkZXRlcm1pbmVZZWFyKHllYXJzWzBdKTtcblx0XHRcdFx0ZW5kWWVhciA9IE1hdGgubWF4KHllYXIsIGRldGVybWluZVllYXIoeWVhcnNbMV0gfHwgXCJcIikpO1xuXHRcdFx0XHR5ZWFyID0gKG1pbkRhdGUgPyBNYXRoLm1heCh5ZWFyLCBtaW5EYXRlLmdldEZ1bGxZZWFyKCkpIDogeWVhcik7XG5cdFx0XHRcdGVuZFllYXIgPSAobWF4RGF0ZSA/IE1hdGgubWluKGVuZFllYXIsIG1heERhdGUuZ2V0RnVsbFllYXIoKSkgOiBlbmRZZWFyKTtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLXllYXInIGRhdGEtaGFuZGxlcj0nc2VsZWN0WWVhcicgZGF0YS1ldmVudD0nY2hhbmdlJz5cIjtcblx0XHRcdFx0Zm9yICg7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrKSB7XG5cdFx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIHllYXIgKyBcIidcIiArXG5cdFx0XHRcdFx0XHQoeWVhciA9PT0gZHJhd1llYXIgPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIHllYXIgKyBcIjwvb3B0aW9uPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QueWVhcnNodG1sICs9IFwiPC9zZWxlY3Q+XCI7XG5cblx0XHRcdFx0aHRtbCArPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGh0bWwgKz0gdGhpcy5fZ2V0KGluc3QsIFwieWVhclN1ZmZpeFwiKTtcblx0XHRpZiAoc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XG5cdFx0XHRodG1sICs9IChzZWNvbmRhcnkgfHwgIShjaGFuZ2VNb250aCAmJiBjaGFuZ2VZZWFyKSA/IFwiJiN4YTA7XCIgOiBcIlwiKSArIG1vbnRoSHRtbDtcblx0XHR9XG5cdFx0aHRtbCArPSBcIjwvZGl2PlwiOyAvLyBDbG9zZSBkYXRlcGlja2VyX2hlYWRlclxuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdEluc3REYXRlOiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIHBlcmlvZCkge1xuXHRcdHZhciB5ZWFyID0gaW5zdC5kcmF3WWVhciArIChwZXJpb2QgPT09IFwiWVwiID8gb2Zmc2V0IDogMCksXG5cdFx0XHRtb250aCA9IGluc3QuZHJhd01vbnRoICsgKHBlcmlvZCA9PT0gXCJNXCIgPyBvZmZzZXQgOiAwKSxcblx0XHRcdGRheSA9IE1hdGgubWluKGluc3Quc2VsZWN0ZWREYXksIHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgKyAocGVyaW9kID09PSBcIkRcIiA/IG9mZnNldCA6IDApLFxuXHRcdFx0ZGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmIChwZXJpb2QgPT09IFwiTVwiIHx8IHBlcmlvZCA9PT0gXCJZXCIpIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogRW5zdXJlIGEgZGF0ZSBpcyB3aXRoaW4gYW55IG1pbi9tYXggYm91bmRzLiAqL1xuXHRfcmVzdHJpY3RNaW5NYXg6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtaW5cIiksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1heFwiKSxcblx0XHRcdG5ld0RhdGUgPSAobWluRGF0ZSAmJiBkYXRlIDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBkYXRlKTtcblx0XHRyZXR1cm4gKG1heERhdGUgJiYgbmV3RGF0ZSA+IG1heERhdGUgPyBtYXhEYXRlIDogbmV3RGF0ZSk7XG5cdH0sXG5cblx0LyogTm90aWZ5IGNoYW5nZSBvZiBtb250aC95ZWFyLiAqL1xuXHRfbm90aWZ5Q2hhbmdlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIG9uQ2hhbmdlID0gdGhpcy5fZ2V0KGluc3QsIFwib25DaGFuZ2VNb250aFllYXJcIik7XG5cdFx0aWYgKG9uQ2hhbmdlKSB7XG5cdFx0XHRvbkNoYW5nZS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSxcblx0XHRcdFx0W2luc3Quc2VsZWN0ZWRZZWFyLCBpbnN0LnNlbGVjdGVkTW9udGggKyAxLCBpbnN0XSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIG1vbnRocyB0byBzaG93LiAqL1xuXHRfZ2V0TnVtYmVyT2ZNb250aHM6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwibnVtYmVyT2ZNb250aHNcIik7XG5cdFx0cmV0dXJuIChudW1Nb250aHMgPT0gbnVsbCA/IFsxLCAxXSA6ICh0eXBlb2YgbnVtTW9udGhzID09PSBcIm51bWJlclwiID8gWzEsIG51bU1vbnRoc10gOiBudW1Nb250aHMpKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmUgdGhlIGN1cnJlbnQgbWF4aW11bSBkYXRlIC0gZW5zdXJlIG5vIHRpbWUgY29tcG9uZW50cyBhcmUgc2V0LiAqL1xuXHRfZ2V0TWluTWF4RGF0ZTogZnVuY3Rpb24oaW5zdCwgbWluTWF4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsIG1pbk1heCArIFwiRGF0ZVwiKSwgbnVsbCk7XG5cdH0sXG5cblx0LyogRmluZCB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBnaXZlbiBtb250aC4gKi9cblx0X2dldERheXNJbk1vbnRoOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuXHRcdHJldHVybiAzMiAtIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCAzMikpLmdldERhdGUoKTtcblx0fSxcblxuXHQvKiBGaW5kIHRoZSBkYXkgb2YgdGhlIHdlZWsgb2YgdGhlIGZpcnN0IG9mIGEgbW9udGguICovXG5cdF9nZXRGaXJzdERheU9mTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmVzIGlmIHdlIHNob3VsZCBhbGxvdyBhIFwibmV4dC9wcmV2XCIgbW9udGggZGlzcGxheSBjaGFuZ2UuICovXG5cdF9jYW5BZGp1c3RNb250aDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBjdXJZZWFyLCBjdXJNb250aCkge1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KSxcblx0XHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShjdXJZZWFyLFxuXHRcdFx0Y3VyTW9udGggKyAob2Zmc2V0IDwgMCA/IG9mZnNldCA6IG51bU1vbnRoc1swXSAqIG51bU1vbnRoc1sxXSksIDEpKTtcblxuXHRcdGlmIChvZmZzZXQgPCAwKSB7XG5cdFx0XHRkYXRlLnNldERhdGUodGhpcy5fZ2V0RGF5c0luTW9udGgoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2lzSW5SYW5nZShpbnN0LCBkYXRlKTtcblx0fSxcblxuXHQvKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgYWNjZXB0ZWQgcmFuZ2U/ICovXG5cdF9pc0luUmFuZ2U6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgeWVhclNwbGl0LCBjdXJyZW50WWVhcixcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWluXCIpLFxuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtYXhcIiksXG5cdFx0XHRtaW5ZZWFyID0gbnVsbCxcblx0XHRcdG1heFllYXIgPSBudWxsLFxuXHRcdFx0eWVhcnMgPSB0aGlzLl9nZXQoaW5zdCwgXCJ5ZWFyUmFuZ2VcIik7XG5cdFx0XHRpZiAoeWVhcnMpe1xuXHRcdFx0XHR5ZWFyU3BsaXQgPSB5ZWFycy5zcGxpdChcIjpcIik7XG5cdFx0XHRcdGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRtaW5ZZWFyID0gcGFyc2VJbnQoeWVhclNwbGl0WzBdLCAxMCk7XG5cdFx0XHRcdG1heFllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMV0sIDEwKTtcblx0XHRcdFx0aWYgKCB5ZWFyU3BsaXRbMF0ubWF0Y2goL1srXFwtXS4qLykgKSB7XG5cdFx0XHRcdFx0bWluWWVhciArPSBjdXJyZW50WWVhcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHllYXJTcGxpdFsxXS5tYXRjaCgvWytcXC1dLiovKSApIHtcblx0XHRcdFx0XHRtYXhZZWFyICs9IGN1cnJlbnRZZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRyZXR1cm4gKCghbWluRGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA+PSBtaW5EYXRlLmdldFRpbWUoKSkgJiZcblx0XHRcdCghbWF4RGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA8PSBtYXhEYXRlLmdldFRpbWUoKSkgJiZcblx0XHRcdCghbWluWWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPj0gbWluWWVhcikgJiZcblx0XHRcdCghbWF4WWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPD0gbWF4WWVhcikpO1xuXHR9LFxuXG5cdC8qIFByb3ZpZGUgdGhlIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGZvcm1hdHRpbmcvcGFyc2luZy4gKi9cblx0X2dldEZvcm1hdENvbmZpZzogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBzaG9ydFllYXJDdXRvZmYgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG9ydFllYXJDdXRvZmZcIik7XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmYgOlxuXHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmLCAxMCkpO1xuXHRcdHJldHVybiB7c2hvcnRZZWFyQ3V0b2ZmOiBzaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRkYXlOYW1lc1Nob3J0OiB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc1Nob3J0XCIpLCBkYXlOYW1lczogdGhpcy5fZ2V0KGluc3QsIFwiZGF5TmFtZXNcIiksXG5cdFx0XHRtb250aE5hbWVzU2hvcnQ6IHRoaXMuX2dldChpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiKSwgbW9udGhOYW1lczogdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1wiKX07XG5cdH0sXG5cblx0LyogRm9ybWF0IHRoZSBnaXZlbiBkYXRlIGZvciBkaXNwbGF5LiAqL1xuXHRfZm9ybWF0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF5LCBtb250aCwgeWVhcikge1xuXHRcdGlmICghZGF5KSB7XG5cdFx0XHRpbnN0LmN1cnJlbnREYXkgPSBpbnN0LnNlbGVjdGVkRGF5O1xuXHRcdFx0aW5zdC5jdXJyZW50TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGg7XG5cdFx0XHRpbnN0LmN1cnJlbnRZZWFyID0gaW5zdC5zZWxlY3RlZFllYXI7XG5cdFx0fVxuXHRcdHZhciBkYXRlID0gKGRheSA/ICh0eXBlb2YgZGF5ID09PSBcIm9iamVjdFwiID8gZGF5IDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSkgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKTtcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXREYXRlKHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksIGRhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdH1cbn0pO1xuXG4vKlxuICogQmluZCBob3ZlciBldmVudHMgZm9yIGRhdGVwaWNrZXIgZWxlbWVudHMuXG4gKiBEb25lIHZpYSBkZWxlZ2F0ZSBzbyB0aGUgYmluZGluZyBvbmx5IG9jY3VycyBvbmNlIGluIHRoZSBsaWZldGltZSBvZiB0aGUgcGFyZW50IGRpdi5cbiAqIEdsb2JhbCBpbnN0QWN0aXZlLCBzZXQgYnkgX3VwZGF0ZURhdGVwaWNrZXIgYWxsb3dzIHRoZSBoYW5kbGVycyB0byBmaW5kIHRoZWlyIHdheSBiYWNrIHRvIHRoZSBhY3RpdmUgcGlja2VyLlxuICovXG5mdW5jdGlvbiBiaW5kSG92ZXIoZHBEaXYpIHtcblx0dmFyIHNlbGVjdG9yID0gXCJidXR0b24sIC51aS1kYXRlcGlja2VyLXByZXYsIC51aS1kYXRlcGlja2VyLW5leHQsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkIGFcIjtcblx0cmV0dXJuIGRwRGl2LmRlbGVnYXRlKHNlbGVjdG9yLCBcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpO1xuXHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXCJ1aS1kYXRlcGlja2VyLXByZXZcIikgIT09IC0xKSB7XG5cdFx0XHRcdCQodGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItbmV4dFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLWRhdGVwaWNrZXItbmV4dC1ob3ZlclwiKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5kZWxlZ2F0ZShzZWxlY3RvciwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXtcblx0XHRcdGlmICghJC5kYXRlcGlja2VyLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggaW5zdEFjdGl2ZS5pbmxpbmUgPyBkcERpdi5wYXJlbnQoKVswXSA6IGluc3RBY3RpdmUuaW5wdXRbMF0pKSB7XG5cdFx0XHRcdCQodGhpcykucGFyZW50cyhcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIpLmZpbmQoXCJhXCIpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtaG92ZXJcIik7XG5cdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcblx0XHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXCJ1aS1kYXRlcGlja2VyLXByZXZcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItbmV4dFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG59XG5cbi8qIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhICovXG5mdW5jdGlvbiBleHRlbmRSZW1vdmUodGFyZ2V0LCBwcm9wcykge1xuXHQkLmV4dGVuZCh0YXJnZXQsIHByb3BzKTtcblx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuXHRcdGlmIChwcm9wc1tuYW1lXSA9PSBudWxsKSB7XG5cdFx0XHR0YXJnZXRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSW52b2tlIHRoZSBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHkuXG4gICBAcGFyYW0gIG9wdGlvbnMgIHN0cmluZyAtIGEgY29tbWFuZCwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgb3Jcblx0XHRcdFx0XHRPYmplY3QgLSBzZXR0aW5ncyBmb3IgYXR0YWNoaW5nIG5ldyBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHlcbiAgIEByZXR1cm4gIGpRdWVyeSBvYmplY3QgKi9cbiQuZm4uZGF0ZXBpY2tlciA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXG5cdC8qIFZlcmlmeSBhbiBlbXB0eSBjb2xsZWN0aW9uIHdhc24ndCBwYXNzZWQgLSBGaXhlcyAjNjk3NiAqL1xuXHRpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRpZiAoISQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCkge1xuXHRcdCQoZG9jdW1lbnQpLm1vdXNlZG93bigkLmRhdGVwaWNrZXIuX2NoZWNrRXh0ZXJuYWxDbGljayk7XG5cdFx0JC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qIEFwcGVuZCBkYXRlcGlja2VyIG1haW4gY29udGFpbmVyIHRvIGJvZHkgaWYgbm90IGV4aXN0LiAqL1xuXHRpZiAoJChcIiNcIiskLmRhdGVwaWNrZXIuX21haW5EaXZJZCkubGVuZ3RoID09PSAwKSB7XG5cdFx0JChcImJvZHlcIikuYXBwZW5kKCQuZGF0ZXBpY2tlci5kcERpdik7XG5cdH1cblxuXHR2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICYmIChvcHRpb25zID09PSBcImlzRGlzYWJsZWRcIiB8fCBvcHRpb25zID09PSBcImdldERhdGVcIiB8fCBvcHRpb25zID09PSBcIndpZGdldFwiKSkge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHR9XG5cdGlmIChvcHRpb25zID09PSBcIm9wdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHR9XG5cdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0dHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0JC5kYXRlcGlja2VyW1wiX1wiICsgb3B0aW9ucyArIFwiRGF0ZXBpY2tlclwiXS5cblx0XHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc10uY29uY2F0KG90aGVyQXJncykpIDpcblx0XHRcdCQuZGF0ZXBpY2tlci5fYXR0YWNoRGF0ZXBpY2tlcih0aGlzLCBvcHRpb25zKTtcblx0fSk7XG59O1xuXG4kLmRhdGVwaWNrZXIgPSBuZXcgRGF0ZXBpY2tlcigpOyAvLyBzaW5nbGV0b24gaW5zdGFuY2VcbiQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCA9IGZhbHNlO1xuJC5kYXRlcGlja2VyLnV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiQuZGF0ZXBpY2tlci52ZXJzaW9uID0gXCIxLjEwLjRcIjtcblxufSkoalF1ZXJ5KTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi9tb3VzZScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgRHJhZ2dhYmxlIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kcmFnZ2FibGUvXG4gKlxuICogRGVwZW5kczpcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xuICpcdGpxdWVyeS51aS5tb3VzZS5qc1xuICpcdGpxdWVyeS51aS53aWRnZXQuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KFwidWkuZHJhZ2dhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjEwLjRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiZHJhZ1wiLFxuXHRvcHRpb25zOiB7XG5cdFx0YWRkQ2xhc3NlczogdHJ1ZSxcblx0XHRhcHBlbmRUbzogXCJwYXJlbnRcIixcblx0XHRheGlzOiBmYWxzZSxcblx0XHRjb25uZWN0VG9Tb3J0YWJsZTogZmFsc2UsXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGN1cnNvcjogXCJhdXRvXCIsXG5cdFx0Y3Vyc29yQXQ6IGZhbHNlLFxuXHRcdGdyaWQ6IGZhbHNlLFxuXHRcdGhhbmRsZTogZmFsc2UsXG5cdFx0aGVscGVyOiBcIm9yaWdpbmFsXCIsXG5cdFx0aWZyYW1lRml4OiBmYWxzZSxcblx0XHRvcGFjaXR5OiBmYWxzZSxcblx0XHRyZWZyZXNoUG9zaXRpb25zOiBmYWxzZSxcblx0XHRyZXZlcnQ6IGZhbHNlLFxuXHRcdHJldmVydER1cmF0aW9uOiA1MDAsXG5cdFx0c2NvcGU6IFwiZGVmYXVsdFwiLFxuXHRcdHNjcm9sbDogdHJ1ZSxcblx0XHRzY3JvbGxTZW5zaXRpdml0eTogMjAsXG5cdFx0c2Nyb2xsU3BlZWQ6IDIwLFxuXHRcdHNuYXA6IGZhbHNlLFxuXHRcdHNuYXBNb2RlOiBcImJvdGhcIixcblx0XHRzbmFwVG9sZXJhbmNlOiAyMCxcblx0XHRzdGFjazogZmFsc2UsXG5cdFx0ekluZGV4OiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGRyYWc6IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIgJiYgISgvXig/OnJ8YXxmKS8pLnRlc3QodGhpcy5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpKSkge1xuXHRcdFx0dGhpcy5lbGVtZW50WzBdLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmFkZENsYXNzZXMpe1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktZHJhZ2dhYmxlXCIpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKXtcblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWRyYWdnYWJsZS1kaXNhYmxlZFwiKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblxuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktZHJhZ2dhYmxlIHVpLWRyYWdnYWJsZS1kcmFnZ2luZyB1aS1kcmFnZ2FibGUtZGlzYWJsZWRcIiApO1xuXHRcdHRoaXMuX21vdXNlRGVzdHJveSgpO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIGFtb25nIG90aGVycywgcHJldmVudCBhIGRyYWcgb24gYSByZXNpemFibGUtaGFuZGxlXG5cdFx0aWYgKHRoaXMuaGVscGVyIHx8IG8uZGlzYWJsZWQgfHwgJChldmVudC50YXJnZXQpLmNsb3Nlc3QoXCIudWktcmVzaXphYmxlLWhhbmRsZVwiKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9RdWl0IGlmIHdlJ3JlIG5vdCBvbiBhIHZhbGlkIGhhbmRsZVxuXHRcdHRoaXMuaGFuZGxlID0gdGhpcy5fZ2V0SGFuZGxlKGV2ZW50KTtcblx0XHRpZiAoIXRoaXMuaGFuZGxlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0JChvLmlmcmFtZUZpeCA9PT0gdHJ1ZSA/IFwiaWZyYW1lXCIgOiBvLmlmcmFtZUZpeCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdCQoXCI8ZGl2IGNsYXNzPSd1aS1kcmFnZ2FibGUtaWZyYW1lRml4JyBzdHlsZT0nYmFja2dyb3VuZDogI2ZmZjsnPjwvZGl2PlwiKVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdHdpZHRoOiB0aGlzLm9mZnNldFdpZHRoK1wicHhcIiwgaGVpZ2h0OiB0aGlzLm9mZnNldEhlaWdodCtcInB4XCIsXG5cdFx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsIG9wYWNpdHk6IFwiMC4wMDFcIiwgekluZGV4OiAxMDAwXG5cdFx0XHR9KVxuXHRcdFx0LmNzcygkKHRoaXMpLm9mZnNldCgpKVxuXHRcdFx0LmFwcGVuZFRvKFwiYm9keVwiKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vQ3JlYXRlIGFuZCBhcHBlbmQgdGhlIHZpc2libGUgaGVscGVyXG5cdFx0dGhpcy5oZWxwZXIgPSB0aGlzLl9jcmVhdGVIZWxwZXIoZXZlbnQpO1xuXG5cdFx0dGhpcy5oZWxwZXIuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIik7XG5cblx0XHQvL0NhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vSWYgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIHNldCB0aGUgZ2xvYmFsIGRyYWdnYWJsZVxuXHRcdGlmKCQudWkuZGRtYW5hZ2VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gdGhpcztcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gZ2VuZXJhdGlvbiAtXG5cdFx0ICogVGhpcyBibG9jayBnZW5lcmF0ZXMgZXZlcnl0aGluZyBwb3NpdGlvbiByZWxhdGVkIC0gaXQncyB0aGUgY29yZSBvZiBkcmFnZ2FibGVzLlxuXHRcdCAqL1xuXG5cdFx0Ly9DYWNoZSB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHRcdHRoaXMuX2NhY2hlTWFyZ2lucygpO1xuXG5cdFx0Ly9TdG9yZSB0aGUgaGVscGVyJ3MgY3NzIHBvc2l0aW9uXG5cdFx0dGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuaGVscGVyLmNzcyggXCJwb3NpdGlvblwiICk7XG5cdFx0dGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQoKTtcblx0XHR0aGlzLm9mZnNldFBhcmVudCA9IHRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO1xuXHRcdHRoaXMub2Zmc2V0UGFyZW50Q3NzUG9zaXRpb24gPSB0aGlzLm9mZnNldFBhcmVudC5jc3MoIFwicG9zaXRpb25cIiApO1xuXG5cdFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0dGhpcy5vZmZzZXQgPSB7XG5cdFx0XHR0b3A6IHRoaXMub2Zmc2V0LnRvcCAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRsZWZ0OiB0aGlzLm9mZnNldC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnRcblx0XHR9O1xuXG5cdFx0Ly9SZXNldCBzY3JvbGwgY2FjaGVcblx0XHR0aGlzLm9mZnNldC5zY3JvbGwgPSBmYWxzZTtcblxuXHRcdCQuZXh0ZW5kKHRoaXMub2Zmc2V0LCB7XG5cdFx0XHRjbGljazogeyAvL1doZXJlIHRoZSBjbGljayBoYXBwZW5lZCwgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXG5cdFx0XHR9LFxuXHRcdFx0cGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcblx0XHRcdHJlbGF0aXZlOiB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpIC8vVGhpcyBpcyBhIHJlbGF0aXZlIHRvIGFic29sdXRlIHBvc2l0aW9uIG1pbnVzIHRoZSBhY3R1YWwgcG9zaXRpb24gY2FsY3VsYXRpb24gLSBvbmx5IHVzZWQgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgaGVscGVyXG5cdFx0fSk7XG5cblx0XHQvL0dlbmVyYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50KTtcblx0XHR0aGlzLm9yaWdpbmFsUGFnZVggPSBldmVudC5wYWdlWDtcblx0XHR0aGlzLm9yaWdpbmFsUGFnZVkgPSBldmVudC5wYWdlWTtcblxuXHRcdC8vQWRqdXN0IHRoZSBtb3VzZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGhlbHBlciBpZiBcImN1cnNvckF0XCIgaXMgc3VwcGxpZWRcblx0XHQoby5jdXJzb3JBdCAmJiB0aGlzLl9hZGp1c3RPZmZzZXRGcm9tSGVscGVyKG8uY3Vyc29yQXQpKTtcblxuXHRcdC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcblx0XHR0aGlzLl9zZXRDb250YWlubWVudCgpO1xuXG5cdFx0Ly9UcmlnZ2VyIGV2ZW50ICsgY2FsbGJhY2tzXG5cdFx0aWYodGhpcy5fdHJpZ2dlcihcInN0YXJ0XCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vUHJlcGFyZSB0aGUgZHJvcHBhYmxlIG9mZnNldHNcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5fbW91c2VEcmFnKGV2ZW50LCB0cnVlKTsgLy9FeGVjdXRlIHRoZSBkcmFnIG9uY2UgLSB0aGlzIGNhdXNlcyB0aGUgaGVscGVyIG5vdCB0byBiZSB2aXNpYmxlIGJlZm9yZSBnZXR0aW5nIGl0cyBjb3JyZWN0IHBvc2l0aW9uXG5cblx0XHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0YXJ0ZWQgKHNlZSAjNTAwMylcblx0XHRpZiAoICQudWkuZGRtYW5hZ2VyICkge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuZHJhZ1N0YXJ0KHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbihldmVudCwgbm9Qcm9wYWdhdGlvbikge1xuXHRcdC8vIHJlc2V0IGFueSBuZWNlc3NhcnkgY2FjaGVkIHByb3BlcnRpZXMgKHNlZSAjNTAwOSlcblx0XHRpZiAoIHRoaXMub2Zmc2V0UGFyZW50Q3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudCA9IHRoaXMuX2dldFBhcmVudE9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vQ29tcHV0ZSB0aGUgaGVscGVycyBwb3NpdGlvblxuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50KTtcblx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtcblxuXHRcdC8vQ2FsbCBwbHVnaW5zIGFuZCBjYWxsYmFja3MgYW5kIHVzZSB0aGUgcmVzdWx0aW5nIHBvc2l0aW9uIGlmIHNvbWV0aGluZyBpcyByZXR1cm5lZFxuXHRcdGlmICghbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0dmFyIHVpID0gdGhpcy5fdWlIYXNoKCk7XG5cdFx0XHRpZih0aGlzLl90cmlnZ2VyKFwiZHJhZ1wiLCBldmVudCwgdWkpID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9tb3VzZVVwKHt9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IHVpLnBvc2l0aW9uO1xuXHRcdH1cblxuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPT0gXCJ5XCIpIHtcblx0XHRcdHRoaXMuaGVscGVyWzBdLnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQrXCJweFwiO1xuXHRcdH1cblx0XHRpZighdGhpcy5vcHRpb25zLmF4aXMgfHwgdGhpcy5vcHRpb25zLmF4aXMgIT09IFwieFwiKSB7XG5cdFx0XHR0aGlzLmhlbHBlclswXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCtcInB4XCI7XG5cdFx0fVxuXHRcdGlmKCQudWkuZGRtYW5hZ2VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vSWYgd2UgYXJlIHVzaW5nIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciBhYm91dCB0aGUgZHJvcFxuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGRyb3BwZWQgPSBmYWxzZTtcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKSB7XG5cdFx0XHRkcm9wcGVkID0gJC51aS5kZG1hbmFnZXIuZHJvcCh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cdFx0Ly9pZiBhIGRyb3AgY29tZXMgZnJvbSBvdXRzaWRlIChhIHNvcnRhYmxlKVxuXHRcdGlmKHRoaXMuZHJvcHBlZCkge1xuXHRcdFx0ZHJvcHBlZCA9IHRoaXMuZHJvcHBlZDtcblx0XHRcdHRoaXMuZHJvcHBlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vaWYgdGhlIG9yaWdpbmFsIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGluIHRoZSBET00gZG9uJ3QgYm90aGVyIHRvIGNvbnRpbnVlIChzZWUgIzgyNjkpXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIgJiYgISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFsgMCBdLm93bmVyRG9jdW1lbnQsIHRoaXMuZWxlbWVudFsgMCBdICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYoKHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IFwiaW52YWxpZFwiICYmICFkcm9wcGVkKSB8fCAodGhpcy5vcHRpb25zLnJldmVydCA9PT0gXCJ2YWxpZFwiICYmIGRyb3BwZWQpIHx8IHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IHRydWUgfHwgKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMucmV2ZXJ0KSAmJiB0aGlzLm9wdGlvbnMucmV2ZXJ0LmNhbGwodGhpcy5lbGVtZW50LCBkcm9wcGVkKSkpIHtcblx0XHRcdCQodGhpcy5oZWxwZXIpLmFuaW1hdGUodGhpcy5vcmlnaW5hbFBvc2l0aW9uLCBwYXJzZUludCh0aGlzLm9wdGlvbnMucmV2ZXJ0RHVyYXRpb24sIDEwKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHRoYXQuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGF0Ll9jbGVhcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYodGhpcy5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQpICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvL1JlbW92ZSBmcmFtZSBoZWxwZXJzXG5cdFx0JChcImRpdi51aS1kcmFnZ2FibGUtaWZyYW1lRml4XCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG5cdFx0fSk7XG5cblx0XHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0b3BwZWQgKHNlZSAjNTAwMylcblx0XHRpZiggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnU3RvcCh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICQudWkubW91c2UucHJvdG90eXBlLl9tb3VzZVVwLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9LFxuXG5cdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmhlbHBlci5pcyhcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIikpIHtcblx0XHRcdHRoaXMuX21vdXNlVXAoe30pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0X2dldEhhbmRsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmhhbmRsZSA/XG5cdFx0XHQhISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMuaGFuZGxlICkgKS5sZW5ndGggOlxuXHRcdFx0dHJ1ZTtcblx0fSxcblxuXHRfY3JlYXRlSGVscGVyOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRoZWxwZXIgPSAkLmlzRnVuY3Rpb24oby5oZWxwZXIpID8gJChvLmhlbHBlci5hcHBseSh0aGlzLmVsZW1lbnRbMF0sIFtldmVudF0pKSA6IChvLmhlbHBlciA9PT0gXCJjbG9uZVwiID8gdGhpcy5lbGVtZW50LmNsb25lKCkucmVtb3ZlQXR0cihcImlkXCIpIDogdGhpcy5lbGVtZW50KTtcblxuXHRcdGlmKCFoZWxwZXIucGFyZW50cyhcImJvZHlcIikubGVuZ3RoKSB7XG5cdFx0XHRoZWxwZXIuYXBwZW5kVG8oKG8uYXBwZW5kVG8gPT09IFwicGFyZW50XCIgPyB0aGlzLmVsZW1lbnRbMF0ucGFyZW50Tm9kZSA6IG8uYXBwZW5kVG8pKTtcblx0XHR9XG5cblx0XHRpZihoZWxwZXJbMF0gIT09IHRoaXMuZWxlbWVudFswXSAmJiAhKC8oZml4ZWR8YWJzb2x1dGUpLykudGVzdChoZWxwZXIuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHRoZWxwZXIuY3NzKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGVscGVyO1xuXG5cdH0sXG5cblx0X2FkanVzdE9mZnNldEZyb21IZWxwZXI6IGZ1bmN0aW9uKG9iaikge1xuXHRcdGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRvYmogPSBvYmouc3BsaXQoXCIgXCIpO1xuXHRcdH1cblx0XHRpZiAoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdG9iaiA9IHtsZWZ0OiArb2JqWzBdLCB0b3A6ICtvYmpbMV0gfHwgMH07XG5cdFx0fVxuXHRcdGlmIChcImxlZnRcIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSBvYmoubGVmdCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoXCJyaWdodFwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSBvYmoucmlnaHQgKyB0aGlzLm1hcmdpbnMubGVmdDtcblx0XHR9XG5cdFx0aWYgKFwidG9wXCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSBvYmoudG9wICsgdGhpcy5tYXJnaW5zLnRvcDtcblx0XHR9XG5cdFx0aWYgKFwiYm90dG9tXCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIG9iai5ib3R0b20gKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxuXHRcdHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIG1vZGlmeSBhIG9mZnNldCBjYWxjdWxhdGVkIG9uIHN0YXJ0LCBzaW5jZSB0aGUgZm9sbG93aW5nIGhhcHBlbmVkOlxuXHRcdC8vIDEuIFRoZSBwb3NpdGlvbiBvZiB0aGUgaGVscGVyIGlzIGFic29sdXRlLCBzbyBpdCdzIHBvc2l0aW9uIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIG5leHQgcG9zaXRpb25lZCBwYXJlbnRcblx0XHQvLyAyLiBUaGUgYWN0dWFsIG9mZnNldCBwYXJlbnQgaXMgYSBjaGlsZCBvZiB0aGUgc2Nyb2xsIHBhcmVudCwgYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzbid0IHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdC8vICAgIHRoZSBzY3JvbGwgaXMgaW5jbHVkZWQgaW4gdGhlIGluaXRpYWwgY2FsY3VsYXRpb24gb2YgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50LCBhbmQgbmV2ZXIgcmVjYWxjdWxhdGVkIHVwb24gZHJhZ1xuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiB0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XG5cdFx0XHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcblx0XHRcdHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHQvL1RoaXMgbmVlZHMgdG8gYmUgYWN0dWFsbHkgZG9uZSBmb3IgYWxsIGJyb3dzZXJzLCBzaW5jZSBwYWdlWC9wYWdlWSBpbmNsdWRlcyB0aGlzIGluZm9ybWF0aW9uXG5cdFx0Ly9VZ2x5IElFIGZpeFxuXHRcdGlmKCh0aGlzLm9mZnNldFBhcmVudFswXSA9PT0gZG9jdW1lbnQuYm9keSkgfHxcblx0XHRcdCh0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lICYmIHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJodG1sXCIgJiYgJC51aS5pZSkpIHtcblx0XHRcdHBvID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBwby50b3AgKyAocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApLFxuXHRcdFx0bGVmdDogcG8ubGVmdCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApIHx8IDApXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09PSBcInJlbGF0aXZlXCIpIHtcblx0XHRcdHZhciBwID0gdGhpcy5lbGVtZW50LnBvc2l0aW9uKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHAudG9wIC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcInRvcFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSxcblx0XHRcdFx0bGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcImxlZnRcIiksMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0fSxcblxuXHRfY2FjaGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm1hcmdpbnMgPSB7XG5cdFx0XHRsZWZ0OiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpbkxlZnRcIiksMTApIHx8IDApLFxuXHRcdFx0dG9wOiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpblRvcFwiKSwxMCkgfHwgMCksXG5cdFx0XHRyaWdodDogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5SaWdodFwiKSwxMCkgfHwgMCksXG5cdFx0XHRib3R0b206IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luQm90dG9tXCIpLDEwKSB8fCAwKVxuXHRcdH07XG5cdH0sXG5cblx0X2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fSxcblxuXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG92ZXIsIGMsIGNlLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICggIW8uY29udGFpbm1lbnQgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwid2luZG93XCIgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxMZWZ0KCkgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsXG5cdFx0XHRcdCQoIHdpbmRvdyApLnNjcm9sbFRvcCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsTGVmdCgpICsgJCggd2luZG93ICkud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsVG9wKCkgKyAoICQoIHdpbmRvdyApLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQgKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcFxuXHRcdFx0XTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwiZG9jdW1lbnRcIikge1xuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdFx0MCxcblx0XHRcdFx0MCxcblx0XHRcdFx0JCggZG9jdW1lbnQgKS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHQoICQoIGRvY3VtZW50ICkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gby5jb250YWlubWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwicGFyZW50XCIgKSB7XG5cdFx0XHRvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbIDAgXS5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGMgPSAkKCBvLmNvbnRhaW5tZW50ICk7XG5cdFx0Y2UgPSBjWyAwIF07XG5cblx0XHRpZiggIWNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG92ZXIgPSBjLmNzcyggXCJvdmVyZmxvd1wiICkgIT09IFwiaGlkZGVuXCI7XG5cblx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyTGVmdFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgKyAoIHBhcnNlSW50KCBjLmNzcyggXCJwYWRkaW5nTGVmdFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyVG9wV2lkdGhcIiApLCAxMCApIHx8IDAgKSArICggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdUb3BcIiApLCAxMCApIHx8IDAgKSAsXG5cdFx0XHQoIG92ZXIgPyBNYXRoLm1heCggY2Uuc2Nyb2xsV2lkdGgsIGNlLm9mZnNldFdpZHRoICkgOiBjZS5vZmZzZXRXaWR0aCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyUmlnaHRXaWR0aFwiICksIDEwICkgfHwgMCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ1JpZ2h0XCIgKSwgMTAgKSB8fCAwICkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQgLSB0aGlzLm1hcmdpbnMucmlnaHQsXG5cdFx0XHQoIG92ZXIgPyBNYXRoLm1heCggY2Uuc2Nyb2xsSGVpZ2h0LCBjZS5vZmZzZXRIZWlnaHQgKSA6IGNlLm9mZnNldEhlaWdodCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyQm90dG9tV2lkdGhcIiApLCAxMCApIHx8IDAgKSAtICggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdCb3R0b21cIiApLCAxMCApIHx8IDAgKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcCAgLSB0aGlzLm1hcmdpbnMuYm90dG9tXG5cdFx0XTtcblx0XHR0aGlzLnJlbGF0aXZlX2NvbnRhaW5lciA9IGM7XG5cdH0sXG5cblx0X2NvbnZlcnRQb3NpdGlvblRvOiBmdW5jdGlvbihkLCBwb3MpIHtcblxuXHRcdGlmKCFwb3MpIHtcblx0XHRcdHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0dmFyIG1vZCA9IGQgPT09IFwiYWJzb2x1dGVcIiA/IDEgOiAtMSxcblx0XHRcdHNjcm9sbCA9IHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiAhKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdLCB0aGlzLm9mZnNldFBhcmVudFsgMCBdICkgKSA/IHRoaXMub2Zmc2V0UGFyZW50IDogdGhpcy5zY3JvbGxQYXJlbnQ7XG5cblx0XHQvL0NhY2hlIHRoZSBzY3JvbGxcblx0XHRpZiAoIXRoaXMub2Zmc2V0LnNjcm9sbCkge1xuXHRcdFx0dGhpcy5vZmZzZXQuc2Nyb2xsID0ge3RvcCA6IHNjcm9sbC5zY3JvbGxUb3AoKSwgbGVmdCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCl9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cG9zLnRvcFx0K1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAqIG1vZCArXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCAqIG1vZCAtXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCApICogbW9kIClcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBvcy5sZWZ0ICtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0ICogbW9kICtcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCAqIG1vZFx0LVx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiB0aGlzLm9mZnNldC5zY3JvbGwubGVmdCApICogbW9kIClcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dlbmVyYXRlUG9zaXRpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgY29udGFpbm1lbnQsIGNvLCB0b3AsIGxlZnQsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0c2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmICEoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gIT09IGRvY3VtZW50ICYmICQuY29udGFpbnMoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0sIHRoaXMub2Zmc2V0UGFyZW50WyAwIF0gKSApID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudCxcblx0XHRcdHBhZ2VYID0gZXZlbnQucGFnZVgsXG5cdFx0XHRwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9DYWNoZSB0aGUgc2Nyb2xsXG5cdFx0aWYgKCF0aGlzLm9mZnNldC5zY3JvbGwpIHtcblx0XHRcdHRoaXMub2Zmc2V0LnNjcm9sbCA9IHt0b3AgOiBzY3JvbGwuc2Nyb2xsVG9wKCksIGxlZnQgOiBzY3JvbGwuc2Nyb2xsTGVmdCgpfTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gY29uc3RyYWluaW5nIC1cblx0XHQgKiBDb25zdHJhaW4gdGhlIHBvc2l0aW9uIHRvIGEgbWl4IG9mIGdyaWQsIGNvbnRhaW5tZW50LlxuXHRcdCAqL1xuXG5cdFx0Ly8gSWYgd2UgYXJlIG5vdCBkcmFnZ2luZyB5ZXQsIHdlIHdvbid0IGNoZWNrIGZvciBvcHRpb25zXG5cdFx0aWYgKCB0aGlzLm9yaWdpbmFsUG9zaXRpb24gKSB7XG5cdFx0XHRpZiAoIHRoaXMuY29udGFpbm1lbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZWxhdGl2ZV9jb250YWluZXIgKXtcblx0XHRcdFx0XHRjbyA9IHRoaXMucmVsYXRpdmVfY29udGFpbmVyLm9mZnNldCgpO1xuXHRcdFx0XHRcdGNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMCBdICsgY28ubGVmdCxcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDEgXSArIGNvLnRvcCxcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDIgXSArIGNvLmxlZnQsXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAzIF0gKyBjby50b3Bcblx0XHRcdFx0XHRdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5tZW50ID0gdGhpcy5jb250YWlubWVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8IGNvbnRhaW5tZW50WzBdKSB7XG5cdFx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudFswXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCBjb250YWlubWVudFsxXSkge1xuXHRcdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gY29udGFpbm1lbnRbMl0pIHtcblx0XHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50WzJdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WzNdKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudFszXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihvLmdyaWQpIHtcblx0XHRcdFx0Ly9DaGVjayBmb3IgZ3JpZCBlbGVtZW50cyBzZXQgdG8gMCB0byBwcmV2ZW50IGRpdmlkZSBieSAwIGVycm9yIGNhdXNpbmcgaW52YWxpZCBhcmd1bWVudCBlcnJvcnMgaW4gSUUgKHNlZSB0aWNrZXQgIzY5NTApXG5cdFx0XHRcdHRvcCA9IG8uZ3JpZFsxXSA/IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoKHBhZ2VZIC0gdGhpcy5vcmlnaW5hbFBhZ2VZKSAvIG8uZ3JpZFsxXSkgKiBvLmdyaWRbMV0gOiB0aGlzLm9yaWdpbmFsUGFnZVk7XG5cdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnQgPyAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsxXSB8fCB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiBjb250YWlubWVudFszXSkgPyB0b3AgOiAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsxXSkgPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0pKSA6IHRvcDtcblxuXHRcdFx0XHRsZWZ0ID0gby5ncmlkWzBdID8gdGhpcy5vcmlnaW5hbFBhZ2VYICsgTWF0aC5yb3VuZCgocGFnZVggLSB0aGlzLm9yaWdpbmFsUGFnZVgpIC8gby5ncmlkWzBdKSAqIG8uZ3JpZFswXSA6IHRoaXMub3JpZ2luYWxQYWdlWDtcblx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudCA/ICgobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gY29udGFpbm1lbnRbMF0gfHwgbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSkgPyBsZWZ0IDogKChsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSBjb250YWlubWVudFswXSkgPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSkpIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cGFnZVkgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wXHQtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiB0aGlzLm9mZnNldC5zY3JvbGwudG9wIClcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBhZ2VYIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyLnJlbW92ZUNsYXNzKFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIpO1xuXHRcdGlmKHRoaXMuaGVscGVyWzBdICE9PSB0aGlzLmVsZW1lbnRbMF0gJiYgIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCkge1xuXHRcdFx0dGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHRoaXMuaGVscGVyID0gbnVsbDtcblx0XHR0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBGcm9tIG5vdyBvbiBidWxrIHN0dWZmIC0gbWFpbmx5IGhlbHBlcnNcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24odHlwZSwgZXZlbnQsIHVpKSB7XG5cdFx0dWkgPSB1aSB8fCB0aGlzLl91aUhhc2goKTtcblx0XHQkLnVpLnBsdWdpbi5jYWxsKHRoaXMsIHR5cGUsIFtldmVudCwgdWldKTtcblx0XHQvL1RoZSBhYnNvbHV0ZSBwb3NpdGlvbiBoYXMgdG8gYmUgcmVjYWxjdWxhdGVkIGFmdGVyIHBsdWdpbnNcblx0XHRpZih0eXBlID09PSBcImRyYWdcIikge1xuXHRcdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7XG5cdFx0fVxuXHRcdHJldHVybiAkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuY2FsbCh0aGlzLCB0eXBlLCBldmVudCwgdWkpO1xuXHR9LFxuXG5cdHBsdWdpbnM6IHt9LFxuXG5cdF91aUhhc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWxwZXI6IHRoaXMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24sXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB0aGlzLm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IHRoaXMucG9zaXRpb25BYnNcblx0XHR9O1xuXHR9XG5cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJjb25uZWN0VG9Tb3J0YWJsZVwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLCBvID0gaW5zdC5vcHRpb25zLFxuXHRcdFx0dWlTb3J0YWJsZSA9ICQuZXh0ZW5kKHt9LCB1aSwgeyBpdGVtOiBpbnN0LmVsZW1lbnQgfSk7XG5cdFx0aW5zdC5zb3J0YWJsZXMgPSBbXTtcblx0XHQkKG8uY29ubmVjdFRvU29ydGFibGUpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc29ydGFibGUgPSAkLmRhdGEodGhpcywgXCJ1aS1zb3J0YWJsZVwiKTtcblx0XHRcdGlmIChzb3J0YWJsZSAmJiAhc29ydGFibGUub3B0aW9ucy5kaXNhYmxlZCkge1xuXHRcdFx0XHRpbnN0LnNvcnRhYmxlcy5wdXNoKHtcblx0XHRcdFx0XHRpbnN0YW5jZTogc29ydGFibGUsXG5cdFx0XHRcdFx0c2hvdWxkUmV2ZXJ0OiBzb3J0YWJsZS5vcHRpb25zLnJldmVydFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29ydGFibGUucmVmcmVzaFBvc2l0aW9ucygpO1x0Ly8gQ2FsbCB0aGUgc29ydGFibGUncyByZWZyZXNoUG9zaXRpb25zIGF0IGRyYWcgc3RhcnQgdG8gcmVmcmVzaCB0aGUgY29udGFpbmVyQ2FjaGUgc2luY2UgdGhlIHNvcnRhYmxlIGNvbnRhaW5lciBjYWNoZSBpcyB1c2VkIGluIGRyYWcgYW5kIG5lZWRzIHRvIGJlIHVwIHRvIGRhdGUgKHRoaXMgd2lsbCBlbnN1cmUgaXQncyBpbml0aWFsaXNlZCBhcyB3ZWxsIGFzIGJlaW5nIGtlcHQgaW4gc3RlcCB3aXRoIGFueSBjaGFuZ2VzIHRoYXQgbWlnaHQgaGF2ZSBoYXBwZW5lZCBvbiB0aGUgcGFnZSkuXG5cdFx0XHRcdHNvcnRhYmxlLl90cmlnZ2VyKFwiYWN0aXZhdGVcIiwgZXZlbnQsIHVpU29ydGFibGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgc3RpbGwgb3ZlciB0aGUgc29ydGFibGUsIHdlIGZha2UgdGhlIHN0b3AgZXZlbnQgb2YgdGhlIHNvcnRhYmxlLCBidXQgYWxzbyByZW1vdmUgaGVscGVyXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksXG5cdFx0XHR1aVNvcnRhYmxlID0gJC5leHRlbmQoe30sIHVpLCB7IGl0ZW06IGluc3QuZWxlbWVudCB9KTtcblxuXHRcdCQuZWFjaChpbnN0LnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLmluc3RhbmNlLmlzT3Zlcikge1xuXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuaXNPdmVyID0gMDtcblxuXHRcdFx0XHRpbnN0LmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlOyAvL0Rvbid0IHJlbW92ZSB0aGUgaGVscGVyIGluIHRoZSBkcmFnZ2FibGUgaW5zdGFuY2Vcblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7IC8vUmVtb3ZlIGl0IGluIHRoZSBzb3J0YWJsZSBpbnN0YW5jZSAoc28gc29ydGFibGUgcGx1Z2lucyBsaWtlIHJldmVydCBzdGlsbCB3b3JrKVxuXG5cdFx0XHRcdC8vVGhlIHNvcnRhYmxlIHJldmVydCBpcyBzdXBwb3J0ZWQsIGFuZCB3ZSBoYXZlIHRvIHNldCBhIHRlbXBvcmFyeSBkcm9wcGVkIHZhcmlhYmxlIG9uIHRoZSBkcmFnZ2FibGUgdG8gc3VwcG9ydCByZXZlcnQ6IFwidmFsaWQvaW52YWxpZFwiXG5cdFx0XHRcdGlmKHRoaXMuc2hvdWxkUmV2ZXJ0KSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLnJldmVydCA9IHRoaXMuc2hvdWxkUmV2ZXJ0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9UcmlnZ2VyIHRoZSBzdG9wIG9mIHRoZSBzb3J0YWJsZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZVN0b3AoZXZlbnQpO1xuXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXIgPSB0aGlzLmluc3RhbmNlLm9wdGlvbnMuX2hlbHBlcjtcblxuXHRcdFx0XHQvL0lmIHRoZSBoZWxwZXIgaGFzIGJlZW4gdGhlIG9yaWdpbmFsIGl0ZW0sIHJlc3RvcmUgcHJvcGVydGllcyBpbiB0aGUgc29ydGFibGVcblx0XHRcdFx0aWYoaW5zdC5vcHRpb25zLmhlbHBlciA9PT0gXCJvcmlnaW5hbFwiKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbS5jc3MoeyB0b3A6IFwiYXV0b1wiLCBsZWZ0OiBcImF1dG9cIiB9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTsgLy9SZW1vdmUgdGhlIGhlbHBlciBpbiB0aGUgc29ydGFibGUgaW5zdGFuY2Vcblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fdHJpZ2dlcihcImRlYWN0aXZhdGVcIiwgZXZlbnQsIHVpU29ydGFibGUpO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cblx0XHR2YXIgaW5zdCA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKSwgdGhhdCA9IHRoaXM7XG5cblx0XHQkLmVhY2goaW5zdC5zb3J0YWJsZXMsIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgaW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2UsXG5cdFx0XHRcdHRoaXNTb3J0YWJsZSA9IHRoaXM7XG5cblx0XHRcdC8vQ29weSBvdmVyIHNvbWUgdmFyaWFibGVzIHRvIGFsbG93IGNhbGxpbmcgdGhlIHNvcnRhYmxlJ3MgbmF0aXZlIF9pbnRlcnNlY3RzV2l0aFxuXHRcdFx0dGhpcy5pbnN0YW5jZS5wb3NpdGlvbkFicyA9IGluc3QucG9zaXRpb25BYnM7XG5cdFx0XHR0aGlzLmluc3RhbmNlLmhlbHBlclByb3BvcnRpb25zID0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucztcblx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrID0gaW5zdC5vZmZzZXQuY2xpY2s7XG5cblx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuX2ludGVyc2VjdHNXaXRoKHRoaXMuaW5zdGFuY2UuY29udGFpbmVyQ2FjaGUpKSB7XG5cdFx0XHRcdGlubmVybW9zdEludGVyc2VjdGluZyA9IHRydWU7XG5cdFx0XHRcdCQuZWFjaChpbnN0LnNvcnRhYmxlcywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UucG9zaXRpb25BYnMgPSBpbnN0LnBvc2l0aW9uQWJzO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuaGVscGVyUHJvcG9ydGlvbnMgPSBpbnN0LmhlbHBlclByb3BvcnRpb25zO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrID0gaW5zdC5vZmZzZXQuY2xpY2s7XG5cdFx0XHRcdFx0aWYgKHRoaXMgIT09IHRoaXNTb3J0YWJsZSAmJlxuXHRcdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5faW50ZXJzZWN0c1dpdGgodGhpcy5pbnN0YW5jZS5jb250YWluZXJDYWNoZSkgJiZcblx0XHRcdFx0XHRcdCQuY29udGFpbnModGhpc1NvcnRhYmxlLmluc3RhbmNlLmVsZW1lbnRbMF0sIHRoaXMuaW5zdGFuY2UuZWxlbWVudFswXSlcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGlubmVybW9zdEludGVyc2VjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW5uZXJtb3N0SW50ZXJzZWN0aW5nO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXG5cdFx0XHRpZihpbm5lcm1vc3RJbnRlcnNlY3RpbmcpIHtcblx0XHRcdFx0Ly9JZiBpdCBpbnRlcnNlY3RzLCB3ZSB1c2UgYSBsaXR0bGUgaXNPdmVyIHZhcmlhYmxlIGFuZCBzZXQgaXQgb25jZSwgc28gb3VyIG1vdmUtaW4gc3R1ZmYgZ2V0cyBmaXJlZCBvbmx5IG9uY2Vcblx0XHRcdFx0aWYoIXRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmlzT3ZlciA9IDE7XG5cdFx0XHRcdFx0Ly9Ob3cgd2UgZmFrZSB0aGUgc3RhcnQgb2YgZHJhZ2dpbmcgZm9yIHRoZSBzb3J0YWJsZSBpbnN0YW5jZSxcblx0XHRcdFx0XHQvL2J5IGNsb25pbmcgdGhlIGxpc3QgZ3JvdXAgaXRlbSwgYXBwZW5kaW5nIGl0IHRvIHRoZSBzb3J0YWJsZSBhbmQgdXNpbmcgaXQgYXMgaW5zdC5jdXJyZW50SXRlbVxuXHRcdFx0XHRcdC8vV2UgY2FuIHRoZW4gZmlyZSB0aGUgc3RhcnQgZXZlbnQgb2YgdGhlIHNvcnRhYmxlIHdpdGggb3VyIHBhc3NlZCBicm93c2VyIGV2ZW50LCBhbmQgb3VyIG93biBoZWxwZXIgKHNvIGl0IGRvZXNuJ3QgY3JlYXRlIGEgbmV3IG9uZSlcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtID0gJCh0aGF0KS5jbG9uZSgpLnJlbW92ZUF0dHIoXCJpZFwiKS5hcHBlbmRUbyh0aGlzLmluc3RhbmNlLmVsZW1lbnQpLmRhdGEoXCJ1aS1zb3J0YWJsZS1pdGVtXCIsIHRydWUpO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyID0gdGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlcjsgLy9TdG9yZSBoZWxwZXIgb3B0aW9uIHRvIGxhdGVyIHJlc3RvcmUgaXRcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyID0gZnVuY3Rpb24oKSB7IHJldHVybiB1aS5oZWxwZXJbMF07IH07XG5cblx0XHRcdFx0XHRldmVudC50YXJnZXQgPSB0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtWzBdO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlQ2FwdHVyZShldmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VTdGFydChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG5cblx0XHRcdFx0XHQvL0JlY2F1c2UgdGhlIGJyb3dzZXIgZXZlbnQgaXMgd2F5IG9mZiB0aGUgbmV3IGFwcGVuZGVkIHBvcnRsZXQsIHdlIG1vZGlmeSBhIGNvdXBsZSBvZiB2YXJpYWJsZXMgdG8gcmVmbGVjdCB0aGUgY2hhbmdlc1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrLnRvcCA9IGluc3Qub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5jbGljay5sZWZ0ID0gaW5zdC5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5wYXJlbnQubGVmdCAtPSBpbnN0Lm9mZnNldC5wYXJlbnQubGVmdCAtIHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC5sZWZ0O1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC50b3AgLT0gaW5zdC5vZmZzZXQucGFyZW50LnRvcCAtIHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC50b3A7XG5cblx0XHRcdFx0XHRpbnN0Ll90cmlnZ2VyKFwidG9Tb3J0YWJsZVwiLCBldmVudCk7XG5cdFx0XHRcdFx0aW5zdC5kcm9wcGVkID0gdGhpcy5pbnN0YW5jZS5lbGVtZW50OyAvL2RyYWdnYWJsZSByZXZlcnQgbmVlZHMgdGhhdFxuXHRcdFx0XHRcdC8vaGFjayBzbyByZWNlaXZlL3VwZGF0ZSBjYWxsYmFja3Mgd29yayAobW9zdGx5KVxuXHRcdFx0XHRcdGluc3QuY3VycmVudEl0ZW0gPSBpbnN0LmVsZW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5mcm9tT3V0c2lkZSA9IGluc3Q7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vUHJvdmlkZWQgd2UgZGlkIGFsbCB0aGUgcHJldmlvdXMgc3RlcHMsIHdlIGNhbiBmaXJlIHRoZSBkcmFnIGV2ZW50IG9mIHRoZSBzb3J0YWJsZSBvbiBldmVyeSBkcmFnZ2FibGUgZHJhZywgd2hlbiBpdCBpbnRlcnNlY3RzIHdpdGggdGhlIHNvcnRhYmxlXG5cdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0pIHtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZURyYWcoZXZlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly9JZiBpdCBkb2Vzbid0IGludGVyc2VjdCB3aXRoIHRoZSBzb3J0YWJsZSwgYW5kIGl0IGludGVyc2VjdGVkIGJlZm9yZSxcblx0XHRcdFx0Ly93ZSBmYWtlIHRoZSBkcmFnIHN0b3Agb2YgdGhlIHNvcnRhYmxlLCBidXQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgcmVtb3ZlIHRoZSBoZWxwZXIgYnkgdXNpbmcgY2FuY2VsSGVscGVyUmVtb3ZhbFxuXHRcdFx0XHRpZih0aGlzLmluc3RhbmNlLmlzT3Zlcikge1xuXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5pc092ZXIgPSAwO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7XG5cblx0XHRcdFx0XHQvL1ByZXZlbnQgcmV2ZXJ0aW5nIG9uIHRoaXMgZm9yY2VkIHN0b3Bcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMucmV2ZXJ0ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBUaGUgb3V0IGV2ZW50IG5lZWRzIHRvIGJlIHRyaWdnZXJlZCBpbmRlcGVuZGVudGx5XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fdHJpZ2dlcihcIm91dFwiLCBldmVudCwgdGhpcy5pbnN0YW5jZS5fdWlIYXNoKHRoaXMuaW5zdGFuY2UpKTtcblxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlU3RvcChldmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlciA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyO1xuXG5cdFx0XHRcdFx0Ly9Ob3cgd2UgcmVtb3ZlIG91ciBjdXJyZW50SXRlbSwgdGhlIGxpc3QgZ3JvdXAgY2xvbmUgYWdhaW4sIGFuZCB0aGUgcGxhY2Vob2xkZXIsIGFuZCBhbmltYXRlIHRoZSBoZWxwZXIgYmFjayB0byBpdCdzIG9yaWdpbmFsIHNpemVcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UucGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UucGxhY2Vob2xkZXIucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5zdC5fdHJpZ2dlcihcImZyb21Tb3J0YWJsZVwiLCBldmVudCk7XG5cdFx0XHRcdFx0aW5zdC5kcm9wcGVkID0gZmFsc2U7IC8vZHJhZ2dhYmxlIHJldmVydCBuZWVkcyB0aGF0XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcImN1cnNvclwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdCA9ICQoXCJib2R5XCIpLCBvID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLm9wdGlvbnM7XG5cdFx0aWYgKHQuY3NzKFwiY3Vyc29yXCIpKSB7XG5cdFx0XHRvLl9jdXJzb3IgPSB0LmNzcyhcImN1cnNvclwiKTtcblx0XHR9XG5cdFx0dC5jc3MoXCJjdXJzb3JcIiwgby5jdXJzb3IpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmIChvLl9jdXJzb3IpIHtcblx0XHRcdCQoXCJib2R5XCIpLmNzcyhcImN1cnNvclwiLCBvLl9jdXJzb3IpO1xuXHRcdH1cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcIm9wYWNpdHlcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHQgPSAkKHVpLmhlbHBlciksIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZih0LmNzcyhcIm9wYWNpdHlcIikpIHtcblx0XHRcdG8uX29wYWNpdHkgPSB0LmNzcyhcIm9wYWNpdHlcIik7XG5cdFx0fVxuXHRcdHQuY3NzKFwib3BhY2l0eVwiLCBvLm9wYWNpdHkpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKG8uX29wYWNpdHkpIHtcblx0XHRcdCQodWkuaGVscGVyKS5jc3MoXCJvcGFjaXR5XCIsIG8uX29wYWNpdHkpO1xuXHRcdH1cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInNjcm9sbFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKTtcblx0XHRpZihpLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgaS5zY3JvbGxQYXJlbnRbMF0udGFnTmFtZSAhPT0gXCJIVE1MXCIpIHtcblx0XHRcdGkub3ZlcmZsb3dPZmZzZXQgPSBpLnNjcm9sbFBhcmVudC5vZmZzZXQoKTtcblx0XHR9XG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdHZhciBpID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLCBvID0gaS5vcHRpb25zLCBzY3JvbGxlZCA9IGZhbHNlO1xuXG5cdFx0aWYoaS5zY3JvbGxQYXJlbnRbMF0gIT09IGRvY3VtZW50ICYmIGkuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT09IFwiSFRNTFwiKSB7XG5cblx0XHRcdGlmKCFvLmF4aXMgfHwgby5heGlzICE9PSBcInhcIikge1xuXHRcdFx0XHRpZigoaS5vdmVyZmxvd09mZnNldC50b3AgKyBpLnNjcm9sbFBhcmVudFswXS5vZmZzZXRIZWlnaHQpIC0gZXZlbnQucGFnZVkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0aS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSBpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYoZXZlbnQucGFnZVkgLSBpLm92ZXJmbG93T2Zmc2V0LnRvcCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieVwiKSB7XG5cdFx0XHRcdGlmKChpLm92ZXJmbG93T2Zmc2V0LmxlZnQgKyBpLnNjcm9sbFBhcmVudFswXS5vZmZzZXRXaWR0aCkgLSBldmVudC5wYWdlWCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fSBlbHNlIGlmKGV2ZW50LnBhZ2VYIC0gaS5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZighby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ4XCIpIHtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSAtIG8uc2Nyb2xsU3BlZWQpO1xuXHRcdFx0XHR9IGVsc2UgaWYoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieVwiKSB7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgLSBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fSBlbHNlIGlmKCQod2luZG93KS53aWR0aCgpIC0gKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmKHNjcm9sbGVkICE9PSBmYWxzZSAmJiAkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhpLCBldmVudCk7XG5cdFx0fVxuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzbmFwXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGkgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksXG5cdFx0XHRvID0gaS5vcHRpb25zO1xuXG5cdFx0aS5zbmFwRWxlbWVudHMgPSBbXTtcblxuXHRcdCQoby5zbmFwLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgPyAoIG8uc25hcC5pdGVtcyB8fCBcIjpkYXRhKHVpLWRyYWdnYWJsZSlcIiApIDogby5zbmFwKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICR0ID0gJCh0aGlzKSxcblx0XHRcdFx0JG8gPSAkdC5vZmZzZXQoKTtcblx0XHRcdGlmKHRoaXMgIT09IGkuZWxlbWVudFswXSkge1xuXHRcdFx0XHRpLnNuYXBFbGVtZW50cy5wdXNoKHtcblx0XHRcdFx0XHRpdGVtOiB0aGlzLFxuXHRcdFx0XHRcdHdpZHRoOiAkdC5vdXRlcldpZHRoKCksIGhlaWdodDogJHQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0XHR0b3A6ICRvLnRvcCwgbGVmdDogJG8ubGVmdFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciB0cywgYnMsIGxzLCBycywgbCwgciwgdCwgYiwgaSwgZmlyc3QsXG5cdFx0XHRpbnN0ID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLFxuXHRcdFx0byA9IGluc3Qub3B0aW9ucyxcblx0XHRcdGQgPSBvLnNuYXBUb2xlcmFuY2UsXG5cdFx0XHR4MSA9IHVpLm9mZnNldC5sZWZ0LCB4MiA9IHgxICsgaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCxcblx0XHRcdHkxID0gdWkub2Zmc2V0LnRvcCwgeTIgPSB5MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0O1xuXG5cdFx0Zm9yIChpID0gaW5zdC5zbmFwRWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXG5cdFx0XHRsID0gaW5zdC5zbmFwRWxlbWVudHNbaV0ubGVmdDtcblx0XHRcdHIgPSBsICsgaW5zdC5zbmFwRWxlbWVudHNbaV0ud2lkdGg7XG5cdFx0XHR0ID0gaW5zdC5zbmFwRWxlbWVudHNbaV0udG9wO1xuXHRcdFx0YiA9IHQgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS5oZWlnaHQ7XG5cblx0XHRcdGlmICggeDIgPCBsIC0gZCB8fCB4MSA+IHIgKyBkIHx8IHkyIDwgdCAtIGQgfHwgeTEgPiBiICsgZCB8fCAhJC5jb250YWlucyggaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5pdGVtLm93bmVyRG9jdW1lbnQsIGluc3Quc25hcEVsZW1lbnRzWyBpIF0uaXRlbSApICkge1xuXHRcdFx0XHRpZihpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZykge1xuXHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMuc25hcC5yZWxlYXNlICYmIGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UuY2FsbChpbnN0LmVsZW1lbnQsIGV2ZW50LCAkLmV4dGVuZChpbnN0Ll91aUhhc2goKSwgeyBzbmFwSXRlbTogaW5zdC5zbmFwRWxlbWVudHNbaV0uaXRlbSB9KSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nID0gZmFsc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihvLnNuYXBNb2RlICE9PSBcImlubmVyXCIpIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyh0IC0geTIpIDw9IGQ7XG5cdFx0XHRcdGJzID0gTWF0aC5hYnMoYiAtIHkxKSA8PSBkO1xuXHRcdFx0XHRscyA9IE1hdGguYWJzKGwgLSB4MikgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyhyIC0geDEpIDw9IGQ7XG5cdFx0XHRcdGlmKHRzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogdCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoYnMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiBiLCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYobHMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogbCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IHIgfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0ID0gKHRzIHx8IGJzIHx8IGxzIHx8IHJzKTtcblxuXHRcdFx0aWYoby5zbmFwTW9kZSAhPT0gXCJvdXRlclwiKSB7XG5cdFx0XHRcdHRzID0gTWF0aC5hYnModCAtIHkxKSA8PSBkO1xuXHRcdFx0XHRicyA9IE1hdGguYWJzKGIgLSB5MikgPD0gZDtcblx0XHRcdFx0bHMgPSBNYXRoLmFicyhsIC0geDEpIDw9IGQ7XG5cdFx0XHRcdHJzID0gTWF0aC5hYnMociAtIHgyKSA8PSBkO1xuXHRcdFx0XHRpZih0cykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IHQsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IGIgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodCwgbGVmdDogMCB9KS50b3AgLSBpbnN0Lm1hcmdpbnMudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGxzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IGwgfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IHIgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoIH0pLmxlZnQgLSBpbnN0Lm1hcmdpbnMubGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighaW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgJiYgKHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0KSkge1xuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnNuYXAuc25hcCAmJiBpbnN0Lm9wdGlvbnMuc25hcC5zbmFwLmNhbGwoaW5zdC5lbGVtZW50LCBldmVudCwgJC5leHRlbmQoaW5zdC5fdWlIYXNoKCksIHsgc25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW0gfSkpKTtcblx0XHRcdH1cblx0XHRcdGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nID0gKHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0KTtcblxuXHRcdH1cblxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwic3RhY2tcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1pbixcblx0XHRcdG8gPSB0aGlzLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucyxcblx0XHRcdGdyb3VwID0gJC5tYWtlQXJyYXkoJChvLnN0YWNrKSkuc29ydChmdW5jdGlvbihhLGIpIHtcblx0XHRcdFx0cmV0dXJuIChwYXJzZUludCgkKGEpLmNzcyhcInpJbmRleFwiKSwxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChiKS5jc3MoXCJ6SW5kZXhcIiksMTApIHx8IDApO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIWdyb3VwLmxlbmd0aCkgeyByZXR1cm47IH1cblxuXHRcdG1pbiA9IHBhcnNlSW50KCQoZ3JvdXBbMF0pLmNzcyhcInpJbmRleFwiKSwgMTApIHx8IDA7XG5cdFx0JChncm91cCkuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHQkKHRoaXMpLmNzcyhcInpJbmRleFwiLCBtaW4gKyBpKTtcblx0XHR9KTtcblx0XHR0aGlzLmNzcyhcInpJbmRleFwiLCAobWluICsgZ3JvdXAubGVuZ3RoKSk7XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJ6SW5kZXhcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHQgPSAkKHVpLmhlbHBlciksIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZih0LmNzcyhcInpJbmRleFwiKSkge1xuXHRcdFx0by5fekluZGV4ID0gdC5jc3MoXCJ6SW5kZXhcIik7XG5cdFx0fVxuXHRcdHQuY3NzKFwiekluZGV4XCIsIG8uekluZGV4KTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZihvLl96SW5kZXgpIHtcblx0XHRcdCQodWkuaGVscGVyKS5jc3MoXCJ6SW5kZXhcIiwgby5fekluZGV4KTtcblx0XHR9XG5cdH1cbn0pO1xuXG59KShqUXVlcnkpO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgTW91c2UgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL21vdXNlL1xuICpcbiAqIERlcGVuZHM6XG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuJCggZG9jdW1lbnQgKS5tb3VzZXVwKCBmdW5jdGlvbigpIHtcblx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG59KTtcblxuJC53aWRnZXQoXCJ1aS5tb3VzZVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRjYW5jZWw6IFwiaW5wdXQsdGV4dGFyZWEsYnV0dG9uLHNlbGVjdCxvcHRpb25cIixcblx0XHRkaXN0YW5jZTogMSxcblx0XHRkZWxheTogMFxuXHR9LFxuXHRfbW91c2VJbml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5iaW5kKFwibW91c2Vkb3duLlwiK3RoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlRG93bihldmVudCk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoXCJjbGljay5cIit0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmICh0cnVlID09PSAkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKSkge1xuXHRcdFx0XHRcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpO1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUT0RPOiBtYWtlIHN1cmUgZGVzdHJveWluZyBvbmUgaW5zdGFuY2Ugb2YgbW91c2UgZG9lc24ndCBtZXNzIHdpdGhcblx0Ly8gb3RoZXIgaW5zdGFuY2VzIG9mIG1vdXNlXG5cdF9tb3VzZURlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC51bmJpbmQoXCIuXCIrdGhpcy53aWRnZXROYW1lKTtcblx0XHRpZiAoIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlICkge1xuXHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0LnVuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0XHQudW5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9tb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gZG9uJ3QgbGV0IG1vcmUgdGhhbiBvbmUgd2lkZ2V0IGhhbmRsZSBtb3VzZVN0YXJ0XG5cdFx0aWYoIG1vdXNlSGFuZGxlZCApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyB3ZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcblx0XHQodGhpcy5fbW91c2VTdGFydGVkICYmIHRoaXMuX21vdXNlVXAoZXZlbnQpKTtcblxuXHRcdHRoaXMuX21vdXNlRG93bkV2ZW50ID0gZXZlbnQ7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRidG5Jc0xlZnQgPSAoZXZlbnQud2hpY2ggPT09IDEpLFxuXHRcdFx0Ly8gZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBJRSA4IHdpdGhcblx0XHRcdC8vIGRpc2FibGVkIGlucHV0cyAoIzc2MjApXG5cdFx0XHRlbElzQ2FuY2VsID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsID09PSBcInN0cmluZ1wiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA/ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KHRoaXMub3B0aW9ucy5jYW5jZWwpLmxlbmd0aCA6IGZhbHNlKTtcblx0XHRpZiAoIWJ0bklzTGVmdCB8fCBlbElzQ2FuY2VsIHx8ICF0aGlzLl9tb3VzZUNhcHR1cmUoZXZlbnQpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdXNlRGVsYXlNZXQgPSAhdGhpcy5vcHRpb25zLmRlbGF5O1xuXHRcdGlmICghdGhpcy5tb3VzZURlbGF5TWV0KSB7XG5cdFx0XHR0aGlzLl9tb3VzZURlbGF5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Lm1vdXNlRGVsYXlNZXQgPSB0cnVlO1xuXHRcdFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9ICh0aGlzLl9tb3VzZVN0YXJ0KGV2ZW50KSAhPT0gZmFsc2UpO1xuXHRcdFx0aWYgKCF0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpY2sgZXZlbnQgbWF5IG5ldmVyIGhhdmUgZmlyZWQgKEdlY2tvICYgT3BlcmEpXG5cdFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpKSB7XG5cdFx0XHQkLnJlbW92ZURhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKTtcblx0XHR9XG5cblx0XHQvLyB0aGVzZSBkZWxlZ2F0ZXMgYXJlIHJlcXVpcmVkIHRvIGtlZXAgY29udGV4dFxuXHRcdHRoaXMuX21vdXNlTW92ZURlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZU1vdmUoZXZlbnQpO1xuXHRcdH07XG5cdFx0dGhpcy5fbW91c2VVcERlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZVVwKGV2ZW50KTtcblx0XHR9O1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0LmJpbmQoXCJtb3VzZXVwLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlKTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRtb3VzZUhhbmRsZWQgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZU1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gSUUgbW91c2V1cCBjaGVjayAtIG1vdXNldXAgaGFwcGVuZWQgd2hlbiBtb3VzZSB3YXMgb3V0IG9mIHdpbmRvd1xuXHRcdGlmICgkLnVpLmllICYmICggIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA5ICkgJiYgIWV2ZW50LmJ1dHRvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoZXZlbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCk7XG5cdFx0XHRyZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9XG5cdFx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0KHRoaXMuX21vdXNlRG93bkV2ZW50LCBldmVudCkgIT09IGZhbHNlKTtcblx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0ZWQgPyB0aGlzLl9tb3VzZURyYWcoZXZlbnQpIDogdGhpcy5fbW91c2VVcChldmVudCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhdGhpcy5fbW91c2VTdGFydGVkO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQudW5iaW5kKFwibW91c2Vtb3ZlLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHQudW5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cblx0XHRpZiAodGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fbW91c2VEb3duRXZlbnQudGFyZ2V0KSB7XG5cdFx0XHRcdCQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZVN0b3AoZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VEaXN0YW5jZU1ldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gKE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLmFicyh0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWCAtIGV2ZW50LnBhZ2VYKSxcblx0XHRcdFx0TWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVkgLSBldmVudC5wYWdlWSlcblx0XHRcdCkgPj0gdGhpcy5vcHRpb25zLmRpc3RhbmNlXG5cdFx0KTtcblx0fSxcblxuXHRfbW91c2VEZWxheU1ldDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZURlbGF5TWV0O1xuXHR9LFxuXG5cdC8vIFRoZXNlIGFyZSBwbGFjZWhvbGRlciBtZXRob2RzLCB0byBiZSBvdmVycmlkZW4gYnkgZXh0ZW5kaW5nIHBsdWdpblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHt9LFxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbigvKiBldmVudCAqLykge30sXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7fSxcblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHsgcmV0dXJuIHRydWU7IH1cbn0pO1xuXG59KShqUXVlcnkpO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2pRdWVyeS53aWRnZXQvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRfY2xlYW5EYXRhID0gJC5jbGVhbkRhdGE7XG4kLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdCQoIGVsZW0gKS50cmlnZ2VySGFuZGxlciggXCJyZW1vdmVcIiApO1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcblx0XHR9IGNhdGNoKCBlICkge31cblx0fVxuXHRfY2xlYW5EYXRhKCBlbGVtcyApO1xufTtcblxuJC53aWRnZXQgPSBmdW5jdGlvbiggbmFtZSwgYmFzZSwgcHJvdG90eXBlICkge1xuXHR2YXIgZnVsbE5hbWUsIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlLFxuXHRcdC8vIHByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0XHQvLyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgbWl4aW4gZm9yIG11bHRpcGxlIHdpZGdldHMgKCM4ODc2KVxuXHRcdHByb3hpZWRQcm90b3R5cGUgPSB7fSxcblx0XHRuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAwIF07XG5cblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0ZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0Ly8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXHQvLyBleHRlbmQgd2l0aCB0aGUgZXhpc3RpbmcgY29uc3RydWN0b3IgdG8gY2Fycnkgb3ZlciBhbnkgc3RhdGljIHByb3BlcnRpZXNcblx0JC5leHRlbmQoIGNvbnN0cnVjdG9yLCBleGlzdGluZ0NvbnN0cnVjdG9yLCB7XG5cdFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXG5cdFx0Ly8gY29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblx0XHQvLyB0cmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cdC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIF9zdXBlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0X3N1cGVyQXBwbHkgPSBmdW5jdGlvbiggYXJncyApIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHksXG5cdFx0XHRcdFx0cmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHR9KTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIHdpZGdldEV2ZW50UHJlZml4XG5cdFx0Ly8gYWx3YXlzIHVzZSB0aGUgbmFtZSArIGEgY29sb24gYXMgdGhlIHByZWZpeCwgZS5nLiwgZHJhZ2dhYmxlOnN0YXJ0XG5cdFx0Ly8gZG9uJ3QgcHJlZml4IGZvciB3aWRnZXRzIHRoYXQgYXJlbid0IERPTS1iYXNlZFxuXHRcdHdpZGdldEV2ZW50UHJlZml4OiBleGlzdGluZ0NvbnN0cnVjdG9yID8gKGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSk7XG5cblx0Ly8gSWYgdGhpcyB3aWRnZXQgaXMgYmVpbmcgcmVkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBmaW5kIGFsbCB3aWRnZXRzIHRoYXRcblx0Ly8gYXJlIGluaGVyaXRpbmcgZnJvbSBpdCBhbmQgcmVkZWZpbmUgYWxsIG9mIHRoZW0gc28gdGhhdCB0aGV5IGluaGVyaXQgZnJvbVxuXHQvLyB0aGUgbmV3IHZlcnNpb24gb2YgdGhpcyB3aWRnZXQuIFdlJ3JlIGVzc2VudGlhbGx5IHRyeWluZyB0byByZXBsYWNlIG9uZVxuXHQvLyBsZXZlbCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuXHRpZiAoIGV4aXN0aW5nQ29uc3RydWN0b3IgKSB7XG5cdFx0JC5lYWNoKCBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycywgZnVuY3Rpb24oIGksIGNoaWxkICkge1xuXHRcdFx0dmFyIGNoaWxkUHJvdG90eXBlID0gY2hpbGQucHJvdG90eXBlO1xuXG5cdFx0XHQvLyByZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xuXHRcdFx0Ly8gb3JpZ2luYWxseSB1c2VkLCBidXQgaW5oZXJpdCBmcm9tIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGUgYmFzZVxuXHRcdFx0JC53aWRnZXQoIGNoaWxkUHJvdG90eXBlLm5hbWVzcGFjZSArIFwiLlwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byApO1xuXHRcdH0pO1xuXHRcdC8vIHJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXG5cdFx0Ly8gc28gdGhlIG9sZCBjaGlsZCBjb25zdHJ1Y3RvcnMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ZGVsZXRlIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UuX2NoaWxkQ29uc3RydWN0b3JzLnB1c2goIGNvbnN0cnVjdG9yICk7XG5cdH1cblxuXHQkLndpZGdldC5icmlkZ2UoIG5hbWUsIGNvbnN0cnVjdG9yICk7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRpbnB1dEluZGV4ID0gMCxcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHRrZXksXG5cdFx0dmFsdWU7XG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblx0XHRcdFx0XHRcdC8vIERvbid0IGV4dGVuZCBzdHJpbmdzLCBhcnJheXMsIGV0Yy4gd2l0aCBvYmplY3RzXG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB2YWx1ZSApO1xuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuXHRcdFx0cmV0dXJuVmFsdWUgPSB0aGlzO1xuXG5cdFx0Ly8gYWxsb3cgbXVsdGlwbGUgaGFzaGVzIHRvIGJlIHBhc3NlZCBvbiBpbml0XG5cdFx0b3B0aW9ucyA9ICFpc01ldGhvZENhbGwgJiYgYXJncy5sZW5ndGggP1xuXHRcdFx0JC53aWRnZXQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIG9wdGlvbnMgXS5jb25jYXQoYXJncykgKSA6XG5cdFx0XHRvcHRpb25zO1xuXG5cdFx0aWYgKCBpc01ldGhvZENhbGwgKSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBtZXRob2RWYWx1ZSxcblx0XHRcdFx0XHRpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIiArIG5hbWUgKyBcIiBwcmlvciB0byBpbml0aWFsaXphdGlvbjsgXCIgK1xuXHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVtvcHRpb25zXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcIm5vIHN1Y2ggbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIicgZm9yIFwiICsgbmFtZSArIFwiIHdpZGdldCBpbnN0YW5jZVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWV0aG9kVmFsdWUgPSBpbnN0YW5jZVsgb3B0aW9ucyBdLmFwcGx5KCBpbnN0YW5jZSwgYXJncyApO1xuXHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gbWV0aG9kVmFsdWUgJiYgbWV0aG9kVmFsdWUuanF1ZXJ5ID9cblx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKS5faW5pdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0YSggdGhpcywgZnVsbE5hbWUsIG5ldyBvYmplY3QoIG9wdGlvbnMsIHRoaXMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblx0b3B0aW9uczoge1xuXHRcdGRpc2FibGVkOiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNyZWF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB1dWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXHRcdHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sXG5cdFx0XHR0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksXG5cdFx0XHRvcHRpb25zICk7XG5cblx0XHR0aGlzLmJpbmRpbmdzID0gJCgpO1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gJCgpO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCgpO1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblx0XHRcdFx0Ly8gZWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgd2luZG93IG9yIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudCApO1xuXHRcdFx0dGhpcy53aW5kb3cgPSAkKCB0aGlzLmRvY3VtZW50WzBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbMF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cdF9nZXRDcmVhdGVPcHRpb25zOiAkLm5vb3AsXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblx0X2NyZWF0ZTogJC5ub29wLFxuXHRfaW5pdDogJC5ub29wLFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0XHQvLyB3ZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXG5cdFx0Ly8gYWxsIGV2ZW50IGJpbmRpbmdzIHNob3VsZCBnbyB0aHJvdWdoIHRoaXMuX29uKClcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0Ly8gMS45IEJDIGZvciAjNzgxMFxuXHRcdFx0Ly8gVE9ETyByZW1vdmUgZHVhbCBzdG9yYWdlXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXROYW1lIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lIClcblx0XHRcdC8vIHN1cHBvcnQ6IGpxdWVyeSA8MS42LjNcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTNcblx0XHRcdC5yZW1vdmVEYXRhKCAkLmNhbWVsQ2FzZSggdGhpcy53aWRnZXRGdWxsTmFtZSApICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHR0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHR9LFxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5LFxuXHRcdFx0cGFydHMsXG5cdFx0XHRjdXJPcHRpb24sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Ly8gaGFuZGxlIG5lc3RlZCBrZXlzLCBlLmcuLCBcImZvby5iYXJcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHBhcnRzID0ga2V5LnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0a2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdGlmICggcGFydHMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJPcHRpb24gPSBvcHRpb25zWyBrZXkgXSA9ICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9uc1sga2V5IF0gKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRcdFx0Y3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSB8fCB7fTtcblx0XHRcdFx0XHRjdXJPcHRpb24gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiBjdXJPcHRpb25bIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogY3VyT3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJPcHRpb25bIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1sga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLm9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgdWktc3RhdGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0fSxcblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50LFxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gbm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBubyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYWNjZXB0IHNlbGVjdG9ycywgRE9NIGVsZW1lbnRzXG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFxcdyspXFxzKiguKikkLyApLFxuXHRcdFx0XHRldmVudE5hbWUgPSBtYXRjaFsxXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlLFxuXHRcdFx0XHRzZWxlY3RvciA9IG1hdGNoWzJdO1xuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50LmRlbGVnYXRlKCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZCggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfb2ZmOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lICkge1xuXHRcdGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgXCJcIikuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgKyB0aGlzLmV2ZW50TmFtZXNwYWNlO1xuXHRcdGVsZW1lbnQudW5iaW5kKCBldmVudE5hbWUgKS51bmRlbGVnYXRlKCBldmVudE5hbWUgKTtcblx0fSxcblxuXHRfZGVsYXk6IGZ1bmN0aW9uKCBoYW5kbGVyLCBkZWxheSApIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoIGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCApO1xuXHR9LFxuXG5cdF9ob3ZlcmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHR2YXIgcHJvcCwgb3JpZyxcblx0XHRcdGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFswXSwgWyBldmVudCBdLmNvbmNhdCggZGF0YSApICkgPT09IGZhbHNlIHx8XG5cdFx0XHRldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApO1xuXHR9XG59O1xuXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcblx0JC5XaWRnZXQucHJvdG90eXBlWyBcIl9cIiArIG1ldGhvZCBdID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0dmFyIGhhc09wdGlvbnMsXG5cdFx0XHRlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0XHRtZXRob2QgOlxuXHRcdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZShmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59KSggalF1ZXJ5ICk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgR2VuZXJpY0ZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2dlbmVyaWMtZmlsdGVyLW1vZGVsJyk7XG52YXIgT3JnUm9sZUZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL29yZy1yb2xlLWZpbHRlci1tb2RlbCcpO1xudmFyIFllYXJzRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtZmlsdGVyLW1vZGVsJyk7XG52YXIgWWVhcnNPbmx5RmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtb25seS1maWx0ZXItbW9kZWwnKTtcblxuXG4vL1RPRE86IG1vdmUgbW9zdCBjb2RlIGZyb20gZmlsdGVycy12aWV3IGhlcmUuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgdXJsOiAnL3Jlc3QvZmlsdGVycycsXG4gIF9sb2FkZWQ6IG51bGwsXG4gIF9hbGxEZWZlcnJlZHM6IFtdLFxuICBvcmdDb2xsZWN0aW9uOiBudWxsLFxuICBvcmdHcm91cENvbGxlY3Rpb246IG51bGwsXG4gIG9yZ1R5cGVDb2xsZWN0aW9uOiBudWxsLFxuICBjb21wb25lbnRDYWxsZXI6IG51bGwsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLG9wdGlvbnMpIHtcbiAgICB0aGlzLm9uKCdhZGQnLCB0aGlzLl9jbGVhblVwQWZ0ZXJBZGQpO1xuICAgIHRoaXMubG9hZCgpO1xuICAgIGlmIChvcHRpb25zLmNhbGxlcikge1xuICAgIFx0Y29tcG9uZW50Q2FsbGVyID0gb3B0aW9ucy5jYWxsZXI7XG4gICAgfVxuICB9LFxuXG4gIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCF0aGlzLl9sb2FkZWQpe1xuICAgICAgdGhpcy5fbG9hZGVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgICAgIHRoaXMuX2FsbERlZmVycmVkcy5wdXNoKHRoaXMuX2NyZWF0ZU9yZ0ZpbHRlcnMoKSk7XG5cbiAgICAgIHRoaXMuZmV0Y2goe3JlbW92ZTogZmFsc2V9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB3aGVuIGFsbCBjaGlsZCBjYWxscyBhcmUgZG9uZSByZXNvbHZlLlxuICAgICAgICAkLndoZW4uYXBwbHkoJCwgc2VsZi5fYWxsRGVmZXJyZWRzKVxuICAgICAgICAgIC5kb25lKHNlbGYuX2xvYWRlZC5yZXNvbHZlKVxuICAgICAgICAgIC5mYWlsKHNlbGYuX2xvYWRlZC5yZWplY3QpO1xuICAgICAgfSkuZmFpbChzZWxmLl9sb2FkZWQucmVqZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICB9LFxuXG4gIF9jbGVhblVwQWZ0ZXJBZGQ6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIHJlbW92ZSBpZiB1aSBmYWxzZSBhbHNvIGNhdGNoZXMgZW1wdHkgZHVtbXkgZmlsdGVycyB3ZSBhZGQgaW4gJ21vZGVsJyBmdW5jdGlvbiBiZWxvdy5cbiAgICBpZiAoIW1vZGVsLmdldCgndWknKSkge1xuICAgICAgc2VsZi5yZW1vdmUobW9kZWwpO1xuICAgIH1cbiAgICAvL3JlbW92ZSBpZiB0aGUgZW5kcG9pbnQgcmV0dXJucyB0aGUgZmlsdGVyIHR5cGUgKGRhc2hib2FyZCx0YWJzLHJlcG9ydHMgYW5kL29yIEdJUykgZm9yIHdoaWNoXG4gICAgLy90aGUgbW9kZWwgc2hvdWxkIGJlIHZpc2libGUgYW5kIHRoZSBjYWxsZXIgaXMgbm90IG9mIHRoZSBzYW1lIHRwZVxuICAgIFxuICAgIGlmIChtb2RlbC5nZXQoJ2ZpbHRlclR5cGUnKSkge1xuICAgIFx0Ly8gQ09OU1RBTlRJTjogaGVyZSBmaWx0ZXJpbmcgaXJyZWxldmFudCBjb2x1bW5zIGZvciB0aGUgc2V0IGZpbHRlciB0eXBlIGFyZSBmaWx0ZXJlZCBvdXRcbiAgICBcdHZhciBpc09mUmVxdWlyZWRUeXBlID0gXy5zb21lKCBtb2RlbC5nZXQoJ2ZpbHRlclR5cGUnKSwgZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgXHQgICAgcmV0dXJuIHR5cGUgPT09IGNvbXBvbmVudENhbGxlciB8fCB0eXBlID09PSBcIkFMTFwiO1xuICAgIFx0fSk7XG4gICAgXHQvL2NvbnNvbGUubG9nKFwiZGVjaWRlZCB3aGV0aGVyIHRvIHNob3cgY29sdW1uIFwiICsgbW9kZWwuZ2V0KFwibmFtZVwiKSArIFwiOiBcIiArIGlzT2ZSZXF1aXJlZFR5cGUpXG4gICAgXHRpZiAoIWlzT2ZSZXF1aXJlZFR5cGUpIHtcbiAgICBcdFx0c2VsZi5yZW1vdmUgKG1vZGVsKTtcbiAgICBcdH1cbiAgICB9XG4gICAgLy8gRXhwb3NlIHRoaXMgZmllbGQgZm9yIGxhdGVyIHVzYWdlLlxuICAgIHRoaXMuY29tcG9uZW50Q2FsbGVyID0gY29tcG9uZW50Q2FsbGVyO1xuICB9LFxuXG5cbi8vICBjb250YWluczogZnVuY3Rpb24oa2V5KSB7XG4vL1x0ICBpZiAoKVxuLy8gIH0sXG4gIFxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIC8vb25seSBrZWVwIGZpbHRlcnMgd2l0aCB1aSA9PSB0cnVlO1xuICAgIGRhdGEgPSBfLmZpbHRlcihkYXRhLCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmoudWk7XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBvcmdzLCBncm91cHMsIGFuZCB0eXBlcywgYmVjYXVzZSB0aGV5IGFyZSBub3QgZmlsdGVycyBvbiB0aGVpciBvd24uXG4gICAgLy8gV2UgdXNlIHRoZW0gZG93biBiZWxvdy5cbiAgICBkYXRhID0gXy5maWx0ZXIoZGF0YSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gKG9iai5lbmRwb2ludCAhPT0gJy9yZXN0L2ZpbHRlcnMvb3JnLWdyb3VwcycgJiZcbiAgICAgICAgb2JqLmVuZHBvaW50ICE9PSAnL3Jlc3QvZmlsdGVycy9vcmctdHlwZXMnICYmXG4gICAgICAgIG9iai5lbmRwb2ludCAhPT0gJy9yZXN0L2ZpbHRlcnMvb3JnLXJvbGVzJyAmJlxuICAgICAgICBvYmouZW5kcG9pbnQgIT09ICcvcmVzdC9maWx0ZXJzL29yZ3MnKTtcbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cblxuICBtb2RlbDogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdG1wTW9kZWwgPSBudWxsO1xuXG4gICAgLy8gc2xpZ2h0bHkgdW5jb252ZW50aW9uYWwsIGJ1dCBtb2RlbCBpcyBzcGVjaWFsIGNhc2Ugc2luY2UgaXQncyBjYWxsZWQgd2l0aFxuICAgIC8vIG5ldyBzbyAndGhpcycgd29udCBiZSB0aGUgY29sbGVjdGlvbi5cbiAgICB2YXIgc2VsZiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcblxuICAgIC8vIHN3aXRjaCBmb3IgbW9kZWwgcG9seW1vcnBoaXNtLlxuICAgIHN3aXRjaCAoYXR0cnMuaWQpIHtcbiAgICAgIGNhc2UgJ1Byb2dyYW1zJzpcbiAgICAgIGNhc2UgJ1NlY3RvcnMnOlxuICAgICAgICBzZWxmLl9hbGxEZWZlcnJlZHMucHVzaChzZWxmLl9nb09uZURlZXBlcihzZWxmLCBhdHRycykpO1xuICAgICAgICAvL3RtcCBoYWNrIGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm4gc29tZXRoaW5nLlxuICAgICAgICB0bXBNb2RlbCA9IG5ldyBCYWNrYm9uZS5Nb2RlbCh7dWk6ZmFsc2V9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgZGVmYXVsdDpcbiAgICBcdCAgXG4gICAgXHQgIGlmIChhdHRycy5pZCA9PSAnZGF0ZScgfHwgKGF0dHJzLmlkLmluZGV4T2YoJy1kYXRlJykgIT0gLTEgKSB8fCAoYXR0cnMuaWQuaW5kZXhPZignZGF0ZS0nKSAhPSAtMSApKSB7XG4gICAgXHRcdCAgdG1wTW9kZWwgPSBuZXcgWWVhcnNGaWx0ZXJNb2RlbChhdHRycyk7ICAvLyBoYWNreSBidXQgbGVzcyBoYWNreSB0aGFuIGVudW1lcmF0aW5nIHRoZW0uIExvbmcgdGVybSBzb2x1dGlvbiAtPiB0aGUgZW5kcG9pbnQgc2hvdWxkIHJldHVybiBhIGZpZWxkIHRlbGxpbmcgdGhlIHR5cGUgb2YgYSBmaWVsZFxuICAgIFx0ICB9IGVsc2UgaWYgKGF0dHJzLmlkID09ICdjb21wdXRlZC15ZWFyJykge1xuICAgIFx0XHQgIHRtcE1vZGVsID0gbmV3IFllYXJzT25seUZpbHRlck1vZGVsKGF0dHJzKTtcbiAgICBcdCAgfSBlbHNlIHtcbiAgICBcdFx0ICB0bXBNb2RlbCA9IG5ldyBHZW5lcmljRmlsdGVyTW9kZWwoYXR0cnMpO1xuICAgIFx0XHQgIHNlbGYuX2FsbERlZmVycmVkcy5wdXNoKHRtcE1vZGVsLmdldFRyZWUoKSk7XG4gICAgXHQgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG1wTW9kZWw7XG4gIH0sXG5cbiAgLy8gZ2V0IGVuZHBvaW50J3MgY2hpbGRyZW4gYW5kIGxvYWQgdGhlbSBpbnRvIHNlbGYuLi5cbiAgX2dvT25lRGVlcGVyOiBmdW5jdGlvbihzZWxmLCBhdHRycykge1xuICAgIHZhciB1cmwgPSBhdHRycy5lbmRwb2ludDtcbiAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG4gICAgdmFyIHRtcERlZmVycmVkcyA9IFtdO1xuXG4gICAgdmFyIHRtcENvbGxlY3Rpb24gPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRtcENvbGxlY3Rpb24udXJsID0gdXJsO1xuICAgIHRtcENvbGxlY3Rpb24uZmV0Y2goKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbihBUElGaWx0ZXIpIHtcbiAgICAgICAgdmFyIHRtcE1vZGVsID0gbmV3IEdlbmVyaWNGaWx0ZXJNb2RlbCh7XG4gICAgICAgICAgdXJsOiB1cmwgKyAnLycgKyBBUElGaWx0ZXIuaWQsXG4gICAgICAgICAgbmFtZTogQVBJRmlsdGVyLm5hbWUsXG4gICAgICAgICAgdGFiOiBBUElGaWx0ZXIudGFiLFxuICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgIGdyb3VwOiBhdHRycy5pZCxcbiAgICAgICAgICBlbXB0eTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgdG1wRGVmZXJyZWRzLnB1c2godG1wTW9kZWwuZ2V0VHJlZSgpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoXy5pc0VtcHR5KGRhdGEpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmlsdGVycyBBUEkgcmV0dXJuZWQgZW1wdHknLCB1cmwpO1xuICAgICAgICAvLyBDcmVhdGUgZW1wdHkgbW9kZWwgc28gdGhlIHZpZXcgZG9lc250IGZhaWwuXG4gICAgICAgIHZhciB0bXBNb2RlbCA9IG5ldyBHZW5lcmljRmlsdGVyTW9kZWwoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBuYW1lOiBhdHRycy5uYW1lLFxuICAgICAgICAgICAgdWk6IHRydWUsXG4gICAgICAgICAgICBncm91cDogYXR0cnMuaWQsXG4gICAgICAgICAgICBlbXB0eTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgICB0bXBEZWZlcnJlZHMucHVzaCh0bXBNb2RlbC5nZXRUcmVlKCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAkLndoZW4uYXBwbHkoJCwgdG1wRGVmZXJyZWRzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfSxcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNwZWNpYWwgb3JnIGFuZCBkb25vciBzcGVjaWZpYyBjb2RlIHNpbmNlIGl0IGhhcyBzcGVjaWFsIGJlaGF2aW91clxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgX2NyZWF0ZU9yZ0ZpbHRlcnM6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gQ3JlYXRlICdqb2lucycgZm9yIGVhY2ggdHlwZSBhZGQgcmVmIHRvIGdyb3VwcywgYW5kIGZvciBlYWNoIGdyb3VwIGFkZCByZWZzIHRvIG9yZ3MuXG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoT3JnQ29sbGVjdGlvbnMoKS50aGVuKGZ1bmN0aW9uKCkge1xuXG4gICAgICAvLyBqc29uaWZ5IG9yZ3MgYW5kIHNldCB0aGVtIGFzIGNoaWxkcmVuIGluIGdyb3Vwcy5cblxuICAgICAgc2VsZi5tYWtlVHJlZUhlbHBlcihzZWxmLm9yZ0dyb3VwQ29sbGVjdGlvbiwgc2VsZi5vcmdDb2xsZWN0aW9uLCAnb3JnSWRzJywgJ2NoaWxkcmVuJyk7XG5cblxuICAgICAgLy8gRm9yIGVhY2ggcm9sZSBjcmVhdGUgYSBmaWx0ZXIgd2l0aCBjb2xsZWN0aW9uIG9mIGp1c3Qgb3JncyB0aGF0IG1hdGNoLlxuICAgICAgc2VsZi5vcmdSb2xlc0NvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihyb2xlKSB7XG4gICAgICAgIHZhciB0bXBKU09OID0gcm9sZS50b0pTT04oKTtcblxuICAgICAgICAvLyB0cmVhdCBkb25vciBkaWZmZXJlbnRseS4uLlxuICAgICAgICBpZiAocm9sZS5nZXQoJ25hbWUnKSA9PT0gJ0Rvbm9yJykge1xuICAgICAgICAgIHNlbGYubWFrZVRyZWVIZWxwZXIoc2VsZi5vcmdUeXBlQ29sbGVjdGlvbiwgc2VsZi5vcmdHcm91cENvbGxlY3Rpb24sICdncm91cElkcycsICdjaGlsZHJlbicpO1xuICAgICAgICAgIC8vIENyZWF0ZSB0cmVlIHJvb3ROb2RlIGFuZCByYXcgSlNPTi5cbiAgICAgICAgICBfLmV4dGVuZCh0bXBKU09OLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB1aTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ3JvdXA6ICdEb25vcicsXG4gICAgICAgICAgICAgIHRhYjogJ0Z1bmRpbmcgT3JnYW5pemF0aW9ucycsXG4gICAgICAgICAgICAgIGRhdGE6IHNlbGYub3JnVHlwZUNvbGxlY3Rpb24udG9KU09OKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gZmlsdGVyIG9yZ3MuLi5cbiAgICAgICAgICB0bXBKU09OLmRhdGEgPSBzZWxmLl9maWx0ZXJEb25vck9yZ3ModG1wSlNPTi5kYXRhLCByb2xlLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdHJlZSByb290Tm9kZSBhbmQgcmF3IEpTT04uXG4gICAgICAgICAgXy5leHRlbmQodG1wSlNPTixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdWk6IHRydWUsXG4gICAgICAgICAgICAgIGdyb3VwOiAnUm9sZScsIC8vVE9ETzogP3Nob3VsZCB0aGlzIGJlICdSb2xlJyBvciByb2xlLmlkIG9yIHJvbGUuZ2V0KCduYW1lJyk/XG4gICAgICAgICAgICAgIHRhYjogJ0FsbCBBZ2VuY2llcycsXG4gICAgICAgICAgICAgIGRhdGE6IHNlbGYub3JnR3JvdXBDb2xsZWN0aW9uLnRvSlNPTigpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vcmVtb3ZlIGFsbCBvcmdzIHRoYXQgZG9uJ3QgYmVsb25nIGluIHRoaXMgcm9sZVxuICAgICAgICAgIHRtcEpTT04uZGF0YSA9IHNlbGYuX2ZpbHRlck9yZ3ModG1wSlNPTi5kYXRhLCByb2xlLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0bXBKU09OLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBcdHZhciBjdXJyZW50RmlsdGVySWQ7XG4gICAgICAgIFx0aWYgKHJvbGUuZ2V0KCdmaWx0ZXJJZCcpKSB7XG4gICAgICAgIFx0XHRjdXJyZW50RmlsdGVySWQgPSByb2xlLmdldCgnZmlsdGVySWQnKTtcbiAgICAgICAgXHR9IGVsc2Uge1xuICAgICAgICBcdFx0Y3VycmVudEZpbHRlcklkID0gcm9sZS5nZXQoJ25hbWUnKSArIFwiIElkXCI7XG4gICAgICAgIFx0fSAgICAgICAgXHRcbiAgICAgICAgXHR0bXBKU09OLmRhdGEgPSBzZWxmLl9zZXRGaWx0ZXJJZCh0bXBKU09OLmRhdGEsIGN1cnJlbnRGaWx0ZXJJZCk7ICAgICAgICAgICAgXG4gICAgICAgIFx0c2VsZi5hZGQobmV3IE9yZ1JvbGVGaWx0ZXJNb2RlbCh0bXBKU09OKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvL29ubHkgbmVlZGVkIGZvciBkb25vciBpZiB3ZSB3YW50IHRvIGRvIHNwZWNpYWwgbGlzdGVuaW5nLi4uLjpcbiAgICAgIC8vIHNlbGYuam9pbkhlbHBlcihzZWxmLm9yZ1R5cGVDb2xsZWN0aW9uLCBzZWxmLm9yZ0dyb3VwQ29sbGVjdGlvbiwgJ2dyb3VwSWRzJywgJ2dyb3VwcycpO1xuICAgICAgLy8gc2VsZi5qb2luSGVscGVyKHNlbGYub3JnR3JvdXBDb2xsZWN0aW9uLCBzZWxmLm9yZ0NvbGxlY3Rpb24sICdvcmdJZHMnLCAnb3JncycpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIGV4cGxpY2l0bHkgc2V0cyB0aGUgZmlsdGVyIGlkIG9uIGFsbCB0aGUgb3Jncy5cbiAgX3NldEZpbHRlcklkOiBmdW5jdGlvbihjb2xsZWN0aW9uLCBmaWx0ZXJJZCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIF8uZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihvcmcpIHtcbiAgICAgIC8vb25seSBzZXQgZmlsdGVySWQgb24gb3Jncywgbm90IGdyb3VwIG9yIHR5cGUsIG9yIGl0IHdpbGwgY2F1c2UgYnVncy5cbiAgICAgIGlmKG9yZy5yb2xlc0lkcyl7XG4gICAgICAgIG9yZy5maWx0ZXJJZCA9IGZpbHRlcklkO1xuICAgICAgfVxuICAgICAgaWYob3JnLmNoaWxkcmVuKXtcbiAgICAgICAgb3JnLmNoaWxkcmVuID0gc2VsZi5fc2V0RmlsdGVySWQob3JnLmNoaWxkcmVuLCBmaWx0ZXJJZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfSxcblxuXG5cbiAgLy8gZmlsdGVyIG9yZ3MgdHJlZSB0byBvbmx5IG9yZ3MgdGhhdCBhcHBlYXIgYXMgdGhlIGdpdmVuIHJvbGVJRFxuICBfZmlsdGVyT3JnczogZnVuY3Rpb24ob3JnR3JvdXBzSlNPTiwgcm9sZUlEKSB7XG4gICAgb3JnR3JvdXBzSlNPTiA9IF8uZmlsdGVyKG9yZ0dyb3Vwc0pTT04sIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICBncm91cC5pc09yZ0dyb3VwID0gdHJ1ZTtcbiAgICAgIGdyb3VwLmNoaWxkcmVuID0gXy5maWx0ZXIoZ3JvdXAuY2hpbGRyZW4sIGZ1bmN0aW9uKG9yZykge1xuICAgICAgICByZXR1cm4gKG9yZy5yb2xlc0lkcy5pbmRleE9mKHJvbGVJRCkgPiAtMSk7XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmlzU2VsZWN0YWJsZSA9IGZhbHNlOyAvL3N0b3BzIHRyZWUgZnJvbSBjcmVhdGluZyAndW5rb3duJyBjaGlsZHJlbi5cbiAgICAgIHJldHVybiAoZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9yZ0dyb3Vwc0pTT047XG4gIH0sXG5cblxuXHQgIC8vIHNwZWNpYWwgY2FzZSBmb3IgZG9ub3IgdHJlZSwgc2luY2UgaXQgaGFzIHR5cGVcblx0X2ZpbHRlckRvbm9yT3JncyA6IGZ1bmN0aW9uKG9yZ1R5cGVzSlNPTiwgcm9sZUlEKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdG9yZ1R5cGVzSlNPTiA9IF8uZmlsdGVyKG9yZ1R5cGVzSlNPTiwgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dHlwZS5jaGlsZHJlbiA9IHNlbGYuX2ZpbHRlck9yZ3ModHlwZS5jaGlsZHJlbiwgcm9sZUlEKTtcblx0XHRcdF8uZWFjaCh0eXBlLmNoaWxkcmVuLCBmdW5jdGlvbihncm91cCkge1xuXHRcdFx0XHRncm91cC5maWx0ZXJJZCA9ICdkb25vci1ncm91cCc7XG5cdFx0XHR9KTtcdFxuXG5cdFx0XHR0eXBlLmZpbHRlcklkID0gJ2Rvbm9yLXR5cGUnO1xuXHRcdFx0dHlwZS5pc1NlbGVjdGFibGUgPSBmYWxzZTsgLy8gc3RvcHMgdHJlZSBmcm9tIGNyZWF0aW5nICd1bmtvd24nIGNoaWxkcmVuLlxuXHRcdFx0cmV0dXJuICh0eXBlLmNoaWxkcmVuLmxlbmd0aCA+IDApO1xuXHRcdH0pO1xuXHRcdHJldHVybiBvcmdUeXBlc0pTT047XG5cdH0sXG5cbiAgICAvLyAxLiBnZXQgYWxsIG9yZ3MsIGdyb3VwcywgdHlwZXMsIGFuZCByb2xlc1xuICBfZmV0Y2hPcmdDb2xsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlckRlZmVycmVkcyA9IFtdO1xuXG4gICAgdGhpcy5vcmdDb2xsZWN0aW9uID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLm9yZ0NvbGxlY3Rpb24udXJsID0gJy9yZXN0L2ZpbHRlcnMvb3Jncyc7XG4gICAgZmlsdGVyRGVmZXJyZWRzLnB1c2godGhpcy5vcmdDb2xsZWN0aW9uLmZldGNoKCkpO1xuXG4gICAgdGhpcy5vcmdHcm91cENvbGxlY3Rpb24gPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRoaXMub3JnR3JvdXBDb2xsZWN0aW9uLnVybCA9ICcvcmVzdC9maWx0ZXJzL29yZy1ncm91cHMnO1xuICAgIGZpbHRlckRlZmVycmVkcy5wdXNoKHRoaXMub3JnR3JvdXBDb2xsZWN0aW9uLmZldGNoKCkpO1xuXG4gICAgdGhpcy5vcmdUeXBlQ29sbGVjdGlvbiA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7XG4gICAgdGhpcy5vcmdUeXBlQ29sbGVjdGlvbi51cmwgPSAnL3Jlc3QvZmlsdGVycy9vcmctdHlwZXMnO1xuICAgIGZpbHRlckRlZmVycmVkcy5wdXNoKHRoaXMub3JnVHlwZUNvbGxlY3Rpb24uZmV0Y2goKSk7XG5cbiAgICB0aGlzLm9yZ1JvbGVzQ29sbGVjdGlvbiA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7XG4gICAgdGhpcy5vcmdSb2xlc0NvbGxlY3Rpb24udXJsID0gJy9yZXN0L2ZpbHRlcnMvb3JnLXJvbGVzJztcbiAgICBmaWx0ZXJEZWZlcnJlZHMucHVzaCh0aGlzLm9yZ1JvbGVzQ29sbGVjdGlvbi5mZXRjaCh7fSkpO1xuXG4gICAgcmV0dXJuICQud2hlbi5hcHBseSgkLCBmaWx0ZXJEZWZlcnJlZHMpO1xuICB9LFxuXG5cbiAgLy8gQWRkcyByZWZlcmVuY2VzIHRvIGNvbGxlY3Rpb25CIGludG8gY29sbGVjdGlvbkEgam9pbmluZyBvbiBnaXZlbiBmb3JlaWduIGtleVxuICAvLyBUT0RPOiBvcHRpb24gdG8gYWRkIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZS5cbiAgam9pbkhlbHBlcjogZnVuY3Rpb24oY29sbGVjdGlvbkEsIGNvbGxlY3Rpb25CLCBrZXlGb3JGb3JlaWduSUQsIGtleUZvckNvbGxlY3Rpb25EZXN0aW5hdGlvbikge1xuICAgIGNvbGxlY3Rpb25BLmVhY2goZnVuY3Rpb24obW9kZWxBKSB7XG4gICAgICB2YXIgaWRzVG9Kb2luID0gbW9kZWxBLmdldChrZXlGb3JGb3JlaWduSUQpO1xuICAgICAgdmFyIHRlbXBDb2xsZWN0aW9uID0gY29sbGVjdGlvbkIuZmlsdGVyKGZ1bmN0aW9uKG1vZGVsQikge1xuICAgICAgICByZXR1cm4gXy5pbmRleE9mKGlkc1RvSm9pbiwgbW9kZWxCLmdldCgnaWQnKSkgPj0gMDtcbiAgICAgIH0pO1xuXG4gICAgICBtb2RlbEEuc2V0KGtleUZvckNvbGxlY3Rpb25EZXN0aW5hdGlvbiwgdGVtcENvbGxlY3Rpb24pO1xuICAgIH0pO1xuICB9LFxuXG4gIG1ha2VUcmVlSGVscGVyIDogZnVuY3Rpb24ocGFyZW50Q29sbGVjdGlvbiwgY2hpbGRDb2xsZWN0aW9uLCBrZXlGb3JGb3JlaWduSUQsIGtleUZvckNvbGxlY3Rpb25EZXN0aW5hdGlvbikge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgZG9ub3JSb2xlID0gXy5maWx0ZXIoc2VsZi5vcmdSb2xlc0NvbGxlY3Rpb24ubW9kZWxzLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS5nZXQoJ25hbWUnKSA9PT0gJ0Rvbm9yJztcblx0XHR9KVswXTtcblx0XHRwYXJlbnRDb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24ocGFyZW50KSB7XG5cdFx0XHR2YXIgaWRzVG9Kb2luID0gcGFyZW50LmdldChrZXlGb3JGb3JlaWduSUQpO1xuXHRcdFx0dmFyIHRlbXBDb2xsZWN0aW9uID0gY2hpbGRDb2xsZWN0aW9uLnRvSlNPTigpO1xuXHRcdFx0XG5cdFx0XHQvLyBCZWNhdXNlIG9mIHRoZSBidXNpbmVzcyBsb2dpYyBvZiBvbGQgZmlsdGVycywgaWYgYW4gb3JnYW5pemF0aW9uIGhhcyBiZWVuIHVzZWQgYXMgYSBmdW5kaW5nIG9yZ1xuXHRcdFx0Ly8gKHByZXNlbnQgaW4gYW1wX2Z1bmRpbmcpIHRoZW4gd2UgbmVlZCB0b1xuXHRcdFx0Ly8gYWRkIGl0IHRvIHRoZSBsaXN0IG9mICdEb25vcnMnIG5vIG1hdHRlciB3aGljaCBpcyB0aGUgJ3JvbGUnIG9mIHRoYXQgb3JnYW5pemF0aW9uLCBzbyBpbiBvcmRlciB0b1xuXHRcdFx0Ly8gbWFrZSBpdCBhcHBlYXIgaW4gdGhlIHRyZWUgd2UgYWxzbyBuZWVkIHRvXG5cdFx0XHQvLyBhZGQgdGhlICdETicgcm9sIHRvIGl0LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBpZ25vcmVkIGV2ZW4gaWYgaXRzIGluIHRlbXBDb2xsZWN0aW9uLlxuXHRcdFx0dGVtcENvbGxlY3Rpb24gPSBfLmVhY2godGVtcENvbGxlY3Rpb24sZnVuY3Rpb24oYXV4KSB7XG5cdFx0XHRcdGlmIChhdXguaGFzRnVuZGluZ3MgPT09IHRydWUgJiYgYXV4LnJvbGVzSWRzICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGF1eC5yb2xlc0lkcy5wdXNoKGRvbm9yUm9sZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGVtcENvbGxlY3Rpb24gPSBfLmZpbHRlcih0ZW1wQ29sbGVjdGlvbixmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0cmV0dXJuIF8uY29udGFpbnMoaWRzVG9Kb2luLCB2YWwuaWQpO1xuXHRcdFx0fSk7XG5cdFx0XHRwYXJlbnQuc2V0KGtleUZvckNvbGxlY3Rpb25EZXN0aW5hdGlvbiwgdGVtcENvbGxlY3Rpb24pO1xuXHRcdH0pO1xuXHR9XG59KTtcbiIsIi8qISBqUXVlcnkgVUkgLSB2MS4xMC40IC0gMjAxNC0wMS0xN1xuKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4qIEluY2x1ZGVzOiBqcXVlcnkudWkuZGF0ZXBpY2tlci1hZi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItYXItRFouanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWFyLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1hei5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItYmUuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWJnLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1icy5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItY2EuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWNzLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1jeS1HQi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZGEuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWRlLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1lbC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZW4tQVUuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWVuLUdCLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1lbi1OWi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZW8uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWVzLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1ldC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZXUuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWZhLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1maS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZm8uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWZyLUNBLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1mci1DSC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZnIuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWdsLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1oZS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItaGkuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWhyLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1odS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItaHkuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWlkLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1pcy5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItaXQuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWphLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1rYS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXIta2suanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWttLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1rby5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXIta3kuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWxiLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1sdC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItbHYuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLW1rLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1tbC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItbXMuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLW5iLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1ubC1CRS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItbmwuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLW5uLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1uby5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItcGwuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXB0LUJSLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1wdC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItcm0uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXJvLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1ydS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItc2suanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXNsLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1zcS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItc3ItU1IuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXNyLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1zdi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItdGEuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXRoLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci10ai5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItdHIuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXVrLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci12aS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItemgtQ04uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXpoLUhLLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci16aC1UVy5qc1xuKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVQgKi9cbi8qIEFmcmlrYWFucyBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFJlbmllciBQcmV0b3JpdXMuICovXG4vKkFMVEVSRUQgRk9SIEFNUCAtLSBBRERFRCBURVRVTSBMT0NBTEUqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2FmJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnU2VsZWt0ZWVyJyxcblx0XHRwcmV2VGV4dDogJ1ZvcmlnZScsXG5cdFx0bmV4dFRleHQ6ICdWb2xnZW5kZScsXG5cdFx0Y3VycmVudFRleHQ6ICdWYW5kYWcnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyaWUnLCdGZWJydWFyaWUnLCdNYWFydCcsJ0FwcmlsJywnTWVpJywnSnVuaWUnLFxuXHRcdCdKdWxpZScsJ0F1Z3VzdHVzJywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vdmVtYmVyJywnRGVzZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNcnQnLCAnQXByJywgJ01laScsICdKdW4nLFxuXHRcdCdKdWwnLCAnQXVnJywgJ1NlcCcsICdPa3QnLCAnTm92JywgJ0RlcyddLFxuXHRcdGRheU5hbWVzOiBbJ1NvbmRhZycsICdNYWFuZGFnJywgJ0RpbnNkYWcnLCAnV29lbnNkYWcnLCAnRG9uZGVyZGFnJywgJ1ZyeWRhZycsICdTYXRlcmRhZyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU29uJywgJ01hYScsICdEaW4nLCAnV29lJywgJ0RvbicsICdWcnknLCAnU2F0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU28nLCdNYScsJ0RpJywnV28nLCdEbycsJ1ZyJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydhZiddKTtcbn0pO1xuXG4vKiBBbGdlcmlhbiBBcmFiaWMgVHJhbnNsYXRpb24gZm9yIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uIChjYW4gYmUgdXNlZCBmb3IgVHVuaXNpYSkqL1xuLyogTW9oYW1lZCBDaGVyaWYgQk9VQ0hFTEFHSEVNIC0tIGNoZXJpZmJvdWNoZWxhZ2hlbUB5YWhvby5mciAqL1xuXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnYXItRFonXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfYpdi62YTYp9mCJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO9in2YTYs9in2KjZgicsXG5cdFx0bmV4dFRleHQ6ICfYp9mE2KrYp9mE2YomI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn2KfZhNmK2YjZhScsXG5cdFx0bW9udGhOYW1lczogWyfYrNin2YbZgdmKJywgJ9mB2YrZgdix2YonLCAn2YXYp9ix2LMnLCAn2KPZgdix2YrZhCcsICfZhdin2YonLCAn2KzZiNin2YYnLFxuXHRcdCfYrNmI2YrZhNmK2KknLCAn2KPZiNiqJywgJ9iz2KjYqtmF2KjYsScsJ9ij2YPYqtmI2KjYsScsICfZhtmI2YHZhdio2LEnLCAn2K/Zitiz2YXYqNixJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJzEwJywgJzExJywgJzEyJ10sXG5cdFx0ZGF5TmFtZXM6IFsn2KfZhNij2K3YrycsICfYp9mE2KfYq9mG2YrZhicsICfYp9mE2KvZhNin2KvYp9ihJywgJ9in2YTYo9ix2KjYudin2KEnLCAn2KfZhNiu2YXZitizJywgJ9in2YTYrNmF2LnYqScsICfYp9mE2LPYqNiqJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfYp9mE2KPYrdivJywgJ9in2YTYp9ir2YbZitmGJywgJ9in2YTYq9mE2KfYq9in2KEnLCAn2KfZhNij2LHYqNi52KfYoScsICfYp9mE2K7ZhdmK2LMnLCAn2KfZhNis2YXYudipJywgJ9in2YTYs9io2KonXSxcblx0XHRkYXlOYW1lc01pbjogWyfYp9mE2KPYrdivJywgJ9in2YTYp9ir2YbZitmGJywgJ9in2YTYq9mE2KfYq9in2KEnLCAn2KfZhNij2LHYqNi52KfYoScsICfYp9mE2K7ZhdmK2LMnLCAn2KfZhNis2YXYudipJywgJ9in2YTYs9io2KonXSxcblx0XHR3ZWVrSGVhZGVyOiAn2KPYs9io2YjYuScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogNixcbiAgXHRcdGlzUlRMOiB0cnVlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydhci1EWiddKTtcbn0pO1xuXG4vKiBBcmFiaWMgVHJhbnNsYXRpb24gZm9yIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBLaGFsZWQgQWxob3VyYW5pIC0tIG1lQGtoYWxlZGFsaG91cmFuaS5jb20gKi9cbi8qIE5PVEU6IG1vbnRoTmFtZXMgYXJlIHRoZSBvcmlnaW5hbCBtb250aHMgbmFtZXMgYW5kIHRoZXkgYXJlIHRoZSBBcmFiaWMgbmFtZXMsIG5vdCB0aGUgbmV3IG1vbnRocyBuYW1lINmB2KjYsdin2YrYsSAtINmK2YbYp9mK2LEgYW5kIHRoZXJlIGlzbid0IGFueSBBcmFiaWMgcm9vdHMgZm9yIHRoZXNlIG1vbnRocyAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2FyJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn2KXYutmE2KfZgicsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzvYp9mE2LPYp9io2YInLFxuXHRcdG5leHRUZXh0OiAn2KfZhNiq2KfZhNmKJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9in2YTZitmI2YUnLFxuXHRcdG1vbnRoTmFtZXM6IFsn2YPYp9mG2YjZhiDYp9mE2KvYp9mG2YonLCAn2LTYqNin2LcnLCAn2KLYsNin2LEnLCAn2YbZitiz2KfZhicsICfZhdin2YrZiCcsICfYrdiy2YrYsdin2YYnLFxuXHRcdCfYqtmF2YjYsicsICfYotioJywgJ9ij2YrZhNmI2YQnLFx0J9iq2LTYsdmK2YYg2KfZhNij2YjZhCcsICfYqti02LHZitmGINin2YTYq9in2YbZiicsICfZg9in2YbZiNmGINin2YTYo9mI2YQnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnMTAnLCAnMTEnLCAnMTInXSxcblx0XHRkYXlOYW1lczogWyfYp9mE2KPYrdivJywgJ9in2YTYp9ir2YbZitmGJywgJ9in2YTYq9mE2KfYq9in2KEnLCAn2KfZhNij2LHYqNi52KfYoScsICfYp9mE2K7ZhdmK2LMnLCAn2KfZhNis2YXYudipJywgJ9in2YTYs9io2KonXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9in2YTYo9it2K8nLCAn2KfZhNin2KvZhtmK2YYnLCAn2KfZhNir2YTYp9ir2KfYoScsICfYp9mE2KPYsdio2LnYp9ihJywgJ9in2YTYrtmF2YrYsycsICfYp9mE2KzZhdi52KknLCAn2KfZhNiz2KjYqiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9itJywgJ9mGJywgJ9irJywgJ9ixJywgJ9iuJywgJ9isJywgJ9izJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9ij2LPYqNmI2LknLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDYsXG4gIFx0XHRpc1JUTDogdHJ1ZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnYXInXSk7XG59KTtcblxuLyogQXplcmJhaWphbmkgKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEphbWlsIE5hamFmb3YgKG5lY2Vmb3YzM0BnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpIHtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydheiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0JhxJ9sYScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztHZXJpJyxcblx0XHRuZXh0VGV4dDogJ8SwcsmZbGkmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnQnVnw7xuJyxcblx0XHRtb250aE5hbWVzOiBbJ1lhbnZhcicsJ0ZldnJhbCcsJ01hcnQnLCdBcHJlbCcsJ01heScsJ8SweXVuJyxcblx0XHQnxLB5dWwnLCdBdnF1c3QnLCdTZW50eWFicicsJ09rdHlhYnInLCdOb3lhYnInLCdEZWthYnInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnWWFuJywnRmV2JywnTWFyJywnQXByJywnTWF5JywnxLB5dW4nLFxuXHRcdCfEsHl1bCcsJ0F2cScsJ1NlbicsJ09rdCcsJ05veScsJ0RlayddLFxuXHRcdGRheU5hbWVzOiBbJ0JhemFyJywnQmF6YXIgZXJ0yZlzaScsJ8OHyZlyxZ/JmW5iyZkgYXjFn2FtxLEnLCfDh8mZcsWfyZluYsmZJywnQ8O8bcmZIGF4xZ9hbcSxJywnQ8O8bcmZJywnxZ7JmW5iyZknXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ0InLCdCZScsJ8OHYScsJ8OHJywnQ2EnLCdDJywnxZ4nXSxcblx0XHRkYXlOYW1lc01pbjogWydCJywnQicsJ8OHJywn0KEnLCfDhycsJ0MnLCfFniddLFxuXHRcdHdlZWtIZWFkZXI6ICdIZicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2F6J10pO1xufSk7XG5cbi8qIEJlbGFydXNpYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBQYXZlbCBTZWxpdHNrYXMgPHAuc2VsaXRza2FzQGdtYWlsLmNvbT4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydiZSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9CX0LDRh9GL0L3RltGG0YwnLFxuXHRcdHByZXZUZXh0OiAnJmxhcnI70J/QsNC/0Y/RgC4nLFxuXHRcdG5leHRUZXh0OiAn0J3QsNGB0YIuJnJhcnI7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9Ch0ZHQvdGM0L3RjycsXG5cdFx0bW9udGhOYW1lczogWyfQodGC0YPQtNC30LXQvdGMJywn0JvRjtGC0YsnLCfQodCw0LrQsNCy0ZbQuicsJ9Ca0YDQsNGB0LDQstGW0LonLCfQotGA0LDQstC10L3RjCcsJ9Cn0Y3RgNCy0LXQvdGMJyxcblx0XHQn0JvRltC/0LXQvdGMJywn0JbQvdGW0LLQtdC90YwnLCfQktC10YDQsNGB0LXQvdGMJywn0JrQsNGB0YLRgNGL0YfQvdGW0LonLCfQm9GW0YHRgtCw0L/QsNC0Jywn0KHRjNC90LXQttCw0L3RjCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfQodGC0YMnLCfQm9GO0YInLCfQodCw0LonLCfQmtGA0LAnLCfQotGA0LAnLCfQp9GN0YAnLFxuXHRcdCfQm9GW0L8nLCfQltC90ZYnLCfQktC10YAnLCfQmtCw0YEnLCfQm9GW0YEnLCfQodGM0L0nXSxcblx0XHRkYXlOYW1lczogWyfQvdGP0LTQt9C10LvRjycsJ9C/0LDQvdGP0LTQt9C10LvQsNC6Jywn0LDRntGC0L7RgNCw0LonLCfRgdC10YDQsNC00LAnLCfRh9Cw0YbRjNCy0LXRgCcsJ9C/0Y/RgtC90ZbRhtCwJywn0YHRg9Cx0L7RgtCwJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfQvdC00LcnLCfQv9C90LQnLCfQsNGe0YInLCfRgdGA0LQnLCfRh9GG0LInLCfQv9GC0L0nLCfRgdCx0YInXSxcblx0XHRkYXlOYW1lc01pbjogWyfQndC0Jywn0J/QvScsJ9CQ0Z4nLCfQodGAJywn0KfRhicsJ9Cf0YInLCfQodCxJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9Ci0LQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydiZSddKTtcbn0pO1xuXG4vKiBCdWxnYXJpYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBTdG95YW4gS3lvc2V2IChodHRwOi8vc3Zlc3Qub3JnKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydiZyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9C30LDRgtCy0L7RgNC4Jyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO9C90LDQt9Cw0LQnLFxuXHRcdG5leHRUZXh0OiAn0L3QsNC/0YDQtdC0JiN4M0U7Jyxcblx0XHRuZXh0QmlnVGV4dDogJyYjeDNFOyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfQtNC90LXRgScsXG5cdFx0bW9udGhOYW1lczogWyfQr9C90YPQsNGA0LgnLCfQpNC10LLRgNGD0LDRgNC4Jywn0JzQsNGA0YInLCfQkNC/0YDQuNC7Jywn0JzQsNC5Jywn0K7QvdC4Jyxcblx0XHQn0K7Qu9C4Jywn0JDQstCz0YPRgdGCJywn0KHQtdC/0YLQtdC80LLRgNC4Jywn0J7QutGC0L7QvNCy0YDQuCcsJ9Cd0L7QtdC80LLRgNC4Jywn0JTQtdC60LXQvNCy0YDQuCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfQr9C90YMnLCfQpNC10LInLCfQnNCw0YAnLCfQkNC/0YAnLCfQnNCw0LknLCfQrtC90LgnLFxuXHRcdCfQrtC70LgnLCfQkNCy0LMnLCfQodC10L8nLCfQntC60YInLCfQndC+0LInLCfQlNC10LonXSxcblx0XHRkYXlOYW1lczogWyfQndC10LTQtdC70Y8nLCfQn9C+0L3QtdC00LXQu9C90LjQuicsJ9CS0YLQvtGA0L3QuNC6Jywn0KHRgNGP0LTQsCcsJ9Cn0LXRgtCy0YrRgNGC0YrQuicsJ9Cf0LXRgtGK0LonLCfQodGK0LHQvtGC0LAnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9Cd0LXQtCcsJ9Cf0L7QvScsJ9CS0YLQvicsJ9Ch0YDRjycsJ9Cn0LXRgicsJ9Cf0LXRgicsJ9Ch0YrQsSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9Cd0LUnLCfQn9C+Jywn0JLRgicsJ9Ch0YAnLCfQp9C1Jywn0J/QtScsJ9Ch0YonXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydiZyddKTtcbn0pO1xuXG4vKiBCb3NuaWFuIGkxOG4gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBLZW5hbiBLb25qby4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydicyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1phdHZvcmknLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7Jyxcblx0XHRuZXh0VGV4dDogJyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdEYW5hcycsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXInLCdGZWJydWFyJywnTWFydCcsJ0FwcmlsJywnTWFqJywnSnVuaScsXG5cdFx0J0p1bGknLCdBdWd1c3QnLCdTZXB0ZW1iYXInLCdPa3RvYmFyJywnTm92ZW1iYXInLCdEZWNlbWJhciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNYWonLCdKdW4nLFxuXHRcdCdKdWwnLCdBdWcnLCdTZXAnLCdPa3QnLCdOb3YnLCdEZWMnXSxcblx0XHRkYXlOYW1lczogWydOZWRlbGphJywnUG9uZWRlbGphaycsJ1V0b3JhaycsJ1NyaWplZGEnLCfEjGV0dnJ0YWsnLCdQZXRhaycsJ1N1Ym90YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnTmVkJywnUG9uJywnVXRvJywnU3JpJywnxIxldCcsJ1BldCcsJ1N1YiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ05lJywnUG8nLCdVdCcsJ1NyJywnxIxlJywnUGUnLCdTdSddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2JzJ10pO1xufSk7XG5cbi8qIEluaWNpYWxpdHphY2nDsyBlbiBjYXRhbMOgIHBlciBhIGwnZXh0ZW5zacOzICdVSSBkYXRlIHBpY2tlcicgcGVyIGpRdWVyeS4gKi9cbi8qIFdyaXRlcnM6IChqb2FuLmxlb25AZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydjYSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1RhbmNhJyxcblx0XHRwcmV2VGV4dDogJ0FudGVyaW9yJyxcblx0XHRuZXh0VGV4dDogJ1NlZ8O8ZW50Jyxcblx0XHRjdXJyZW50VGV4dDogJ0F2dWknLFxuXHRcdG1vbnRoTmFtZXM6IFsnZ2VuZXInLCdmZWJyZXInLCdtYXLDpycsJ2FicmlsJywnbWFpZycsJ2p1bnknLFxuXHRcdCdqdWxpb2wnLCdhZ29zdCcsJ3NldGVtYnJlJywnb2N0dWJyZScsJ25vdmVtYnJlJywnZGVzZW1icmUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnZ2VuJywnZmViJywnbWFyw6cnLCdhYnInLCdtYWlnJywnanVueScsXG5cdFx0J2p1bCcsJ2FnJywnc2V0Jywnb2N0Jywnbm92JywnZGVzJ10sXG5cdFx0ZGF5TmFtZXM6IFsnZGl1bWVuZ2UnLCdkaWxsdW5zJywnZGltYXJ0cycsJ2RpbWVjcmVzJywnZGlqb3VzJywnZGl2ZW5kcmVzJywnZGlzc2FidGUnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ2RnJywnZGwnLCdkdCcsJ2RjJywnZGonLCdkdicsJ2RzJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnZGcnLCdkbCcsJ2R0JywnZGMnLCdkaicsJ2R2JywnZHMnXSxcblx0XHR3ZWVrSGVhZGVyOiAnU2V0Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnY2EnXSk7XG59KTtcblxuLyogQ3plY2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBUb21hcyBNdWxsZXIgKHRvbWFzQHRvbWFzLW11bGxlci5uZXQpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2NzJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnWmF2xZnDrXQnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7RMWZw612ZScsXG5cdFx0bmV4dFRleHQ6ICdQb3pkxJtqaSYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdOeW7DrScsXG5cdFx0bW9udGhOYW1lczogWydsZWRlbicsJ8O6bm9yJywnYsWZZXplbicsJ2R1YmVuJywna3bEm3RlbicsJ8SNZXJ2ZW4nLFxuXHRcdCfEjWVydmVuZWMnLCdzcnBlbicsJ3rDocWZw60nLCfFmcOtamVuJywnbGlzdG9wYWQnLCdwcm9zaW5lYyddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydsZWQnLCfDum5vJywnYsWZZScsJ2R1YicsJ2t2xJsnLCfEjWVyJyxcblx0XHQnxI12YycsJ3NycCcsJ3rDocWZJywnxZnDrWonLCdsaXMnLCdwcm8nXSxcblx0XHRkYXlOYW1lczogWyduZWTEm2xlJywgJ3BvbmTEm2zDrScsICfDunRlcsO9JywgJ3N0xZllZGEnLCAnxI10dnJ0ZWsnLCAncMOhdGVrJywgJ3NvYm90YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnbmUnLCAncG8nLCAnw7p0JywgJ3N0JywgJ8SNdCcsICdww6EnLCAnc28nXSxcblx0XHRkYXlOYW1lc01pbjogWyduZScsJ3BvJywnw7p0Jywnc3QnLCfEjXQnLCdww6EnLCdzbyddLFxuXHRcdHdlZWtIZWFkZXI6ICdUw71kJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnY3MnXSk7XG59KTtcblxuLyogV2Vsc2gvVUsgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBXaWxsaWFtIEdyaWZmaXRocy4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydjeS1HQiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0RvbmUnLFxuXHRcdHByZXZUZXh0OiAnUHJldicsXG5cdFx0bmV4dFRleHQ6ICdOZXh0Jyxcblx0XHRjdXJyZW50VGV4dDogJ1RvZGF5Jyxcblx0XHRtb250aE5hbWVzOiBbJ0lvbmF3cicsJ0Nod2Vmcm9yJywnTWF3cnRoJywnRWJyaWxsJywnTWFpJywnTWVoZWZpbicsXG5cdFx0J0dvcmZmZW5uYWYnLCdBd3N0JywnTWVkaScsJ0h5ZHJlZicsJ1RhY2h3ZWRkJywnUmhhZ2Z5ciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydJb24nLCAnQ2h3JywgJ01hdycsICdFYnInLCAnTWFpJywgJ01laCcsXG5cdFx0J0dvcicsICdBd3MnLCAnTWVkJywgJ0h5ZCcsICdUYWMnLCAnUmhhJ10sXG5cdFx0ZGF5TmFtZXM6IFsnRHlkZCBTdWwnLCAnRHlkZCBMbHVuJywgJ0R5ZGQgTWF3cnRoJywgJ0R5ZGQgTWVyY2hlcicsICdEeWRkIElhdScsICdEeWRkIEd3ZW5lcicsICdEeWRkIFNhZHdybiddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3VsJywgJ0xsdScsICdNYXcnLCAnTWVyJywgJ0lhdScsICdHd2UnLCAnU2FkJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdMbCcsJ01hJywnTWUnLCdJYScsJ0d3JywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV3knLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydjeS1HQiddKTtcbn0pO1xuXG4vKiBEYW5pc2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBKYW4gQ2hyaXN0ZW5zZW4gKCBkZWxldGVzdHVmZkBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2RhJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnTHVrJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO0ZvcnJpZ2UnLFxuXHRcdG5leHRUZXh0OiAnTsOmc3RlJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0lkYWcnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyJywnRmVicnVhcicsJ01hcnRzJywnQXByaWwnLCdNYWonLCdKdW5pJyxcblx0XHQnSnVsaScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09rdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01haicsJ0p1bicsXG5cdFx0J0p1bCcsJ0F1ZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ1PDuG5kYWcnLCdNYW5kYWcnLCdUaXJzZGFnJywnT25zZGFnJywnVG9yc2RhZycsJ0ZyZWRhZycsJ0zDuHJkYWcnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1PDuG4nLCdNYW4nLCdUaXInLCdPbnMnLCdUb3InLCdGcmUnLCdMw7hyJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU8O4JywnTWEnLCdUaScsJ09uJywnVG8nLCdGcicsJ0zDuCddLFxuXHRcdHdlZWtIZWFkZXI6ICdVZ2UnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC1tbS15eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydkYSddKTtcbn0pO1xuXG4vKiBHZXJtYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBNaWxpYW4gV29sZmYgKG1haWxAbWlsaWFudy5kZSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZGUnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdTY2hsaWXDn2VuJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO1p1csO8Y2snLFxuXHRcdG5leHRUZXh0OiAnVm9yJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0hldXRlJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcicsJ0ZlYnJ1YXInLCdNw6RyeicsJ0FwcmlsJywnTWFpJywnSnVuaScsXG5cdFx0J0p1bGknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPa3RvYmVyJywnTm92ZW1iZXInLCdEZXplbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNw6RyJywnQXByJywnTWFpJywnSnVuJyxcblx0XHQnSnVsJywnQXVnJywnU2VwJywnT2t0JywnTm92JywnRGV6J10sXG5cdFx0ZGF5TmFtZXM6IFsnU29ubnRhZycsJ01vbnRhZycsJ0RpZW5zdGFnJywnTWl0dHdvY2gnLCdEb25uZXJzdGFnJywnRnJlaXRhZycsJ1NhbXN0YWcnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1NvJywnTW8nLCdEaScsJ01pJywnRG8nLCdGcicsJ1NhJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU28nLCdNbycsJ0RpJywnTWknLCdEbycsJ0ZyJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnS1cnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydkZSddKTtcbn0pO1xuXG4vKiBHcmVlayAoZWwpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQWxleCBDaWNvdmljIChodHRwOi8vd3d3LmFsZXhjaWNvdmljLmNvbSkgKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ86azrvOtc6vz4POuc68zr8nLFxuXHRcdHByZXZUZXh0OiAnzqDPgc6/zrfOs86/z43OvM61zr3Ov8+CJyxcblx0XHRuZXh0VGV4dDogJ86Vz4DPjM68zrXOvc6/z4InLFxuXHRcdGN1cnJlbnRUZXh0OiAnzqTPgc6tz4fPic69IM6czq7Ovc6xz4InLFxuXHRcdG1vbnRoTmFtZXM6IFsnzpnOsc69zr/Phc6sz4HOuc6/z4InLCfOps61zrLPgc6/z4XOrM+BzrnOv8+CJywnzpzOrM+Bz4TOuc6/z4InLCfOkc+Az4HOr867zrnOv8+CJywnzpzOrM65zr/PgicsJ86Zzr/Pjc69zrnOv8+CJyxcblx0XHQnzpnOv8+NzrvOuc6/z4InLCfOkc+NzrPOv8+Fz4PPhM6/z4InLCfOo861z4DPhM6tzrzOss+BzrnOv8+CJywnzp/Ous+Ez47Oss+BzrnOv8+CJywnzp3Ov86tzrzOss+BzrnOv8+CJywnzpTOtc66zq3OvM6yz4HOuc6/z4InXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnzpnOsc69JywnzqbOtc6yJywnzpzOsc+BJywnzpHPgM+BJywnzpzOsc65JywnzpnOv8+Fzr0nLFxuXHRcdCfOmc6/z4XOuycsJ86Rz4XOsycsJ86jzrXPgCcsJ86fzrrPhCcsJ86dzr/OtScsJ86UzrXOuiddLFxuXHRcdGRheU5hbWVzOiBbJ86az4XPgc65zrHOus6uJywnzpTOtc+Fz4TOrc+BzrEnLCfOpM+Bzq/PhM63JywnzqTOtc+EzqzPgc+EzrcnLCfOoM6tzrzPgM+EzrcnLCfOoM6xz4HOsc+DzrrOtc+Fzq4nLCfOo86szrLOss6xz4TOvyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnzprPhc+BJywnzpTOtc+FJywnzqTPgc65JywnzqTOtc+EJywnzqDOtc68JywnzqDOsc+BJywnzqPOsc6yJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnzprPhScsJ86UzrUnLCfOpM+BJywnzqTOtScsJ86gzrUnLCfOoM6xJywnzqPOsSddLFxuXHRcdHdlZWtIZWFkZXI6ICfOlc6yzrQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbCddKTtcbn0pO1xuXG4vKiBFbmdsaXNoL0F1c3RyYWxpYSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBCYXNlZCBvbiB0aGUgZW4tR0IgaW5pdGlhbGlzYXRpb24uICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZW4tQVUnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdEb25lJyxcblx0XHRwcmV2VGV4dDogJ1ByZXYnLFxuXHRcdG5leHRUZXh0OiAnTmV4dCcsXG5cdFx0Y3VycmVudFRleHQ6ICdUb2RheScsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXJ5JywnRmVicnVhcnknLCdNYXJjaCcsJ0FwcmlsJywnTWF5JywnSnVuZScsXG5cdFx0J0p1bHknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPY3RvYmVyJywnTm92ZW1iZXInLCdEZWNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsXG5cdFx0J0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1N1JywnTW8nLCdUdScsJ1dlJywnVGgnLCdGcicsJ1NhJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1drJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZW4tQVUnXSk7XG59KTtcblxuLyogRW5nbGlzaC9VSyBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFN0dWFydC4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbi1HQiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0RvbmUnLFxuXHRcdHByZXZUZXh0OiAnUHJldicsXG5cdFx0bmV4dFRleHQ6ICdOZXh0Jyxcblx0XHRjdXJyZW50VGV4dDogJ1RvZGF5Jyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcnknLCdGZWJydWFyeScsJ01hcmNoJywnQXByaWwnLCdNYXknLCdKdW5lJyxcblx0XHQnSnVseScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09jdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcblx0XHQnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdNbycsJ1R1JywnV2UnLCdUaCcsJ0ZyJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbi1HQiddKTtcbn0pO1xuXG4vKiBFbmdsaXNoL05ldyBaZWFsYW5kIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIEJhc2VkIG9uIHRoZSBlbi1HQiBpbml0aWFsaXNhdGlvbi4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbi1OWiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0RvbmUnLFxuXHRcdHByZXZUZXh0OiAnUHJldicsXG5cdFx0bmV4dFRleHQ6ICdOZXh0Jyxcblx0XHRjdXJyZW50VGV4dDogJ1RvZGF5Jyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcnknLCdGZWJydWFyeScsJ01hcmNoJywnQXByaWwnLCdNYXknLCdKdW5lJyxcblx0XHQnSnVseScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09jdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcblx0XHQnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdNbycsJ1R1JywnV2UnLCdUaCcsJ0ZyJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbi1OWiddKTtcbn0pO1xuXG4vKiBFc3BlcmFudG8gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBPbGl2aWVyIE0uIChvbGl2aWVyd2ViQGlmcmFuY2UuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0Zlcm1pJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO0FudGEnLFxuXHRcdG5leHRUZXh0OiAnU2VrdiYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdOdW5hJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcm8nLCdGZWJydWFybycsJ01hcnRvJywnQXByaWxvJywnTWFqbycsJ0p1bmlvJyxcblx0XHQnSnVsaW8nLCdBxa1ndXN0bycsJ1NlcHRlbWJybycsJ09rdG9icm8nLCdOb3ZlbWJybycsJ0RlY2VtYnJvJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01haicsJ0p1bicsXG5cdFx0J0p1bCcsJ0HFrWcnLCdTZXAnLCdPa3QnLCdOb3YnLCdEZWMnXSxcblx0XHRkYXlOYW1lczogWydEaW1hbsSJbycsJ0x1bmRvJywnTWFyZG8nLCdNZXJrcmVkbycsJ8S0YcWtZG8nLCdWZW5kcmVkbycsJ1NhYmF0byddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnRGltJywnTHVuJywnTWFyJywnTWVyJywnxLRhxa0nLCdWZW4nLCdTYWInXSxcblx0XHRkYXlOYW1lc01pbjogWydEaScsJ0x1JywnTWEnLCdNZScsJ8S0YScsJ1ZlJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnU2InLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbyddKTtcbn0pO1xuXG4vKiBJbmljaWFsaXphY2nDs24gZW4gZXNwYcOxb2wgcGFyYSBsYSBleHRlbnNpw7NuICdVSSBkYXRlIHBpY2tlcicgcGFyYSBqUXVlcnkuICovXG4vKiBUcmFkdWNpZG8gcG9yIFZlc3RlciAoeHZlc3RlckBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VzJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnQ2VycmFyJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO0FudCcsXG5cdFx0bmV4dFRleHQ6ICdTaWcmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnSG95Jyxcblx0XHRtb250aE5hbWVzOiBbJ2VuZXJvJywnZmVicmVybycsJ21hcnpvJywnYWJyaWwnLCdtYXlvJywnanVuaW8nLFxuXHRcdCdqdWxpbycsJ2Fnb3N0bycsJ3NlcHRpZW1icmUnLCdvY3R1YnJlJywnbm92aWVtYnJlJywnZGljaWVtYnJlJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2VuZScsJ2ZlYicsJ21hcicsJ2FicicsJ21heScsJ2p1bicsXG5cdFx0J2p1bCcsJ29nbycsJ3NlcCcsJ29jdCcsJ25vdicsJ2RpYyddLFxuXHRcdGRheU5hbWVzOiBbJ2RvbWluZ28nLCdsdW5lcycsJ21hcnRlcycsJ21pw6lyY29sZXMnLCdqdWV2ZXMnLCd2aWVybmVzJywnc8OhYmFkbyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnZG9tJywnbHVuJywnbWFyJywnbWnDqScsJ2p1dicsJ3ZpZScsJ3PDoWInXSxcblx0XHRkYXlOYW1lc01pbjogWydEJywnTCcsJ00nLCdYJywnSicsJ1YnLCdTJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1NtJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZXMnXSk7XG59KTtcblxuLyogRXN0b25pYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBNYXJ0IFPDtW1lcm1hYSAobXJ0cy5weWRldiBhdCBnbWFpbCBjb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2V0J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnU3VsZ2UnLFxuXHRcdHByZXZUZXh0OiAnRWVsbmV2Jyxcblx0XHRuZXh0VGV4dDogJ0rDpHJnbmV2Jyxcblx0XHRjdXJyZW50VGV4dDogJ1TDpG5hJyxcblx0XHRtb250aE5hbWVzOiBbJ0phYW51YXInLCdWZWVicnVhcicsJ03DpHJ0cycsJ0FwcmlsbCcsJ01haScsJ0p1dW5pJyxcblx0XHQnSnV1bGknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPa3Rvb2JlcicsJ05vdmVtYmVyJywnRGV0c2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phYW4nLCAnVmVlYnInLCAnTcOkcnRzJywgJ0FwcicsICdNYWknLCAnSnV1bmknLFxuXHRcdCdKdXVsaScsICdBdWcnLCAnU2VwdCcsICdPa3QnLCAnTm92JywgJ0RldHMnXSxcblx0XHRkYXlOYW1lczogWydQw7xoYXDDpGV2JywgJ0VzbWFzcMOkZXYnLCAnVGVpc2lww6RldicsICdLb2xtYXDDpGV2JywgJ05lbGphcMOkZXYnLCAnUmVlZGUnLCAnTGF1cMOkZXYnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1DDvGhhcCcsICdFc21hc3AnLCAnVGVpc2lwJywgJ0tvbG1hcCcsICdOZWxqYXAnLCAnUmVlZGUnLCAnTGF1cCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1AnLCdFJywnVCcsJ0snLCdOJywnUicsJ0wnXSxcblx0XHR3ZWVrSGVhZGVyOiAnbsOkZCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2V0J10pO1xufSk7XG5cbi8qIEV1c2thcmFrbyBvaW5hcnJpYSAnVUkgZGF0ZSBwaWNrZXInIGpxdWVyeS1rbyBleHRlbnRzaW9hcmVudHphdCAqL1xuLyogS2FycmlrYXMtZWsgaXR6dWxpYSAoa2FycmlrYXNAa2FycmlrYXMuY29tKSAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2V1J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRWdpbmEnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7QXVyJyxcblx0XHRuZXh0VGV4dDogJ0h1ciYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdHYXVyJyxcblx0XHRtb250aE5hbWVzOiBbJ3VydGFycmlsYScsJ290c2FpbGEnLCdtYXJ0eG9hJywnYXBpcmlsYScsJ21haWF0emEnLCdla2FpbmEnLFxuXHRcdFx0J3V6dGFpbGEnLCdhYnV6dHVhJywnaXJhaWxhJywndXJyaWEnLCdhemFyb2EnLCdhYmVuZHVhJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ3VydC4nLCdvdHMuJywnbWFyLicsJ2FwaS4nLCdtYWkuJywnZWthLicsXG5cdFx0XHQndXp0LicsJ2FidS4nLCdpcmEuJywndXJyLicsJ2F6YS4nLCdhYmUuJ10sXG5cdFx0ZGF5TmFtZXM6IFsnaWdhbmRlYScsJ2FzdGVsZWhlbmEnLCdhc3RlYXJ0ZWEnLCdhc3RlYXprZW5hJywnb3N0ZWd1bmEnLCdvc3RpcmFsYScsJ2xhcnVuYmF0YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnaWcuJywnYWwuJywnYXIuJywnYXouJywnb2cuJywnb2wuJywnbHIuJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnaWcnLCdhbCcsJ2FyJywnYXonLCdvZycsJ29sJywnbHInXSxcblx0XHR3ZWVrSGVhZGVyOiAnQXMnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS1tbS1kZCcsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydldSddKTtcbn0pO1xuXG4vKiBQZXJzaWFuIChGYXJzaSkgVHJhbnNsYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogSmF2YWQgTW93bGFuZXpoYWQgLS0gam1vd2xhQGdtYWlsLmNvbSAqL1xuLyogSmFsYWxpIGNhbGVuZGFyIHNob3VsZCBzdXBwb3J0ZWQgc29vbiEgKEl0cyBpbXBsZW1lbnRlZCBidXQgSSBoYXZlIHRvIHRlc3QgaXQpICovXG5qUXVlcnkoZnVuY3Rpb24oJCkge1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ZhJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn2KjYs9iq2YYnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M72YLYqNmE24wnLFxuXHRcdG5leHRUZXh0OiAn2KjYudiv24wmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn2KfZhdix2YjYsicsXG5cdFx0bW9udGhOYW1lczogW1xuXHRcdFx0J9mB2LHZiNix2K/ZitmGJyxcblx0XHRcdCfYp9ix2K/Zitio2YfYtNiqJyxcblx0XHRcdCfYrtix2K/Yp9ivJyxcblx0XHRcdCfYqtmK2LEnLFxuXHRcdFx0J9mF2LHYr9in2K8nLFxuXHRcdFx0J9i02YfYsdmK2YjYsScsXG5cdFx0XHQn2YXZh9ixJyxcblx0XHRcdCfYotio2KfZhicsXG5cdFx0XHQn2KLYsNixJyxcblx0XHRcdCfYr9uMJyxcblx0XHRcdCfYqNmH2YXZhicsXG5cdFx0XHQn2KfYs9mB2YbYrydcblx0XHRdLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWycxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknLCcxMCcsJzExJywnMTInXSxcblx0XHRkYXlOYW1lczogW1xuXHRcdFx0J9mK2qnYtNmG2KjZhycsXG5cdFx0XHQn2K/ZiNi02YbYqNmHJyxcblx0XHRcdCfYs9mH4oCM2LTZhtio2YcnLFxuXHRcdFx0J9qG2YfYp9ix2LTZhtio2YcnLFxuXHRcdFx0J9m+2YbYrNi02YbYqNmHJyxcblx0XHRcdCfYrNmF2LnZhycsXG5cdFx0XHQn2LTZhtio2YcnXG5cdFx0XSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbXG5cdFx0XHQn24wnLFxuXHRcdFx0J9ivJyxcblx0XHRcdCfYsycsXG5cdFx0XHQn2oYnLFxuXHRcdFx0J9m+Jyxcblx0XHRcdCfYrCcsXG5cdFx0XHQn2LQnXG5cdFx0XSxcblx0XHRkYXlOYW1lc01pbjogW1xuXHRcdFx0J9uMJyxcblx0XHRcdCfYrycsXG5cdFx0XHQn2LMnLFxuXHRcdFx0J9qGJyxcblx0XHRcdCfZvicsXG5cdFx0XHQn2KwnLFxuXHRcdFx0J9i0J1xuXHRcdF0sXG5cdFx0d2Vla0hlYWRlcjogJ9mH2YEnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS9tbS9kZCcsXG5cdFx0Zmlyc3REYXk6IDYsXG5cdFx0aXNSVEw6IHRydWUsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ZhJ10pO1xufSk7XG5cbi8qIEZpbm5pc2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBIYXJyaSBLaWxwacO2IChoYXJyaWtpbHBpb0BnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ZpJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnU3VsamUnLFxuXHRcdHByZXZUZXh0OiAnJiN4QUI7RWRlbGxpbmVuJyxcblx0XHRuZXh0VGV4dDogJ1NldXJhYXZhJiN4QkI7Jyxcblx0XHRjdXJyZW50VGV4dDogJ1TDpG7DpMOkbicsXG5cdFx0bW9udGhOYW1lczogWydUYW1taWt1dScsJ0hlbG1pa3V1JywnTWFhbGlza3V1JywnSHVodGlrdXUnLCdUb3Vrb2t1dScsJ0tlc8Oka3V1Jyxcblx0XHQnSGVpbsOka3V1JywnRWxva3V1JywnU3l5c2t1dScsJ0xva2FrdXUnLCdNYXJyYXNrdXUnLCdKb3VsdWt1dSddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydUYW1taScsJ0hlbG1pJywnTWFhbGlzJywnSHVodGknLCdUb3VrbycsJ0tlc8OkJyxcblx0XHQnSGVpbsOkJywnRWxvJywnU3l5cycsJ0xva2EnLCdNYXJyYXMnLCdKb3VsdSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3UnLCdNYScsJ1RpJywnS2UnLCdUbycsJ1BlJywnTGEnXSxcblx0XHRkYXlOYW1lczogWydTdW5udW50YWknLCdNYWFuYW50YWknLCdUaWlzdGFpJywnS2Vza2l2aWlra28nLCdUb3JzdGFpJywnUGVyamFudGFpJywnTGF1YW50YWknXSxcblx0XHRkYXlOYW1lc01pbjogWydTdScsJ01hJywnVGknLCdLZScsJ1RvJywnUGUnLCdMYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdWaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2QubS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydmaSddKTtcbn0pO1xuXG4vKiBGYXJvZXNlIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbiAqL1xuLyogV3JpdHRlbiBieSBTdmVycmkgTW9ociBPbHNlbiwgc3ZlcnJpbW9AZ21haWwuY29tICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZm8nXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdMYXQgYWZ0dXInLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7RnlycmEnLFxuXHRcdG5leHRUZXh0OiAnTsOmc3RhJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ8ONIGRhZycsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXInLCdGZWJydWFyJywnTWFycycsJ0FwcsOtbCcsJ01laScsJ0p1bmknLFxuXHRcdCdKdWxpJywnQXVndXN0JywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vdmVtYmVyJywnRGVzZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFyJywnQXByJywnTWVpJywnSnVuJyxcblx0XHQnSnVsJywnQXVnJywnU2VwJywnT2t0JywnTm92JywnRGVzJ10sXG5cdFx0ZGF5TmFtZXM6IFsnU3VubnVkYWd1cicsJ03DoW5hZGFndXInLCdUw71zZGFndXInLCdNaWt1ZGFndXInLCdIw7NzZGFndXInLCdGcsOtZ2dqYWRhZ3VyJywnTGV5YXJkYWd1ciddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3VuJywnTcOhbicsJ1TDvXMnLCdNaWsnLCdIw7NzJywnRnLDrScsJ0xleSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1N1JywnTcOhJywnVMO9JywnTWknLCdIw7MnLCdGcicsJ0xlJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1ZrJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQtbW0teXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZm8nXSk7XG59KTtcblxuLyogQ2FuYWRpYW4tRnJlbmNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbmpRdWVyeShmdW5jdGlvbiAoJCkge1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ZyLUNBJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRmVybWVyJyxcblx0XHRwcmV2VGV4dDogJ1Byw6ljw6lkZW50Jyxcblx0XHRuZXh0VGV4dDogJ1N1aXZhbnQnLFxuXHRcdGN1cnJlbnRUZXh0OiAnQXVqb3VyZFxcJ2h1aScsXG5cdFx0bW9udGhOYW1lczogWydqYW52aWVyJywgJ2bDqXZyaWVyJywgJ21hcnMnLCAnYXZyaWwnLCAnbWFpJywgJ2p1aW4nLFxuXHRcdFx0J2p1aWxsZXQnLCAnYW/Du3QnLCAnc2VwdGVtYnJlJywgJ29jdG9icmUnLCAnbm92ZW1icmUnLCAnZMOpY2VtYnJlJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2phbnYuJywgJ2bDqXZyLicsICdtYXJzJywgJ2F2cmlsJywgJ21haScsICdqdWluJyxcblx0XHRcdCdqdWlsLicsICdhb8O7dCcsICdzZXB0LicsICdvY3QuJywgJ25vdi4nLCAnZMOpYy4nXSxcblx0XHRkYXlOYW1lczogWydkaW1hbmNoZScsICdsdW5kaScsICdtYXJkaScsICdtZXJjcmVkaScsICdqZXVkaScsICd2ZW5kcmVkaScsICdzYW1lZGknXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ2RpbS4nLCAnbHVuLicsICdtYXIuJywgJ21lci4nLCAnamV1LicsICd2ZW4uJywgJ3NhbS4nXSxcblx0XHRkYXlOYW1lc01pbjogWydEJywgJ0wnLCAnTScsICdNJywgJ0onLCAnVicsICdTJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1NlbS4nLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS1tbS1kZCcsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJydcblx0fTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZnItQ0EnXSk7XG59KTtcblxuLyogU3dpc3MtRnJlbmNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gTWFydGluIFZvZWxrbGUgKG1hcnRpbi52b2Vsa2xlQGUtdGMuY2gpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ZyLUNIJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRmVybWVyJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO1Byw6ljJyxcblx0XHRuZXh0VGV4dDogJ1N1aXYmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnQ291cmFudCcsXG5cdFx0bW9udGhOYW1lczogWydqYW52aWVyJywgJ2bDqXZyaWVyJywgJ21hcnMnLCAnYXZyaWwnLCAnbWFpJywgJ2p1aW4nLFxuXHRcdFx0J2p1aWxsZXQnLCAnYW/Du3QnLCAnc2VwdGVtYnJlJywgJ29jdG9icmUnLCAnbm92ZW1icmUnLCAnZMOpY2VtYnJlJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2phbnYuJywgJ2bDqXZyLicsICdtYXJzJywgJ2F2cmlsJywgJ21haScsICdqdWluJyxcblx0XHRcdCdqdWlsLicsICdhb8O7dCcsICdzZXB0LicsICdvY3QuJywgJ25vdi4nLCAnZMOpYy4nXSxcblx0XHRkYXlOYW1lczogWydkaW1hbmNoZScsICdsdW5kaScsICdtYXJkaScsICdtZXJjcmVkaScsICdqZXVkaScsICd2ZW5kcmVkaScsICdzYW1lZGknXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ2RpbS4nLCAnbHVuLicsICdtYXIuJywgJ21lci4nLCAnamV1LicsICd2ZW4uJywgJ3NhbS4nXSxcblx0XHRkYXlOYW1lc01pbjogWydEJywgJ0wnLCAnTScsICdNJywgJ0onLCAnVicsICdTJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1NtJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZnItQ0gnXSk7XG59KTtcblxuLyogRnJlbmNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgS2VpdGggV29vZCAoa2J3b29ke2F0fWlpbmV0LmNvbS5hdSksXG5cdFx0XHQgIFN0w6lwaGFuZSBOYWhtYW5pIChzaG9sYnlAc2hvbGJ5Lm5ldCksXG5cdFx0XHQgIFN0w6lwaGFuZSBSYWltYmF1bHQgPHN0ZXBoYW5lLnJhaW1iYXVsdEBnbWFpbC5jb20+ICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZnInXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdGZXJtZXInLFxuXHRcdHByZXZUZXh0OiAnUHLDqWPDqWRlbnQnLFxuXHRcdG5leHRUZXh0OiAnU3VpdmFudCcsXG5cdFx0Y3VycmVudFRleHQ6ICdBdWpvdXJkXFwnaHVpJyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnZpZXInLCAnZsOpdnJpZXInLCAnbWFycycsICdhdnJpbCcsICdtYWknLCAnanVpbicsXG5cdFx0XHQnanVpbGxldCcsICdhb8O7dCcsICdzZXB0ZW1icmUnLCAnb2N0b2JyZScsICdub3ZlbWJyZScsICdkw6ljZW1icmUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnamFudi4nLCAnZsOpdnIuJywgJ21hcnMnLCAnYXZyaWwnLCAnbWFpJywgJ2p1aW4nLFxuXHRcdFx0J2p1aWwuJywgJ2Fvw7t0JywgJ3NlcHQuJywgJ29jdC4nLCAnbm92LicsICdkw6ljLiddLFxuXHRcdGRheU5hbWVzOiBbJ2RpbWFuY2hlJywgJ2x1bmRpJywgJ21hcmRpJywgJ21lcmNyZWRpJywgJ2pldWRpJywgJ3ZlbmRyZWRpJywgJ3NhbWVkaSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnZGltLicsICdsdW4uJywgJ21hci4nLCAnbWVyLicsICdqZXUuJywgJ3Zlbi4nLCAnc2FtLiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0QnLCdMJywnTScsJ00nLCdKJywnVicsJ1MnXSxcblx0XHR3ZWVrSGVhZGVyOiAnU2VtLicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ZyJ10pO1xufSk7XG5cbi8qIEdhbGljaWFuIGxvY2FsaXphdGlvbiBmb3IgJ1VJIGRhdGUgcGlja2VyJyBqUXVlcnkgZXh0ZW5zaW9uLiAqL1xuLyogVHJhbnNsYXRlZCBieSBKb3JnZSBCYXJyZWlybyA8eW9ydHguYmFycnlAZ21haWwuY29tPi4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydnbCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1BlY2hhcicsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztBbnQnLFxuXHRcdG5leHRUZXh0OiAnU2VnJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0hveGUnLFxuXHRcdG1vbnRoTmFtZXM6IFsnWGFuZWlybycsJ0ZlYnJlaXJvJywnTWFyem8nLCdBYnJpbCcsJ01haW8nLCdYdcOxbycsXG5cdFx0J1h1bGxvJywnQWdvc3RvJywnU2V0ZW1icm8nLCdPdXR1YnJvJywnTm92ZW1icm8nLCdEZWNlbWJybyddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydYYW4nLCdGZWInLCdNYXInLCdBYnInLCdNYWknLCdYdcOxJyxcblx0XHQnWHVsJywnQWdvJywnU2V0JywnT3V0JywnTm92JywnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnRG9taW5nbycsJ0x1bnMnLCdNYXJ0ZXMnLCdNw6lyY29yZXMnLCdYb3ZlcycsJ1ZlbnJlcycsJ1PDoWJhZG8nXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ0RvbScsJ0x1bicsJ01hcicsJ03DqXInLCdYb3YnLCdWZW4nLCdTw6FiJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnRG8nLCdMdScsJ01hJywnTcOpJywnWG8nLCdWZScsJ1PDoSddLFxuXHRcdHdlZWtIZWFkZXI6ICdTbScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2dsJ10pO1xufSk7XG5cbi8qIEhlYnJldyBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIFVJIERhdGVwaWNrZXIgZXh0ZW5zaW9uLiAqL1xuLyogV3JpdHRlbiBieSBBbWlyIEhhcmRvbiAoYWhhcmRvbiBhdCBnbWFpbCBkb3QgY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydoZSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9eh15LXldeoJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO9eU16fXldeT150nLFxuXHRcdG5leHRUZXh0OiAn15TXkdeQJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9eU15nXldedJyxcblx0XHRtb250aE5hbWVzOiBbJ9eZ16DXldeQ16gnLCfXpNeR16jXldeQ16gnLCfXnteo16UnLCfXkNek16jXmdecJywn157XkNeZJywn15nXldeg15knLFxuXHRcdCfXmdeV15zXmScsJ9eQ15XXkteV16HXmCcsJ9eh16TXmNee15HXqCcsJ9eQ15XXp9eY15XXkdeoJywn16DXldeR157XkdeoJywn15PXptee15HXqCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfXmdeg15UnLCfXpNeR16gnLCfXnteo16UnLCfXkNek16gnLCfXnteQ15knLCfXmdeV16DXmScsXG5cdFx0J9eZ15XXnNeZJywn15DXldeSJywn16HXpNeYJywn15DXldenJywn16DXldeRJywn15PXpteeJ10sXG5cdFx0ZGF5TmFtZXM6IFsn16jXkNep15XXnycsJ9ep16DXmScsJ9ep15zXmdep15knLCfXqNeR15nXoteZJywn15fXnteZ16nXmScsJ9ep15nXqdeZJywn16nXkdeqJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfXkFxcJycsJ9eRXFwnJywn15JcXCcnLCfXk1xcJycsJ9eUXFwnJywn15VcXCcnLCfXqdeR16onXSxcblx0XHRkYXlOYW1lc01pbjogWyfXkFxcJycsJ9eRXFwnJywn15JcXCcnLCfXk1xcJycsJ9eUXFwnJywn15VcXCcnLCfXqdeR16onXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IHRydWUsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2hlJ10pO1xufSk7XG5cbi8qIEhpbmRpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgTWljaGFlbCBEYXdhcnQuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaGknXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfgpKzgpILgpKYnLFxuXHRcdHByZXZUZXh0OiAn4KSq4KS/4KSb4KSy4KS+Jyxcblx0XHRuZXh0VGV4dDogJ+CkheCkl+CksuCkvicsXG5cdFx0Y3VycmVudFRleHQ6ICfgpIbgpJwnLFxuXHRcdG1vbnRoTmFtZXM6IFsn4KSc4KSo4KS14KSw4KWAICcsJ+Ckq+CksOCkteCksOClgCcsJ+CkruCkvuCksOCljeCkmicsJ+CkheCkquCljeCksOClh+CksicsJ+CkruCkiCcsJ+CknOClguCkqCcsXG5cdFx0J+CknOClguCksuCkvuCkiCcsJ+CkheCkl+CkuOCljeCkpCAnLCfgpLjgpL/gpKTgpK7gpY3gpKzgpLAnLCfgpIXgpJXgpY3gpJ/gpYLgpKzgpLAnLCfgpKjgpLXgpK7gpY3gpKzgpLAnLCfgpKbgpL/gpLjgpK7gpY3gpKzgpLAnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn4KSc4KSoJywgJ+Ckq+CksCcsICfgpK7gpL7gpLDgpY3gpJonLCAn4KSF4KSq4KWN4KSw4KWH4KSyJywgJ+CkruCkiCcsICfgpJzgpYLgpKgnLFxuXHRcdCfgpJzgpYLgpLLgpL7gpIgnLCAn4KSF4KSXJywgJ+CkuOCkv+CkpCcsICfgpIXgpJXgpY3gpJ8nLCAn4KSo4KS1JywgJ+CkpuCkvyddLFxuXHRcdGRheU5hbWVzOiBbJ+CksOCkteCkv+CkteCkvuCksCcsICfgpLjgpYvgpK7gpLXgpL7gpLAnLCAn4KSu4KSC4KSX4KSy4KS14KS+4KSwJywgJ+CkrOClgeCkp+CkteCkvuCksCcsICfgpJfgpYHgpLDgpYHgpLXgpL7gpLAnLCAn4KS24KWB4KSV4KWN4KSw4KS14KS+4KSwJywgJ+CktuCkqOCkv+CkteCkvuCksCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn4KSw4KS14KS/JywgJ+CkuOCli+CkricsICfgpK7gpILgpJfgpLInLCAn4KSs4KWB4KSnJywgJ+Ckl+ClgeCksOClgScsICfgpLbgpYHgpJXgpY3gpLAnLCAn4KS24KSo4KS/J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn4KSw4KS14KS/JywgJ+CkuOCli+CkricsICfgpK7gpILgpJfgpLInLCAn4KSs4KWB4KSnJywgJ+Ckl+ClgeCksOClgScsICfgpLbgpYHgpJXgpY3gpLAnLCAn4KS24KSo4KS/J10sXG5cdFx0d2Vla0hlYWRlcjogJ+CkueCkq+CljeCkpOCkvicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2hpJ10pO1xufSk7XG5cbi8qIENyb2F0aWFuIGkxOG4gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBWamVrb3NsYXYgTmVzZWsuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaHInXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdaYXR2b3JpJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDOycsXG5cdFx0bmV4dFRleHQ6ICcmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnRGFuYXMnLFxuXHRcdG1vbnRoTmFtZXM6IFsnU2lqZcSNYW5qJywnVmVsamHEjWEnLCdPxb51amFrJywnVHJhdmFuaicsJ1N2aWJhbmonLCdMaXBhbmonLFxuXHRcdCdTcnBhbmonLCdLb2xvdm96JywnUnVqYW4nLCdMaXN0b3BhZCcsJ1N0dWRlbmknLCdQcm9zaW5hYyddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydTaWonLCdWZWxqJywnT8W+dScsJ1RyYScsJ1N2aScsJ0xpcCcsXG5cdFx0J1NycCcsJ0tvbCcsJ1J1aicsJ0xpcycsJ1N0dScsJ1BybyddLFxuXHRcdGRheU5hbWVzOiBbJ05lZGplbGphJywnUG9uZWRqZWxqYWsnLCdVdG9yYWsnLCdTcmlqZWRhJywnxIxldHZydGFrJywnUGV0YWsnLCdTdWJvdGEnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ05lZCcsJ1BvbicsJ1V0bycsJ1NyaScsJ8SMZXQnLCdQZXQnLCdTdWInXSxcblx0XHRkYXlOYW1lc01pbjogWydOZScsJ1BvJywnVXQnLCdTcicsJ8SMZScsJ1BlJywnU3UnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVGplJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXkuJyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2hyJ10pO1xufSk7XG5cbi8qIEh1bmdhcmlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IElzdHZhbiBLYXJhc3ppIChqcXVlcnlAc3BhbS5yYXN6aS5odSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaHUnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdiZXrDoXInLFxuXHRcdHByZXZUZXh0OiAndmlzc3phJyxcblx0XHRuZXh0VGV4dDogJ2VsxZFyZScsXG5cdFx0Y3VycmVudFRleHQ6ICdtYScsXG5cdFx0bW9udGhOYW1lczogWydKYW51w6FyJywgJ0ZlYnJ1w6FyJywgJ03DoXJjaXVzJywgJ8OBcHJpbGlzJywgJ03DoWp1cycsICdKw7puaXVzJyxcblx0XHQnSsO6bGl1cycsICdBdWd1c3p0dXMnLCAnU3plcHRlbWJlcicsICdPa3TDs2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ03DoXInLCAnw4FwcicsICdNw6FqJywgJ0rDum4nLFxuXHRcdCdKw7psJywgJ0F1ZycsICdTemVwJywgJ09rdCcsICdOb3YnLCAnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnVmFzw6FybmFwJywgJ0jDqXRmxZEnLCAnS2VkZCcsICdTemVyZGEnLCAnQ3PDvHTDtnJ0w7ZrJywgJ1DDqW50ZWsnLCAnU3pvbWJhdCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnVmFzJywgJ0jDqXQnLCAnS2VkJywgJ1N6ZScsICdDc8O8JywgJ1DDqW4nLCAnU3pvJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnVicsICdIJywgJ0snLCAnU3plJywgJ0NzJywgJ1AnLCAnU3pvJ10sXG5cdFx0d2Vla0hlYWRlcjogJ0jDqXQnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS5tbS5kZC4nLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IHRydWUsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydodSddKTtcbn0pO1xuXG4vKiBBcm1lbmlhbihVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBMZXZvbiBaYWthcnlhbiAobGV2b24uemFrYXJ5YW5AZ21haWwuY29tKSovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaHknXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfVk9Wh1a/VpdWsJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO9WG1aHVrS4nLFxuXHRcdG5leHRUZXh0OiAn1YDVodW7LiYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfUsdW11b3WhdaAJyxcblx0XHRtb250aE5hbWVzOiBbJ9WA1bjWgtW21b7VodaAJywn1ZPVpdW/1oDVvtWh1oAnLCfVhNWh1oDVvycsJ9Sx1brWgNWr1awnLCfVhNWh1bXVq9W9Jywn1YDVuNaC1bbVq9W9Jyxcblx0XHQn1YDVuNaC1azVq9W9Jywn1ZXVo9W41b3Vv9W41b0nLCfVjdWl1brVv9Wl1bTVotWl1oAnLCfVgNW41a/Vv9Wl1bTVotWl1oAnLCfVhtW41bXVpdW01aLVpdaAJywn1LTVpdWv1b/VpdW01aLVpdaAJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9WA1bjWgtW21b4nLCfVk9Wl1b/WgCcsJ9WE1aHWgNW/Jywn1LHVutaAJywn1YTVodW11avVvScsJ9WA1bjWgtW21avVvScsXG5cdFx0J9WA1bjWgtWsJywn1ZXVo9W9Jywn1Y3VpdW6Jywn1YDVuNWvJywn1YbVuNW1Jywn1LTVpdWvJ10sXG5cdFx0ZGF5TmFtZXM6IFsn1a/Vq9aA1aHVr9WrJywn1aXVr9W41oLVt9Wh1aLVqdWrJywn1aXWgNWl1oTVt9Wh1aLVqdWrJywn1bnVuNaA1aXWhNW31aHVotWp1asnLCfVsNWr1bbVo9W31aHVotWp1asnLCfVuNaC1oDVotWh1aknLCfVt9Wh1aLVodWpJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfVr9Wr1oAnLCfVpdaA1a8nLCfVpdaA1oQnLCfVudaA1oQnLCfVsNW21aMnLCfVuNaC1oDVoicsJ9W31aLVqSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9Wv1avWgCcsJ9Wl1oDVrycsJ9Wl1oDWhCcsJ9W51oDWhCcsJ9Ww1bbVoycsJ9W41oLWgNWiJywn1bfVotWpJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9WH1LLVjycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2h5J10pO1xufSk7XG5cbi8qIEluZG9uZXNpYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBEZWRlbiBGYXRodXJhaG1hbiAoZGVkZW5mQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaWQnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdUdXR1cCcsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzttdW5kdXInLFxuXHRcdG5leHRUZXh0OiAnbWFqdSYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdoYXJpIGluaScsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXJpJywnRmVicnVhcmknLCdNYXJldCcsJ0FwcmlsJywnTWVpJywnSnVuaScsXG5cdFx0J0p1bGknLCdBZ3VzdHVzJywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vcGVtYmVyJywnRGVzZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFyJywnQXByJywnTWVpJywnSnVuJyxcblx0XHQnSnVsJywnQWd1cycsJ1NlcCcsJ09rdCcsJ05vcCcsJ0RlcyddLFxuXHRcdGRheU5hbWVzOiBbJ01pbmdndScsJ1NlbmluJywnU2VsYXNhJywnUmFidScsJ0thbWlzJywnSnVtYXQnLCdTYWJ0dSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnTWluJywnU2VuJywnU2VsJywnUmFiJywna2FtJywnSnVtJywnU2FiJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnTWcnLCdTbicsJ1NsJywnUmInLCdLbScsJ2ptJywnU2InXSxcblx0XHR3ZWVrSGVhZGVyOiAnTWcnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydpZCddKTtcbn0pO1xuXG4vKiBJY2VsYW5kaWMgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBIYXVrdXIgSC4gVGhvcnNzb24gKGhhdWt1ckBlc2tpbGwuaXMpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2lzJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnTG9rYScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzsgRnlycmknLFxuXHRcdG5leHRUZXh0OiAnTsOmc3RpICYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfDjSBkYWcnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFuw7phcicsJ0ZlYnLDumFyJywnTWFycycsJ0FwcsOtbCcsJ01hw60nLCdKw7puw60nLFxuXHRcdCdKw7psw60nLCfDgWfDunN0JywnU2VwdGVtYmVyJywnT2t0w7NiZXInLCdOw7N2ZW1iZXInLCdEZXNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNYcOtJywnSsO6bicsXG5cdFx0J0rDumwnLCfDgWfDuicsJ1NlcCcsJ09rdCcsJ07Ds3YnLCdEZXMnXSxcblx0XHRkYXlOYW1lczogWydTdW5udWRhZ3VyJywnTcOhbnVkYWd1cicsJ8OecmnDsGp1ZGFndXInLCdNacOwdmlrdWRhZ3VyJywnRmltbXR1ZGFndXInLCdGw7ZzdHVkYWd1cicsJ0xhdWdhcmRhZ3VyJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCdNw6FuJywnw55yaScsJ01pw7AnLCdGaW0nLCdGw7ZzJywnTGF1J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdNw6EnLCfDnnInLCdNaScsJ0ZpJywnRsO2JywnTGEnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVmlrYScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2lzJ10pO1xufSk7XG5cbi8qIEl0YWxpYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBBbnRvbmVsbG8gUGFzZWxsYSAoYW50b25lbGxvLnBhc2VsbGFAZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydpdCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0NoaXVkaScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztQcmVjJyxcblx0XHRuZXh0VGV4dDogJ1N1Y2MmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnT2dnaScsXG5cdFx0bW9udGhOYW1lczogWydHZW5uYWlvJywnRmViYnJhaW8nLCdNYXJ6bycsJ0FwcmlsZScsJ01hZ2dpbycsJ0dpdWdubycsXG5cdFx0XHQnTHVnbGlvJywnQWdvc3RvJywnU2V0dGVtYnJlJywnT3R0b2JyZScsJ05vdmVtYnJlJywnRGljZW1icmUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnR2VuJywnRmViJywnTWFyJywnQXByJywnTWFnJywnR2l1Jyxcblx0XHRcdCdMdWcnLCdBZ28nLCdTZXQnLCdPdHQnLCdOb3YnLCdEaWMnXSxcblx0XHRkYXlOYW1lczogWydEb21lbmljYScsJ0x1bmVkw6wnLCdNYXJ0ZWTDrCcsJ01lcmNvbGVkw6wnLCdHaW92ZWTDrCcsJ1ZlbmVyZMOsJywnU2FiYXRvJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEb20nLCdMdW4nLCdNYXInLCdNZXInLCdHaW8nLCdWZW4nLCdTYWInXSxcblx0XHRkYXlOYW1lc01pbjogWydEbycsJ0x1JywnTWEnLCdNZScsJ0dpJywnVmUnLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdTbScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2l0J10pO1xufSk7XG5cbi8qIEphcGFuZXNlIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgS2VudGFybyBTQVRPIChrZW50YXJvQHJhbnZpcy5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2phJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn6ZaJ44GY44KLJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO+WJjScsXG5cdFx0bmV4dFRleHQ6ICfmrKEmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn5LuK5pelJyxcblx0XHRtb250aE5hbWVzOiBbJzHmnIgnLCcy5pyIJywnM+aciCcsJzTmnIgnLCc15pyIJywnNuaciCcsXG5cdFx0JzfmnIgnLCc45pyIJywnOeaciCcsJzEw5pyIJywnMTHmnIgnLCcxMuaciCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWycx5pyIJywnMuaciCcsJzPmnIgnLCc05pyIJywnNeaciCcsJzbmnIgnLFxuXHRcdCc35pyIJywnOOaciCcsJznmnIgnLCcxMOaciCcsJzEx5pyIJywnMTLmnIgnXSxcblx0XHRkYXlOYW1lczogWyfml6Xmm5zml6UnLCfmnIjmm5zml6UnLCfngavmm5zml6UnLCfmsLTmm5zml6UnLCfmnKjmm5zml6UnLCfph5Hmm5zml6UnLCflnJ/mm5zml6UnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ+aXpScsJ+aciCcsJ+eBqycsJ+awtCcsJ+acqCcsJ+mHkScsJ+WcnyddLFxuXHRcdGRheU5hbWVzTWluOiBbJ+aXpScsJ+aciCcsJ+eBqycsJ+awtCcsJ+acqCcsJ+mHkScsJ+WcnyddLFxuXHRcdHdlZWtIZWFkZXI6ICfpgLEnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS9tbS9kZCcsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogdHJ1ZSxcblx0XHR5ZWFyU3VmZml4OiAn5bm0J307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2phJ10pO1xufSk7XG5cbi8qIEdlb3JnaWFuIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBMYWRvIExvbWlkemUgKGxhZG8ubG9taWR6ZUBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2thJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn4YOT4YOQ4YOu4YOj4YOg4YOV4YOQJyxcblx0XHRwcmV2VGV4dDogJyYjeDNjOyDhg6zhg5jhg5zhg5AnLFxuXHRcdG5leHRUZXh0OiAn4YOo4YOU4YOb4YOT4YOU4YOS4YOYICYjeDNlOycsXG5cdFx0Y3VycmVudFRleHQ6ICfhg5Phg6bhg5Thg6EnLFxuXHRcdG1vbnRoTmFtZXM6IFsn4YOY4YOQ4YOc4YOV4YOQ4YOg4YOYJywn4YOX4YOU4YOR4YOU4YOg4YOV4YOQ4YOa4YOYJywn4YOb4YOQ4YOg4YOi4YOYJywn4YOQ4YOe4YOg4YOY4YOa4YOYJywn4YOb4YOQ4YOY4YOh4YOYJywn4YOY4YOV4YOc4YOY4YOh4YOYJywgJ+GDmOGDleGDmuGDmOGDoeGDmCcsJ+GDkOGDkuGDleGDmOGDoeGDouGDnScsJ+GDoeGDlOGDpeGDouGDlOGDm+GDkeGDlOGDoOGDmCcsJ+GDneGDpeGDouGDneGDm+GDkeGDlOGDoOGDmCcsJ+GDnOGDneGDlOGDm+GDkeGDlOGDoOGDmCcsJ+GDk+GDlOGDmeGDlOGDm+GDkeGDlOGDoOGDmCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfhg5jhg5Dhg5wnLCfhg5fhg5Thg5EnLCfhg5vhg5Dhg6AnLCfhg5Dhg57hg6AnLCfhg5vhg5Dhg5gnLCfhg5jhg5Xhg5wnLCAn4YOY4YOV4YOaJywn4YOQ4YOS4YOVJywn4YOh4YOU4YOlJywn4YOd4YOl4YOiJywn4YOc4YOd4YOUJywn4YOT4YOU4YOZJ10sXG5cdFx0ZGF5TmFtZXM6IFsn4YOZ4YOV4YOY4YOg4YOQJywn4YOd4YOg4YOo4YOQ4YOR4YOQ4YOX4YOYJywn4YOh4YOQ4YOb4YOo4YOQ4YOR4YOQ4YOX4YOYJywn4YOd4YOX4YOu4YOo4YOQ4YOR4YOQ4YOX4YOYJywn4YOu4YOj4YOX4YOo4YOQ4YOR4YOQ4YOX4YOYJywn4YOe4YOQ4YOg4YOQ4YOh4YOZ4YOU4YOV4YOYJywn4YOo4YOQ4YOR4YOQ4YOX4YOYJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfhg5nhg5UnLCfhg53hg6Dhg6gnLCfhg6Hhg5Dhg5snLCfhg53hg5fhg64nLCfhg67hg6Phg5cnLCfhg57hg5Dhg6AnLCfhg6jhg5Dhg5EnXSxcblx0XHRkYXlOYW1lc01pbjogWyfhg5nhg5UnLCfhg53hg6Dhg6gnLCfhg6Hhg5Dhg5snLCfhg53hg5fhg64nLCfhg67hg6Phg5cnLCfhg57hg5Dhg6AnLCfhg6jhg5Dhg5EnXSxcblx0XHR3ZWVrSGVhZGVyOiAn4YOZ4YOV4YOY4YOg4YOQJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQtbW0teXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsna2EnXSk7XG59KTtcblxuLyogS2F6YWtoIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBEbWl0cml5IEthcmFzeW92IChkbWl0cml5LmthcmFzeW92QGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsna2snXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfQltCw0LHRgycsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzvQkNC70LTRi9Kj0pPRiycsXG5cdFx0bmV4dFRleHQ6ICfQmtC10LvQtdGB0ZYmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn0JHSr9Cz0ZbQvScsXG5cdFx0bW9udGhOYW1lczogWyfSmtCw0qPRgtCw0YAnLCfQkNKb0L/QsNC9Jywn0J3QsNGD0YDRi9C3Jywn0KHTmdGD0ZbRgCcsJ9Cc0LDQvNGL0YAnLCfQnNCw0YPRgdGL0LwnLFxuXHRcdCfQqNGW0LvQtNC1Jywn0KLQsNC80YvQtycsJ9Ka0YvRgNC60q/QudC10LonLCfSmtCw0LfQsNC9Jywn0prQsNGA0LDRiNCwJywn0JbQtdC70YLQvtKb0YHQsNC9J10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9Ka0LDSoycsJ9CQ0pvQvycsJ9Cd0LDRgycsJ9Ch05nRgycsJ9Cc0LDQvCcsJ9Cc0LDRgycsXG5cdFx0J9Co0ZbQuycsJ9Ci0LDQvCcsJ9Ka0YvRgCcsJ9Ka0LDQtycsJ9Ka0LDRgCcsJ9CW0LXQuyddLFxuXHRcdGRheU5hbWVzOiBbJ9CW0LXQutGB0LXQvdCx0ZYnLCfQlNKv0LnRgdC10L3QsdGWJywn0KHQtdC50YHQtdC90LHRlicsJ9Ch05nRgNGB0LXQvdCx0ZYnLCfQkdC10LnRgdC10L3QsdGWJywn0JbSsdC80LAnLCfQodC10L3QsdGWJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfQttC60YEnLCfQtNGB0L0nLCfRgdGB0L0nLCfRgdGA0YEnLCfQsdGB0L0nLCfQttC80LAnLCfRgdC90LEnXSxcblx0XHRkYXlOYW1lc01pbjogWyfQltC6Jywn0JTRgScsJ9Ch0YEnLCfQodGAJywn0JHRgScsJ9CW0LwnLCfQodC9J10sXG5cdFx0d2Vla0hlYWRlcjogJ9Cd0LUnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydrayddKTtcbn0pO1xuXG4vKiBLaG1lciBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBjYWxlbmRhciBleHRlbnNpb24uICovXG4vKiBXcml0dGVuIGJ5IENoYW5kYXJhIE9tIChjaGFuZGFyYS50ZWFjaGVyQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsna20nXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfhnpLhn5Lhnpzhnr7igIvhnprhnr3hnoUnLFxuXHRcdHByZXZUZXh0OiAn4Z6Y4Z674Z6TJyxcblx0XHRuZXh0VGV4dDogJ+GelOGek+GfkuGekeGetuGelOGfiycsXG5cdFx0Y3VycmVudFRleHQ6ICfhnpDhn5LhnoThn4PigIvhnpPhn4Hhn4cnLFxuXHRcdG1vbnRoTmFtZXM6IFsn4Z6Y4Z6A4Z6a4Z62Jywn4Z6A4Z674Z6Y4Z+S4Z6X4Z+IJywn4Z6Y4Z644Z6T4Z62Jywn4Z6Y4Z+B4Z6f4Z62Jywn4Z6n4Z6f4Z6X4Z62Jywn4Z6Y4Z634Z6Q4Z674Z6T4Z62Jyxcblx0XHQn4Z6A4Z6A4Z+S4Z6A4Z6K4Z62Jywn4Z6f4Z644Z6g4Z62Jywn4Z6A4Z6J4Z+S4Z6J4Z62Jywn4Z6P4Z674Z6b4Z62Jywn4Z6c4Z634Z6F4Z+S4Z6G4Z634Z6A4Z62Jywn4Z6S4Z+S4Z6T4Z68J10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ+GemOGegOGemuGeticsJ+GegOGeu+GemOGfkuGel+GfiCcsJ+GemOGeuOGek+GeticsJ+GemOGfgeGen+GeticsJ+Gep+Gen+Gel+GeticsJ+GemOGet+GekOGeu+Gek+GeticsXG5cdFx0J+GegOGegOGfkuGegOGeiuGeticsJ+Gen+GeuOGeoOGeticsJ+GegOGeieGfkuGeieGeticsJ+Gej+Geu+Gem+GeticsJ+GenOGet+GeheGfkuGehuGet+GegOGeticsJ+GekuGfkuGek+GevCddLFxuXHRcdGRheU5hbWVzOiBbJ+GeouGetuGekeGet+Gej+GfkuGemScsICfhnoXhnpPhn5LhnpEnLCAn4Z6i4Z6E4Z+S4Z6C4Z624Z6aJywgJ+GeluGeu+GekicsICfhnpbhn5LhnprhnqDhnp/hn5LhnpThno/hnrfhn40nLCAn4Z6f4Z674Z6A4Z+S4Z6aJywgJ+Gen+GfheGemuGfjSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn4Z6i4Z62JywgJ+GehScsICfhnqInLCAn4Z6W4Z67JywgJ+GeluGfkuGemuGeoCcsICfhnp/hnrsnLCAn4Z6f4Z+FJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn4Z6i4Z62JywgJ+GehScsICfhnqInLCAn4Z6W4Z67JywgJ+GeluGfkuGemuGeoCcsICfhnp/hnrsnLCAn4Z6f4Z+FJ10sXG5cdFx0d2Vla0hlYWRlcjogJ+Gen+GelOGfkuGeiuGetuGeoOGfjScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLW1tLXl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ttJ10pO1xufSk7XG5cbi8qIEtvcmVhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBjYWxlbmRhciBleHRlbnNpb24uICovXG4vKiBXcml0dGVuIGJ5IERhZUt3b24gS2FuZyAobmNyYXNoLmRrQGdtYWlsLmNvbSksIEVkaXRlZCBieSBHZW5pZS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydrbyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ+uLq+q4sCcsXG5cdFx0cHJldlRleHQ6ICfsnbTsoITri6wnLFxuXHRcdG5leHRUZXh0OiAn64uk7J2M64usJyxcblx0XHRjdXJyZW50VGV4dDogJ+yYpOuKmCcsXG5cdFx0bW9udGhOYW1lczogWycx7JuUJywnMuyblCcsJzPsm5QnLCc07JuUJywnNeyblCcsJzbsm5QnLFxuXHRcdCc37JuUJywnOOyblCcsJznsm5QnLCcxMOyblCcsJzEx7JuUJywnMTLsm5QnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnMeyblCcsJzLsm5QnLCcz7JuUJywnNOyblCcsJzXsm5QnLCc27JuUJyxcblx0XHQnN+yblCcsJzjsm5QnLCc57JuUJywnMTDsm5QnLCcxMeyblCcsJzEy7JuUJ10sXG5cdFx0ZGF5TmFtZXM6IFsn7J287JqU7J28Jywn7JuU7JqU7J28Jywn7ZmU7JqU7J28Jywn7IiY7JqU7J28Jywn66qp7JqU7J28Jywn6riI7JqU7J28Jywn7Yag7JqU7J28J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfsnbwnLCfsm5QnLCftmZQnLCfsiJgnLCfrqqknLCfquIgnLCfthqAnXSxcblx0XHRkYXlOYW1lc01pbjogWyfsnbwnLCfsm5QnLCftmZQnLCfsiJgnLCfrqqknLCfquIgnLCfthqAnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS1tbS1kZCcsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogdHJ1ZSxcblx0XHR5ZWFyU3VmZml4OiAn64WEJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2tvJ10pO1xufSk7XG5cbi8qIEt5cmd5eiAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgU2VyZ2V5IEthcnRhc2hvdiAoZWJpc2hrZWtAeWFuZGV4LnJ1KS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydreSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9CW0LDQsdGD0YMnLFxuXHRcdHByZXZUZXh0OiAnJiN4M2M70JzRg9GAJyxcblx0XHRuZXh0VGV4dDogJ9Ca0LjQuSYjeDNlOycsXG5cdFx0Y3VycmVudFRleHQ6ICfQkdKv0LPSr9C9Jyxcblx0XHRtb250aE5hbWVzOiBbJ9Cv0L3QstCw0YDRjCcsJ9Ck0LXQstGA0LDQu9GMJywn0JzQsNGA0YInLCfQkNC/0YDQtdC70YwnLCfQnNCw0LknLCfQmNGO0L3RjCcsXG5cdFx0J9CY0Y7Qu9GMJywn0JDQstCz0YPRgdGCJywn0KHQtdC90YLRj9Cx0YDRjCcsJ9Ce0LrRgtGP0LHRgNGMJywn0J3QvtGP0LHRgNGMJywn0JTQtdC60LDQsdGA0YwnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn0K/QvdCyJywn0KTQtdCyJywn0JzQsNGAJywn0JDQv9GAJywn0JzQsNC5Jywn0JjRjtC9Jyxcblx0XHQn0JjRjtC7Jywn0JDQstCzJywn0KHQtdC9Jywn0J7QutGCJywn0J3QvtGPJywn0JTQtdC6J10sXG5cdFx0ZGF5TmFtZXM6IFsn0LbQtdC60YjQtdC80LHQuCcsICfQtNKv0LnRiNOp0LzQsdKvJywgJ9GI0LXQudGI0LXQvNCx0LgnLCAn0YjQsNGA0YjQtdC80LHQuCcsICfQsdC10LnRiNC10LzQsdC4JywgJ9C20YPQvNCwJywgJ9C40YjQtdC80LHQuCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn0LbQtdC6JywgJ9C00q/QuScsICfRiNC10LknLCAn0YjQsNGAJywgJ9Cx0LXQuScsICfQttGD0LwnLCAn0LjRiNC1J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn0JbQuicsJ9CU0YgnLCfQqNGIJywn0KjRgCcsJ9CR0YgnLCfQltC8Jywn0JjRiCddLFxuXHRcdHdlZWtIZWFkZXI6ICfQltGD0LwnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJydcblx0fTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsna3knXSk7XG59KTtcblxuLyogTHV4ZW1ib3VyZ2lzaCBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IE1pY2hlbCBXZWltZXJza2lyY2ggPG1pY2hlbEB3ZWltZXJza2lyY2gubmV0PiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2xiJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRsOkZXJkZWcnLFxuXHRcdHByZXZUZXh0OiAnWnLDqWNrJyxcblx0XHRuZXh0VGV4dDogJ1dlaWRlcicsXG5cdFx0Y3VycmVudFRleHQ6ICdIYXV0Jyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcicsJ0ZlYnJ1YXInLCdNw6RlcnonLCdBYnLDq2xsJywnTWVlJywnSnVuaScsXG5cdFx0J0p1bGknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPa3RvYmVyJywnTm92ZW1iZXInLCdEZXplbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ03DpGUnLCAnQWJyJywgJ01lZScsICdKdW4nLFxuXHRcdCdKdWwnLCAnQXVnJywgJ1NlcCcsICdPa3QnLCAnTm92JywgJ0RleiddLFxuXHRcdGRheU5hbWVzOiBbJ1Nvbm5kZWcnLCAnTcOpaW5kZWcnLCAnRMOrbnNjaGRlZycsICdNw6t0dHdvY2gnLCAnRG9ubmVzY2hkZWcnLCAnRnJlaWRlZycsICdTYW1zY2hkZWcnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1NvbicsICdNw6lpJywgJ0TDq24nLCAnTcOrdCcsICdEb24nLCAnRnJlJywgJ1NhbSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1NvJywnTcOpJywnRMOrJywnTcOrJywnRG8nLCdGcicsJ1NhJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1cnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydsYiddKTtcbn0pO1xuXG4vKiBMaXRodWFuaWFuIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogQGF1dGhvciBBcnR1cmFzIFBhbGVpY2lrYXMgPGFydHVyYXNAYXZhbG9uLmx0PiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2x0J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnVcW+ZGFyeXRpJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO0F0Z2FsJyxcblx0XHRuZXh0VGV4dDogJ1Bpcm15biYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfFoGlhbmRpZW4nLFxuXHRcdG1vbnRoTmFtZXM6IFsnU2F1c2lzJywnVmFzYXJpcycsJ0tvdmFzJywnQmFsYW5kaXMnLCdHZWd1xb7ElycsJ0JpcsW+ZWxpcycsXG5cdFx0J0xpZXBhJywnUnVncGrFq3RpcycsJ1J1Z3PEl2ppcycsJ1NwYWxpcycsJ0xhcGtyaXRpcycsJ0dydW9kaXMnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnU2F1JywnVmFzJywnS292JywnQmFsJywnR2VnJywnQmlyJyxcblx0XHQnTGllJywnUnVncCcsJ1J1Z3MnLCdTcGEnLCdMYXAnLCdHcnUnXSxcblx0XHRkYXlOYW1lczogWydzZWttYWRpZW5pcycsJ3Bpcm1hZGllbmlzJywnYW50cmFkaWVuaXMnLCd0cmXEjWlhZGllbmlzJywna2V0dmlydGFkaWVuaXMnLCdwZW5rdGFkaWVuaXMnLCfFoWXFoXRhZGllbmlzJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydzZWsnLCdwaXInLCdhbnQnLCd0cmUnLCdrZXQnLCdwZW4nLCfFoWXFoSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1NlJywnUHInLCdBbicsJ1RyJywnS2UnLCdQZScsJ8WgZSddLFxuXHRcdHdlZWtIZWFkZXI6ICdTQVYnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS1tbS1kZCcsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogdHJ1ZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2x0J10pO1xufSk7XG5cbi8qIExhdHZpYW4gKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBAYXV0aG9yIEFydHVyYXMgUGFsZWljaWthcyA8YXJ0dXJhcy5wYWxlaWNpa2FzQG1ldGFzaXRlLm5ldD4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydsdiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0FpenbEk3J0Jyxcblx0XHRwcmV2VGV4dDogJ0llcHIuJyxcblx0XHRuZXh0VGV4dDogJ07EgWsuJyxcblx0XHRjdXJyZW50VGV4dDogJ8Wgb2RpZW4nLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudsSBcmlzJywnRmVicnXEgXJpcycsJ01hcnRzJywnQXByxKtsaXMnLCdNYWlqcycsJ0rFq25panMnLFxuXHRcdCdKxatsaWpzJywnQXVndXN0cycsJ1NlcHRlbWJyaXMnLCdPa3RvYnJpcycsJ05vdmVtYnJpcycsJ0RlY2VtYnJpcyddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNYWknLCdKxatuJyxcblx0XHQnSsWrbCcsJ0F1ZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ3N2xJN0ZGllbmEnLCdwaXJtZGllbmEnLCdvdHJkaWVuYScsJ3RyZcWhZGllbmEnLCdjZXR1cnRkaWVuYScsJ3BpZWt0ZGllbmEnLCdzZXN0ZGllbmEnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ3N2dCcsJ3BybScsJ290cicsJ3RyZScsJ2N0cicsJ3BrdCcsJ3NzdCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1N2JywnUHInLCdPdCcsJ1RyJywnQ3QnLCdQaycsJ1NzJ10sXG5cdFx0d2Vla0hlYWRlcjogJ05lZC4nLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydsdiddKTtcbn0pO1xuXG4vKiBNYWNlZG9uaWFuIGkxOG4gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBTdG9qY2UgU2xhdmtvdnNraS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydtayddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9CX0LDRgtCy0L7RgNC4Jyxcblx0XHRwcmV2VGV4dDogJyYjeDNDOycsXG5cdFx0bmV4dFRleHQ6ICcmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn0JTQtdC90LXRgScsXG5cdFx0bW9udGhOYW1lczogWyfQiNCw0L3Rg9Cw0YDQuCcsJ9Ck0LXQstGA0YPQsNGA0LgnLCfQnNCw0YDRgicsJ9CQ0L/RgNC40LsnLCfQnNCw0ZgnLCfQiNGD0L3QuCcsXG5cdFx0J9CI0YPQu9C4Jywn0JDQstCz0YPRgdGCJywn0KHQtdC/0YLQtdC80LLRgNC4Jywn0J7QutGC0L7QvNCy0YDQuCcsJ9Cd0L7QtdC80LLRgNC4Jywn0JTQtdC60LXQvNCy0YDQuCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfQiNCw0L0nLCfQpNC10LInLCfQnNCw0YAnLCfQkNC/0YAnLCfQnNCw0ZgnLCfQiNGD0L0nLFxuXHRcdCfQiNGD0LsnLCfQkNCy0LMnLCfQodC10L8nLCfQntC60YInLCfQndC+0LUnLCfQlNC10LonXSxcblx0XHRkYXlOYW1lczogWyfQndC10LTQtdC70LAnLCfQn9C+0L3QtdC00LXQu9C90LjQuicsJ9CS0YLQvtGA0L3QuNC6Jywn0KHRgNC10LTQsCcsJ9Cn0LXRgtCy0YDRgtC+0LonLCfQn9C10YLQvtC6Jywn0KHQsNCx0L7RgtCwJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfQndC10LQnLCfQn9C+0L0nLCfQktGC0L4nLCfQodGA0LUnLCfQp9C10YInLCfQn9C10YInLCfQodCw0LEnXSxcblx0XHRkYXlOYW1lc01pbjogWyfQndC1Jywn0J/QvicsJ9CS0YInLCfQodGAJywn0KfQtScsJ9Cf0LUnLCfQodCwJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9Ch0LXQtCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ21rJ10pO1xufSk7XG5cbi8qIE1hbGF5YWxhbSAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgU2FqaSBOZWRpeWFuY2hhdGggKHNhamk4OUBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ21sJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn4LS24LSw4LS/Jyxcblx0XHRwcmV2VGV4dDogJ+C0ruC1geC0qOC1jeC0qOC0pOC1jeC0pOC1hicsXG5cdFx0bmV4dFRleHQ6ICfgtIXgtJ/gtYHgtKTgtY3gtKTgtKTgtY0gJyxcblx0XHRjdXJyZW50VGV4dDogJ+C0h+C0qOC1jeC0qOC1jScsXG5cdFx0bW9udGhOYW1lczogWyfgtJzgtKjgtYHgtLXgtLDgtL8nLCfgtKvgtYbgtKzgtY3gtLDgtYHgtLXgtLDgtL8nLCfgtK7gtL7gtLDgtY3igI3gtJrgtY3gtJrgtY0nLCfgtI/gtKrgtY3gtLDgtL/gtLLgtY3igI0nLCfgtK7gtYfgtK/gtY0nLCfgtJzgtYLgtKPgtY3igI0nLFxuXHRcdCfgtJzgtYLgtLLgtYgnLCfgtIbgtJfgtLjgtY3gtLHgtY3gtLHgtY0nLCfgtLjgtYbgtKrgtY3gtLHgtY3gtLHgtILgtKzgtLDgtY3igI0nLCfgtJLgtJXgtY3gtJ/gtYvgtKzgtLDgtY3igI0nLCfgtKjgtLXgtILgtKzgtLDgtY3igI0nLCfgtKHgtL/gtLjgtILgtKzgtLDgtY3igI0nXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn4LSc4LSo4LWBJywgJ+C0q+C1huC0rOC1jScsICfgtK7gtL7gtLDgtY3igI0nLCAn4LSP4LSq4LWN4LSw4LS/JywgJ+C0ruC1h+C0r+C1jScsICfgtJzgtYLgtKPgtY3igI0nLFxuXHRcdCfgtJzgtYLgtLLgtL4nLCAn4LSG4LSXJywgJ+C0uOC1huC0quC1jScsICfgtJLgtJXgtY3gtJ/gtYsnLCAn4LSo4LS14LSCJywgJ+C0oeC0v+C0uCddLFxuXHRcdGRheU5hbWVzOiBbJ+C0nuC0vuC0r+C0sOC1jeKAjScsICfgtKTgtL/gtJngtY3gtJXgtLPgtY3igI0nLCAn4LSa4LWK4LS14LWN4LS1JywgJ+C0rOC1geC0p+C0qOC1jeKAjScsICfgtLXgtY3gtK/gtL7gtLTgtIInLCAn4LS14LWG4LSz4LWN4LSz4LS/JywgJ+C0tuC0qOC0vyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn4LSe4LS+4LSvJywgJ+C0pOC0v+C0meC1jeC0lScsICfgtJrgtYrgtLXgtY3gtLUnLCAn4LSs4LWB4LSnJywgJ+C0teC1jeC0r+C0vuC0tOC0gicsICfgtLXgtYbgtLPgtY3gtLPgtL8nLCAn4LS24LSo4LS/J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn4LSe4LS+Jywn4LSk4LS/Jywn4LSa4LWKJywn4LSs4LWBJywn4LS14LWN4LSv4LS+Jywn4LS14LWGJywn4LS2J10sXG5cdFx0d2Vla0hlYWRlcjogJ+C0hicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ21sJ10pO1xufSk7XG5cbi8qIE1hbGF5c2lhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IE1vaGQgTmF3YXdpIE1vaGFtYWQgSmFtaWxpIChuYXdhd2lAcm9uZ2dlbmcubmV0KS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydtcyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1R1dHVwJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO1NlYmVsdW0nLFxuXHRcdG5leHRUZXh0OiAnU2VsZXBhcyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdoYXJpIGluaScsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXJpJywnRmVicnVhcmknLCdNYWMnLCdBcHJpbCcsJ01laScsJ0p1bicsXG5cdFx0J0p1bGFpJywnT2dvcycsJ1NlcHRlbWJlcicsJ09rdG9iZXInLCdOb3ZlbWJlcicsJ0Rpc2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hYycsJ0FwcicsJ01laScsJ0p1bicsXG5cdFx0J0p1bCcsJ09nbycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RpcyddLFxuXHRcdGRheU5hbWVzOiBbJ0FoYWQnLCdJc25pbicsJ1NlbGFzYScsJ1JhYnUnLCdLaGFtaXMnLCdKdW1hYXQnLCdTYWJ0dSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnQWhhJywnSXNuJywnU2VsJywnUmFiJywna2hhJywnSnVtJywnU2FiJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnQWgnLCdJcycsJ1NlJywnUmEnLCdLaCcsJ0p1JywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnTWcnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydtcyddKTtcbn0pO1xuXG4vKiBOb3J3ZWdpYW4gQm9rbcOlbCBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEJqw7hybiBKb2hhbnNlbiAocG9zdEBiam9ybmpvaGFuc2VuLm5vKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWyduYiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0x1a2snLFxuXHRcdHByZXZUZXh0OiAnJiN4QUI7Rm9ycmlnZScsXG5cdFx0bmV4dFRleHQ6ICdOZXN0ZSYjeEJCOycsXG5cdFx0Y3VycmVudFRleHQ6ICdJIGRhZycsXG5cdFx0bW9udGhOYW1lczogWydqYW51YXInLCdmZWJydWFyJywnbWFycycsJ2FwcmlsJywnbWFpJywnanVuaScsJ2p1bGknLCdhdWd1c3QnLCdzZXB0ZW1iZXInLCdva3RvYmVyJywnbm92ZW1iZXInLCdkZXNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydqYW4nLCdmZWInLCdtYXInLCdhcHInLCdtYWknLCdqdW4nLCdqdWwnLCdhdWcnLCdzZXAnLCdva3QnLCdub3YnLCdkZXMnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ3PDuG4nLCdtYW4nLCd0aXInLCdvbnMnLCd0b3InLCdmcmUnLCdsw7hyJ10sXG5cdFx0ZGF5TmFtZXM6IFsnc8O4bmRhZycsJ21hbmRhZycsJ3RpcnNkYWcnLCdvbnNkYWcnLCd0b3JzZGFnJywnZnJlZGFnJywnbMO4cmRhZyddLFxuXHRcdGRheU5hbWVzTWluOiBbJ3PDuCcsJ21hJywndGknLCdvbicsJ3RvJywnZnInLCdsw7gnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVWtlJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnXG5cdH07XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ25iJ10pO1xufSk7XG5cbi8qIER1dGNoIChCZWxnaXVtKSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBEYXZpZCBEZSBTbG9vdmVyZSBARGF2aWREZVNsb292ZXJlICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbmwtQkUnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdTbHVpdGVuJyxcblx0XHRwcmV2VGV4dDogJ+KGkCcsXG5cdFx0bmV4dFRleHQ6ICfihpInLFxuXHRcdGN1cnJlbnRUZXh0OiAnVmFuZGFhZycsXG5cdFx0bW9udGhOYW1lczogWydqYW51YXJpJywgJ2ZlYnJ1YXJpJywgJ21hYXJ0JywgJ2FwcmlsJywgJ21laScsICdqdW5pJyxcblx0XHQnanVsaScsICdhdWd1c3R1cycsICdzZXB0ZW1iZXInLCAnb2t0b2JlcicsICdub3ZlbWJlcicsICdkZWNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydqYW4nLCAnZmViJywgJ21ydCcsICdhcHInLCAnbWVpJywgJ2p1bicsXG5cdFx0J2p1bCcsICdhdWcnLCAnc2VwJywgJ29rdCcsICdub3YnLCAnZGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnem9uZGFnJywgJ21hYW5kYWcnLCAnZGluc2RhZycsICd3b2Vuc2RhZycsICdkb25kZXJkYWcnLCAndnJpamRhZycsICd6YXRlcmRhZyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnem9uJywgJ21hYScsICdkaW4nLCAnd29lJywgJ2RvbicsICd2cmknLCAnemF0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnem8nLCAnbWEnLCAnZGknLCAnd28nLCAnZG8nLCAndnInLCAnemEnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydubC1CRSddKTtcbn0pO1xuXG4vKiBEdXRjaCAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgTWF0aGlhcyBCeW5lbnMgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlLz4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsLm5sID0ge1xuXHRcdGNsb3NlVGV4dDogJ1NsdWl0ZW4nLFxuXHRcdHByZXZUZXh0OiAn4oaQJyxcblx0XHRuZXh0VGV4dDogJ+KGkicsXG5cdFx0Y3VycmVudFRleHQ6ICdWYW5kYWFnJyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnVhcmknLCAnZmVicnVhcmknLCAnbWFhcnQnLCAnYXByaWwnLCAnbWVpJywgJ2p1bmknLFxuXHRcdCdqdWxpJywgJ2F1Z3VzdHVzJywgJ3NlcHRlbWJlcicsICdva3RvYmVyJywgJ25vdmVtYmVyJywgJ2RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2phbicsICdmZWInLCAnbXJ0JywgJ2FwcicsICdtZWknLCAnanVuJyxcblx0XHQnanVsJywgJ2F1ZycsICdzZXAnLCAnb2t0JywgJ25vdicsICdkZWMnXSxcblx0XHRkYXlOYW1lczogWyd6b25kYWcnLCAnbWFhbmRhZycsICdkaW5zZGFnJywgJ3dvZW5zZGFnJywgJ2RvbmRlcmRhZycsICd2cmlqZGFnJywgJ3phdGVyZGFnJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyd6b24nLCAnbWFhJywgJ2RpbicsICd3b2UnLCAnZG9uJywgJ3ZyaScsICd6YXQnXSxcblx0XHRkYXlOYW1lc01pbjogWyd6bycsICdtYScsICdkaScsICd3bycsICdkbycsICd2cicsICd6YSddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLW1tLXl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWwubmwpO1xufSk7XG5cbi8qIE5vcndlZ2lhbiBOeW5vcnNrIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQmrDuHJuIEpvaGFuc2VuIChwb3N0QGJqb3Juam9oYW5zZW4ubm8pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ25uJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnTHVraycsXG5cdFx0cHJldlRleHQ6ICcmI3hBQjtGw7hycmUnLFxuXHRcdG5leHRUZXh0OiAnTmVzdGUmI3hCQjsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnSSBkYWcnLFxuXHRcdG1vbnRoTmFtZXM6IFsnamFudWFyJywnZmVicnVhcicsJ21hcnMnLCdhcHJpbCcsJ21haScsJ2p1bmknLCdqdWxpJywnYXVndXN0Jywnc2VwdGVtYmVyJywnb2t0b2JlcicsJ25vdmVtYmVyJywnZGVzZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnamFuJywnZmViJywnbWFyJywnYXByJywnbWFpJywnanVuJywnanVsJywnYXVnJywnc2VwJywnb2t0Jywnbm92JywnZGVzJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydzdW4nLCdtw6VuJywndHlzJywnb25zJywndG9yJywnZnJlJywnbGF1J10sXG5cdFx0ZGF5TmFtZXM6IFsnc3VuZGFnJywnbcOlbmRhZycsJ3R5c2RhZycsJ29uc2RhZycsJ3RvcnNkYWcnLCdmcmVkYWcnLCdsYXVyZGFnJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnc3UnLCdtw6UnLCd0eScsJ29uJywndG8nLCdmcicsJ2xhJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1Zla2UnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJydcblx0fTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbm4nXSk7XG59KTtcblxuLyogTm9yd2VnaWFuIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgTmFpbWRqb24gVGFraGlyb3YgKG5haW1kam9uQGdtYWlsLmNvbSkuICovXG5cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydubyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0x1a2snLFxuXHRcdHByZXZUZXh0OiAnJiN4QUI7Rm9ycmlnZScsXG5cdFx0bmV4dFRleHQ6ICdOZXN0ZSYjeEJCOycsXG5cdFx0Y3VycmVudFRleHQ6ICdJIGRhZycsXG5cdFx0bW9udGhOYW1lczogWydqYW51YXInLCdmZWJydWFyJywnbWFycycsJ2FwcmlsJywnbWFpJywnanVuaScsJ2p1bGknLCdhdWd1c3QnLCdzZXB0ZW1iZXInLCdva3RvYmVyJywnbm92ZW1iZXInLCdkZXNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydqYW4nLCdmZWInLCdtYXInLCdhcHInLCdtYWknLCdqdW4nLCdqdWwnLCdhdWcnLCdzZXAnLCdva3QnLCdub3YnLCdkZXMnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ3PDuG4nLCdtYW4nLCd0aXInLCdvbnMnLCd0b3InLCdmcmUnLCdsw7hyJ10sXG5cdFx0ZGF5TmFtZXM6IFsnc8O4bmRhZycsJ21hbmRhZycsJ3RpcnNkYWcnLCdvbnNkYWcnLCd0b3JzZGFnJywnZnJlZGFnJywnbMO4cmRhZyddLFxuXHRcdGRheU5hbWVzTWluOiBbJ3PDuCcsJ21hJywndGknLCdvbicsJ3RvJywnZnInLCdsw7gnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVWtlJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnXG5cdH07XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ25vJ10pO1xufSk7XG5cbi8qIFBvbGlzaCBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEphY2VrIFd5c29ja2kgKGphY2VrLnd5c29ja2lAZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydwbCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1phbWtuaWonLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7UG9wcnplZG5pJyxcblx0XHRuZXh0VGV4dDogJ05hc3TEmXBueSYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdEemnFmycsXG5cdFx0bW9udGhOYW1lczogWydTdHljemXFhCcsJ0x1dHknLCdNYXJ6ZWMnLCdLd2llY2llxYQnLCdNYWonLCdDemVyd2llYycsXG5cdFx0J0xpcGllYycsJ1NpZXJwaWXFhCcsJ1dyemVzaWXFhCcsJ1Bhxbpkemllcm5paycsJ0xpc3RvcGFkJywnR3J1ZHppZcWEJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ1N0eScsJ0x1JywnTWFyJywnS3cnLCdNYWonLCdDemUnLFxuXHRcdCdMaXAnLCdTaWUnLCdXcnonLCdQYScsJ0xpcycsJ0dydSddLFxuXHRcdGRheU5hbWVzOiBbJ05pZWR6aWVsYScsJ1BvbmllZHppYcWCZWsnLCdXdG9yZWsnLCfFmnJvZGEnLCdDendhcnRlaycsJ1BpxIV0ZWsnLCdTb2JvdGEnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ05pZScsJ1BuJywnV3QnLCfFmnInLCdDencnLCdQdCcsJ1NvJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnTicsJ1BuJywnV3QnLCfFmnInLCdDeicsJ1B0JywnU28nXSxcblx0XHR3ZWVrSGVhZGVyOiAnVHlkeicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3BsJ10pO1xufSk7XG5cbi8qIEJyYXppbGlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IExlb25pbGRvIENvc3RhIFNpbHZhIChsZW9jc2lsdmFAZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydwdC1CUiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0ZlY2hhcicsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztBbnRlcmlvcicsXG5cdFx0bmV4dFRleHQ6ICdQcsOzeGltbyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdIb2plJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbmVpcm8nLCdGZXZlcmVpcm8nLCdNYXLDp28nLCdBYnJpbCcsJ01haW8nLCdKdW5obycsXG5cdFx0J0p1bGhvJywnQWdvc3RvJywnU2V0ZW1icm8nLCdPdXR1YnJvJywnTm92ZW1icm8nLCdEZXplbWJybyddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZXYnLCdNYXInLCdBYnInLCdNYWknLCdKdW4nLFxuXHRcdCdKdWwnLCdBZ28nLCdTZXQnLCdPdXQnLCdOb3YnLCdEZXonXSxcblx0XHRkYXlOYW1lczogWydEb21pbmdvJywnU2VndW5kYS1mZWlyYScsJ1RlcsOnYS1mZWlyYScsJ1F1YXJ0YS1mZWlyYScsJ1F1aW50YS1mZWlyYScsJ1NleHRhLWZlaXJhJywnU8OhYmFkbyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnRG9tJywnU2VnJywnVGVyJywnUXVhJywnUXVpJywnU2V4JywnU8OhYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0RvbScsJ1NlZycsJ1RlcicsJ1F1YScsJ1F1aScsJ1NleCcsJ1PDoWInXSxcblx0XHR3ZWVrSGVhZGVyOiAnU20nLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydwdC1CUiddKTtcbn0pO1xuXG4vKiBQb3J0dWd1ZXNlIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydwdCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0ZlY2hhcicsXG5cdFx0cHJldlRleHQ6ICdBbnRlcmlvcicsXG5cdFx0bmV4dFRleHQ6ICdTZWd1aW50ZScsXG5cdFx0Y3VycmVudFRleHQ6ICdIb2plJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbmVpcm8nLCdGZXZlcmVpcm8nLCdNYXLDp28nLCdBYnJpbCcsJ01haW8nLCdKdW5obycsXG5cdFx0J0p1bGhvJywnQWdvc3RvJywnU2V0ZW1icm8nLCdPdXR1YnJvJywnTm92ZW1icm8nLCdEZXplbWJybyddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZXYnLCdNYXInLCdBYnInLCdNYWknLCdKdW4nLFxuXHRcdCdKdWwnLCdBZ28nLCdTZXQnLCdPdXQnLCdOb3YnLCdEZXonXSxcblx0XHRkYXlOYW1lczogWydEb21pbmdvJywnU2VndW5kYS1mZWlyYScsJ1RlcsOnYS1mZWlyYScsJ1F1YXJ0YS1mZWlyYScsJ1F1aW50YS1mZWlyYScsJ1NleHRhLWZlaXJhJywnU8OhYmFkbyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnRG9tJywnU2VnJywnVGVyJywnUXVhJywnUXVpJywnU2V4JywnU8OhYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0RvbScsJ1NlZycsJ1RlcicsJ1F1YScsJ1F1aScsJ1NleCcsJ1PDoWInXSxcblx0XHR3ZWVrSGVhZGVyOiAnU2VtJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAwLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsncHQnXSk7XG59KTtcblxuLyogUm9tYW5zaCBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFl2b25uZSBHaWVuYWwgKHl2b25uZS5naWVuYWxAZWR1Y2EuY2gpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3JtJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnU2VycmFyJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO1N1YW5kYW50Jyxcblx0XHRuZXh0VGV4dDogJ1ByZWNlZGVudCYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdBY3R1YWwnLFxuXHRcdG1vbnRoTmFtZXM6IFsnU2NoYW5lcicsJ0ZhdnJlcicsJ01hcnMnLCdBdnJpZ2wnLCdNYXRnJywnWmVyY2xhZHVyJywgJ0ZhbmFkdXInLCdBdnVzdCcsJ1NldHRlbWJlcicsJ09jdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ1NjaGEnLCdGZXYnLCdNYXInLCdBdnInLCdNYXRnJywnWmVyJywgJ0ZhbicsJ0F2dScsJ1NldHQnLCdPY3QnLCdOb3YnLCdEZWMnXSxcblx0XHRkYXlOYW1lczogWydEdW1lbmdpYScsJ0dsaW5kZXNkaScsJ01hcmRpJywnTWVzZW1uYScsJ0dpZXZnaWEnLCdWZW5kZXJkaScsJ1NvbmRhJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEdW0nLCdHbGknLCdNYXInLCdNZXMnLCdHaWUnLCdWZW4nLCdTb20nXSxcblx0XHRkYXlOYW1lc01pbjogWydEdScsJ0dsJywnTWEnLCdNZScsJ0dpJywnVmUnLCdTbyddLFxuXHRcdHdlZWtIZWFkZXI6ICdlbW5hJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsncm0nXSk7XG59KTtcblxuLyogUm9tYW5pYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLlxuICpcbiAqIFdyaXR0ZW4gYnkgRWRtb25kIEwuIChsbF9lZG1vbmRAd2FsbGEuY29tKVxuICogYW5kIElvbnV0IEcuIFN0YW4gKGlvbnV0Lmcuc3RhbkBnbWFpbC5jb20pXG4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydybyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ8OObmNoaWRlJyxcblx0XHRwcmV2VGV4dDogJyYjeEFCOyBMdW5hIHByZWNlZGVudMSDJyxcblx0XHRuZXh0VGV4dDogJ0x1bmEgdXJtxIN0b2FyZSAmI3hCQjsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnQXppJyxcblx0XHRtb250aE5hbWVzOiBbJ0lhbnVhcmllJywnRmVicnVhcmllJywnTWFydGllJywnQXByaWxpZScsJ01haScsJ0l1bmllJyxcblx0XHQnSXVsaWUnLCdBdWd1c3QnLCdTZXB0ZW1icmllJywnT2N0b21icmllJywnTm9pZW1icmllJywnRGVjZW1icmllJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0lhbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYWknLCAnSXVuJyxcblx0XHQnSXVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRkYXlOYW1lczogWydEdW1pbmljxIMnLCAnTHVuaScsICdNYXLFo2knLCAnTWllcmN1cmknLCAnSm9pJywgJ1ZpbmVyaScsICdTw6JtYsSDdMSDJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEdW0nLCAnTHVuJywgJ01hcicsICdNaWUnLCAnSm9pJywgJ1ZpbicsICdTw6JtJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnRHUnLCdMdScsJ01hJywnTWknLCdKbycsJ1ZpJywnU8OiJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1PEg3B0Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsncm8nXSk7XG59KTtcblxuLyogUnVzc2lhbiAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQW5kcmV3IFN0cm9tbm92IChzdHJvbW5vdkBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3J1J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn0JfQsNC60YDRi9GC0YwnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M70J/RgNC10LQnLFxuXHRcdG5leHRUZXh0OiAn0KHQu9C10LQmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn0KHQtdCz0L7QtNC90Y8nLFxuXHRcdG1vbnRoTmFtZXM6IFsn0K/QvdCy0LDRgNGMJywn0KTQtdCy0YDQsNC70YwnLCfQnNCw0YDRgicsJ9CQ0L/RgNC10LvRjCcsJ9Cc0LDQuScsJ9CY0Y7QvdGMJyxcblx0XHQn0JjRjtC70YwnLCfQkNCy0LPRg9GB0YInLCfQodC10L3RgtGP0LHRgNGMJywn0J7QutGC0Y/QsdGA0YwnLCfQndC+0Y/QsdGA0YwnLCfQlNC10LrQsNCx0YDRjCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfQr9C90LInLCfQpNC10LInLCfQnNCw0YAnLCfQkNC/0YAnLCfQnNCw0LknLCfQmNGO0L0nLFxuXHRcdCfQmNGO0LsnLCfQkNCy0LMnLCfQodC10L0nLCfQntC60YInLCfQndC+0Y8nLCfQlNC10LonXSxcblx0XHRkYXlOYW1lczogWyfQstC+0YHQutGA0LXRgdC10L3RjNC1Jywn0L/QvtC90LXQtNC10LvRjNC90LjQuicsJ9Cy0YLQvtGA0L3QuNC6Jywn0YHRgNC10LTQsCcsJ9GH0LXRgtCy0LXRgNCzJywn0L/Rj9GC0L3QuNGG0LAnLCfRgdGD0LHQsdC+0YLQsCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn0LLRgdC6Jywn0L/QvdC0Jywn0LLRgtGAJywn0YHRgNC0Jywn0YfRgtCyJywn0L/RgtC9Jywn0YHQsdGCJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn0JLRgScsJ9Cf0L0nLCfQktGCJywn0KHRgCcsJ9Cn0YInLCfQn9GCJywn0KHQsSddLFxuXHRcdHdlZWtIZWFkZXI6ICfQndC10LQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydydSddKTtcbn0pO1xuXG4vKiBTbG92YWsgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBWb2p0ZWNoIFJpbmlrICh2b2p0b0BobW0uc2spLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3NrJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnWmF2cmllxaUnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7UHJlZGNow6FkemFqw7pjaScsXG5cdFx0bmV4dFRleHQ6ICdOYXNsZWR1asO6Y2kmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnRG5lcycsXG5cdFx0bW9udGhOYW1lczogWydqYW51w6FyJywnZmVicnXDoXInLCdtYXJlYycsJ2FwcsOtbCcsJ23DoWonLCdqw7puJyxcblx0XHQnasO6bCcsJ2F1Z3VzdCcsJ3NlcHRlbWJlcicsJ29rdMOzYmVyJywnbm92ZW1iZXInLCdkZWNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNw6FqJywnSsO6bicsXG5cdFx0J0rDumwnLCdBdWcnLCdTZXAnLCdPa3QnLCdOb3YnLCdEZWMnXSxcblx0XHRkYXlOYW1lczogWyduZWRlxL5hJywncG9uZGVsb2snLCd1dG9yb2snLCdzdHJlZGEnLCfFoXR2cnRvaycsJ3BpYXRvaycsJ3NvYm90YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnTmVkJywnUG9uJywnVXRvJywnU3RyJywnxaB0dicsJ1BpYScsJ1NvYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ05lJywnUG8nLCdVdCcsJ1N0JywnxaB0JywnUGlhJywnU28nXSxcblx0XHR3ZWVrSGVhZGVyOiAnVHknLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzayddKTtcbn0pO1xuXG4vKiBTbG92ZW5pYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBKYWthIEphbmNhciAoamFrYUBrdWJqZS5vcmcpLiAqL1xuLyogYyA9IMSNLCBzID0gxaEgeiA9IMW+IEMgPSDEjCBTID0gxaAgWiA9IMW9ICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnc2wnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdaYXByaScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztQcmVqxaFuamknLFxuXHRcdG5leHRUZXh0OiAnTmFzbGVkbmppJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ1RyZW51dG5pJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcicsJ0ZlYnJ1YXInLCdNYXJlYycsJ0FwcmlsJywnTWFqJywnSnVuaWonLFxuXHRcdCdKdWxpaicsJ0F2Z3VzdCcsJ1NlcHRlbWJlcicsJ09rdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01haicsJ0p1bicsXG5cdFx0J0p1bCcsJ0F2ZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ05lZGVsamEnLCdQb25lZGVsamVrJywnVG9yZWsnLCdTcmVkYScsJ8SMZXRydGVrJywnUGV0ZWsnLCdTb2JvdGEnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ05lZCcsJ1BvbicsJ1RvcicsJ1NyZScsJ8SMZXQnLCdQZXQnLCdTb2InXSxcblx0XHRkYXlOYW1lc01pbjogWydOZScsJ1BvJywnVG8nLCdTcicsJ8SMZScsJ1BlJywnU28nXSxcblx0XHR3ZWVrSGVhZGVyOiAnVGVkZW4nLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzbCddKTtcbn0pO1xuXG4vKiBBbGJhbmlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEZsYWtyb24gQnl0eXFpIChmbGFrcm9uQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnc3EnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdtYnlsbGUnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7bWJyYXBhJyxcblx0XHRuZXh0VGV4dDogJ1DDq3JwYXJhJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ3NvdCcsXG5cdFx0bW9udGhOYW1lczogWydKYW5hcicsJ1Noa3VydCcsJ01hcnMnLCdQcmlsbCcsJ01haicsJ1FlcnNob3InLFxuXHRcdCdLb3JyaWsnLCdHdXNodCcsJ1NodGF0b3InLCdUZXRvcicsJ07Dq250b3InLCdEaGpldG9yJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ1NoaycsJ01hcicsJ1ByaScsJ01haicsJ1FlcicsXG5cdFx0J0tvcicsJ0d1cycsJ1NodCcsJ1RldCcsJ07Dq24nLCdEaGonXSxcblx0XHRkYXlOYW1lczogWydFIERpZWwnLCdFIEjDq27DqycsJ0UgTWFydMOrJywnRSBNw6tya3Vyw6snLCdFIEVuanRlJywnRSBQcmVtdGUnLCdFIFNodHVuZSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnRGknLCdIw6snLCdNYScsJ03DqycsJ0VuJywnUHInLCdTaCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0RpJywnSMOrJywnTWEnLCdNw6snLCdFbicsJ1ByJywnU2gnXSxcblx0XHR3ZWVrSGVhZGVyOiAnSmEnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzcSddKTtcbn0pO1xuXG4vKiBTZXJiaWFuIGkxOG4gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBEZWphbiBEaW1pxIcuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnc3ItU1InXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdaYXR2b3JpJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDOycsXG5cdFx0bmV4dFRleHQ6ICcmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnRGFuYXMnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyJywnRmVicnVhcicsJ01hcnQnLCdBcHJpbCcsJ01haicsJ0p1bicsXG5cdFx0J0p1bCcsJ0F2Z3VzdCcsJ1NlcHRlbWJhcicsJ09rdG9iYXInLCdOb3ZlbWJhcicsJ0RlY2VtYmFyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01haicsJ0p1bicsXG5cdFx0J0p1bCcsJ0F2ZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ05lZGVsamEnLCdQb25lZGVsamFrJywnVXRvcmFrJywnU3JlZGEnLCfEjGV0dnJ0YWsnLCdQZXRhaycsJ1N1Ym90YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnTmVkJywnUG9uJywnVXRvJywnU3JlJywnxIxldCcsJ1BldCcsJ1N1YiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ05lJywnUG8nLCdVdCcsJ1NyJywnxIxlJywnUGUnLCdTdSddLFxuXHRcdHdlZWtIZWFkZXI6ICdTZWQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzci1TUiddKTtcbn0pO1xuXG4vKiBTZXJiaWFuIGkxOG4gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBEZWphbiBEaW1pxIcuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnc3InXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfQl9Cw0YLQstC+0YDQuCcsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzsnLFxuXHRcdG5leHRUZXh0OiAnJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9CU0LDQvdCw0YEnLFxuXHRcdG1vbnRoTmFtZXM6IFsn0IjQsNC90YPQsNGAJywn0KTQtdCx0YDRg9Cw0YAnLCfQnNCw0YDRgicsJ9CQ0L/RgNC40LsnLCfQnNCw0ZgnLCfQiNGD0L0nLFxuXHRcdCfQiNGD0LsnLCfQkNCy0LPRg9GB0YInLCfQodC10L/RgtC10LzQsdCw0YAnLCfQntC60YLQvtCx0LDRgCcsJ9Cd0L7QstC10LzQsdCw0YAnLCfQlNC10YbQtdC80LHQsNGAJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9CI0LDQvScsJ9Ck0LXQsScsJ9Cc0LDRgCcsJ9CQ0L/RgCcsJ9Cc0LDRmCcsJ9CI0YPQvScsXG5cdFx0J9CI0YPQuycsJ9CQ0LLQsycsJ9Ch0LXQvycsJ9Ce0LrRgicsJ9Cd0L7QsicsJ9CU0LXRhiddLFxuXHRcdGRheU5hbWVzOiBbJ9Cd0LXQtNC10ZnQsCcsJ9Cf0L7QvdC10LTQtdGZ0LDQuicsJ9Cj0YLQvtGA0LDQuicsJ9Ch0YDQtdC00LAnLCfQp9C10YLQstGA0YLQsNC6Jywn0J/QtdGC0LDQuicsJ9Ch0YPQsdC+0YLQsCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn0J3QtdC0Jywn0J/QvtC9Jywn0KPRgtC+Jywn0KHRgNC1Jywn0KfQtdGCJywn0J/QtdGCJywn0KHRg9CxJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn0J3QtScsJ9Cf0L4nLCfQo9GCJywn0KHRgCcsJ9Cn0LUnLCfQn9C1Jywn0KHRgyddLFxuXHRcdHdlZWtIZWFkZXI6ICfQodC10LQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzciddKTtcbn0pO1xuXG4vKiBTd2VkaXNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQW5kZXJzIEVrZGFobCAoIGFuZGVyc0Bub21hZGl6LnNlKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzdiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1N0w6RuZycsXG5cdFx0cHJldlRleHQ6ICcmI3hBQjtGw7ZycmEnLFxuXHRcdG5leHRUZXh0OiAnTsOkc3RhJiN4QkI7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0lkYWcnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyaScsJ0ZlYnJ1YXJpJywnTWFycycsJ0FwcmlsJywnTWFqJywnSnVuaScsXG5cdFx0J0p1bGknLCdBdWd1c3RpJywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFyJywnQXByJywnTWFqJywnSnVuJyxcblx0XHQnSnVsJywnQXVnJywnU2VwJywnT2t0JywnTm92JywnRGVjJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTw7ZuJywnTcOlbicsJ1RpcycsJ09ucycsJ1RvcicsJ0ZyZScsJ0zDtnInXSxcblx0XHRkYXlOYW1lczogWydTw7ZuZGFnJywnTcOlbmRhZycsJ1Rpc2RhZycsJ09uc2RhZycsJ1RvcnNkYWcnLCdGcmVkYWcnLCdMw7ZyZGFnJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU8O2JywnTcOlJywnVGknLCdPbicsJ1RvJywnRnInLCdMw7YnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVmUnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS1tbS1kZCcsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzdiddKTtcbn0pO1xuXG4vKiBUYW1pbCAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgUyBBIFN1cmVzaGt1bWFyIChzYXNrdW1hckBsaXZlLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndGEnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfgrq7gr4Lgrp/gr4EnLFxuXHRcdHByZXZUZXh0OiAn4K6u4K+B4K6p4K+N4K6p4K+I4K6v4K6k4K+BJyxcblx0XHRuZXh0VGV4dDogJ+CuheCun+CvgeCupOCvjeCupOCupOCvgScsXG5cdFx0Y3VycmVudFRleHQ6ICfgrofgrqngr43grrHgr4EnLFxuXHRcdG1vbnRoTmFtZXM6IFsn4K6k4K+IJywn4K6u4K6+4K6a4K6/Jywn4K6q4K6Z4K+N4K6V4K+B4K6p4K6/Jywn4K6a4K6/4K6k4K+N4K6k4K6/4K6w4K+IJywn4K614K+I4K6V4K6+4K6a4K6/Jywn4K6G4K6p4K6/Jyxcblx0XHQn4K6G4K6f4K6/Jywn4K6G4K614K6j4K6/Jywn4K6q4K+B4K6w4K6f4K+N4K6f4K6+4K6a4K6/Jywn4K6Q4K6q4K+N4K6q4K6a4K6/Jywn4K6V4K6+4K6w4K+N4K6k4K+N4K6k4K6/4K6V4K+IJywn4K6u4K6+4K6w4K+N4K6V4K604K6/J10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ+CupOCviCcsJ+CuruCuvuCumuCuvycsJ+CuquCumeCvjScsJ+CumuCuv+CupOCvjScsJ+CuteCviOCuleCuvicsJ+CuhuCuqeCuvycsXG5cdFx0J+CuhuCun+CuvycsJ+CuhuCutScsJ+CuquCvgeCusCcsJ+CukOCuquCvjScsJ+CuleCuvuCusOCvjScsJ+CuruCuvuCusOCvjSddLFxuXHRcdGRheU5hbWVzOiBbJ+CunuCuvuCur+Cuv+CuseCvjeCuseCvgeCuleCvjeCuleCuv+CutOCuruCviCcsJ+CupOCuv+CumeCvjeCuleCun+CvjeCuleCuv+CutOCuruCviCcsJ+CumuCvhuCuteCvjeCuteCuvuCur+CvjeCuleCvjeCuleCuv+CutOCuruCviCcsJ+CuquCvgeCupOCuqeCvjeCuleCuv+CutOCuruCviCcsJ+CuteCuv+Cur+CuvuCutOCuleCvjeCuleCuv+CutOCuruCviCcsJ+CuteCvhuCus+CvjeCus+Cuv+CuleCvjeCuleCuv+CutOCuruCviCcsJ+CumuCuqeCuv+CuleCvjeCuleCuv+CutOCuruCviCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn4K6e4K6+4K6v4K6/4K6x4K+BJywn4K6k4K6/4K6Z4K+N4K6V4K6z4K+NJywn4K6a4K+G4K614K+N4K614K6+4K6v4K+NJywn4K6q4K+B4K6k4K6p4K+NJywn4K614K6/4K6v4K6+4K604K6p4K+NJywn4K614K+G4K6z4K+N4K6z4K6/Jywn4K6a4K6p4K6/J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn4K6e4K6+Jywn4K6k4K6/Jywn4K6a4K+GJywn4K6q4K+BJywn4K614K6/Jywn4K614K+GJywn4K6aJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9Cd0LUnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd0YSddKTtcbn0pO1xuXG4vKiBUaGFpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgcGlwbyAocGlwb0BzaXhoZWFkLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndGgnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfguJvguLTguJQnLFxuXHRcdHByZXZUZXh0OiAnJiN4QUI7JiN4QTA74Lii4LmJ4Lit4LiZJyxcblx0XHRuZXh0VGV4dDogJ+C4luC4seC4lOC5hOC4myYjeEEwOyYjeEJCOycsXG5cdFx0Y3VycmVudFRleHQ6ICfguKfguLHguJnguJnguLXguYknLFxuXHRcdG1vbnRoTmFtZXM6IFsn4Lih4LiB4Lij4Liy4LiE4LihJywn4LiB4Li44Lih4Lig4Liy4Lie4Lix4LiZ4LiY4LmMJywn4Lih4Li14LiZ4Liy4LiE4LihJywn4LmA4Lih4Lip4Liy4Lii4LiZJywn4Lie4Lik4Lip4Lig4Liy4LiE4LihJywn4Lih4Li04LiW4Li44LiZ4Liy4Lii4LiZJyxcblx0XHQn4LiB4Lij4LiB4LiO4Liy4LiE4LihJywn4Liq4Li04LiH4Lir4Liy4LiE4LihJywn4LiB4Lix4LiZ4Lii4Liy4Lii4LiZJywn4LiV4Li44Lil4Liy4LiE4LihJywn4Lie4Lik4Lio4LiI4Li04LiB4Liy4Lii4LiZJywn4LiY4Lix4LiZ4Lin4Liy4LiE4LihJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ+C4oS7guIQuJywn4LiBLuC4ni4nLCfguKHguLUu4LiELicsJ+C5gOC4oS7guKIuJywn4LieLuC4hC4nLCfguKHguLQu4LiiLicsXG5cdFx0J+C4gS7guIQuJywn4LiqLuC4hC4nLCfguIEu4LiiLicsJ+C4lS7guIQuJywn4LieLuC4oi4nLCfguJgu4LiELiddLFxuXHRcdGRheU5hbWVzOiBbJ+C4reC4suC4l+C4tOC4leC4ouC5jCcsJ+C4iOC4seC4meC4l+C4o+C5jCcsJ+C4reC4seC4h+C4hOC4suC4oycsJ+C4nuC4uOC4mCcsJ+C4nuC4pOC4q+C4seC4quC4muC4lOC4tScsJ+C4qOC4uOC4geC4o+C5jCcsJ+C5gOC4quC4suC4o+C5jCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn4Lit4LiyLicsJ+C4iC4nLCfguK0uJywn4LieLicsJ+C4nuC4pC4nLCfguKguJywn4LiqLiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ+C4reC4si4nLCfguIguJywn4LitLicsJ+C4ni4nLCfguJ7guKQuJywn4LioLicsJ+C4qi4nXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd0aCddKTtcbn0pO1xuXG4vKiBUYWppa2kgKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEFiZHVyYWhtb24gU2FpZG92IChzYWlkb3ZhYkBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3RqJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn0JjQtNC+0LzQsCcsXG5cdFx0cHJldlRleHQ6ICcmI3gzYzvSmtCw0YTQvicsXG5cdFx0bmV4dFRleHQ6ICfQn9C10YgmI3gzZTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn0JjQvNGA06/QtycsXG5cdFx0bW9udGhOYW1lczogWyfQr9C90LLQsNGAJywn0KTQtdCy0YDQsNC7Jywn0JzQsNGA0YInLCfQkNC/0YDQtdC7Jywn0JzQsNC5Jywn0JjRjtC9Jyxcblx0XHQn0JjRjtC7Jywn0JDQstCz0YPRgdGCJywn0KHQtdC90YLRj9Cx0YAnLCfQntC60YLRj9Cx0YAnLCfQndC+0Y/QsdGAJywn0JTQtdC60LDQsdGAJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9Cv0L3QsicsJ9Ck0LXQsicsJ9Cc0LDRgCcsJ9CQ0L/RgCcsJ9Cc0LDQuScsJ9CY0Y7QvScsXG5cdFx0J9CY0Y7QuycsJ9CQ0LLQsycsJ9Ch0LXQvScsJ9Ce0LrRgicsJ9Cd0L7RjycsJ9CU0LXQuiddLFxuXHRcdGRheU5hbWVzOiBbJ9GP0LrRiNCw0L3QsdC1Jywn0LTRg9GI0LDQvdCx0LUnLCfRgdC10YjQsNC90LHQtScsJ9GH0L7RgNGI0LDQvdCx0LUnLCfQv9Cw0L3St9GI0LDQvdCx0LUnLCfSt9GD0LzRitCwJywn0YjQsNC90LHQtSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn0Y/QutGIJywn0LTRg9GIJywn0YHQtdGIJywn0YfQvtGAJywn0L/QsNC9Jywn0rfRg9C8Jywn0YjQsNC9J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn0K/QuicsJ9CU0YgnLCfQodGIJywn0KfRiCcsJ9Cf0YgnLCfSttC8Jywn0KjQvSddLFxuXHRcdHdlZWtIZWFkZXI6ICfQpdGEJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndGonXSk7XG59KTtcblxuLyogVGV0dW0gKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEFsZXhhbmRydSBDYXJ0YWxlYW51IChhY2FydGFsZWFudUBkZXZlbG9wbWVudGdhdGV3YXkub3JnKS4gKi9cbi8qIExPQ0FMIEFNUCBDT0RFIC0tIFRISVMgV0lMTCBESVNBUFBFQVIgKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd0bSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0hhbG8gb25hJyxcblx0XHRwcmV2VGV4dDogJ1VsdWsnLFxuXHRcdG5leHRUZXh0OiAnVHVpciBtYWknLFxuXHRcdGN1cnJlbnRUZXh0OiAnT2hpbiBsb3JvbicsXG5cdFx0bW9udGhOYW1lczogWydKYW5laXJ1JywnRmV2cmVpcnUnLCdNYXJzdScsJ0FicmlsJywnTWFpdScsJ0p1bmh1Jyxcblx0XHQnSnVsaHUnLCdBZ29zdHUnLCdTZXB0ZW1icnUnLCdPdHVicnUnLCdOb3ZlbWJydScsJ0RlenJlbWJydSddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmV2JywgJ01hcicsICdBYnInLCAnTWFpJywgJ0p1bicsXG5cdFx0J0p1bCcsICdBZ28nLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGV6J10sXG5cdFx0ZGF5TmFtZXM6IFsnRHVtaW5ndScsICdTZWd1bmRhJywgJ1RlcnNhJywgJ0t1YXJ0YScsICdLaW50YScsICdTZXN0YScsICdTYWJhZHUnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ0R1bScsICdTZWcnLCAnVGVyJywgJ0tydCcsICdLaW4nLCAnU2VzJywgJ1NhYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0RtJywnU2cnLCdUcicsJ0t0JywnS24nLCdTcycsJ1NiJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1NtJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndG0nXSk7XG59KTtcbi8qIFR1cmtpc2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBJenpldCBFbXJlIEVya2FuIChrYXJhQGthcmFsYW1hbGFyLm5ldCkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndHInXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdrYXBhdCcsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztnZXJpJyxcblx0XHRuZXh0VGV4dDogJ2lsZXJpJiN4M2UnLFxuXHRcdGN1cnJlbnRUZXh0OiAnYnVnw7xuJyxcblx0XHRtb250aE5hbWVzOiBbJ09jYWsnLCfFnnViYXQnLCdNYXJ0JywnTmlzYW4nLCdNYXnEsXMnLCdIYXppcmFuJyxcblx0XHQnVGVtbXV6JywnQcSfdXN0b3MnLCdFeWzDvGwnLCdFa2ltJywnS2FzxLFtJywnQXJhbMSxayddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydPY2EnLCfFnnViJywnTWFyJywnTmlzJywnTWF5JywnSGF6Jyxcblx0XHQnVGVtJywnQcSfdScsJ0V5bCcsJ0VraScsJ0thcycsJ0FyYSddLFxuXHRcdGRheU5hbWVzOiBbJ1BhemFyJywnUGF6YXJ0ZXNpJywnU2FsxLEnLCfDh2FyxZ9hbWJhJywnUGVyxZ9lbWJlJywnQ3VtYScsJ0N1bWFydGVzaSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnUHonLCdQdCcsJ1NhJywnw4dhJywnUGUnLCdDdScsJ0N0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnUHonLCdQdCcsJ1NhJywnw4dhJywnUGUnLCdDdScsJ0N0J10sXG5cdFx0d2Vla0hlYWRlcjogJ0hmJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndHInXSk7XG59KTtcblxuLyogVWtyYWluaWFuIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBNYXhpbSBEcm9nb2JpdHNraXkgKG1heGRhb0BnbWFpbC5jb20pLiAqL1xuLyogQ29ycmVjdGVkIGJ5IElnb3IgTWlsbGEgKGlnb3IuZnNwLm1pbGxhQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndWsnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfQl9Cw0LrRgNC40YLQuCcsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzsnLFxuXHRcdG5leHRUZXh0OiAnJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9Ch0YzQvtCz0L7QtNC90ZYnLFxuXHRcdG1vbnRoTmFtZXM6IFsn0KHRltGH0LXQvdGMJywn0JvRjtGC0LjQuScsJ9CR0LXRgNC10LfQtdC90YwnLCfQmtCy0ZbRgtC10L3RjCcsJ9Ci0YDQsNCy0LXQvdGMJywn0KfQtdGA0LLQtdC90YwnLFxuXHRcdCfQm9C40L/QtdC90YwnLCfQodC10YDQv9C10L3RjCcsJ9CS0LXRgNC10YHQtdC90YwnLCfQltC+0LLRgtC10L3RjCcsJ9Cb0LjRgdGC0L7Qv9Cw0LQnLCfQk9GA0YPQtNC10L3RjCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfQodGW0YcnLCfQm9GO0YInLCfQkdC10YAnLCfQmtCy0ZYnLCfQotGA0LAnLCfQp9C10YAnLFxuXHRcdCfQm9C40L8nLCfQodC10YAnLCfQktC10YAnLCfQltC+0LInLCfQm9C40YEnLCfQk9GA0YMnXSxcblx0XHRkYXlOYW1lczogWyfQvdC10LTRltC70Y8nLCfQv9C+0L3QtdC00ZbQu9C+0LonLCfQstGW0LLRgtC+0YDQvtC6Jywn0YHQtdGA0LXQtNCwJywn0YfQtdGC0LLQtdGAJywn0L/igJnRj9GC0L3QuNGG0Y8nLCfRgdGD0LHQvtGC0LAnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9C90LXQtCcsJ9C/0L3QtCcsJ9Cy0ZbQsicsJ9GB0YDQtCcsJ9GH0YLQsicsJ9C/0YLQvScsJ9GB0LHRgiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9Cd0LQnLCfQn9C9Jywn0JLRgicsJ9Ch0YAnLCfQp9GCJywn0J/RgicsJ9Ch0LEnXSxcblx0XHR3ZWVrSGVhZGVyOiAn0KLQuNC2Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndWsnXSk7XG59KTtcblxuLyogVmlldG5hbWVzZSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBUcmFuc2xhdGVkIGJ5IExlIFRoYW5oIEh1eSAobHRoYW5oaHV5QGNpdC5jdHUuZWR1LnZuKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd2aSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ8SQw7NuZycsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztUcsaw4bubYycsXG5cdFx0bmV4dFRleHQ6ICdUaeG6v3AmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnSMO0bSBuYXknLFxuXHRcdG1vbnRoTmFtZXM6IFsnVGjDoW5nIE3hu5l0JywgJ1Row6FuZyBIYWknLCAnVGjDoW5nIEJhJywgJ1Row6FuZyBUxrAnLCAnVGjDoW5nIE7Eg20nLCAnVGjDoW5nIFPDoXUnLFxuXHRcdCdUaMOhbmcgQuG6o3knLCAnVGjDoW5nIFTDoW0nLCAnVGjDoW5nIENow61uJywgJ1Row6FuZyBNxrDhu51pJywgJ1Row6FuZyBNxrDhu51pIE3hu5l0JywgJ1Row6FuZyBNxrDhu51pIEhhaSddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydUaMOhbmcgMScsICdUaMOhbmcgMicsICdUaMOhbmcgMycsICdUaMOhbmcgNCcsICdUaMOhbmcgNScsICdUaMOhbmcgNicsXG5cdFx0J1Row6FuZyA3JywgJ1Row6FuZyA4JywgJ1Row6FuZyA5JywgJ1Row6FuZyAxMCcsICdUaMOhbmcgMTEnLCAnVGjDoW5nIDEyJ10sXG5cdFx0ZGF5TmFtZXM6IFsnQ2jhu6cgTmjhuq10JywgJ1Ro4bupIEhhaScsICdUaOG7qSBCYScsICdUaOG7qSBUxrAnLCAnVGjhu6kgTsSDbScsICdUaOG7qSBTw6F1JywgJ1Ro4bupIELhuqN5J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydDTicsICdUMicsICdUMycsICdUNCcsICdUNScsICdUNicsICdUNyddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0NOJywgJ1QyJywgJ1QzJywgJ1Q0JywgJ1Q1JywgJ1Q2JywgJ1Q3J10sXG5cdFx0d2Vla0hlYWRlcjogJ1R1Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAwLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndmknXSk7XG59KTtcblxuLyogQ2hpbmVzZSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IENsb3VkcmVhbSAoY2xvdWRyZWFtQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnemgtQ04nXSA9IHtcblx0XHRjbG9zZVRleHQ6ICflhbPpl60nLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M75LiK5pyIJyxcblx0XHRuZXh0VGV4dDogJ+S4i+aciCYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfku4rlpKknLFxuXHRcdG1vbnRoTmFtZXM6IFsn5LiA5pyIJywn5LqM5pyIJywn5LiJ5pyIJywn5Zub5pyIJywn5LqU5pyIJywn5YWt5pyIJyxcblx0XHQn5LiD5pyIJywn5YWr5pyIJywn5Lmd5pyIJywn5Y2B5pyIJywn5Y2B5LiA5pyIJywn5Y2B5LqM5pyIJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ+S4gOaciCcsJ+S6jOaciCcsJ+S4ieaciCcsJ+Wbm+aciCcsJ+S6lOaciCcsJ+WFreaciCcsXG5cdFx0J+S4g+aciCcsJ+WFq+aciCcsJ+S5neaciCcsJ+WNgeaciCcsJ+WNgeS4gOaciCcsJ+WNgeS6jOaciCddLFxuXHRcdGRheU5hbWVzOiBbJ+aYn+acn+aXpScsJ+aYn+acn+S4gCcsJ+aYn+acn+S6jCcsJ+aYn+acn+S4iScsJ+aYn+acn+WbmycsJ+aYn+acn+S6lCcsJ+aYn+acn+WFrSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn5ZGo5pelJywn5ZGo5LiAJywn5ZGo5LqMJywn5ZGo5LiJJywn5ZGo5ZubJywn5ZGo5LqUJywn5ZGo5YWtJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn5pelJywn5LiAJywn5LqMJywn5LiJJywn5ZubJywn5LqUJywn5YWtJ10sXG5cdFx0d2Vla0hlYWRlcjogJ+WRqCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiB0cnVlLFxuXHRcdHllYXJTdWZmaXg6ICflubQnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnemgtQ04nXSk7XG59KTtcblxuLyogQ2hpbmVzZSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFNDQ1kgKHNhbXVlbGN5Y2hhbkBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3poLUhLJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn6Zec6ZaJJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO+S4iuaciCcsXG5cdFx0bmV4dFRleHQ6ICfkuIvmnIgmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn5LuK5aSpJyxcblx0XHRtb250aE5hbWVzOiBbJ+S4gOaciCcsJ+S6jOaciCcsJ+S4ieaciCcsJ+Wbm+aciCcsJ+S6lOaciCcsJ+WFreaciCcsXG5cdFx0J+S4g+aciCcsJ+WFq+aciCcsJ+S5neaciCcsJ+WNgeaciCcsJ+WNgeS4gOaciCcsJ+WNgeS6jOaciCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfkuIDmnIgnLCfkuozmnIgnLCfkuInmnIgnLCflm5vmnIgnLCfkupTmnIgnLCflha3mnIgnLFxuXHRcdCfkuIPmnIgnLCflhavmnIgnLCfkuZ3mnIgnLCfljYHmnIgnLCfljYHkuIDmnIgnLCfljYHkuozmnIgnXSxcblx0XHRkYXlOYW1lczogWyfmmJ/mnJ/ml6UnLCfmmJ/mnJ/kuIAnLCfmmJ/mnJ/kuownLCfmmJ/mnJ/kuIknLCfmmJ/mnJ/lm5snLCfmmJ/mnJ/kupQnLCfmmJ/mnJ/lha0nXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ+WRqOaXpScsJ+WRqOS4gCcsJ+WRqOS6jCcsJ+WRqOS4iScsJ+WRqOWbmycsJ+WRqOS6lCcsJ+WRqOWFrSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ+aXpScsJ+S4gCcsJ+S6jCcsJ+S4iScsJ+WbmycsJ+S6lCcsJ+WFrSddLFxuXHRcdHdlZWtIZWFkZXI6ICflkagnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC1tbS15eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogdHJ1ZSxcblx0XHR5ZWFyU3VmZml4OiAn5bm0J307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3poLUhLJ10pO1xufSk7XG5cbi8qIENoaW5lc2UgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBSZXNzb2wgKHJlc3NvbEBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3poLVRXJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn6Zec6ZaJJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO+S4iuaciCcsXG5cdFx0bmV4dFRleHQ6ICfkuIvmnIgmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn5LuK5aSpJyxcblx0XHRtb250aE5hbWVzOiBbJ+S4gOaciCcsJ+S6jOaciCcsJ+S4ieaciCcsJ+Wbm+aciCcsJ+S6lOaciCcsJ+WFreaciCcsXG5cdFx0J+S4g+aciCcsJ+WFq+aciCcsJ+S5neaciCcsJ+WNgeaciCcsJ+WNgeS4gOaciCcsJ+WNgeS6jOaciCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfkuIDmnIgnLCfkuozmnIgnLCfkuInmnIgnLCflm5vmnIgnLCfkupTmnIgnLCflha3mnIgnLFxuXHRcdCfkuIPmnIgnLCflhavmnIgnLCfkuZ3mnIgnLCfljYHmnIgnLCfljYHkuIDmnIgnLCfljYHkuozmnIgnXSxcblx0XHRkYXlOYW1lczogWyfmmJ/mnJ/ml6UnLCfmmJ/mnJ/kuIAnLCfmmJ/mnJ/kuownLCfmmJ/mnJ/kuIknLCfmmJ/mnJ/lm5snLCfmmJ/mnJ/kupQnLCfmmJ/mnJ/lha0nXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ+WRqOaXpScsJ+WRqOS4gCcsJ+WRqOS6jCcsJ+WRqOS4iScsJ+WRqOWbmycsJ+WRqOS6lCcsJ+WRqOWFrSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ+aXpScsJ+S4gCcsJ+S6jCcsJ+S4iScsJ+WbmycsJ+S6lCcsJ+WFrSddLFxuXHRcdHdlZWtIZWFkZXI6ICflkagnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS9tbS9kZCcsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogdHJ1ZSxcblx0XHR5ZWFyU3VmZml4OiAn5bm0J307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3poLVRXJ10pO1xufSk7XG5cblxuLyogRW5nbGlzaC9FTiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFN0dWFydC4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0RvbmUnLFxuXHRcdHByZXZUZXh0OiAnUHJldicsXG5cdFx0bmV4dFRleHQ6ICdOZXh0Jyxcblx0XHRjdXJyZW50VGV4dDogJ1RvZGF5Jyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcnknLCdGZWJydWFyeScsJ01hcmNoJywnQXByaWwnLCdNYXknLCdKdW5lJyxcblx0XHQnSnVseScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09jdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcblx0XHQnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdNbycsJ1R1JywnV2UnLCdUaCcsJ0ZyJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbi1HQiddKTtcbn0pOyIsIi8qXG5cbiQuTGluayAocGFydCBvZiBub1VpU2xpZGVyKSAtIFdURlBMICovXG4oZnVuY3Rpb24oYyl7ZnVuY3Rpb24gbShhLGMsZCl7aWYoKGFbY118fGFbZF0pJiZhW2NdPT09YVtkXSl0aHJvdyBFcnJvcihcIihMaW5rKSAnXCIrYytcIicgY2FuJ3QgbWF0Y2ggJ1wiK2QrXCInLidcIik7fWZ1bmN0aW9uIHIoYSl7dm9pZCAwPT09YSYmKGE9e30pO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYSl0aHJvdyBFcnJvcihcIihGb3JtYXQpICdmb3JtYXQnIG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdC5cIik7dmFyIGg9e307Yyh1KS5lYWNoKGZ1bmN0aW9uKGMsbil7aWYodm9pZCAwPT09YVtuXSloW25dPUFbY107ZWxzZSBpZih0eXBlb2YgYVtuXT09PXR5cGVvZiBBW2NdKXtpZihcImRlY2ltYWxzXCI9PT1uJiYoMD5hW25dfHw3PGFbbl0pKXRocm93IEVycm9yKFwiKEZvcm1hdCkgJ2Zvcm1hdC5kZWNpbWFscycgb3B0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA3LlwiKTtoW25dPWFbbl19ZWxzZSB0aHJvdyBFcnJvcihcIihGb3JtYXQpICdmb3JtYXQuXCIrbitcIicgbXVzdCBiZSBhIFwiK3R5cGVvZiBBW2NdK1xuXCIuXCIpO30pO20oaCxcIm1hcmtcIixcInRob3VzYW5kXCIpO20oaCxcInByZWZpeFwiLFwibmVnYXRpdmVcIik7bShoLFwicHJlZml4XCIsXCJuZWdhdGl2ZUJlZm9yZVwiKTt0aGlzLnI9aH1mdW5jdGlvbiBrKGEsaCl7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZjLmVycm9yKFwiKExpbmspIEluaXRpYWxpemUgd2l0aCBhbiBvYmplY3QuXCIpO3JldHVybiBuZXcgay5wcm90b3R5cGUucChhLnRhcmdldHx8ZnVuY3Rpb24oKXt9LGEubWV0aG9kLGEuZm9ybWF0fHx7fSxoKX12YXIgdT1cImRlY2ltYWxzIG1hcmsgdGhvdXNhbmQgcHJlZml4IHBvc3RmaXggZW5jb2RlciBkZWNvZGVyIG5lZ2F0aXZlIG5lZ2F0aXZlQmVmb3JlIHRvIGZyb21cIi5zcGxpdChcIiBcIiksQT1bMixcIi5cIixcIlwiLFwiXCIsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYX0sZnVuY3Rpb24oYSl7cmV0dXJuIGF9LFwiLVwiLFwiXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGF9LGZ1bmN0aW9uKGEpe3JldHVybiBhfV07ci5wcm90b3R5cGUuYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5yW2FdfTtcbnIucHJvdG90eXBlLkw9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKX1hPXRoaXMuYShcImVuY29kZXJcIikoYSk7dmFyIGQ9dGhpcy5hKFwiZGVjaW1hbHNcIiksbj1cIlwiLGs9XCJcIixtPVwiXCIscj1cIlwiOzA9PT1wYXJzZUZsb2F0KGEudG9GaXhlZChkKSkmJihhPVwiMFwiKTswPmEmJihuPXRoaXMuYShcIm5lZ2F0aXZlXCIpLGs9dGhpcy5hKFwibmVnYXRpdmVCZWZvcmVcIikpO2E9TWF0aC5hYnMoYSkudG9GaXhlZChkKS50b1N0cmluZygpO2E9YS5zcGxpdChcIi5cIik7dGhpcy5hKFwidGhvdXNhbmRcIik/KG09YyhhWzBdKS5tYXRjaCgvLnsxLDN9L2cpLG09YyhtLmpvaW4oYyh0aGlzLmEoXCJ0aG91c2FuZFwiKSkpKSk6bT1hWzBdO3RoaXMuYShcIm1hcmtcIikmJjE8YS5sZW5ndGgmJihyPXRoaXMuYShcIm1hcmtcIikrYVsxXSk7cmV0dXJuIHRoaXMuYShcInRvXCIpKGsrdGhpcy5hKFwicHJlZml4XCIpK24rbStyK3RoaXMuYShcInBvc3RmaXhcIikpfTtyLnByb3RvdHlwZS53PVxuZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYS5yZXBsYWNlKC9bXFwtXFwvXFxcXFxcXiQqKz8uKCl8XFxbXFxde31dL2csXCJcXFxcJCZcIil9dmFyIGQ7aWYobnVsbD09PWF8fHZvaWQgMD09PWEpcmV0dXJuITE7YT10aGlzLmEoXCJmcm9tXCIpKGEpO2E9YS50b1N0cmluZygpO2Q9YS5yZXBsYWNlKFJlZ0V4cChcIl5cIitjKHRoaXMuYShcIm5lZ2F0aXZlQmVmb3JlXCIpKSksXCJcIik7YSE9PWQ/KGE9ZCxkPVwiLVwiKTpkPVwiXCI7YT1hLnJlcGxhY2UoUmVnRXhwKFwiXlwiK2ModGhpcy5hKFwicHJlZml4XCIpKSksXCJcIik7dGhpcy5hKFwibmVnYXRpdmVcIikmJihkPVwiXCIsYT1hLnJlcGxhY2UoUmVnRXhwKFwiXlwiK2ModGhpcy5hKFwibmVnYXRpdmVcIikpKSxcIi1cIikpO2E9YS5yZXBsYWNlKFJlZ0V4cChjKHRoaXMuYShcInBvc3RmaXhcIikpK1wiJFwiKSxcIlwiKS5yZXBsYWNlKFJlZ0V4cChjKHRoaXMuYShcInRob3VzYW5kXCIpKSxcImdcIiksXCJcIikucmVwbGFjZSh0aGlzLmEoXCJtYXJrXCIpLFwiLlwiKTthPXRoaXMuYShcImRlY29kZXJcIikocGFyc2VGbG9hdChkK1xuYSkpO3JldHVybiBpc05hTihhKT8hMTphfTtrLnByb3RvdHlwZS5LPWZ1bmN0aW9uKGEsaCl7dGhpcy5tZXRob2Q9aHx8XCJodG1sXCI7dGhpcy5qPWMoYS5yZXBsYWNlKFwiLXRvb2x0aXAtXCIsXCJcIil8fFwiPGRpdi8+XCIpWzBdfTtrLnByb3RvdHlwZS5IPWZ1bmN0aW9uKGEpe3RoaXMubWV0aG9kPVwidmFsXCI7dGhpcy5qPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTt0aGlzLmoubmFtZT1hO3RoaXMuai50eXBlPVwiaGlkZGVuXCJ9O2sucHJvdG90eXBlLkc9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gaChhLGMpe3JldHVybltjP251bGw6YSxjP2E6bnVsbF19dmFyIGQ9dGhpczt0aGlzLm1ldGhvZD1cInZhbFwiO3RoaXMudGFyZ2V0PWEub24oXCJjaGFuZ2VcIixmdW5jdGlvbihhKXtkLkIudmFsKGgoYyhhLnRhcmdldCkudmFsKCksZC50KSx7bGluazpkLHNldDohMH0pfSl9O2sucHJvdG90eXBlLnA9ZnVuY3Rpb24oYSxoLGQsayl7dGhpcy5nPWQ7dGhpcy51cGRhdGU9IWs7aWYoXCJzdHJpbmdcIj09PVxudHlwZW9mIGEmJjA9PT1hLmluZGV4T2YoXCItdG9vbHRpcC1cIikpdGhpcy5LKGEsaCk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEmJjAhPT1hLmluZGV4T2YoXCItXCIpKXRoaXMuSChhKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXRoaXMudGFyZ2V0PSExLHRoaXMubWV0aG9kPWE7ZWxzZXtpZihhIGluc3RhbmNlb2YgY3x8Yy56ZXB0byYmYy56ZXB0by5pc1ooYSkpe2lmKCFoKXtpZihhLmlzKFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWFcIikpe3RoaXMuRyhhKTtyZXR1cm59aD1cImh0bWxcIn1pZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgaHx8XCJzdHJpbmdcIj09PXR5cGVvZiBoJiZhW2hdKXt0aGlzLm1ldGhvZD1oO3RoaXMudGFyZ2V0PWE7cmV0dXJufX10aHJvdyBuZXcgUmFuZ2VFcnJvcihcIihMaW5rKSBJbnZhbGlkIExpbmsuXCIpO319O2sucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGEsYyxkLGspe2lmKCF0aGlzLnVwZGF0ZXx8ITEhPT1rKWlmKHRoaXMudT1hLHRoaXMuRj1hPVxudGhpcy5mb3JtYXQoYSksXCJmdW5jdGlvblwiPT09dHlwZW9mIHRoaXMubWV0aG9kKXRoaXMubWV0aG9kLmNhbGwodGhpcy50YXJnZXRbMF18fGRbMF0sYSxjLGQpO2Vsc2UgdGhpcy50YXJnZXRbdGhpcy5tZXRob2RdKGEsYyxkKX07ay5wcm90b3R5cGUucT1mdW5jdGlvbihhKXt0aGlzLmc9bmV3IHIoYy5leHRlbmQoe30sYSx0aGlzLmcgaW5zdGFuY2VvZiByP3RoaXMuZy5yOnRoaXMuZykpfTtrLnByb3RvdHlwZS5KPWZ1bmN0aW9uKGEpe3RoaXMuQj1hfTtrLnByb3RvdHlwZS5JPWZ1bmN0aW9uKGEpe3RoaXMudD1hfTtrLnByb3RvdHlwZS5mb3JtYXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZy5MKGEpfTtrLnByb3RvdHlwZS5BPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmcudyhhKX07ay5wcm90b3R5cGUucC5wcm90b3R5cGU9ay5wcm90b3R5cGU7Yy5MaW5rPWt9KSh3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG8pOy8qXG5cbiQuZm4ubm9VaVNsaWRlciAtIFdURlBMIC0gcmVmcmVzaGxlc3MuY29tL25vdWlzbGlkZXIvICovXG4oZnVuY3Rpb24oYyl7ZnVuY3Rpb24gbShlKXtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGUmJiFpc05hTihlKSYmaXNGaW5pdGUoZSl9ZnVuY3Rpb24gcihlKXtyZXR1cm4gYy5pc0FycmF5KGUpP2U6W2VdfWZ1bmN0aW9uIGsoZSxiKXtlLmFkZENsYXNzKGIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtlLnJlbW92ZUNsYXNzKGIpfSwzMDApfWZ1bmN0aW9uIHUoZSxiKXtyZXR1cm4gMTAwKmIvKGVbMV0tZVswXSl9ZnVuY3Rpb24gQShlLGIpe2lmKGI+PWUuZC5zbGljZSgtMSlbMF0pcmV0dXJuIDEwMDtmb3IodmFyIGE9MSxjLGYsZDtiPj1lLmRbYV07KWErKztjPWUuZFthLTFdO2Y9ZS5kW2FdO2Q9ZS5jW2EtMV07Yz1bYyxmXTtyZXR1cm4gZCt1KGMsMD5jWzBdP2IrTWF0aC5hYnMoY1swXSk6Yi1jWzBdKS8oMTAwLyhlLmNbYV0tZCkpfWZ1bmN0aW9uIGEoZSxiKXtpZigxMDA8PWIpcmV0dXJuIGUuZC5zbGljZSgtMSlbMF07Zm9yKHZhciBhPTEsYyxmLGQ7Yj49ZS5jW2FdOylhKys7Yz1cbmUuZFthLTFdO2Y9ZS5kW2FdO2Q9ZS5jW2EtMV07Yz1bYyxmXTtyZXR1cm4gMTAwLyhlLmNbYV0tZCkqKGItZCkqKGNbMV0tY1swXSkvMTAwK2NbMF19ZnVuY3Rpb24gaChhLGIpe2Zvcih2YXIgYz0xLGc7KGEuZGlyPzEwMC1iOmIpPj1hLmNbY107KWMrKztpZihhLm0pcmV0dXJuIGc9YS5jW2MtMV0sYz1hLmNbY10sYi1nPihjLWcpLzI/YzpnO2EuaFtjLTFdPyhnPWEuaFtjLTFdLGM9YS5jW2MtMV0rTWF0aC5yb3VuZCgoYi1hLmNbYy0xXSkvZykqZyk6Yz1iO3JldHVybiBjfWZ1bmN0aW9uIGQoYSxiKXtpZighbShiKSl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdzdGVwJyBpcyBub3QgbnVtZXJpYy5cIik7YS5oWzBdPWJ9ZnVuY3Rpb24gbihhLGIpe2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYnx8Yy5pc0FycmF5KGIpKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3JhbmdlJyBpcyBub3QgYW4gb2JqZWN0LlwiKTtpZih2b2lkIDA9PT1iLm1pbnx8dm9pZCAwPT09Yi5tYXgpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiBNaXNzaW5nICdtaW4nIG9yICdtYXgnIGluICdyYW5nZScuXCIpO1xuYy5lYWNoKGIsZnVuY3Rpb24oYixnKXt2YXIgZDtcIm51bWJlclwiPT09dHlwZW9mIGcmJihnPVtnXSk7aWYoIWMuaXNBcnJheShnKSl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgY29udGFpbnMgaW52YWxpZCB2YWx1ZS5cIik7ZD1cIm1pblwiPT09Yj8wOlwibWF4XCI9PT1iPzEwMDpwYXJzZUZsb2F0KGIpO2lmKCFtKGQpfHwhbShnWzBdKSl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgdmFsdWUgaXNuJ3QgbnVtZXJpYy5cIik7YS5jLnB1c2goZCk7YS5kLnB1c2goZ1swXSk7ZD9hLmgucHVzaChpc05hTihnWzFdKT8hMTpnWzFdKTppc05hTihnWzFdKXx8KGEuaFswXT1nWzFdKX0pO2MuZWFjaChhLmgsZnVuY3Rpb24oYixjKXtpZighYylyZXR1cm4hMDthLmhbYl09dShbYS5kW2JdLGEuZFtiKzFdXSxjKS8oMTAwLyhhLmNbYisxXS1hLmNbYl0pKX0pfWZ1bmN0aW9uIEUoYSxiKXtcIm51bWJlclwiPT09dHlwZW9mIGImJihiPVtiXSk7aWYoIWMuaXNBcnJheShiKXx8IWIubGVuZ3RofHxcbjI8Yi5sZW5ndGgpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO2EuYj1iLmxlbmd0aDthLnN0YXJ0PWJ9ZnVuY3Rpb24gSShhLGIpe2EubT1iO2lmKFwiYm9vbGVhblwiIT09dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTt9ZnVuY3Rpb24gSihhLGIpe2lmKFwibG93ZXJcIj09PWImJjE9PT1hLmIpYS5pPTE7ZWxzZSBpZihcInVwcGVyXCI9PT1iJiYxPT09YS5iKWEuaT0yO2Vsc2UgaWYoITA9PT1iJiYyPT09YS5iKWEuaT0zO2Vsc2UgaWYoITE9PT1iKWEuaT0wO2Vsc2UgdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTt9ZnVuY3Rpb24gRChhLGIpe3N3aXRjaChiKXtjYXNlIFwiaG9yaXpvbnRhbFwiOmEuaz0wO2JyZWFrO2Nhc2UgXCJ2ZXJ0aWNhbFwiOmEuaz0xO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcbn19ZnVuY3Rpb24gSyhhLGIpe2lmKDI8YS5jLmxlbmd0aCl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdtYXJnaW4nIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycy5cIik7YS5tYXJnaW49dShhLmQsYik7aWYoIW0oYikpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnbWFyZ2luJyBvcHRpb24gbXVzdCBiZSBudW1lcmljLlwiKTt9ZnVuY3Rpb24gTChhLGIpe3N3aXRjaChiKXtjYXNlIFwibHRyXCI6YS5kaXI9MDticmVhaztjYXNlIFwicnRsXCI6YS5kaXI9MTthLmk9WzAsMiwxLDNdW2EuaV07YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdkaXJlY3Rpb24nIG9wdGlvbiB3YXMgbm90IHJlY29nbml6ZWQuXCIpO319ZnVuY3Rpb24gTShhLGIpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYil0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTt2YXIgYz0wPD1iLmluZGV4T2YoXCJzbmFwXCIpO1xuYS5uPXtzOjA8PWIuaW5kZXhPZihcInRhcFwiKXx8YyxleHRlbmQ6MDw9Yi5pbmRleE9mKFwiZXh0ZW5kXCIpLHY6MDw9Yi5pbmRleE9mKFwiZHJhZ1wiKSxmaXhlZDowPD1iLmluZGV4T2YoXCJmaXhlZFwiKSxtOmN9fWZ1bmN0aW9uIE4oYSxiLGQpe2Eubz1bYi5sb3dlcixiLnVwcGVyXTthLmc9Yi5mb3JtYXQ7Yy5lYWNoKGEubyxmdW5jdGlvbihhLGUpe2lmKCFjLmlzQXJyYXkoZSkpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnc2VyaWFsaXphdGlvbi5cIisoYT9cInVwcGVyXCI6XCJsb3dlclwiKStcIicgbXVzdCBiZSBhbiBhcnJheS5cIik7Yy5lYWNoKGUsZnVuY3Rpb24oKXtpZighKHRoaXMgaW5zdGFuY2VvZiBjLkxpbmspKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3NlcmlhbGl6YXRpb24uXCIrKGE/XCJ1cHBlclwiOlwibG93ZXJcIikrXCInIGNhbiBvbmx5IGNvbnRhaW4gTGluayBpbnN0YW5jZXMuXCIpO3RoaXMuSShhKTt0aGlzLkooZCk7dGhpcy5xKGIuZm9ybWF0KX0pfSk7YS5kaXImJjE8YS5iJiZhLm8ucmV2ZXJzZSgpfVxuZnVuY3Rpb24gTyhhLGIpe3ZhciBmPXtjOltdLGQ6W10saDpbITFdLG1hcmdpbjowfSxnO2c9e3N0ZXA6e2U6ITEsZjpkfSxzdGFydDp7ZTohMCxmOkV9LGNvbm5lY3Q6e2U6ITAsZjpKfSxkaXJlY3Rpb246e2U6ITAsZjpMfSxyYW5nZTp7ZTohMCxmOm59LHNuYXA6e2U6ITEsZjpJfSxvcmllbnRhdGlvbjp7ZTohMSxmOkR9LG1hcmdpbjp7ZTohMSxmOkt9LGJlaGF2aW91cjp7ZTohMCxmOk19LHNlcmlhbGl6YXRpb246e2U6ITAsZjpOfX07YT1jLmV4dGVuZCh7Y29ubmVjdDohMSxkaXJlY3Rpb246XCJsdHJcIixiZWhhdmlvdXI6XCJ0YXBcIixvcmllbnRhdGlvbjpcImhvcml6b250YWxcIn0sYSk7YS5zZXJpYWxpemF0aW9uPWMuZXh0ZW5kKHtsb3dlcjpbXSx1cHBlcjpbXSxmb3JtYXQ6e319LGEuc2VyaWFsaXphdGlvbik7Yy5lYWNoKGcsZnVuY3Rpb24oYyxkKXtpZih2b2lkIDA9PT1hW2NdKXtpZihkLmUpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnXCIrYytcIicgaXMgcmVxdWlyZWQuXCIpO1xucmV0dXJuITB9ZC5mKGYsYVtjXSxiKX0pO2Yuc3R5bGU9Zi5rP1widG9wXCI6XCJsZWZ0XCI7cmV0dXJuIGZ9ZnVuY3Rpb24gUChhLGIpe3ZhciBkPWMoXCI8ZGl2PjxkaXYvPjwvZGl2PlwiKS5hZGRDbGFzcyhmWzJdKSxnPVtcIi1sb3dlclwiLFwiLXVwcGVyXCJdO2EuZGlyJiZnLnJldmVyc2UoKTtkLmNoaWxkcmVuKCkuYWRkQ2xhc3MoZlszXStcIiBcIitmWzNdK2dbYl0pO3JldHVybiBkfWZ1bmN0aW9uIFEoYSxiKXtiLmomJihiPW5ldyBjLkxpbmsoe3RhcmdldDpjKGIuaikuY2xvbmUoKS5hcHBlbmRUbyhhKSxtZXRob2Q6Yi5tZXRob2QsZm9ybWF0OmIuZ30sITApKTtyZXR1cm4gYn1mdW5jdGlvbiBSKGEsYil7dmFyIGQsZj1bXTtmb3IoZD0wO2Q8YS5iO2QrKyl7dmFyIGs9ZixoPWQsbT1hLm9bZF0sbj1iW2RdLmNoaWxkcmVuKCkscj1hLmcscz12b2lkIDAsdj1bXSxzPW5ldyBjLkxpbmsoe30sITApO3MucShyKTt2LnB1c2gocyk7Zm9yKHM9MDtzPG0ubGVuZ3RoO3MrKyl2LnB1c2goUShuLG1bc10pKTtcbmtbaF09dn1yZXR1cm4gZn1mdW5jdGlvbiBTKGEsYixjKXtzd2l0Y2goYSl7Y2FzZSAxOmIuYWRkQ2xhc3MoZls3XSk7Y1swXS5hZGRDbGFzcyhmWzZdKTticmVhaztjYXNlIDM6Y1sxXS5hZGRDbGFzcyhmWzZdKTtjYXNlIDI6Y1swXS5hZGRDbGFzcyhmWzddKTtjYXNlIDA6Yi5hZGRDbGFzcyhmWzZdKX19ZnVuY3Rpb24gVChhLGIpe3ZhciBjLGQ9W107Zm9yKGM9MDtjPGEuYjtjKyspZC5wdXNoKFAoYSxjKS5hcHBlbmRUbyhiKSk7cmV0dXJuIGR9ZnVuY3Rpb24gVShhLGIpe2IuYWRkQ2xhc3MoW2ZbMF0sZls4K2EuZGlyXSxmWzQrYS5rXV0uam9pbihcIiBcIikpO3JldHVybiBjKFwiPGRpdi8+XCIpLmFwcGVuZFRvKGIpLmFkZENsYXNzKGZbMV0pfWZ1bmN0aW9uIFYoZCxiLG0pe2Z1bmN0aW9uIGcoKXtyZXR1cm4gdFtbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdW2Iua11dKCl9ZnVuY3Rpb24gbihhKXt2YXIgYixjPVtxLnZhbCgpXTtmb3IoYj0wO2I8YS5sZW5ndGg7YisrKXEudHJpZ2dlcihhW2JdLFxuYyl9ZnVuY3Rpb24gdShkLHAsZSl7dmFyIGc9ZFswXSE9PWxbMF1bMF0/MTowLEg9eFswXStiLm1hcmdpbixrPXhbMV0tYi5tYXJnaW47ZSYmMTxsLmxlbmd0aCYmKHA9Zz9NYXRoLm1heChwLEgpOk1hdGgubWluKHAsaykpOzEwMD5wJiYocD1oKGIscCkpO3A9TWF0aC5tYXgoTWF0aC5taW4ocGFyc2VGbG9hdChwLnRvRml4ZWQoNykpLDEwMCksMCk7aWYocD09PXhbZ10pcmV0dXJuIDE9PT1sLmxlbmd0aD8hMTpwPT09SHx8cD09PWs/MDohMTtkLmNzcyhiLnN0eWxlLHArXCIlXCIpO2QuaXMoXCI6Zmlyc3QtY2hpbGRcIikmJmQudG9nZ2xlQ2xhc3MoZlsxN10sNTA8cCk7eFtnXT1wO2IuZGlyJiYocD0xMDAtcCk7Yyh5W2ddKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy53cml0ZShhKGIscCksZC5jaGlsZHJlbigpLHEpfSk7cmV0dXJuITB9ZnVuY3Rpb24gQihhLGIsYyl7Y3x8ayhxLGZbMTRdKTt1KGEsYiwhMSk7bihbXCJzbGlkZVwiLFwic2V0XCIsXCJjaGFuZ2VcIl0pfWZ1bmN0aW9uIHcoYSxjLGQsZSl7YT1cbmEucmVwbGFjZSgvXFxzL2csXCIubnVpIFwiKStcIi5udWlcIjtjLm9uKGEsZnVuY3Rpb24oYSl7dmFyIGM9cS5hdHRyKFwiZGlzYWJsZWRcIik7aWYocS5oYXNDbGFzcyhmWzE0XSl8fHZvaWQgMCE9PWMmJm51bGwhPT1jKXJldHVybiExO2EucHJldmVudERlZmF1bHQoKTt2YXIgYz0wPT09YS50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSxwPTA9PT1hLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpLEY9MD09PWEudHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSxnLGssbD1hOzA9PT1hLnR5cGUuaW5kZXhPZihcIk1TUG9pbnRlclwiKSYmKEY9ITApO2Eub3JpZ2luYWxFdmVudCYmKGE9YS5vcmlnaW5hbEV2ZW50KTtjJiYoZz1hLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYLGs9YS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSk7aWYocHx8RilGfHx2b2lkIDAhPT13aW5kb3cucGFnZVhPZmZzZXR8fCh3aW5kb3cucGFnZVhPZmZzZXQ9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsd2luZG93LnBhZ2VZT2Zmc2V0PVxuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksZz1hLmNsaWVudFgrd2luZG93LnBhZ2VYT2Zmc2V0LGs9YS5jbGllbnRZK3dpbmRvdy5wYWdlWU9mZnNldDtsLkM9W2csa107bC5jdXJzb3I9cDthPWw7YS5sPWEuQ1tiLmtdO2QoYSxlKX0pfWZ1bmN0aW9uIEMoYSxjKXt2YXIgYj1jLmJ8fGwsZCxlPSExLGU9MTAwKihhLmwtYy5zdGFydCkvZygpLGY9YlswXVswXSE9PWxbMF1bMF0/MTowO3ZhciBrPWMuRDtkPWUra1swXTtlKz1rWzFdOzE8Yi5sZW5ndGg/KDA+ZCYmKGUrPU1hdGguYWJzKGQpKSwxMDA8ZSYmKGQtPWUtMTAwKSxkPVtNYXRoLm1heChNYXRoLm1pbihkLDEwMCksMCksTWF0aC5tYXgoTWF0aC5taW4oZSwxMDApLDApXSk6ZD1bZCxlXTtlPXUoYlswXSxkW2ZdLDE9PT1iLmxlbmd0aCk7MTxiLmxlbmd0aCYmKGU9dShiWzFdLGRbZj8wOjFdLCExKXx8ZSk7ZSYmbihbXCJzbGlkZVwiXSl9ZnVuY3Rpb24gcyhhKXtjKFwiLlwiK2ZbMTVdKS5yZW1vdmVDbGFzcyhmWzE1XSk7XG5hLmN1cnNvciYmYyhcImJvZHlcIikuY3NzKFwiY3Vyc29yXCIsXCJcIikub2ZmKFwiLm51aVwiKTtHLm9mZihcIi5udWlcIik7cS5yZW1vdmVDbGFzcyhmWzEyXSk7bihbXCJzZXRcIixcImNoYW5nZVwiXSl9ZnVuY3Rpb24gdihhLGIpezE9PT1iLmIubGVuZ3RoJiZiLmJbMF0uY2hpbGRyZW4oKS5hZGRDbGFzcyhmWzE1XSk7YS5zdG9wUHJvcGFnYXRpb24oKTt3KHoubW92ZSxHLEMse3N0YXJ0OmEubCxiOmIuYixEOlt4WzBdLHhbbC5sZW5ndGgtMV1dfSk7dyh6LmVuZCxHLHMsbnVsbCk7YS5jdXJzb3ImJihjKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIixjKGEudGFyZ2V0KS5jc3MoXCJjdXJzb3JcIikpLDE8bC5sZW5ndGgmJnEuYWRkQ2xhc3MoZlsxMl0pLGMoXCJib2R5XCIpLm9uKFwic2VsZWN0c3RhcnQubnVpXCIsITEpKX1mdW5jdGlvbiBEKGEpe3ZhciBkPWEubCxlPTA7YS5zdG9wUHJvcGFnYXRpb24oKTtjLmVhY2gobCxmdW5jdGlvbigpe2UrPXRoaXMub2Zmc2V0KClbYi5zdHlsZV19KTtlPWQ8ZS8yfHwxPT09bC5sZW5ndGg/XG4wOjE7ZC09dC5vZmZzZXQoKVtiLnN0eWxlXTtkPTEwMCpkL2coKTtCKGxbZV0sZCxiLm4ubSk7Yi5uLm0mJnYoYSx7YjpbbFtlXV19KX1mdW5jdGlvbiBFKGEpe3ZhciBjPShhPWEubDx0Lm9mZnNldCgpW2Iuc3R5bGVdKT8wOjEwMDthPWE/MDpsLmxlbmd0aC0xO0IobFthXSxjLCExKX12YXIgcT1jKGQpLHg9Wy0xLC0xXSx0LHksbDtpZihxLmhhc0NsYXNzKGZbMF0pKXRocm93IEVycm9yKFwiU2xpZGVyIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkLlwiKTt0PVUoYixxKTtsPVQoYix0KTt5PVIoYixsKTtTKGIuaSxxLGwpOyhmdW5jdGlvbihhKXt2YXIgYjtpZighYS5maXhlZClmb3IoYj0wO2I8bC5sZW5ndGg7YisrKXcoei5zdGFydCxsW2JdLmNoaWxkcmVuKCksdix7YjpbbFtiXV19KTthLnMmJncoei5zdGFydCx0LEQse2I6bH0pO2EuZXh0ZW5kJiYocS5hZGRDbGFzcyhmWzE2XSksYS5zJiZ3KHouc3RhcnQscSxFLHtiOmx9KSk7YS52JiYoYj10LmZpbmQoXCIuXCIrZls3XSkuYWRkQ2xhc3MoZlsxMF0pLFxuYS5maXhlZCYmKGI9Yi5hZGQodC5jaGlsZHJlbigpLm5vdChiKS5jaGlsZHJlbigpKSksdyh6LnN0YXJ0LGIsdix7YjpsfSkpfSkoYi5uKTtkLnZTZXQ9ZnVuY3Rpb24oKXt2YXIgYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCksZCxlLGcsaCxtLHMsdD1yKGFbMF0pO1wib2JqZWN0XCI9PT10eXBlb2YgYVsxXT8oZD1hWzFdLnNldCxlPWFbMV0ubGluayxnPWFbMV0udXBkYXRlLGg9YVsxXS5hbmltYXRlKTohMD09PWFbMV0mJihkPSEwKTtiLmRpciYmMTxiLmImJnQucmV2ZXJzZSgpO2gmJmsocSxmWzE0XSk7YT0xPGwubGVuZ3RoPzM6MTsxPT09dC5sZW5ndGgmJihhPTEpO2ZvcihtPTA7bTxhO20rKyloPWV8fHlbbSUyXVswXSxoPWguQSh0W20lMl0pLCExIT09aCYmKGg9QShiLGgpLGIuZGlyJiYoaD0xMDAtaCksITAhPT11KGxbbSUyXSxoLCEwKSYmYyh5W20lMl0pLmVhY2goZnVuY3Rpb24oYSl7aWYoIWEpcmV0dXJuIHM9dGhpcy51LCEwO3RoaXMud3JpdGUocyxcbmxbbSUyXS5jaGlsZHJlbigpLHEsZyl9KSk7ITA9PT1kJiZuKFtcInNldFwiXSk7cmV0dXJuIHRoaXN9O2QudkdldD1mdW5jdGlvbigpe3ZhciBhLGM9W107Zm9yKGE9MDthPGIuYjthKyspY1thXT15W2FdWzBdLkY7cmV0dXJuIDE9PT1jLmxlbmd0aD9jWzBdOmIuZGlyP2MucmV2ZXJzZSgpOmN9O2QuZGVzdHJveT1mdW5jdGlvbigpe2MuZWFjaCh5LGZ1bmN0aW9uKCl7Yy5lYWNoKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnRhcmdldCYmdGhpcy50YXJnZXQub2ZmKFwiLm51aVwiKX0pfSk7Yyh0aGlzKS5vZmYoXCIubnVpXCIpLnJlbW92ZUNsYXNzKGYuam9pbihcIiBcIikpLmVtcHR5KCk7cmV0dXJuIG19O3EudmFsKGIuc3RhcnQpfWZ1bmN0aW9uIFcoYSl7aWYoIXRoaXMubGVuZ3RoKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogQ2FuJ3QgaW5pdGlhbGl6ZSBzbGlkZXIgb24gZW1wdHkgc2VsZWN0aW9uLlwiKTt2YXIgYj1PKGEsdGhpcyk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1YodGhpcyxcbmIsYSl9KX1mdW5jdGlvbiBYKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1jKHRoaXMpLnZhbCgpLGQ9dGhpcy5kZXN0cm95KCksZj1jLmV4dGVuZCh7fSxkLGEpO2ModGhpcykubm9VaVNsaWRlcihmKTtkLnN0YXJ0PT09Zi5zdGFydCYmYyh0aGlzKS52YWwoYil9KX1mdW5jdGlvbiBCKCl7cmV0dXJuIHRoaXNbMF1bYXJndW1lbnRzLmxlbmd0aD9cInZTZXRcIjpcInZHZXRcIl0uYXBwbHkodGhpc1swXSxhcmd1bWVudHMpfXZhciBHPWMoZG9jdW1lbnQpLEM9Yy5mbi52YWwsej13aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkP3tzdGFydDpcInBvaW50ZXJkb3duXCIsbW92ZTpcInBvaW50ZXJtb3ZlXCIsZW5kOlwicG9pbnRlcnVwXCJ9OndpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZD97c3RhcnQ6XCJNU1BvaW50ZXJEb3duXCIsbW92ZTpcIk1TUG9pbnRlck1vdmVcIixlbmQ6XCJNU1BvaW50ZXJVcFwifTp7c3RhcnQ6XCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLG1vdmU6XCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIsXG5lbmQ6XCJtb3VzZXVwIHRvdWNoZW5kXCJ9LGY9XCJub1VpLXRhcmdldCBub1VpLWJhc2Ugbm9VaS1vcmlnaW4gbm9VaS1oYW5kbGUgbm9VaS1ob3Jpem9udGFsIG5vVWktdmVydGljYWwgbm9VaS1iYWNrZ3JvdW5kIG5vVWktY29ubmVjdCBub1VpLWx0ciBub1VpLXJ0bCBub1VpLWRyYWdhYmxlICBub1VpLXN0YXRlLWRyYWcgIG5vVWktc3RhdGUtdGFwIG5vVWktYWN0aXZlIG5vVWktZXh0ZW5kZWQgbm9VaS1zdGFja2luZ1wiLnNwbGl0KFwiIFwiKTtjLmZuLnZhbD1mdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50cyxiPWModGhpc1swXSk7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7KGModGhpcykuaGFzQ2xhc3MoZlswXSk/QjpDKS5hcHBseShjKHRoaXMpLGEpfSk6KGIuaGFzQ2xhc3MoZlswXSk/QjpDKS5jYWxsKGIpfTtjLm5vVWlTbGlkZXI9e0xpbms6Yy5MaW5rfTtjLmZuLm5vVWlTbGlkZXI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYj9YOlcpLmNhbGwodGhpcyxcbmEpfX0pKHdpbmRvdy5qUXVlcnl8fHdpbmRvdy5aZXB0byk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8vIGxvYWRpbmcgaGFja3NcbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbi8vbG9hZGluZyBqcXVlcnnDkSBvbmx5IGxvYWQgaXQgaWZcbi8vaXQgaXMgbm90IGxvYWRlZCBvciBpZiB0aGVyZSBpcyBhIGpxdWVyeSBsb2FkZWQgYnV0IHZlcnNpb24gaXMgb2xkZXIgdGhhbiAyLngueFxuaWYgKHdpbmRvdy4kID09IHVuZGVmaW5lZCB8fCAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylbMF0gPCAyKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IEJhY2tib25lLiQgPSBqUXVlcnk7XG59XG5yZXF1aXJlKCdqcXVlcnktdWkvZHJhZ2dhYmxlJyk7XG5yZXF1aXJlKCdib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAnKTtcbnJlcXVpcmUoJy4vbGliL2pxdWVyeS11aS1pMThuJylcblxudmFyIEZpbHRlclZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL2ZpbHRlcnMtdmlldycpO1xuXG4vLyBzZWUgUkVBRE1FLm1kIGZvciBkb2N1bWVudGF0aW9uIG9uIHVzaW5nIHdpZGdldC5cblxuXG5mdW5jdGlvbiBXaWRnZXQoKSB7XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5fLmV4dGVuZChXaWRnZXQucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xuICAgIGlmIChfLmhhcyhvcHRpb25zLCAnc3luYycpKSB7XG4gICAgICBCYWNrYm9uZS5zeW5jID0gb3B0aW9ucy5zeW5jO1xuICAgIH1cbiAgICB0aGlzLnZpZXcgPSBuZXcgRmlsdGVyVmlldyhvcHRpb25zKTtcblxuICAgIC8vIHVzZWQgdG8gbWFrZSBhbGwgZmlsdGVycyByZXF1ZXN0IGZhc3Rlci5cbiAgICB0aGlzLl9jYWNoZWRBbGxGaWx0ZXJzID0gbnVsbDtcblxuICAgIC8vIGxvYWRlZCBkZWZlcnJlZCB0byBhbGxvdyBmb3Igb3RoZXIgY29kZSB0byB3YWl0IGZvciBmaWx0ZXJzIHRvIGZpbmlzaCBsb2FkaW5nLlxuICAgIHRoaXMubG9hZGVkID0gdGhpcy52aWV3Ll9sb2FkZWQucHJvbWlzZSgpO1xuXG4gICAgLy8gcHJveHkgYWxsIGZpbHRlciBldmVudHMgdGhyb3VnaCBoZXJlXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnZpZXcsICdhbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIHB1dCB0aGUgZmlsdGVycyBpbnRvIHRoZSBET00gdHJlZSBwb3N0LWluaXRpYWxpemF0aW9uXG4gIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlldy5zZXRFbGVtZW50KGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLy8gdGhpcyB3aWxsIHN0YXNoIGN1cnJlbnQgZmlsdGVyIHN0YXRlLCBzbyBpdCBjYW4gYmUgcmVzdG9yZWQgb24gY2FuY2VsLlxuICBzaG93RmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3LnNob3dGaWx0ZXJzKCk7XG4gIH0sXG5cbiAgc2V0U3Rhc2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlldy5zZXRTdGFzaCgpO1xuICB9LFxuXG4gIC8vIHJldHVybiBtb2RlbHMgb2YgYWxsIGZpbHRlcnMsIGV2ZW4gdW5zZWxlY3RlZCBvbmVzLi5cbiAgZ2V0QWxsRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmxvYWRlZC50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBjYWNoZSwgYmVjYXVzZSB3b24ndCBjaGFuZ2UuIGF2b2lkcyBjYWxsaW5nIHNlcmlhbGl6ZSBldmVyeXRpbWUuXG4gICAgICBpZighdGhpcy5fY2FjaGVkQWxsRmlsdGVycyl7XG4gICAgICAgIHRoaXMuX2NhY2hlZEFsbEZpbHRlcnMgPSBzZWxmLnZpZXcuc2VyaWFsaXplKHtpbmNsdWRlVW5zZWxlY3RlZDogdHJ1ZSwgd2hvbGVNb2RlbDogdHJ1ZX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZEFsbEZpbHRlcnM7XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gcmV0dXJuIG1vZGVscyBvZiBzZXJpYWxpemVkIGZpbHRlciBzdGF0ZSwgaGFzIGVudGlyZSBtb2RlbHMgaW5zdGVhZCBvZiBqdXN0IGlkcy5cbiAgc2VyaWFsaXplVG9Nb2RlbHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc2VyaWFsaXplKHt3aG9sZU1vZGVsOiB0cnVlfSk7XG4gIH0sXG5cbiAgZm9ybWF0RGF0ZTogZnVuY3Rpb24oZGF0ZSl7XG5cdCAgcmV0dXJuIHRoaXMudmlldy5mb3JtYXREYXRlKGRhdGUpOyAgXG4gIH0sXG4gIFxuICAvLyByZXR1cm4ganNvbiBibG9iIG9mIHNlcmlhbGl6ZWQgZmlsdGVyIHN0YXRlLCBpZHMgb25seS5cbiAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnNlcmlhbGl6ZSh7fSk7XG4gIH0sXG5cbiAgLy8gcmVzdG9yZXMgZmlsdGVyIHN0YXRlIGdpdmVuIGEganNvbiBibG9iLCBpZHMgb25seS5cbiAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKHN0YXRlQmxvYiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZGVzZXJpYWxpemUoc3RhdGVCbG9iLCBvcHRpb25zKTtcbiAgfSxcblxuICAvLyByZXNldCBmaWx0ZXJzIHRvIGVtcHR5IHN0YXRlXG4gIHJlc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy52aWV3LnJlc2V0RmlsdGVycygpO1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHRoaXMudmlldy5hcHBseUZpbHRlcnMoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBzZWFyY2hlcyB0aGUgc2V0dGluZ3MgYXJyYXkgb2YgbW9kZWxzIGZvciB0aGUgb25lcyB3aGljaCBob2xkIHRoZSBtaW4vbWF4IHZhbHVlcyBpbnN0cnVjdGVkIHRvIGFuZCwgaWYgZm91bmQsXG4gICAqIHdyaXRlcyB0aGVtIGluIGZpbHRlcnNPdXQuZGF0ZS57c3RhcnR9e2VuZH1cbiAgICpcbiAgICogdXNlIGl0IGFzIGFuIHV0aWxpdHkgZnVuY3Rpb24gKGl0IGRvZXMgbm90IHJlZmVyZW5jZSAndGhpcycsIHNvXG4gICAqIGl0IGlzIHNhZmUgdG8gdXNlIGl0IGF0IGFueSBwb2ludCBpbiB0aGUgbGlmZWN5Y2xlIG9mIHRoZSB3aWRnZXRcbiAgICovXG4gIGV4dHJhY3REYXRlczogZnVuY3Rpb24oc2V0dGluZ3MsIGZpbHRlcnNPdXQsIG1pbk5hbWUsIG1heE5hbWUpIHtcblx0ICBmaWx0ZXJzT3V0ID0gZmlsdGVyc091dCB8fCB7fTsgIFxuXHQgIGlmKF8uaXNVbmRlZmluZWQoZmlsdGVyc091dC5kYXRlKSB8fCBfLmlzRW1wdHkoZmlsdGVyc091dC5kYXRlKSl7XG5cdFx0ICBmaWx0ZXJzT3V0LmRhdGUgPSBmaWx0ZXJzT3V0LmRhdGUgfHwge1xuXHRcdFx0ICBzdGFydDogJycsXG5cdFx0XHQgIGVuZDogJydcblx0XHQgIH07XG5cblx0XHQgIHZhciBkZWZhdWx0TWluRGF0ZSA9IHNldHRpbmdzLmdldChtaW5OYW1lKTsgICAgXG5cdFx0ICBpZiAoZGVmYXVsdE1pbkRhdGUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0TWluRGF0ZSAhPT0gJycpIHtcblx0XHRcdCAgZmlsdGVyc091dC5kYXRlLnN0YXJ0ID0gZGVmYXVsdE1pbkRhdGU7XG5cdFx0ICB9XG5cdFx0ICB2YXIgZGVmYXVsdE1heERhdGUgPSBzZXR0aW5ncy5nZXQobWF4TmFtZSk7XG5cdFx0ICBpZiAoZGVmYXVsdE1heERhdGUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0TWF4RGF0ZSAhPT0gJycpIHtcblx0XHRcdCAgZmlsdGVyc091dC5kYXRlLmVuZCA9IGRlZmF1bHRNYXhEYXRlO1xuXHRcdCAgfVxuXHQgIH0gICAgXG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0OyIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbiAgLy8gUGFyZW50IG1vZGVsIGZvciBmaWx0ZXJzLlxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICBkZWZhdWx0czoge1xuICAgIG5hbWU6ICdGaWx0ZXIgTmFtZScsXG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB0b3RhbENvdW50OiAwLFxuICAgIGFjdGl2ZUNvdW50OiAwLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuICAgIGVtcHR5OiBmYWxzZVxuICB9LFxuXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuc2V0KCduYW1lJywgb3B0aW9ucy5uYW1lKTtcbiAgICB0aGlzLnNldCgnZ3JvdXAnLCBvcHRpb25zLmdyb3VwIHx8IG9wdGlvbnMuaWQpO1xuICAgIHRoaXMuc2V0KCdtZXRob2QnLCBvcHRpb25zLm1ldGhvZCk7XG4gICAgdGhpcy5zZXQoJ2NvbHVtbnMnLCBvcHRpb25zLmNvbHVtbnMpO1xuICAgIHRoaXMuc2V0KCdlbXB0eScsIG9wdGlvbnMuZW1wdHkgfHwgZmFsc2UpO1xuICAgIHRoaXMudXJsID0gIG9wdGlvbnMudXJsIHx8IG9wdGlvbnMuZW5kcG9pbnQ7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxudmFyIEJhc2VGaWx0ZXJNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9iYXNlLWZpbHRlci1tb2RlbCcpO1xudmFyIFRyZWVOb2RlTW9kZWwgPSByZXF1aXJlKCcuLi90cmVlL3RyZWUtbm9kZS1tb2RlbCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZUZpbHRlck1vZGVsLmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgQmFzZUZpbHRlck1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgdGhpcy5zZXQoJ21vZGVsVHlwZScsICdUUkVFJyk7XG4gICAgdGhpcy5nZXRUcmVlKCk7IC8vIHN0YXJ0cyBnZXRUcmVlIGNhbGxzXG4gIH0sXG5cbiAgLy8gbG9hZCB0cmVlIGlmIG5lZWRlZCwgZWxzZSByZXR1cm4gd2hhdCB3ZSBhbHJlYWR5IGhhdmUuLlxuICBnZXRUcmVlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxvYWRlZCA9IHRoaXMuZ2V0KCdfbG9hZGVkJyk7XG5cbiAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgc2VsZi5zZXQoJ19sb2FkZWQnLCB0aGlzLl9jcmVhdGVUcmVlKCkudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyB0cmlja2xlIHVwIG51bVNlbGVjdGVkLlxuICAgIFx0ICBpZihzZWxmLmdldCgndHJlZScpIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgc2VsZi5nZXQoJ3RyZWUnKS5vbignY2hhbmdlOm51bVNlbGVjdGVkJywgZnVuY3Rpb24obW9kZWwsIHZhbHVlKSB7XG4gICAgICAgICAgc2VsZi5zZXQoJ251bVNlbGVjdGVkJywgdmFsdWUpO1xuICAgICAgICAgIHNlbGYuc2V0KCdudW1Qb3NzaWJsZScsIHNlbGYuZ2V0KCd0cmVlJykuZ2V0KCdudW1Qb3NzaWJsZScpKTtcbiAgICAgICAgfSk7XG4gICAgXHQgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0KCd0cmVlJyk7XG4gICAgICB9KSk7XG4gICAgICBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXQoJ19sb2FkZWQnKTtcbiAgfSxcblxuICBnZXROdW1TZWxlY3RlZDogZnVuY3Rpb24oKXtcbiAgICB2YXIgbnVtU2VsZWN0ZWQgPSB0aGlzLmdldCgnbnVtU2VsZWN0ZWQnKTtcbiAgICAvLyBpZiBub25lIHNlbGVjdGVkLCBvciBhbGwgc2VsZWN0ZWQsIHRyZWF0IHRoZSBzYW1lLlxuICAgIGlmICghbnVtU2VsZWN0ZWQgfHwgdGhpcy5nZXQoJ251bVNlbGVjdGVkJykgPT09IHRoaXMuZ2V0KCdudW1Qb3NzaWJsZScpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bVNlbGVjdGVkO1xuICAgIH1cbiAgfSxcblxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgdHJlZSA9IHRoaXMuZ2V0KCd0cmVlJyk7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICAvL2NvbnNvbGUud2Fybignbm8gdHJlZSBmb3VuZCcsIHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4ge307IC8vbm8gdHJlZSwgbm90aGluZyB0byBzZXJpYWxpemUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0bXBBcnkgPSB0cmVlLnNlcmlhbGl6ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB0bXBBcnk7XG4gICAgfVxuICB9LFxuXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbihsaXN0T2ZTZWxlY3RlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHJlZSA9IHRoaXMuZ2V0KCd0cmVlJyk7XG4gICAgaWYgKGxpc3RPZlNlbGVjdGVkKSB7XG4gICAgICBpZiAoIXRyZWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdkZXNlcmlhbGl6ZSBubyB0cmVlIGZvdW5kJywgc2VsZik7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy9ubyB0cmVlLCBub3RoaW5nIHRvIHNlcmlhbGl6ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyZWUuZGVzZXJpYWxpemUobGlzdE9mU2VsZWN0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyZWUgPSB0aGlzLmdldCgndHJlZScpO1xuICAgIGlmICh0cmVlKSB7XG4gICAgICAvLyBUT0RPOiBhZGQgYSB0aGlyZCB0eXBlIGZvciBzZW1pLWZpbGxlZFxuICAgICAgLy8gZm9yY2UgdHJpZ2dlciwgYmVjYXVzZSBvdGhlcndpc2Ugbm9kZXMgdGhhdCBhcmUgJ2hhbGYtZmlsbGVkJyBidXQgZmFsc2Ugd29uJ3QgcmVmcmVzaC5cbiAgICAgIHRyZWUuc2V0KCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgdHJlZS5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuXG4gICAgfVxuICB9LFxuXG4gIF9jcmVhdGVUcmVlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICB0aGlzLnVybCA9IHRoaXMuZ2V0KCdlbmRwb2ludCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZldGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuZ2V0KCdtZXRob2QnKSxcbiAgICAgIGRhdGE6J3t9J1xuICAgIH0pXG4gICAgLmZhaWwoZnVuY3Rpb24oanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gZ2V0IGZpbHRlciAnLCBqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH0pO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAgICBcblxuICAgIC8vaWYgaXQncyBhbiBvYmosIGphbSBpdCBpbnRvIGFuIGFycmF5IGZpcnN0LCBoZWxwcyBzb2x2ZSBpbmNvbnNpc3RhbmN5IGluIEFQSSBmb3JtYXQuXG4gICAgaWYgKCFfLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNBcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciByb290Tm9kZU9iaiA9IG51bGw7XG4gICAgICAvLyBCdWlsZHMgdHJlZSBvZiB2aWV3cyBmcm9tIHJldHVybmVkIGRhdGFcbiAgICAgIC8vIElmIGRhdGEgaXMgYSBzaW5nbGUgZWxlbWVudCwganVzdCBtYWtlIGl0IHRoZSByb290Li5cbiAgICAgIFxuICAgICAgLyogVE9ETy1DT05TVEFOVElOOiB0ZW1wb3JhcnkgY29tbWVudCB1bnRpbCBJIGZpbmlzaCBsZWFybmluZyBGaWx0ZXJzIGZyb250ZW5kXG4gICAgICBjb25zb2xlLmxvZyhcIml0ZXJhdGluZyBcIiArIGRhdGEubGVuZ3RoICsgXCIgZWxlbXMuLi5cIik7XG4gICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24oZWxlbSkge1xuICAgIFx0ICBjb25zb2xlLmxvZyhcIlxcdG5hbWUgPSBcIiArIGVsZW0ubmFtZSArIFwiLCBpZCA9IFwiICsgZWxlbS5pZCk7XG4gICAgICB9KTtcbiAgICAgICovXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICBcdGlmKGRhdGFbMF0uZmlsdGVySWQgJiYgIWRhdGFbMF0ubmFtZSkge1xuICAgICAgICAgIGRhdGFbMF0ubmFtZSA9ICBkYXRhWzBdLmZpbHRlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFbMF0udmFsdWVzKXtcbiAgICAgICAgICBkYXRhWzBdLmNoaWxkcmVuID0gIGRhdGFbMF0udmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVswXS5pc1NlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIC8vZGF0YVswXS5maWx0ZXJOYW1lID0gZGF0YVswXS5kaXNwbGF5TmFtZTtcblxuICAgICAgICByb290Tm9kZU9iaiA9IGRhdGFbMF07XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3ROb2RlT2JqID0ge1xuICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICBjb2RlOiAnLTEnLFxuICAgICAgICAgIG5hbWU6IHNlbGYuZ2V0KCduYW1lJyksXG4gICAgICAgICAgY2hpbGRyZW46IGRhdGEsXG4gICAgICAgICAgc2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgICAgaXNTZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjcmVhdGVVbmtvd25zOiB0cnVlLyosXG4gICAgICAgICAgZmlsdGVyTmFtZTogc2VsZi5nZXQoJ2Rpc3BsYXlOYW1lJykqL1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJlZU1vZGVsID0gbmV3IFRyZWVOb2RlTW9kZWwocm9vdE5vZGVPYmopO1xuICAgICAgc2VsZi5zZXQoJ3RyZWUnLCB0cmVlTW9kZWwpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG59KTtcblxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIEdlbmVyaWNGaWx0ZXJNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9nZW5lcmljLWZpbHRlci1tb2RlbCcpO1xudmFyIFRyZWVOb2RlTW9kZWwgPSByZXF1aXJlKCcuLi90cmVlL3RyZWUtbm9kZS1tb2RlbCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY0ZpbHRlck1vZGVsLmV4dGVuZCh7XG5cblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvYWRlZCA9ICQuRGVmZXJyZWQoKTtcbiAgICB0aGlzLl9jcmVhdGVUcmVlKG9wdGlvbnMuZGF0YSk7XG4gICAgR2VuZXJpY0ZpbHRlck1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gIH0sXG5cbiAgLy9vcmcgZG9lc24ndCBoYXZlIGFzeW5jIHBhcnQsIGJ1dCBzdGlsbCB1c2UgZGVmZXJyZWQsIHNvIGJlaGF2ZXMgc2FtZSBhcyBnZW5lcmljIGZpbHRlciBtb2RlbFxuICBnZXRUcmVlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkZWQ7XG4gIH0sXG5cbiAgX2NyZWF0ZVRyZWU6ZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcm9vdE5vZGVPYmogPSB7fTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJvb3ROb2RlT2JqID0gZGF0YVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdE5vZGVPYmogPSB7XG4gICAgICAgIGlkOiAtMSxcbiAgICAgICAgY29kZTogJy0xJyxcbiAgICAgICAgbmFtZTogc2VsZi5nZXQoJ2Rpc3BsYXlOYW1lJyksXG4gICAgICAgIGZpbHRlcklkOiBzZWxmLmdldCgnZmlsdGVySWQnKSxcbiAgICAgICAgY2hpbGRyZW46IGRhdGEsXG4gICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgICAgaXNTZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlVW5rb3duczogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRyZWVNb2RlbCA9IG5ldyBUcmVlTm9kZU1vZGVsKHJvb3ROb2RlT2JqKTtcbiAgICB0aGlzLnNldCgndHJlZScsIHRyZWVNb2RlbCk7XG5cbiAgICAvLyB0cmlja2xlIHVwIG51bVNlbGVjdGVkLlxuICAgIHNlbGYuZ2V0KCd0cmVlJykub24oJ2NoYW5nZTpudW1TZWxlY3RlZCcsIGZ1bmN0aW9uKG1vZGVsLCB2YWx1ZSkge1xuICAgICAgc2VsZi5zZXQoJ251bVNlbGVjdGVkJywgdmFsdWUpO1xuICAgICAgc2VsZi5zZXQoJ251bVBvc3NpYmxlJywgc2VsZi5nZXQoJ3RyZWUnKS5nZXQoJ251bVBvc3NpYmxlJykpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5sb2FkZWQucmVzb2x2ZSh0cmVlTW9kZWwpO1xuICB9XG5cbn0pO1xuXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFzZUZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2Jhc2UtZmlsdGVyLW1vZGVsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyTW9kZWwuZXh0ZW5kKHtcblxuXG4gIGRlZmF1bHRzOiB7XG4gICAgc2VsZWN0ZWRTdGFydDogbnVsbCxcbiAgICBzZWxlY3RlZEVuZDogbnVsbCxcbiAgICAvLyByYW5nZSBpcyBwcm92aWRlZCBieSBhcGksIGJ1dCB3aWxsIGZhbGxiYWNrIHRvIHRoaXMgaWYgbm90IHByb3ZpZGVkLCBvciBzZXQgdG8gLTFcbiAgICBzdGFydFllYXI6ICcnLFxuICAgIGVuZFllYXI6ICcnLFxuICAgIG1vZGVsVHlwZTogJ0RBVEUtUkFOR0UtVkFMVUVTJ1xuICB9LFxuICBcbiAgc3luYzogZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIGhhY2tpc2g6IHRoZSBkYXRhIGNvbWluZyBvZmYgdGhlIC9kYXRlcyBlbmRwb2ludCBzaG91bGQgYmUgaWdub3JlZCBhdCBhbGwgbW9tZW50cywgYmVjYXVzZVxuXHQgICAqIDEuIGZvciB0YWJzL3NhaWt1LCBpdCBzaG91bGQgYWx3YXlzIGJlIGVtcHR5XG5cdCAgICogMi4gZm9yIGdpcy9kYXNoYm9hcmRzLCBpdCBpcyBjb21pbmcgb2ZmIHRoZSAvc2V0dGluZyBlbmRwb2ludFxuXHQgICAqIFxuXHQgICAqIEFsbCB0aGUgb3RoZXIgeWVhcnMtZmlsdGVyLW1vZGVsIHNob3VsZCBieSBzcGVjIGJlIGFsd2F5cyBlbXB0eSBhdCB0aGlzIHBvaW50LiBJbiBjYXNlIHRoaXMgd291bGQgY2Vhc2UgdG8gYmUgdHJ1ZSBpbiB0aGUgZnV0dXJlLFxuXHQgICAqIGp1c3QgZmlsdGVyIGJ5IFwibmFtZVwiXG5cdCAgICovIFxuXHQgIFx0XG5cdCAgLy9jb25zb2xlLmVycm9yKCdTWU5DSU5HIFlFQVJTIE1PREVMOiAnICsgdGhpcy5nZXQoJ25hbWUnKSk7XG5cdCAgcmV0dXJuICQud2hlbih0cnVlKTtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgQmFzZUZpbHRlck1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLmVuZHBvaW50O1xuICAgIHRoaXMuc2V0KCdfbG9hZGVkJywgJC5EZWZlcnJlZCgpKTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuXHQgIGNvbnNvbGUubG9nKCd5ZWFycy1maWx0ZXItbW9kZWwucGFyc2U6IGRhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIGlmICghZGF0YS5zdGFydFllYXIgfHwgZGF0YS5zdGFydFllYXIgPT09IC0xKSB7XG4gICAgICBkYXRhLnN0YXJ0WWVhciA9IHRoaXMuZGVmYXVsdHMuc3RhcnRZZWFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnN0YXJ0WWVhciA9IGRhdGEuc3RhcnRZZWFyICsgJy0wMS0wMSc7XG4gICAgfVxuICAgIGlmICghZGF0YS5lbmRZZWFyIHx8IGRhdGEuZW5kWWVhciA9PT0gLTEpIHtcbiAgICAgIGRhdGEuZW5kWWVhciA9IHRoaXMuZGVmYXVsdHMuZW5kWWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5lbmRZZWFyID0gZGF0YS5lbmRZZWFyICsgJy0xMi0zMSc7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhLnNlbGVjdGVkU3RhcnQpIHtcbiAgICBcdC8vIGdvb2Qgb2xlJyBwYXJ0aWFsIGNvcHktcGFzdGUgb2ZmIHBvc3Rwcm9jZXNzKClcbiAgICBcdGRhdGEuc2VsZWN0ZWRTdGFydCA9IGRhdGEuc3RhcnRZZWFyO1xuICAgIFx0ZGF0YS5zZWxlY3RlZEVuZCA9IGRhdGEuZW5kWWVhcjtcbiAgICB9XG4gICAgdGhpcy5nZXQoJ19sb2FkZWQnKS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdC8vIEFNUC0yMTA0MTogRW5hYmxlZCBmaWx0ZXJpbmcgYnkgc3RhcnQgT1IgZW5kIGRhdGUuXG4gICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZFN0YXJ0JykgfHwgdGhpcy5nZXQoJ3NlbGVjdGVkRW5kJykpIHtcbiAgICBcdCAgdmFyIGtleSA9IHRoaXMuZ2V0KCdpZCcpOyAgICBcdCAgIFx0ICBcbiAgICBcdCAgdmFyIG9iaiA9IHt9O1xuICAgIFx0ICBpZihvcHRpb25zLndob2xlTW9kZWwgPT09IHRydWUpe1xuICAgIFx0XHQgIG9ialtrZXldID0ge1x0XHRcdFxuICAgIFx0XHRcdFx0ICBtb2RlbFR5cGUgOiB0aGlzLmdldCgnbW9kZWxUeXBlJyksICAgIFx0XHQgIFxuICAgIFx0XHRcdFx0ICBzdGFydDogdGhpcy5nZXQoJ3NlbGVjdGVkU3RhcnQnKSxcbiAgICBcdFx0XHRcdCAgZW5kOiB0aGlzLmdldCgnc2VsZWN0ZWRFbmQnKVx0XHRcdCAgXG4gICAgXHRcdFx0IH07XG4gICAgXHQgIH0gZWxzZSB7XG4gICAgXHRcdCAgb2JqW2tleV0gPSB7XHRcdFx0XHQgIFxuICAgIFx0XHRcdFx0ICBzdGFydDogdGhpcy5nZXQoJ3NlbGVjdGVkU3RhcnQnKSxcbiAgICBcdFx0XHRcdCAgZW5kOiB0aGlzLmdldCgnc2VsZWN0ZWRFbmQnKVx0XHRcdCAgXG4gICAgXHRcdFx0IH07IFxuICAgIFx0ICB9XG4gICAgXHQgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogcG9zdHByb2Nlc3MgbW9kZWwgYWZ0ZXIgaGF2aW5nIGZldGNoZWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIHBvc3Rwcm9jZXNzOiBmdW5jdGlvbigpIHtcblx0ICAvLyBvbmx5IHNldCBpZiBub3Qgc2V0IGJ5IGRlc2VyaWFsaXplXG5cdCAgaWYgKCF0aGlzLmdldCgnc2VsZWN0ZWRTdGFydCcpKSB7XG5cdCAgXHQgIHRoaXMuc2V0KCdzZWxlY3RlZFN0YXJ0JywgdGhpcy5nZXQoJ3N0YXJ0WWVhcicpKTtcblx0ICB9XG5cdCAgLy8gQU1QLTIxMDQxOiBFbmFibGVkIGZpbHRlcmluZyBieSBzdGFydCBPUiBlbmQgZGF0ZS5cbiAgICAgIGlmICghdGhpcy5nZXQoJ3NlbGVjdGVkRW5kJykpIHsgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICB0aGlzLnNldCgnc2VsZWN0ZWRFbmQnLCB0aGlzLmdldCgnZW5kWWVhcicpKTtcbiAgICAgIH1cbiAgfSxcbiAgXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbihvYmopIHtcblx0dmFyIGtleSA9IHRoaXMuZ2V0KCdpZCcpO1xuXHRpZiAob2JqICYmIG9ialtrZXldKSB7XG5cdCAgdGhpcy5zZXQoJ3NlbGVjdGVkU3RhcnQnLCB0aGlzLl9kYXRlQ29udmVydChvYmpba2V5XS5zdGFydCkpO1xuXHQgIHRoaXMuc2V0KCdzZWxlY3RlZEVuZCcsIHRoaXMuX2RhdGVDb252ZXJ0KG9ialtrZXldLmVuZCkpO1xuICAgICAgdGhpcy5wb3N0cHJvY2VzcygpO1xuXHR9ZWxzZXtcblx0XHR0aGlzLnNldCgnc2VsZWN0ZWRTdGFydCcsIHRoaXMuZ2V0KCdzdGFydFllYXInKSk7XG5cdCAgICB0aGlzLnNldCgnc2VsZWN0ZWRFbmQnLCB0aGlzLmdldCgnZW5kWWVhcicpKTtcblx0fVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnc2VsZWN0ZWRTdGFydCcsIHRoaXMuZ2V0KCdzdGFydFllYXInKSk7XG4gICAgdGhpcy5zZXQoJ3NlbGVjdGVkRW5kJywgdGhpcy5nZXQoJ2VuZFllYXInKSk7XG4gIH0sXG5cbiAgLy8gY29udmVydHM6IDAzLzAxLzE5NjEgPT0+IDE5NjEtMDEtMDEgSUYgTkVFREVELlxuICAvLyBET0VTIE5PVCBDT05WRVJUIGZyb20gdGhlIFwiLVwiIGZvcm1hdCB0byBcIi9cIiBmb3JtYXQgYW55bW9yZVxuICAvLyBcbiAgLy8gYW1wIGV4cGVjdHMgd2l0aCAnLScgYW5kIGpRdWVyeSB3YW50cyB3aXRoICcvJ1xuICBfZGF0ZUNvbnZlcnQ6IGZ1bmN0aW9uKGlucHV0KXtcblx0ICBjb25zb2xlLmxvZygnYXNrZWQgdG8gY29udmVydCBpbnB1dDogJyArIGlucHV0KTtcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5pbmRleE9mKCcvJyk+LTEpe1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNwbGl0KCcvJyk7XG4gICAgICAgIG91dHB1dCA9IGlucHV0WzJdICsgJy0nICsgaW5wdXRbMV0gKyAnLScgKyBpbnB1dFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgXHQgIG91dHB1dCA9IGlucHV0O1xuICAgICAgfVxuICAgICAgLyogZWxzZSBpZihpbnB1dC5pbmRleE9mKCctJyk+LTEpe1xuICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0LnNwbGl0KCctJyk7XG4gICAgICAgIG91dHB1dCA9IGlucHV0WzJdICsgJy8nICsgaW5wdXRbMV0gKyAnLycgKyBpbnB1dFswXTtcbiAgICAgIH0qL1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhc2VGaWx0ZXJNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9iYXNlLWZpbHRlci1tb2RlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VGaWx0ZXJNb2RlbC5leHRlbmQoe1xuXG5cdGRlZmF1bHRzIDoge1xuXHRcdHNlbGVjdGVkWWVhciA6IHVuZGVmaW5lZCxcblx0XHRkZWZhdWx0WWVhciA6IHVuZGVmaW5lZCxcblx0XHRtb2RlbFR5cGUgOiAnWUVBUi1TSU5HTEUtVkFMVUUnXG5cdH0sXG5cblx0aW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRCYXNlRmlsdGVyTW9kZWwucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgWyBvcHRpb25zIF0pO1xuXHRcdHRoaXMudXJsID0gb3B0aW9ucy5lbmRwb2ludDtcblx0XHR0aGlzLnNldCgnX2xvYWRlZCcsICQuRGVmZXJyZWQoKSk7XG5cdH0sXG5cblx0cGFyc2UgOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0aWYgKGRhdGEgJiYgZGF0YS52YWx1ZSAmJiBkYXRhLnZhbHVlLm9wdGlvbnMpIHtcblx0XHRcdGRhdGEuZGVmYXVsdFllYXIgPSBfLmZpbmQoZGF0YS52YWx1ZS5vcHRpb25zLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiBpdGVtLmlkID09PSBkYXRhLnZhbHVlLmRlZmF1bHRJZDtcblx0XHRcdH0pLnZhbHVlO1xuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhkYXRhKTtcblx0XHR0aGlzLmdldCgnX2xvYWRlZCcpLnJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbihvcHRpb25zKSB7XHRcblx0XHRpZiAodGhpcy5nZXQoJ3NlbGVjdGVkWWVhcicpKSB7XG5cdFx0XHR2YXIga2V5ID0gdGhpcy5nZXQoJ2lkJyk7XG5cdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRpZihvcHRpb25zLndob2xlTW9kZWwgPT09IHRydWUpe1xuXHRcdFx0XHRvYmpba2V5XSA9IHtcblx0XHRcdFx0XHRcdHllYXIgOiB0aGlzLmdldCgnc2VsZWN0ZWRZZWFyJyksXG5cdFx0XHRcdFx0XHRtb2RlbFR5cGUgOiB0aGlzLmdldCgnbW9kZWxUeXBlJyksXG5cdFx0XHRcdFx0XHRkaXNwbGF5TmFtZSA6IHRoaXMuZ2V0KCduYW1lJylcblx0XHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JqW2tleV0gPSB0aGlzLmdldCgnc2VsZWN0ZWRZZWFyJyk7XHRcblx0XHRcdH1cdFxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdGRlc2VyaWFsaXplIDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGtleSA9IHRoaXMuZ2V0KCdpZCcpO1xuXHRcdGlmIChvYmogJiYgb2JqW2tleV0pIHtcblx0XHRcdHRoaXMuc2V0KCdzZWxlY3RlZFllYXInLCBvYmpba2V5XSk7XHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9XG5cdH0sXG5cblx0cmVzZXQgOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNldCgnc2VsZWN0ZWRZZWFyJywgJycpO1xuXHRcdHRoaXMuc2V0KCdkaXNwbGF5TmFtZScsICcnKVxuXHR9LFxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBUcmVlTm9kZU1vZGVsOyAvLyBkZWNsYXJlIGhlcmUgdG8gaGVscCB3aXRoIHJlZiBsb29wIG9mIGNvbGxlY3Rpb24gYW5kIG1vZGVsXG52YXIgVHJlZU5vZGVDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoeyAgbW9kZWw6VHJlZU5vZGVNb2RlbCB9KTtcblxuLy9UT0RPOiBwcm9wYWdhdGlvbiBidWcgaWYgbWlkIGxldmVsIG5vZGUgaXMgaGFsZiBmaWxsZWQgYW5kIHlvdSAnZGVzZWxlY3QgYWxsJyBpdCB3b24ndCBwcm9wb2dhdGUgdG8gY2hpbGRyZW4uXG5cblRyZWVOb2RlTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICBkZWZhdWx0czp7XG4gICAgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgIC8vIGRlZmF1bHQgaXMgc2VsZWN0ZWQuIGNoYW5nZSB0byBzdHJpbmcgLyB0ZXJuYXJ5LCBmb3Igb2ZmLCBzZW1pLCBhbmQgb25cbiAgICBleHBhbmRlZDogdHJ1ZSxcbiAgICB2aXNpYmxlOiB0cnVlLFxuICAgIG51bVNlbGVjdGVkOiAwLFxuICAgIG51bVBvc3NpYmxlOiAwLFxuICAgIGNoaWxkcmVuOiBudWxsLCAgICAgLy8gdHlwZSBUcmVlTm9kZUNvbGxlY3Rpb25cbiAgICBpc1NlbGVjdGFibGU6IGZhbHNlICAvLyBpcyB0aGlzIG5vZGUgaXRzZWxmIHNlbGVjdGFibGUgKGllLiBzaG91bGQgaXQgaGF2ZSBhbiAndW5rb3duJyBjaGlsZClcbiAgfSxcbiAgaWdub3JlTGlzdDogWydkb25vci1ncm91cCcsICdkb25vci10eXBlJywgJ2ltcGxlbWVudGluZy1hZ2VuY3knLCAnYmVuZWZpY2lhcnktYWdlbmN5JywgJ2V4ZWN1dGluZy1hZ2VuY3knLCAncmVzcG9uc2libGUtb3JnYW5pemF0aW9uJywgJ2NvbXBvbmVudC1mdW5kaW5nLW9yZ2FuaXphdGlvbicsICdjb21wb25lbnQtc2Vjb25kLXJlc3BvbnNpYmxlLW9yZ2FuaXphdGlvbiddLC8vbGlzdCBvZiBmaWx0ZXJJZHMgdG8gaWdub3JlIHdoZW4gc2VyaWFsaXppbmdcbiAgaWdub3JlT3JnR3JvdXBMaXN0OiBbJ2ltcGxlbWVudGluZy1hZ2VuY3knLCdiZW5lZmljaWFyeS1hZ2VuY3knLCAnZXhlY3V0aW5nLWFnZW5jeScsICdyZXNwb25zaWJsZS1vcmdhbml6YXRpb24nLCAnY29tcG9uZW50LWZ1bmRpbmctb3JnYW5pemF0aW9uJywgJ2NvbXBvbmVudC1zZWNvbmQtcmVzcG9uc2libGUtb3JnYW5pemF0aW9uJ10sIC8vIGZvciB0aGlzIGZpbHRlcklkcyB3ZSBkbyBub3QgZGVzZXJpYWxpemUgb3JnIGdyb3VwcyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBzYW1lIGlkc1xuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hpbGRyZW5Db2xsZWN0aW9uID0gbmV3IFRyZWVOb2RlQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuc2V0KCdjaGlsZHJlbicsIGNoaWxkcmVuQ29sbGVjdGlvbik7XG4gICAgLy9pdGVyYXRlIG92ZXIgY2hpbGRyZW5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2hpbGRyZW4pKSB7XG4gICAgICBfLmVhY2gob2JqLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgbmV3Q2hpbGQgPSBuZXcgVHJlZU5vZGVNb2RlbChjaGlsZCk7XG4gICAgICAgIGNoaWxkcmVuQ29sbGVjdGlvbi5hZGQobmV3Q2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBjaGlsZHJlbiwgdGhlbiBhZGQgc2VsZiBhcyBhIGxlYWYgbm9kZSwgJ3Vua293bidcbiAgICBpZiAoIWNoaWxkcmVuQ29sbGVjdGlvbi5pc0VtcHR5KCkgJiYgIHRoaXMuZ2V0KCdpc1NlbGVjdGFibGUnKSkge1xuICAgICAgdmFyIHVua293bk5vZGUgPSBuZXcgVHJlZU5vZGVNb2RlbChzZWxmLnRvSlNPTigpKTtcbiAgICAgIHVua293bk5vZGUuc2V0KCduYW1lJywgJ3Vua293bjogJyArIHRoaXMuZ2V0KCduYW1lJykpO1xuICAgICAgY2hpbGRyZW5Db2xsZWN0aW9uLmFkZCh1bmtvd25Ob2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hZGRMaXN0ZW5lcnNUb0NoaWxkcmVuKCk7XG5cbiAgICB0aGlzLm9uKCdjaGFuZ2U6c2VsZWN0ZWQnLCBzZWxmLl9vblNlbGVjdENoYW5nZSk7XG5cbiAgICB0aGlzLl91cGRhdGVDb3VudCgpO1xuICB9LFxuXG5cbi8vIG1lcmdlIGJhc2VkIG9uIGZpbHRlcklkIGFzIHdlIHNlcmlhbGl6ZS4uLi5cbi8vIG9wdGlvbnMud2hvbGVNb2RlbCByZXR1cm5zIHdob2xlIE1vZGVscyBpbnN0ZWFkIG9mIGp1c3QgaWRzXG4vLyBvcHRpb25zLmluY2x1ZGVVbnNlbGVjdGVkIHJldHVybnMgZnVsbCB0cmVlLCBldmVuIGlmIG5vZGVzIGFyZSBub3Qgc2VsZWN0ZWQuXG4vLyBDb2RlIGV4cGxpY2l0bHkgaWdub3JlcyBkb25vci1ncm91cCxkb25vci10eXBlIGFuZCB0aGUgcmVzdCBvZiB0aGUgb3JnYW5pemF0aW9ucy5cbi8vICAgdGhleSBvbmx5IGhhdmUgRmlsdGVySWRzIGZvciBkZXNlcmlhbGl6ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4vLyBUT0RPOiBjb25zaWRlciBwdWxsaW5nIG91dCBvcHRpb25zLmluY2x1ZGVVbnNlbGVjdGVkIGludG8gaXRzIG93biBmdW5jdGlvbiBnZXRBbGxGaWx0ZXJzKClcbnNlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgdmFyIHRtcFNlcmlhbGl6ZWQgPSB7fTtcblx0IHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgICBpZiAob3B0aW9ucy5pbmNsdWRlVW5zZWxlY3RlZCkge1xuICAgIFx0aWYgKHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICYmICF0aGlzLl9pc0luSWdub3JlTGlzdCh0aGlzLmdldCgnZmlsdGVySWQnKSkpIHtcbiAgICBcdFx0XHR0bXBTZXJpYWxpemVkW3RoaXMuZ2V0KCdmaWx0ZXJJZCcpXSA9IChvcHRpb25zLndob2xlTW9kZWw/IFt0aGlzXTpbdGhpcy5pZF0pO1xuICAgIFx0fSBlbHNle1xuICAgIFx0XHR0bXBTZXJpYWxpemVkLnVuYXNzaWduZWQgPSAob3B0aW9ucy53aG9sZU1vZGVsPyBbdGhpc106W3RoaXMuaWRdKTtcbiAgICBcdH1cbiAgICBcdHRoaXMuX3NlcmlhbGl6ZUNoaWxkcmVuKHRtcFNlcmlhbGl6ZWQsIGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgICAgfSBlbHNlIHtcbiAgICAgICAvLyBBTVAtMjg2ODM6IEJlZm9yZSBjaGVja2luZyBpZiBpdCBoYXMgY2hpbGRyZW4sIGNoZWNrIGlmIHRoZSBcInBhcmVudFwiIGlzIHNlbGVjdGVkIHRvby5cbiAgICAgICBpZiAodGhpcy5nZXQoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgIGlmICh0aGlzLmdldCgnZmlsdGVySWQnKSAmJiAhdGhpcy5faXNJbklnbm9yZUxpc3QodGhpcy5nZXQoJ2ZpbHRlcklkJykpICkge1xuICAgICAgICAgICB0bXBTZXJpYWxpemVkW3RoaXMuZ2V0KCdmaWx0ZXJJZCcpXSA9IChvcHRpb25zLndob2xlTW9kZWw/IFt0aGlzXTpbdGhpcy5pZF0pO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdG1wU2VyaWFsaXplZC51bmFzc2lnbmVkID0gKG9wdGlvbnMud2hvbGVNb2RlbD8gW3RoaXNdOlt0aGlzLmlkXSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgIFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vVW50aWwgd2UgcmVmYWN0b3IgZmlsdGVycyBpbiAzLnggd2Ugd2lsbCBzZXJpYWxpemUgZXZlbiBpZiB0aGUgd2hvbGUgdHJlZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgdGhpcy5fc2VyaWFsaXplQ2hpbGRyZW4odG1wU2VyaWFsaXplZCwgY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICBcdCAgLy9ubyBjaGlsZHJlbiBzbyBqdXN0IHJldHVybiBzZWxmLlxuICAgIFx0ICBpZiAodGhpcy5nZXQoJ3NlbGVjdGVkJykpIHtcbiAgICBcdFx0ICBpZiAodGhpcy5nZXQoJ2ZpbHRlcklkJykgJiYgIXRoaXMuX2lzSW5JZ25vcmVMaXN0KHRoaXMuZ2V0KCdmaWx0ZXJJZCcpKSApIHtcbiAgICBcdFx0XHQgIFx0dG1wU2VyaWFsaXplZFt0aGlzLmdldCgnZmlsdGVySWQnKV0gPSAob3B0aW9ucy53aG9sZU1vZGVsPyBbdGhpc106W3RoaXMuaWRdKTtcbiAgICBcdFx0ICB9IGVsc2Uge1xuICAgIFx0XHRcdCAgdG1wU2VyaWFsaXplZC51bmFzc2lnbmVkID0gKG9wdGlvbnMud2hvbGVNb2RlbD8gW3RoaXNdOlt0aGlzLmlkXSk7XG4gICAgXHRcdCAgfVxuICAgIFx0ICB9XG4gICAgICB9XG4gICB9XG4gICB0aGlzLl9tZXJnZVVuYXNzaWduZWQodG1wU2VyaWFsaXplZCk7XG4gICByZXR1cm4gdG1wU2VyaWFsaXplZDtcbn0sXG5faXNJbklnbm9yZUxpc3Q6ICBmdW5jdGlvbihmaWx0ZXJJZCl7XG4gcmV0dXJuIHRoaXMuaWdub3JlTGlzdC5pbmRleE9mKGZpbHRlcklkKSA+IC0xO1xufSxcbl9zZXJpYWxpemVDaGlsZHJlbjogZnVuY3Rpb24odG1wU2VyaWFsaXplZCwgY2hpbGRyZW4sIG9wdGlvbnMpe1xuICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkQ2hpbGQgPSBjaGlsZC5zZXJpYWxpemUob3B0aW9ucyk7XG4gICAgICBfLmVhY2goc2VyaWFsaXplZENoaWxkLCBmdW5jdGlvbih2LGspe1xuICAgICAgICBpZih2KXtcbiAgICAgICAgICAvL21lcmdlIGlmIGtleSBleGlzdHNcbiAgICAgICAgICBpZiAodG1wU2VyaWFsaXplZFtrXSkge1xuICAgICAgICAgICAgdG1wU2VyaWFsaXplZFtrXSA9IHRtcFNlcmlhbGl6ZWRba10uY29uY2F0KHYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBTZXJpYWxpemVkW2tdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIF9tZXJnZVVuYXNzaWduZWQ6IGZ1bmN0aW9uKHRtcFNlcmlhbGl6ZWQpe1xuICAgIC8vIGlmIGN1cnJlbnQgbm9kZSBoYXMgYSBmaWx0ZXJJZCBwdXQgYWxsICd1bmFzc2lnbmVkJyBlbGVtZW50cyB1bmRlciB0aGlzLlxuICAgIGlmKHRoaXMuZ2V0KCdmaWx0ZXJJZCcpKXtcbiAgICAgIHZhciBmaWx0ZXJJZCA9IHRoaXMuZ2V0KCdmaWx0ZXJJZCcpO1xuICAgICAgaWYodG1wU2VyaWFsaXplZFtmaWx0ZXJJZF0gJiYgdG1wU2VyaWFsaXplZC51bmFzc2lnbmVkKXtcbiAgICAgICAgdG1wU2VyaWFsaXplZFtmaWx0ZXJJZF0gPSB0bXBTZXJpYWxpemVkW2ZpbHRlcklkXS5jb25jYXQodG1wU2VyaWFsaXplZC51bmFzc2lnbmVkKTtcbiAgICAgICAgZGVsZXRlIHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZDtcbiAgICAgIH0gZWxzZSBpZiAodG1wU2VyaWFsaXplZC51bmFzc2lnbmVkKXtcbiAgICAgICAgdG1wU2VyaWFsaXplZFtmaWx0ZXJJZF0gPSB0bXBTZXJpYWxpemVkLnVuYXNzaWduZWQ7XG4gICAgICAgIGRlbGV0ZSB0bXBTZXJpYWxpemVkLnVuYXNzaWduZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbihibG9iKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmKCFjaGlsZC5nZXQoJ2ZpbHRlcklkJykgJiYgc2VsZi5nZXQoJ2ZpbHRlcklkJykpe1xuICAgICAgICAgIGNoaWxkLnNldCgnZmlsdGVySWQnLCBzZWxmLmdldCgnZmlsdGVySWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuZGVzZXJpYWxpemUoYmxvYik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZihibG9iW3RoaXMuZ2V0KCdmaWx0ZXJJZCcpXSl7ICAgIFx0XHRcbiAgICAgICAgaWYgKHRoaXMuaXNJbkZpbHRlcnMoYmxvYiwgdGhpcy5pZCkpeyAgICBcdFx0ICBcbiAgICAgICAgICB0aGlzLnNldCgnc2VsZWN0ZWQnLCB0cnVlLCB7cHJvcGFnYXRpb246IHRydWV9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnNldCgnc2VsZWN0ZWQnLCBmYWxzZSwge3Byb3BhZ2F0aW9uOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaXNJbkZpbHRlcnM6IGZ1bmN0aW9uKGJsb2IsIGlkKXtcdCBcblx0ICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cdCAgaWYgKCEodGhpcy5pZ25vcmVPcmdHcm91cExpc3QuaW5kZXhPZih0aGlzLmdldCgnZmlsdGVySWQnKSkgPiAtMSAmJiAgdGhpcy5nZXQoJ2lzT3JnR3JvdXAnKSA9PSB0cnVlKSl7XHRcdFx0ICBcblx0XHQgcmVzdWx0ID0gKGJsb2JbdGhpcy5nZXQoJ2ZpbHRlcklkJyldKS5pbmRleE9mKHRoaXMuaWQpID4gLTFcblx0ICB9XHQgIFxuXHQgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIFxuICBfb25TZWxlY3RDaGFuZ2U6ZnVuY3Rpb24obW9kZWwsIGFyZ3VtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZCcpKSB7XG4gICAgICB0aGlzLnNldCgnbnVtU2VsZWN0ZWQnLCB0aGlzLmdldCgnbnVtUG9zc2libGUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0KCdudW1TZWxlY3RlZCcsIDApO1xuICAgIH1cblxuICAgIGlmICghY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICBzZWxmLl91cGRhdGVDaGlsZE5vZGVzKG9wdGlvbnMucHJvcGFnYXRpb24pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnByb3BhZ2F0aW9uKSB7XG4gICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZUNvdW50Jyk7XG4gICAgfVxuICB9LFxuXG5cbiAgX2FkZExpc3RlbmVyc1RvQ2hpbGRyZW46ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLm9uKCdjaGFuZ2U6dmlzaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJZiBubyBjaGlsZHJlbiBhcmUgdmlzaWJsZSwgdGhlbiBoaWRlIHNlbGYuXG4gICAgICAgIGlmICghY2hpbGRyZW4uZmluZFdoZXJlKHt2aXNpYmxlOiB0cnVlfSkpIHtcbiAgICAgICAgICBzZWxmLnNldCh7dmlzaWJsZTogZmFsc2V9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNldCh7dmlzaWJsZTogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNoaWxkLm9uKCd1cGRhdGVDb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl91cGRhdGVDb3VudCgpO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZUNvdW50Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBfdXBkYXRlQ291bnQ6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgdmFyIGNvdW50VG90YWwgPSB7XG4gICAgICBzZWxlY3RlZDogMCxcbiAgICAgIHBvc3NpYmxlOjBcbiAgICB9O1xuXG4gICAgaWYgKCFjaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY291bnRUb3RhbC5zZWxlY3RlZCArPSBjaGlsZC5nZXQoJ251bVNlbGVjdGVkJyk7XG4gICAgICAgIGNvdW50VG90YWwucG9zc2libGUgKz0gY2hpbGQuZ2V0KCdudW1Qb3NzaWJsZScpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50VG90YWwgPSB7XG4gICAgICAgIHNlbGVjdGVkOiAodGhpcy5nZXQoJ3NlbGVjdGVkJykgPyAxIDogMCksXG4gICAgICAgIHBvc3NpYmxlOiAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdudW1TZWxlY3RlZCcsIGNvdW50VG90YWwuc2VsZWN0ZWQpO1xuICAgIHRoaXMuc2V0KCdudW1Qb3NzaWJsZScsIGNvdW50VG90YWwucG9zc2libGUpO1xuICB9LFxuXG4gIF91cGRhdGVDaGlsZE5vZGVzOmZ1bmN0aW9uKHByb3BhZ2F0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuXG4gICAgaWYgKCFjaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc2V0KCdzZWxlY3RlZCcsIHNlbGYuZ2V0KCdzZWxlY3RlZCcpLCB7cHJvcGFnYXRpb246IHByb3BhZ2F0aW9ufSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgZmlsdGVyVGV4dDogZnVuY3Rpb24odHh0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICBpZiAoIWNoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgLy8gaWYgdGhlIG5vZGUgaXRzZWxmIG1hdGNoZXMsIHR1cm4gaXQgb24sIGV2ZW4gaWYgbm8gY2hpbGRyZW4gYXJlIHZpc2libGUuXG4gICAgICBpZiAodGhpcy5nZXQoJ25hbWUnKSAmJiB0aGlzLmdldCgnbmFtZScpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0eHQpID4gLTEpIHtcbiAgICAgICAgdGhpcy5zZXQoJ3Zpc2libGUnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gRllJOiBwdXR0aW5nIGluc2lkZSBhbiBlbHNlIGFib3ZlIGtlZXBzIGNoaWxkcmVuIHZpc2libGUgaWYgcGFyZW50IG1hdGNoZXMuXG4gICAgICBjaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmZpbHRlclRleHQodHh0KTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmdldCgnbmFtZScpICYmIHRoaXMuZ2V0KCduYW1lJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKHR4dCkgPiAtMSkge1xuICAgICAgICB0aGlzLnNldCgndmlzaWJsZScsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXQoJ3Zpc2libGUnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZU5vZGVNb2RlbDtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIFRlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPVxcXCJub2RlIHNtYWxsXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInNlbGVjdGFibGVcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwidG9nZ2xlLW5hdlxcXCI+XFxuICAgIDwlIGlmKG5hbWUubGVuZ3RoID4gNjMpeyAlPlxcbiAgICAgIDxzcGFuIHRpdGxlPVxcXCI8JT0gbmFtZSAlPlxcXCI+PCU9IG5hbWUuc3Vic3RyaW5nKDAsNjApICU+Li4uPC9zcGFuPlxcbiAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgIDwlPSBuYW1lICU+XFxuICAgIDwlIH0gJT5cXG5cXG5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImNvdW50XFxcIj4oPCU9IG51bVNlbGVjdGVkICU+IC8gPCU9IG51bVBvc3NpYmxlICU+KTwvc3Bhbj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImV4cGFuZGVkXFxcIj4rPC9zcGFuPlxcbiAgPC9kaXY+XFxuXFxuICA8JSAvKlRPRE86IGZpeCBoYXJkY29kZSBvZiAndW5rb3duJyAqL1xcbiAgaWYgKG9iai5uYW1lICYmIG9iai5uYW1lLmluZGV4T2YoXFxcInVua293blxcXCIpPi0xKSB7ICU+XFxuICAgICZuYnNwOzxhIGhyZWY9XFxcIiNcXFwiXFxuICAgICAgZGF0YS10b2dnbGU9XFxcInBvcG92ZXJcXFwiXFxuICAgICAgZGF0YS1jb250YWluZXI9XFxcImJvZHlcXFwiXFxuICAgICAgZGF0YS1wbGFjZW1lbnQ9XFxcInJpZ2h0XFxcIlxcbiAgICAgIGRhdGEtdHJpZ2dlcj1cXFwiY2xpY2tcXFwiXFxuICAgICAgZGF0YS1jb250ZW50PVxcXCJwcm9qZWN0cyB0aGF0IGFyZW4ndCB0YWdnZWQgdG8gYSBzcGVjaWZpYyBjaGlsZC5cXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnblxcXCI+PC9zcGFuPlxcbiAgICA8L2E+XFxuICA8JX0lPlxcbjwvZGl2PlxcblwiO1xuXG5cbnZhciBUcmVlTm9kZVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgdGFnTmFtZTogJ2xpJyxcbiAgY2xhc3NOYW1lOiAncGFyZW50X2xpJyxcblxuICAvL1RPRE86IGRlYnVnIGFmdGVyIHVzYWJpbGl0eSB0ZXN0aW5nLCBjdXJyZW50bHkgc2V0dGluZyBpbiBhZGRVSUxpc3RlbmVyc1xuICAvLyB3b24ndCB3b3JrIG9uIHNlY29uZCB1c2Ugb2Ygd2lkZ2V0LlxuICAvLyBldmVudHM6IHtcbiAgLy8gICAnY2xpY2sgLnNlbGVjdGFibGUnOiAnc2VsZWN0JyxcbiAgLy8gICAnY2xpY2sgIC50b2dnbGUtbmF2JzogJ2NsaWNrTmFtZSdcbiAgLy8gfSxcblxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG4gIGlzUm9vdDogZmFsc2UsXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgaWYoIV8uaXNVbmRlZmluZWQob3B0aW9ucykgJiYgIV8uaXNVbmRlZmluZWQob3B0aW9ucy5pc1Jvb3QpKXtcblx0XHQgdGhpcy5pc1Jvb3QgPSBvcHRpb25zLmlzUm9vdDtcblx0IH1cblx0ICBcbiAgfSxcblxuXG4gIHJlbmRlcjpmdW5jdGlvbihtb2RlbCkge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZShtb2RlbC50b0pTT04oKSkpO1xuICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlckNoaWxkcmVuOmZ1bmN0aW9uKCkge1xuICAgIHZhciB1bCA9ICQoJzx1bD4nKTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodWwpO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5tb2RlbC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIHRtcFZpZXcgPSBuZXcgVHJlZU5vZGVWaWV3KCk7XG4gICAgICAgIHVsLmFwcGVuZCh0bXBWaWV3LnJlbmRlcihjaGlsZCkuJGVsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiQoJy5leHBhbmRlZCcpLnJlbW92ZSgpO1xuICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnRvZ2dsZS1uYXYgPiAuY291bnQnKS50ZXh0KCcnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hZGRNb2RlbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2FkZFVJTGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLl91cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB0aGlzLl91cGRhdGVFeHBhbmRlZCh1bCk7XG4gIH0sXG5cbiAgX2FkZE1vZGVsTGlzdGVuZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vQWRkIG1vZGVsIGxpc3RlbmVyZXNcbiAgICB0aGlzLm1vZGVsLm9uKCdjaGFuZ2U6c2VsZWN0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3VwZGF0ZVNlbGVjdGlvbigpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlOmV4cGFuZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl91cGRhdGVFeHBhbmRlZCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlOm51bVNlbGVjdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl91cGRhdGVDb3VudFVJKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1vZGVsLm9uKCdjaGFuZ2U6dmlzaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fdXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIF9hZGRVSUxpc3RlbmVyczpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuY2xpY2tCb3goKTtcblxuICAgIH0pO1xuICAgIHRoaXMuJCgnPiAubm9kZSA+IC50b2dnbGUtbmF2Jykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmNsaWNrTmFtZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIF91cGRhdGVTZWxlY3Rpb246ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlQ2hlY2tib3hGaWxsKCk7XG4gIH0sXG5cbiAgX3VwZGF0ZUNvdW50VUk6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsLmdldCgnY2hpbGRyZW4nKS5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC50b2dnbGUtbmF2ID4gLmNvdW50JykudGV4dChcbiAgICAgICAgJygnICsgdGhpcy5tb2RlbC5nZXQoJ251bVNlbGVjdGVkJykgKyAnIC8gJyArIHRoaXMubW9kZWwuZ2V0KCdudW1Qb3NzaWJsZScpICsgJyknKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNoZWNrYm94RmlsbCgpO1xuICAgIH1cbiAgfSxcblxuICBfdXBkYXRlVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCd2aXNpYmxlJykpIHtcbiAgICAgIHRoaXMuJGVsLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwuaGlkZSgpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIEZvciB1cGRhdGluZyBub24tbGVhZiBub2Rlc1xuICBfdXBkYXRlQ2hlY2tib3hGaWxsOmZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5tb2RlbC5nZXQoJ2NoaWxkcmVuJykuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ251bVNlbGVjdGVkJykgPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbnVtU2VsZWN0ZWQnKSA8IHRoaXMubW9kZWwuZ2V0KCdudW1Qb3NzaWJsZScpKSB7XG4gICAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5hZGRDbGFzcygnaGFsZi1maWxsJyk7XG4gICAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLnJlbW92ZUNsYXNzKCdoYWxmLWZpbGwnKTtcbiAgICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZWwuZ2V0KCdudW1TZWxlY3RlZCcpID09PSAwKSB7XG4gICAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC5zZWxlY3RhYmxlJykucmVtb3ZlQ2xhc3MoJ2hhbGYtZmlsbCcpO1xuICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGVsc2UgbGVhZiBub2RlXG4gICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC5zZWxlY3RhYmxlJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF91cGRhdGVFeHBhbmRlZDpmdW5jdGlvbih1bCkge1xuICAgIHZhciBpRWxlbWVudCA9IHRoaXMuJCgnPiAubm9kZSA+IC50b2dnbGUtbmF2ID4gLmV4cGFuZGVkJyk7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdleHBhbmRlZCcpKSB7XG4gICAgICB0aGlzLmV4cGFuZCgpO1xuICAgICAgaUVsZW1lbnQudGV4dCgnLScpO1xuICAgICAgaUVsZW1lbnQuYWRkQ2xhc3MoJ29wZW4nKS5yZW1vdmVDbGFzcygnY2xvc2VkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbGFwc2UoKTtcblxuICAgICAgLy8gdG8gcnVuIG9uIGZpcnN0IHRpbWUuLi5uZWVkIHRvIHVzZSB1bCwgc2luY2UgZWwgaXMgbm90IG9uIERPTSB5ZXRcbiAgICAgIGlmICh1bCkge1xuICAgICAgICB1bC5maW5kKCc+IGxpJykuaGlkZSgpO1xuICAgICAgfVxuXG4gICAgICBpRWxlbWVudC50ZXh0KCcrJyk7XG4gICAgICBpRWxlbWVudC5hZGRDbGFzcygnY2xvc2VkJykucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcbiAgICB9XG4gIH0sXG5cblxuICBjbGlja0JveDpmdW5jdGlvbigpIHtcblx0ICBpZih0aGlzLmlzUm9vdCl7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc2VsZWN0ZWQnLCAhdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJykpO1x0XHQgIFxuXHQgIH1lbHNle1xuXHRcdCAgdGhpcy5tb2RlbC5zZXQoJ3NlbGVjdGVkJywgIXRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZCcpLCB7cHJvcGFnYXRpb246IHRydWV9KTsgIFxuXHQgIH0gICAgXG4gIH0sXG5cblxuICBjbGlja05hbWU6ZnVuY3Rpb24oKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBjaGlsZHJlbiBleHBhbmRcbiAgICBpZiAoIXRoaXMubW9kZWwuZ2V0KCdjaGlsZHJlbicpLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5tb2RlbC5zZXQoJ2V4cGFuZGVkJywgIXRoaXMubW9kZWwuZ2V0KCdleHBhbmRlZCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGVhZiBub2RlLCBzbyBwcmV0ZW5kIHRoZSBjbGlja2VkIG9uIHRoZSBib3hcbiAgICAgIHRoaXMuY2xpY2tCb3goKTtcbiAgICB9XG4gIH0sXG5cblxuICBjb2xsYXBzZTpmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRlbC5maW5kKCcgPiB1bCA+IGxpJyk7XG4gICAgY2hpbGRyZW4uaGlkZSgnZmFzdCcpO1xuXG4gIH0sXG5cbiAgZXhwYW5kOmZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJGVsLmZpbmQoJyA+IHVsID4gbGknKTtcbiAgICBjaGlsZHJlbi5zaG93KCdmYXN0Jyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZU5vZGVWaWV3O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcblxyXG52YXIgZXh0cmFjdERhdGVzID0gZnVuY3Rpb24oc2V0dGluZ3MsIGZpbHRlcnNPdXQsIG1pbk5hbWUsIG1heE5hbWUpIHtcclxuXHRmaWx0ZXJzT3V0ID0gZmlsdGVyc091dCB8fCB7fTsgIFxyXG5cdGlmKF8uaXNVbmRlZmluZWQoZmlsdGVyc091dC5kYXRlKSB8fCBfLmlzRW1wdHkoZmlsdGVyc091dC5kYXRlKSl7XHJcblx0XHQgIGZpbHRlcnNPdXQuZGF0ZSA9IGZpbHRlcnNPdXQuZGF0ZSB8fCB7XHJcblx0XHRcdCAgc3RhcnQ6ICcnLFxyXG5cdFx0XHQgIGVuZDogJydcclxuXHRcdCAgfTtcclxuXHJcblx0XHQgIHZhciBkZWZhdWx0TWluRGF0ZSA9IHNldHRpbmdzLmdldChtaW5OYW1lKTsgICAgXHJcblx0XHQgIGlmIChkZWZhdWx0TWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRNaW5EYXRlICE9PSAnJykge1xyXG5cdFx0XHQgIGZpbHRlcnNPdXQuZGF0ZS5zdGFydCA9IGRlZmF1bHRNaW5EYXRlO1xyXG5cdFx0ICB9XHJcblx0XHQgIHZhciBkZWZhdWx0TWF4RGF0ZSA9IHNldHRpbmdzLmdldChtYXhOYW1lKTtcclxuXHRcdCAgaWYgKGRlZmF1bHRNYXhEYXRlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdE1heERhdGUgIT09ICcnKSB7XHJcblx0XHRcdCAgZmlsdGVyc091dC5kYXRlLmVuZCA9IGRlZmF1bHRNYXhEYXRlO1xyXG5cdFx0ICB9XHJcblx0ICB9ICBcclxuICB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRcdGV4dHJhY3REYXRlczogZXh0cmFjdERhdGVzXHJcbn1cclxuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgVGl0bGVUZW1wbGF0ZSA9IFwiPGxpPlxcblxcdDxhIGhyZWY9XFxcIiNcXFwiPlxcblxcdFxcdDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtPCU9IG5hbWUucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCI+XFxuXFx0XFx0XFx0PCU9IG5hbWUgJT5cXG5cXHRcXHQ8L3NwYW4+ICAgXFxuXFx0XFx0PHNwYW4gY2xhc3M9J2ZpbHRlci1jb3VudCBzbWFsbCBwdWxsLXJpZ2h0Jz48L3NwYW4+XFxuXFx0PC9hPlxcbjwvbGk+XCI7XG52YXIgQ29udGVudFRlbXBsYXRlID0gXCI8JVxcbiAgLy8gdGhpcyByZW5kZXJzIHRoZSBcXFwiYmlnXFxcIiBmaWx0ZXIgbGlzdCAodGhlIHRhYnMpXFxuJT5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG4gIDxhIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlIGNhbmNlbFxcXCIgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9hPlxcbiAgPGgzIGRhdGEtaTE4bj1cXFwiYW1wLmdpczp0aXRsZS1maWx0ZXJzXFxcIiBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPkZpbHRlcnM8L2gzPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHkgZmlsdGVyLWJvZHlcXFwiPlxcblxcbiAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnMgZmlsdGVyLXRpdGxlc1xcXCIgcm9sZT1cXFwidGFibGlzdFxcXCI+XFxuICA8L3VsPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnQgZmlsdGVyLW9wdGlvbnNcXFwiPlxcbiAgICA8aW1nIHNyYz1cXFwiaW1nXzIvbG9hZGluZy1pY29uLmdpZlxcXCIgLz5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWZvb3RlclxcXCI+XFxuICAmbmJzcDtcXG4gIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG1hcmdpbi1ib3R0b206IDVweDtcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRhbmdlciByZXNldFxcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpidXR0b24tcmVzZXRcXFwiICB0aXRsZT1cXFwiVHVybiBvZmYgYWxsIGZpbHRlcnMuXFxcIj5SZXNldDwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLXdhcm5pbmcgY2FuY2VsXFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOmJ1dHRvbi1jYW5jZWxcXFwiICB0aXRsZT1cXFwiUmV2ZXJ0IGZpbHRlcnMgdG8gc3RhdGUgd2hlbiBvcGVuZWQuXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIGFwcGx5XFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOmJ1dHRvbi1hcHBseVxcXCIgPkFwcGx5PC9idXR0b24+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuLy8gUGFyZW50IGJhc2UgdmlldyBmb3IgZmlsdGVycy5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ2ZpbHRlci10eXBlJyxcblxuICB0aXRsZVRlbXBsYXRlOiBfLnRlbXBsYXRlKFRpdGxlVGVtcGxhdGUpLFxuICBjb250ZW50VGVtcGxhdGU6IF8udGVtcGxhdGUoQ29udGVudFRlbXBsYXRlKSxcblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICB9LFxuXG4gIHJlbmRlckZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuXG4gIH0sXG5cbiAgcmVuZGVyVGl0bGU6IGZ1bmN0aW9uKCkge1x0ICBcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy50aXRsZUVsID0gdGhpcy50aXRsZVRlbXBsYXRlKHRoaXMubW9kZWwudG9KU09OKCkpO1xuICAgIHRoaXMuJHRpdGxlRWwgPSAkKHRoaXMudGl0bGVFbCk7XG4gICAgdGhpcy4kdGl0bGVFbC5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICQodGhpcykuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAkKHRoaXMpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgIHNlbGYuJGVsLmh0bWwoJycpO1xuICAgICAgc2VsZi5yZW5kZXJGaWx0ZXJzKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59KTtcbiIsIi8qKlxuICogdGhpcyBpcyB0aGUgdmlldyB3aGljaCByZW5kZXJzIHRoZSBiaWcgRmlsdGVyIGNvbnRlbnRzICh0aGUgdGFicylcbiAqL1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG52YXIgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ2FtcC10cmFuc2xhdGUnKTtcblxudmFyIFRvcExldmVsRmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3RvcC1sZXZlbC1maWx0ZXItdmlldycpO1xudmFyIEFsbEZpbHRlckNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9hbGwtZmlsdGVycy1jb2xsZWN0aW9uJyk7XG5cblxudmFyIFRlbXBsYXRlID0gXCI8JVxcbiAgLy8gdGhpcyByZW5kZXJzIHRoZSBcXFwiYmlnXFxcIiBmaWx0ZXIgbGlzdCAodGhlIHRhYnMpXFxuJT5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG4gIDxhIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlIGNhbmNlbFxcXCIgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9hPlxcbiAgPGgzIGRhdGEtaTE4bj1cXFwiYW1wLmdpczp0aXRsZS1maWx0ZXJzXFxcIiBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPkZpbHRlcnM8L2gzPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHkgZmlsdGVyLWJvZHlcXFwiPlxcblxcbiAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnMgZmlsdGVyLXRpdGxlc1xcXCIgcm9sZT1cXFwidGFibGlzdFxcXCI+XFxuICA8L3VsPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnQgZmlsdGVyLW9wdGlvbnNcXFwiPlxcbiAgICA8aW1nIHNyYz1cXFwiaW1nXzIvbG9hZGluZy1pY29uLmdpZlxcXCIgLz5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWZvb3RlclxcXCI+XFxuICAmbmJzcDtcXG4gIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG1hcmdpbi1ib3R0b206IDVweDtcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRhbmdlciByZXNldFxcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpidXR0b24tcmVzZXRcXFwiICB0aXRsZT1cXFwiVHVybiBvZmYgYWxsIGZpbHRlcnMuXFxcIj5SZXNldDwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLXdhcm5pbmcgY2FuY2VsXFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOmJ1dHRvbi1jYW5jZWxcXFwiICB0aXRsZT1cXFwiUmV2ZXJ0IGZpbHRlcnMgdG8gc3RhdGUgd2hlbiBvcGVuZWQuXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIGFwcGx5XFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOmJ1dHRvbi1hcHBseVxcXCIgPkFwcGx5PC9idXR0b24+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbnZhciBUaXRsZVRlbXBsYXRlID0gXCI8JVxcbi8vIHJlbmRlcnMgdGhlIHRpdGxlIG9mIGEgdGFiIFxcbiU+XFxuPGxpIGNsYXNzPVxcXCJcXFwiPjxhIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtPCU9IG5hbWUucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCIgaHJlZj1cXFwiI2ZpbHRlci1wYW5lLTwlPSBuYW1lLnJlcGxhY2UoLyAvZywnJykgJT5cXFwiIHJvbGU9XFxcInRhYlxcXCIgZGF0YS10b2dnbGU9XFxcInRhYlxcXCI+PCU9IG5hbWUgJT48L2E+PC9saT5cXG5cIjtcbnZhciBmaWx0ZXJzVmlld0xvZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9yZWFtcC90b29scy9sb2dcIikoJ2FtcDpmaWx0ZXJzOnRvcC1sZXZlbDp2aWV3Jyk7XG5cbnZhciBHZW5lcmFsU2V0dGluZ3MgPSByZXF1aXJlKCcuLi9tb2RlbHMvZ2VuZXJhbC1zZXR0aW5ncycpO1xuXG52YXIgRGF0ZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZGF0ZS11dGlscycpO1xuXG52YXIgZmlsdGVySW5zdGFuY2VzTmFtZXMgPSB7ZG9ub3JzOiAnRnVuZGluZyBPcmdhbml6YXRpb25zJywgc2VjdG9ycyA6ICdTZWN0b3JzJywgcHJvZ3JhbXM6ICdQcm9ncmFtcycsIFxuXHQgIGFjdGl2aXR5OiAnQWN0aXZpdHknLCBhbGxBZ2VuY2llczogJ0FsbCBBZ2VuY2llcycsIGZpbmFuY2lhbHM6ICdGaW5hbmNpYWwnLFxuXHRcdCAgbG9jYXRpb25zOiAnTG9jYXRpb24nLCBvdGhlcnM6ICdPdGhlcid9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBpZDogJ3Rvb2wtZmlsdGVycycsXG4gIG5hbWU6ICdGaWx0ZXJzJyxcbiAgYXBpVVJMOiAnL3Jlc3QvZmlsdGVycycsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5hcHBseSc6ICdhcHBseUZpbHRlcnMnLFxuICAgICdjbGljayAuY2FuY2VsJzogJ2NhbmNlbCcsXG4gICAgJ2NsaWNrIC5yZXNldCc6ICdyZXNldEZpbHRlcnMnXG4gIH0sXG4gIFBBUkFNU19EQVRFX0ZPUk1BVDoneXktbW0tZGQnLCAvL2JhY2tlbmQgZXhwZWN0cyBmaWx0ZXJzIHRvIGJlIHN1Ym1pdHRlZCBpbiB0aGlzIGZvcm1hdFxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kcmFnZ2FibGUgPSBvcHRpb25zLmRyYWdnYWJsZTtcbiAgICB0aGlzLmNhbGxlciA9IG9wdGlvbnMuY2FsbGVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgR2VuZXJhbFNldHRpbmdzKCk7XG4gICAgdGhpcy5zZXR0aW5ncy5mZXRjaCgpO1xuICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMgPSB7fTtcbiAgICB0aGlzLnRlbXBsYXRlID0gXy50ZW1wbGF0ZShUZW1wbGF0ZSk7XG4gICAgdGhpcy50aXRsZVRlbXBsYXRlID0gXy50ZW1wbGF0ZShUaXRsZVRlbXBsYXRlKTsgICAgXG4gICAgdGhpcy5kYXRlRm9ybWF0TWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLmRhdGVGb3JtYXRNYXBwaW5ncy5wdXNoKHthbXBmb3JtYXQ6ICdkZC9NTU0veXl5eScsIGRhdGVwaWNrZXJmb3JtYXQ6J2RkL00veXknfSk7XG4gICAgdGhpcy5kYXRlRm9ybWF0TWFwcGluZ3MucHVzaCh7YW1wZm9ybWF0OiAnTU1NL2RkL3l5eXknLCBkYXRlcGlja2VyZm9ybWF0OidNL2RkL3l5J30pO1xuICAgIHRoaXMuZGF0ZUZvcm1hdE1hcHBpbmdzLnB1c2goe2FtcGZvcm1hdDogJ2RkL01NL3l5eXknLCBkYXRlcGlja2VyZm9ybWF0OidkZC9tbS95eSd9KTtcbiAgICB0aGlzLmRhdGVGb3JtYXRNYXBwaW5ncy5wdXNoKHthbXBmb3JtYXQ6ICdNTS9kZC95eXl5JywgZGF0ZXBpY2tlcmZvcm1hdDonbW0vZGQveXknfSk7XG4gICAgXG4gICAgaWYob3B0aW9ucy50cmFuc2xhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY3JlYXRlVHJhbnNsYXRvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3I7XG4gICAgfVxuXG4gICAgdGhpcy5maXJzdFJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5fY3JlYXRlVG9wTGV2ZWxGaWx0ZXJWaWV3cygpO1xuICAgIHRoaXMuYWxsRmlsdGVycyA9IG5ldyBBbGxGaWx0ZXJDb2xsZWN0aW9uKFtdLG9wdGlvbnMpO1xuICAgIHRoaXMuX2xvYWRlZCA9ICB0aGlzLmFsbEZpbHRlcnMuX2xvYWRlZDtcbiAgICB0aGlzLl9nZXRGaWx0ZXJMaXN0KCkudGhlbihmdW5jdGlvbigpIHsgICAgXHRcbiAgICAgICAgc2VsZi5hbGxGaWx0ZXJzLmVhY2goZnVuY3Rpb24obW9kZWwpIHsgICAgICAgIFx0XG4gICAgICBcdCAgaWYobW9kZWwuZ2V0KCdlbXB0eScpKXsgICAgICBcdFx0ICAgICBcdFx0ICBcbiAgICAgIFx0XHRmb3IgKGtleSBpbiBmaWx0ZXJJbnN0YW5jZXNOYW1lcykge1xuICAgIFx0XHRcdGlmIChmaWx0ZXJJbnN0YW5jZXNOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgXHRcdFx0XHRpZihmaWx0ZXJJbnN0YW5jZXNOYW1lc1trZXldID09IG1vZGVsLmdldCgnZ3JvdXAnKSl7XG4gICAgXHRcdFx0XHRcdC8vIHJlbW92ZSB0YWIgaWYgdGhlcmUgaXMgbm8gZGF0YSBmb3IgdGhlIHRhYlxuICAgIFx0XHRcdFx0XHRkZWxldGUgZmlsdGVySW5zdGFuY2VzTmFtZXNba2V5XTtcbiAgICBcdFx0XHRcdFx0ZGVsZXRlIHNlbGYuZmlsdGVyVmlld3NJbnN0YW5jZXNba2V5XTtcbiAgICBcdFx0XHRcdH0gICAgXHRcdFx0XHRcbiAgICBcdFx0XHRcdFxuICAgIFx0XHRcdH1cbiAgICBcdFx0fSAgICAgIFx0XHRcbiAgICAgIFx0ICB9ZWxzZXtcbiAgICAgIFx0XHRzZWxmLl9jcmVhdGVGaWx0ZXJWaWV3cyhtb2RlbCk7ICBcbiAgICAgIFx0ICB9XG4gICAgICBcdCAgXG4gICAgICB9KTsgICAgICAgIFxuICAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICB9LFxuXG4gIF9jcmVhdGVUb3BMZXZlbEZpbHRlclZpZXdzOiBmdW5jdGlvbigpIHsgICAgXG4gICAgXHRcdGZvciAoa2V5IGluIGZpbHRlckluc3RhbmNlc05hbWVzKSB7XG4gICAgXHRcdFx0aWYgKGZpbHRlckluc3RhbmNlc05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBcdFx0XHRcdFxuICAgIFx0XHRcdFx0dGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlc1trZXldID0gbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTpmaWx0ZXJJbnN0YW5jZXNOYW1lc1trZXldLCB0cmFuc2xhdG9yOiB0aGlzLnRyYW5zbGF0b3IsIHRyYW5zbGF0ZTogdGhpcy50cmFuc2xhdGUsIGZpbHRlclZpZXc6IHRoaXN9KTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH0gICAgXHRcdFxuICB9LFxuXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ3BhbmVsIHBhbmVsLXByaW1hcnknKTtcbiAgICBpZiAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuJGVsLmRyYWdnYWJsZSh7Y3Vyc29yOiAnbW92ZScsIGNvbnRhaW5tZW50OiAnd2luZG93JyB9KTtcbiAgICB9XG4gICAgdGhpcy5maXJzdFJlbmRlciA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5maXJzdFJlbmRlcikge1xuICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHt9KSk7XG4gICAgICB0aGlzLiRlbC5zaG93KCk7XG5cbiAgICAgIHRoaXMuX2dldEZpbHRlckxpc3QoKS5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnJlbmRlckZpbHRlcnMoKTtcbiAgICAgICAgc2VsZi50cmFuc2xhdGUodGhpcy4kZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIGhhbmRsZSBjbGljayBvbiBhIFRhYidzIHRpdGxlOiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzLWV2ZW50c1xuICAgICAgJChkb2N1bWVudCkub24oJ3Nob3duLmJzLnRhYiBjbGljaycsIFwidWwubmF2LmZpbHRlci10aXRsZXM+bGk+YVtkYXRhLXRvZ2dsZT0ndGFiJ11cIiwgZnVuY3Rpb24gKGUpIHsgIC8vIDwtIHRoaXMgbGluZSBtYWtlcyBsaXR0bGUgc2Vuc2UgYnV0IHdvcmtzIGluIFNhaWt1L1RhYnMgYWxzb1xuICAgICAgICAvL3RoaXMuJGVsLmZpbmQoXCJ1bC5uYXYuZmlsdGVyLXRpdGxlcz5saT5hW2RhdGEtdG9nZ2xlPSd0YWInXVwiKS5vbignc2hvd24uYnMudGFiJywgZnVuY3Rpb24gKGUpIHsgICAvLyA8LSB0aGlzIGxpbmUgd29ya3MgaW4gYW55dGhpbmcgZXhjZXB0IFNhaWt1L1RhYnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSAnY2xpY2snIGV2ZW50IGFkZGVkIGJlY2F1c2UgKHdlaXJkbHkpIHRoZSBzaG93bi5icy50YWIgZXZlbnQgbm90IGJlaW5nIGZpcmVkIEFUIEFMTCB1bmRlciBTYWlrdS9UYWJzLiBVbnRpbCB0aGlzIGlzIGludmVzdGlnYXRlZFxuICAgICAgICAgKiBvbiBHSVMvRGFzaGJvYXJkIHRhYnMgdGhpcyBzZWNvbmQgZXZlbnQgaXMgc3VwZXJmbHVvdXNcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGFjdGl2ZVRhYiA9ICQoZS50YXJnZXQucGFyZW50RWxlbWVudCkuaW5kZXgoKTsgLy8gc2hhbWVmdWwgaGFjaywgYnV0IGhhdmVuJ3QgYmVlbiBhYmxlIHRvIGZpbmQgYSBjbGVhbmVyIHNvbHV0aW9uXG4gICAgICAgIHZhciBvbGRUYWJOciA9IGUucmVsYXRlZFRhcmdldCA/ICQoZS5yZWxhdGVkVGFyZ2V0LnBhcmVudEVsZW1lbnQpLmluZGV4KCkgOiAtMTtcbiAgICAgICAgZmlsdGVyc1ZpZXdMb2cubG9nKCdzd2l0Y2hpbmcgZnJvbSBmaWx0ZXJzIHRhYicsIG9sZFRhYk5yLCAndG8gdGFiJywgYWN0aXZlVGFiKTtcbiAgICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgndWwuZmlsdGVyLXRpdGxlcycpLmF0dHIoJ2FjdGl2ZS10YWItbnVtYmVyJywgYWN0aXZlVGFiKTsgLy8gbm90IHVzZWQgaW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNvZGVcblxuICAgICAgICAvLyByZW5kZXIgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHRhYlxuICAgICAgICB2YXIgdGFiSWQgPSAkKGUudGFyZ2V0KS5hdHRyKCdocmVmJyk7XG4gICAgICAgIHZhciB0YWJGaXJzdENoaWxkID0gJCh0YWJJZCkuZmluZCgndWwuc3ViLWZpbHRlcnMtdGl0bGVzPmxpOmZpcnN0IGEnKTtcbiAgICAgICAgaWYgKHRhYkZpcnN0Q2hpbGQpXG4gICAgICAgICAgdGFiRmlyc3RDaGlsZC5jbGljaygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZmlyc3RSZW5kZXIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi50cmFuc2xhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjcmVhdGVUcmFuc2xhdG9yOiBmdW5jdGlvbihmb3JjZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmlsdGVyVHJhbnNsYXRlS2V5cyA9IEpTT04ucGFyc2UoXCJ7XFxuICBcXFwiYW1wLmdpczp0aXRsZS1Db3VudHJ5XFxcIjogXFxcIkNvdW50cnlcXFwiLFxcbiAgXFxcImFtcC5naXM6dGl0bGUtUmVnaW9uXFxcIjogXFxcIlJlZ2lvblxcXCIsXFxuICBcXFwiYW1wLmdpczp0aXRsZS1ab25lXFxcIjogXFxcIlpvbmVcXFwiLFxcbiAgXFxcImFtcC5naXM6dGl0bGUtRGlzdHJpY3RcXFwiOiBcXFwiRGlzdHJpY3RcXFwiLFxcbiAgXFxcImFtcC5naXM6dGl0bGUtZmlsdGVyc1xcXCI6IFxcXCJGaWx0ZXJcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLXNlYXJjaFxcXCI6IFxcXCJHb1xcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtc2VsZWN0XFxcIjogXFxcInNlbGVjdCBhbGxcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLWRlc2VsZWN0XFxcIjogXFxcImRlc2VsZWN0IGFsbFxcXCIsXFxuICBcXFwiW3BsYWNlaG9sZGVyXWFtcC5naXM6cGFuZS1maWx0ZXJzLXNlYXJjaC1wbGFjZWhvbGRlclxcXCI6IFxcXCJTZWFyY2guLi5cXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLUZ1bmRpbmdPcmdhbml6YXRpb25zXFxcIjogXFxcIkZ1bmRpbmcgT3JnYW5pemF0aW9uc1xcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtU2VjdG9yXFxcIjogXFxcIlNlY3RvclxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtU2VjdG9yc1xcXCI6IFxcXCJTZWN0b3JzXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1Qcm9ncmFtc1xcXCI6IFxcXCJQcm9ncmFtc1xcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtQWN0aXZpdHlcXFwiOiBcXFwiQWN0aXZpdHlcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLUFsbEFnZW5jaWVzXFxcIjogXFxcIkFsbCBBZ2VuY2llc1xcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtRmluYW5jaWFsXFxcIjogXFxcIkZpbmFuY2lhbFxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtTG9jYXRpb25cXFwiOiBcXFwiTG9jYXRpb25cXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLU90aGVyXFxcIjogXFxcIk90aGVyXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1Eb25vclxcXCI6IFxcXCJEb25vclxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtUHJpbWFyeVxcXCI6IFxcXCJQcmltYXJ5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1TZWNvbmRhcnlcXFwiOiBcXFwiU2Vjb25kYXJ5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1OYXRpb25hbFBsYW5PYmplY3RpdmVcXFwiOiBcXFwiTmF0aW9uYWwgUGxhbiBPYmplY3RpdmVcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUFjdGl2aXR5U3RhdHVzXFxcIjogXFxcIkFjdGl2aXR5IFN0YXR1c1xcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtQXBwcm92YWxTdGF0dXNcXFwiOiBcXFwiQXBwcm92YWwgU3RhdHVzXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1JbXBsZW1lbnRpbmdBZ2VuY3lcXFwiOiBcXFwiSW1wbGVtZW50aW5nIEFnZW5jeVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtRXhlY3V0aW5nQWdlbmN5XFxcIjogXFxcIkV4ZWN1dGluZyBBZ2VuY3lcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUJlbmVmaWNpYXJ5QWdlbmN5XFxcIjogXFxcIkJlbmVmaWNpYXJ5IEFnZW5jeVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtQ29udHJhY3RpbmdBZ2VuY3lcXFwiOiBcXFwiQ29udHJhY3RpbmcgQWdlbmN5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1BaWRNb2RhbGl0eVxcXCI6IFxcXCJBaWQgTW9kYWxpdHlcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVR5cGVPZkFzc2lzdGFuY2VcXFwiOiBcXFwiVHlwZSBPZiBBc3Npc3RhbmNlXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1SZXNwb25zaWJsZU9yZ2FuaXphdGlvblxcXCI6IFxcXCJSZXNwb25zaWJsZSBPcmdhbml6YXRpb25cXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUNvbXBvbmVudEZ1bmRpbmdPcmdhbml6YXRpb25cXFwiOiBcXFwiQ29tcG9uZW50IEZ1bmRpbmcgT3JnYW5pemF0aW9uXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1Db21wb25lbnRTZWNvbmRSZXNwb25zaWJsZU9yZ2FuaXphdGlvblxcXCI6IFxcXCJDb21wb25lbnQgU2Vjb25kIFJlc3BvbnNpYmxlIE9yZ2FuaXphdGlvblxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtRGF0ZXNcXFwiOiBcXFwiRGF0ZXNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVJlZ2lvbmFsR3JvdXBcXFwiOiBcXFwiUmVnaW9uYWwgR3JvdXBcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVNlY3Rvckdyb3VwXFxcIjogXFxcIlNlY3RvciBHcm91cFxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtVGVydGlhcnlTZWN0b3JzXFxcIjogXFxcIlRlcnRpYXJ5IFNlY3RvcnNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUZpbmFuY2luZ0luc3RydW1lbnRzXFxcIjogXFxcIkZpbmFuY2luZyBJbnN0cnVtZW50c1xcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtYWxsXFxcIjogXFxcImFsbFxcXCIsXFxuICBcXFwiYW1wLmdpczpidXR0b24tcmVzZXRcXFwiOiBcXFwiUmVzZXRcXFwiLFxcbiAgXFxcImFtcC5naXM6YnV0dG9uLWNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgXFxcImFtcC5naXM6YnV0dG9uLWFwcGx5XFxcIjogXFxcIkFwcGx5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1zdGFydGRhdGVcXFwiOiBcXFwiU3RhcnQgRGF0ZTpcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLWVuZGRhdGVcXFwiOiBcXFwiRW5kIERhdGU6XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1lbXB0eVxcXCI6IFxcXCJObyBkYXRhIGZvciB0aGlzIGZpbHRlclxcXCIsXFxuICBcXFwiYW1wLmdpczpkYXRlLWZyb21cXFwiOiBcXFwiRnJvbVxcXCIsXFxuICBcXFwiYW1wLmdpczpkYXRlLXVudGlsXFxcIjogXFxcIlVudGlsXFxcIlxcbn1cXG5cIik7XG4gICAgLy8gc2V0dXAgYW55IHBvcG92ZXJzIGFzIG5lZWRlZC4uLlxuICAgIHNlbGYucG9wb3ZlcnMgPSBzZWxmLiQoJ1tkYXRhLXRvZ2dsZT1cInBvcG92ZXJcIl0nKTtcbiAgICBzZWxmLnBvcG92ZXJzLnBvcG92ZXIoKTtcbiAgICBpZiAoZm9yY2UgPT09IHRydWUgfHwgc2VsZi50cmFuc2xhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbHRlcnNWaWV3TG9nLm9uRGVidWcoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZpbHRlcnNWaWV3TG9nLmxvZygnQ3JlYXRpbmcgdHJhbnNsYXRvciBmb3IgZmlsdGVycyBiZWNhdXNlJywgZm9yY2UgPT09IHRydWUgPyAnSSB3YXMgZm9yY2VkJyA6ICd0aGVyZSBpcyBubyB0cmFuc2xhdG9yJyk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHtkZWZhdWx0S2V5czogZmlsdGVyVHJhbnNsYXRlS2V5c30pO1xuICAgIH1cbiAgfSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcztcbiAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVET00oZWxlbWVudC5lbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVET00oZWxlbWVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiByZW5kZXJzIHRoZSB0YWJzIHdpdGhpbiB0aGUgZmlsdGVycywgb25seSByZW5kZXJpbmcgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIGFjdGl2ZSB0YWIgKHRoZSBvdGhlcnMgZG9uJ3QgaGF2ZSB0aGVpciBmaXJzdCBpdGVtJ3MgY29udGVudHMgcmVuZGVyZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpXG4gICAqL1xuICByZW5kZXJGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoJy5maWx0ZXItb3B0aW9ucycpLmh0bWwoJycpO1xuXG4gICAgdmFyIHJlbmRlcmluZ1RpdGxlTnVtYmVyID0gLTE7XG4gICAgdmFyIGFjdGl2ZVRpdGxlTnVtYmVyID0gdGhpcy4kKCcuZmlsdGVyLXRpdGxlcycpLmF0dHIoJ2FjdGl2ZS10YWItbnVtYmVyJykgfHwgMDtcblxuICAgIGZvciAodmFyIGZpbHRlclZpZXcgaW4gdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlcykge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoZmlsdGVyVmlldykpIHtcbiAgICBcdCAgY29udGFpbmVkID0gZmFsc2U7XG4gICAgXHQgIHZhciBpbmRleDtcbiAgICBcdCAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5hbGxGaWx0ZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIFx0XHQgIGlmICgodGhpcy5hbGxGaWx0ZXJzLm1vZGVsc1tpbmRleF0uYXR0cmlidXRlcy50YWIgPT09IHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXNbZmlsdGVyVmlld10ubmFtZSkgfHwgXG4gICAgXHRcdCAgKHRoaXMuYWxsRmlsdGVycy5tb2RlbHNbaW5kZXhdLmF0dHJpYnV0ZXMuZ3JvdXAgPT09IHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXNbZmlsdGVyVmlld10ubmFtZSkpe1xuICAgIFx0XHRcdCAgY29udGFpbmVkID0gdHJ1ZTtcbiAgICBcdFx0XHQgIGJyZWFrO1xuICAgIFx0XHQgIH0gXG4gICAgXHQgIH1cbiAgICBcdCAgaWYgKCFjb250YWluZWQpIHtcbiAgICBcdFx0ICBkZWxldGUgdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlc1tmaWx0ZXJWaWV3XTtcbiAgICBcdFx0ICBjb250aW51ZTtcbiAgICBcdCAgfVxuICAgIFx0XHQgIFxuICAgICAgICB2YXIgdG1wRmlsdGVyVmlldyA9IHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXNbZmlsdGVyVmlld107XG4gICAgICAgIHJlbmRlcmluZ1RpdGxlTnVtYmVyID0gcmVuZGVyaW5nVGl0bGVOdW1iZXIgKyAxO1xuICAgICAgICB0aGlzLiQoJy5maWx0ZXItdGl0bGVzJykuYXBwZW5kKHRtcEZpbHRlclZpZXcucmVuZGVyVGl0bGUoKS50aXRsZUVsKTtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IHJlbmRlcmluZ1RpdGxlTnVtYmVyID09IGFjdGl2ZVRpdGxlTnVtYmVyO1xuICAgICAgICB0aGlzLiQoJy5maWx0ZXItb3B0aW9ucycpLmFwcGVuZCh0bXBGaWx0ZXJWaWV3LnJlbmRlckZpbHRlcnMoYWN0aXZlKS5lbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3BlbnMgdGhlIGZpcnN0IHRhYiBpbiB0aGUgZmlsdGVyXG4gICAgdGhpcy4kKCcuZmlsdGVyLXRpdGxlcyBhOmZpcnN0JykudGFiKCdzaG93Jyk7XG4gIH0sXG5cblxuICBfZ2V0RmlsdGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsRmlsdGVycy5sb2FkKCk7XG4gIH0sXG5cbiAgX2NyZWF0ZUZpbHRlclZpZXdzOiBmdW5jdGlvbih0bXBNb2RlbCkge1xuICAgIC8vIFRPRE86IG1hZ2ljIHN0cmluZ3MgYXJlIGRhbmdlcm91cywgY29uZmlnIHNvbWV3aGVyZS4uLlxuXHRzd2l0Y2ggKHRtcE1vZGVsLmdldCgnZ3JvdXAnKSkge1xuICAgICAgY2FzZSAnQWN0aXZpdHlCdWRnZXRMaXN0JzpcbiAgICAgIGNhc2UgJ3R5cGUtb2YtYXNzaXN0YW5jZSc6XG4gICAgICBjYXNlICdtb2RlLW9mLXBheW1lbnQnOlxuICAgICAgY2FzZSAnZXhwZW5kaXR1cmUtY2xhc3MnOlxuICAgICAgY2FzZSAnZmluYW5jaW5nLWluc3RydW1lbnQnOlxuICAgICAgY2FzZSAnZnVuZGluZy1zdGF0dXMnOlxuICAgICAgY2FzZSAnZWZmZWN0aXZlLWZ1bmRpbmctZGF0ZSc6XG4gICAgICBjYXNlICdmdW5kaW5nLWNsb3NpbmctZGF0ZSc6XG4gICAgICBjYXNlICdjb25jZXNzaW9uYWxpdHktbGV2ZWwnOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLmZpbmFuY2lhbHMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICBjYXNlICdwZXJmb3JtYW5jZS1hbGVydC1sZXZlbCc6XG4gICAgICBjYXNlICdhcHByb3ZhbC1zdGF0dXMnOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLmFjdGl2aXR5LmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQcm9ncmFtcyc6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMucHJvZ3JhbXMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1NlY3RvcnMnOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLnNlY3RvcnMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Rvbm9yJzpcbiAgICAgICAgdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlcy5kb25vcnMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1JvbGUnOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLmFsbEFnZW5jaWVzLmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb2NhdGlvbic6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMubG9jYXRpb25zLmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLm90aGVycy5maWx0ZXJDb2xsZWN0aW9uLmFkZCh0bXBNb2RlbCk7XG4gICAgfVxuXG4gIH0sXG4gIFxuICBzZXJpYWxpemVUb01vZGVsczogZnVuY3Rpb24oZmlsdGVyKSB7XG5cdCAgdmFyIF9zZWxmID0gdGhpcztcblx0ICBfc2VsZi52YWx1ZXMgPSB7MDogW10sIDE6IFtdLCAyOiBbXSwgMzogW119OyAvL1RPRE86IEltcGxlbWVudCBjYWxjdWxhdGVGaWx0ZXJEZXB0KCkgZnVuY3Rpb24uXG5cdCAgaWYgKGZpbHRlci5nZXQoJ3RyZWUnKSkge1xuXHRcdCAgdmFyIGVudHJ5UG9pbnQgPSBmaWx0ZXIuZ2V0KCd0cmVlJykuZ2V0KCdjaGlsZHJlbicpO1xuXHRcdCAgdmFyIGN1cnJlbnRMZXZlbCA9IDA7XG5cdFx0ICBpZiAoZmlsdGVyLmdldCgnbnVtU2VsZWN0ZWQnKSAhPT0gZmlsdGVyLmdldCgnbnVtUG9zc2libGUnKSkge1xuXHRcdFx0ICBfLmVhY2goZW50cnlQb2ludC5tb2RlbHMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0ICBfc2VsZi5zZXJpYWxpemVMZXZlbChpdGVtLCAwLCBfc2VsZi52YWx1ZXMpO1xuXHRcdFx0ICB9KTtcblx0XHQgIH1cblx0ICB9IGVsc2Uge1xuXHRcdCAgX3NlbGYudmFsdWVzID0gZmlsdGVyO1xuXHQgIH1cblx0ICByZXR1cm4gX3NlbGYudmFsdWVzO1xuICB9LFxuICAgIFxuICBzZXJpYWxpemVMZXZlbDogZnVuY3Rpb24obm9kZSwgbGV2ZWwsIHZhbHVlcykge1xuXHQvLyBXaGVuIHdlIGVudGVyIGhlcmUgaXQgbWVhbnMgdGhlIHBhcmVudCBpcyBub3QgJ2Z1bGx5IHNlbGVjdGVkJy5cblx0ICB2YXIgX3NlbGYgPSB0aGlzO1xuXHQgIGlmIChub2RlLmdldCgnY2hpbGRyZW4nKS5tb2RlbHMubGVuZ3RoID4gMCkge1xuXHRcdCAgLy8gXCJEb3VibGUgY2hlY2tcIiBiZWNhdXNlIHNvbWUgc2VsZWN0ZWQgbWlkZGxlIG5vZGVzIGhhdmUgZ2V0KCdzZWxlY3RlZCcpID09PSBmYWxzZS4gXG5cdFx0ICBpZiAobm9kZS5nZXQoJ251bVNlbGVjdGVkJykgIT09IG5vZGUuZ2V0KCdudW1Qb3NzaWJsZScpICYmIG5vZGUuZ2V0KCdzZWxlY3RlZCcpID09PSBmYWxzZSkge1xuXHRcdFx0ICBfLmVhY2gobm9kZS5nZXQoJ2NoaWxkcmVuJykubW9kZWxzLCBmdW5jdGlvbihub2RlMikge1x0XHRcdFx0ICBcblx0XHRcdFx0ICBfc2VsZi5zZXJpYWxpemVMZXZlbChub2RlMiwgbGV2ZWwgKyAxLCB2YWx1ZXMpO1xuXHRcdFx0ICB9KTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHQgIGlmICh2YWx1ZXNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ICB2YWx1ZXMgPDwgW107XG5cdFx0XHQgIH1cblx0XHRcdCAgdmFsdWVzW2xldmVsXS5wdXNoKHsnbGV2ZWwnOiBsZXZlbCwgJ2xldmVsTmFtZSc6IG5vZGUuZ2V0KCdmaWx0ZXJJZCcpLCBuYW1lOiBub2RlLmdldCgnbmFtZScpfSk7XG5cdFx0ICB9XG5cdCAgfSBlbHNlIHsgLy8gV2UgcmVhY2hlZCB0aGUgbGFzdCBsZXZlbC4uXG5cdFx0ICBpZiAobm9kZS5nZXQoJ3NlbGVjdGVkJykgPT09IHRydWUpIHtcblx0XHRcdCAgaWYgKHZhbHVlc1tsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQgIHZhbHVlcyA8PCBbXTtcblx0XHRcdCAgfVxuXHRcdFx0ICB2YWx1ZXNbbGV2ZWxdLnB1c2goeydsZXZlbCc6IGxldmVsLCAnbGV2ZWxOYW1lJzogbm9kZS5nZXQoJ2ZpbHRlcklkJyksIG5hbWU6IG5vZGUuZ2V0KCduYW1lJyl9KTtcblx0XHQgIH1cblx0ICB9XHQgIFxuICB9LFxuICBcbiAgLy9UT0RPOiBtb3ZlIGZyb20gdmlldyB0byBhbGwtY29sbGVjdGlvblxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNlcmlhbGl6ZWRGaWx0ZXJzID0ge2ZpbHRlcnM6e319O1xuXG4gICAgdGhpcy5hbGxGaWx0ZXJzLmVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAvLyBUT0RPOiBidWlsZCBhIHV0aWwgZm9yIGJldHRlcm1lcmdlIHRoYXQgY29uY2F0J3MgYXJyYXkgaWZcbiAgICAgIC8vIGR1cGxpY2F0ZSBrZXlzIGluIG9iamVjdHMuLi5cbiAgICAgIGlmIChmaWx0ZXIuZ2V0KCdpZCcpIHx8IGZpbHRlci51cmwpIHtcbiAgICAgICAgaWYgKGZpbHRlci5nZXQoJ21vZGVsVHlwZScpID09PSAnREFURS1SQU5HRS1WQUxVRVMnIHx8IGZpbHRlci5nZXQoJ21vZGVsVHlwZScpID09PSAnWUVBUi1TSU5HTEUtVkFMVUUnKSB7XG4gICAgICAgICAgXy5leHRlbmQoc2VyaWFsaXplZEZpbHRlcnMuZmlsdGVycywgZmlsdGVyLnNlcmlhbGl6ZShvcHRpb25zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBmaWx0ZXIuc2VyaWFsaXplKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndob2xlTW9kZWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IodmFyIGsgaW4gc2VyaWFsaXplZCkga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgaWYgKGtleXNbMF0gIT09IHVuZGVmaW5lZCAmJiBzZXJpYWxpemVkW2tleXNbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2VyaWFsaXplZFtrZXlzWzBdXS5maWx0ZXJOYW1lID0gKGZpbHRlci5nZXQoJ2Rpc3BsYXlOYW1lJykgfHwgZmlsdGVyLmdldCgnbmFtZScpKTtcbiAgICAgICAgICAgICAgc2VyaWFsaXplZFtrZXlzWzBdXS5zZXJpYWxpemVkVG9Nb2RlbHMgPSBzZWxmLnNlcmlhbGl6ZVRvTW9kZWxzKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF8uZXh0ZW5kKHNlcmlhbGl6ZWRGaWx0ZXJzLmZpbHRlcnMsIHNlcmlhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBlbXB0eSAvIGZhbHNlIHZhbHVlcy5cbiAgICBfLmVhY2goc2VyaWFsaXplZEZpbHRlcnMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgIGlmKCF2IHx8IF8uaXNFbXB0eSh2KSkge1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZEZpbHRlcnMuZmlsdGVyc1trXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzZXJpYWxpemVkRmlsdGVycztcbiAgfSxcbiBkZXNlcmlhbGl6ZTogZnVuY3Rpb24oZmlsdGVyc09iamVjdCwgb3B0aW9ucykge1xuXHR2YXIgYmxvYiA9IGZpbHRlcnNPYmplY3QuZmlsdGVycyB8fCB7fTtcbiAgICBpZiAoYmxvYikge1xuICAgICAgaWYoXy5pc1VuZGVmaW5lZCh0aGlzLmluaXRpYWxGaWx0ZXJzKSl7XG4gICAgXHQgIHRoaXMuaW5pdGlhbEZpbHRlcnMgPSBibG9iO1xuICAgICAgfSAgICAgXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGF0LmFsbEZpbHRlcnMuZWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICBcdGZpbHRlci5yZXNldCgpO1xuICAgICAgICBpZiAoZmlsdGVyLmdldCgnaWQnKSB8fCBmaWx0ZXIudXJsKSB7XG4gICAgICAgICAgaWYoZmlsdGVyLmdldCgnbW9kZWxUeXBlJykgPT09ICdEQVRFLVJBTkdFLVZBTFVFUycpIHtcbiAgICAgICAgIFx0dGhhdC5zZXREZWZhdWx0RGF0ZXMoYmxvYik7ICAgICAgICAgICAgXG4gICAgICAgICAgICBmaWx0ZXIuZGVzZXJpYWxpemUoYmxvYik7XG4gICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgZmlsdGVyLmRlc2VyaWFsaXplKGJsb2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignY291bGQgbm90IGRlc2VyaWFsaXplIGJsb2I6JywgYmxvYik7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXJzKCk7ICAvLyB0cmlnZ2VycyB0aGUgXCJhcHBseVwiIGV2ZW50XG4gICAgfVxuICB9LFxuXG4gIHNob3dGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHRoaXMuZmlsdGVyU3Rhc2ggPSBudWxsOyAgLy8gaW4gY2FzZSB0aGV5IGhhdmVuJ3QgbG9hZGVkIHlldCwgZG9uJ3QgdHJ5IHRvIC5zZXJpYWxpemUoKVxuICAgIHRoaXMuX2xvYWRlZC5kb25lKF8uYmluZChmdW5jdGlvbigpIHsgdGhpcy5maWx0ZXJTdGFzaCA9IHRoaXMuc2VyaWFsaXplKHt9KTsgfSwgdGhpcykpO1xuICB9LFxuXG4gIHNldFN0YXNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpbHRlclN0YXNoID0gbnVsbDsgIC8vIGluIGNhc2UgdGhleSBoYXZlbid0IGxvYWRlZCB5ZXQsIGRvbid0IHRyeSB0byAuc2VyaWFsaXplKClcbiAgICB0aGlzLl9sb2FkZWQuZG9uZShfLmJpbmQoZnVuY3Rpb24oKSB7IHRoaXMuZmlsdGVyU3Rhc2ggPSB0aGlzLnNlcmlhbGl6ZSh7fSk7IH0sIHRoaXMpKTtcbiAgfSxcblxuICByZXNldEZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdCB2YXIgYmxvYiA9ICFfLmlzVW5kZWZpbmVkKHRoaXMuaW5pdGlhbEZpbHRlcnMpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxGaWx0ZXJzKSkgOiB7fTsvL2Nsb25lIGluaXRpYWwgZmlsdGVyc1xuICAgIHRoaXMuYWxsRmlsdGVycy5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuZ2V0KCdtb2RlbFR5cGUnKSA9PT0gJ0RBVEUtUkFOR0UtVkFMVUVTJykge1xuICAgIFx0IHNlbGYuc2V0RGVmYXVsdERhdGVzKGJsb2IpOyAgICAgICAgICBcdCBcbiAgICBcdCBmaWx0ZXIuZGVzZXJpYWxpemUoYmxvYik7XG4gICAgIH1lbHNle1xuICAgIFx0IGZpbHRlci5yZXNldCgpO1xuICAgICB9ICAgICAgXG4gICAgfSk7XG4gIH0sXG5cbiAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9sb2FkZWQuZG9uZShfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnNlcmlhbGl6ZSh7fSk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2FwcGx5Jywgc3RhdGUpO1xuICAgIH0sIHRoaXMpKTtcbiAgfSxcblxuICBnZXREYXRlRm9ybWF0OiBmdW5jdGlvbigpe1xuXHQgIGlmKHRoaXMuZEZvcm1hdCl7XG5cdFx0ICByZXR1cm4gdGhpcy5kRm9ybWF0O1xuXHQgIH1cdFxuXHQgIFxuXHQgIHZhciBkYXRlRm9ybWF0U2V0dGluZyA9IHRoaXMuc2V0dGluZ3MuZ2V0KCdkZWZhdWx0LWRhdGUtZm9ybWF0Jyk7XG5cdCAgaWYoZGF0ZUZvcm1hdFNldHRpbmcpe1x0XHRcdFxuXHRcdFx0dmFyIGZvdW5kTWFwcGluZyA9Xy5maW5kV2hlcmUodGhpcy5kYXRlRm9ybWF0TWFwcGluZ3MsIHthbXBmb3JtYXQ6IGRhdGVGb3JtYXRTZXR0aW5nfSk7XG5cdFx0XHRpZihmb3VuZE1hcHBpbmcpe1xuXHRcdFx0XHR0aGlzLmRGb3JtYXQgPSBmb3VuZE1hcHBpbmcuZGF0ZXBpY2tlcmZvcm1hdDtcblx0XHRcdH1cblx0ICB9XHQgIFxuXHQgIGlmKCF0aGlzLmRGb3JtYXQpe1xuXHRcdCAgdGhpcy5kRm9ybWF0ID0gdGhpcy5QQVJBTVNfREFURV9GT1JNQVQ7XG5cdCAgfVx0ICBcblx0ICByZXR1cm4gdGhpcy5kRm9ybWF0O1xuICAgfSxcbiAgXG4gICBmb3JtYXREYXRlOiBmdW5jdGlvbihkYXRlKXtcblx0ICAgcmV0dXJuICQuZGF0ZXBpY2tlci5mb3JtYXREYXRlKHRoaXMuZ2V0RGF0ZUZvcm1hdCgpLCAoJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSh0aGlzLlBBUkFNU19EQVRFX0ZPUk1BVCxkYXRlKSkpO1xuICAgfSwgXG4gICBzZXREZWZhdWx0RGF0ZXM6IGZ1bmN0aW9uKGJsb2Ipe1xuXHQgdmFyIHNlbGYgPSB0aGlzO1xuICBcdCBpZihzZWxmLmNhbGxlciA9PT0gXCJEQVNIQk9BUkRcIil7XG4gIFx0XHQgcmV0dXJuIERhdGVVdGlscy5leHRyYWN0RGF0ZXMoc2VsZi5zZXR0aW5ncywgYmxvYiwgJ2Rhc2hib2FyZC1kZWZhdWx0LW1pbi1kYXRlJywgJ2Rhc2hib2FyZC1kZWZhdWx0LW1heC1kYXRlJyk7IFx0IFxuICBcdCB9ZWxzZSBpZihzZWxmLmNhbGxlciA9PT0gXCJHSVNcIil7XG4gIFx0XHRyZXR1cm4gRGF0ZVV0aWxzLmV4dHJhY3REYXRlcyhzZWxmLnNldHRpbmdzLCBibG9iLCAnZ2lzLWRlZmF1bHQtbWluLWRhdGUnLCAnZ2lzLWRlZmF1bHQtbWF4LWRhdGUnKTtcbiAgXHQgfVxuICBcdCByZXR1cm4gYmxvYlxuICAgfSxcbiAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0aWYodGhpcy5maWx0ZXJTdGFzaCl7ICAgIFx0XG4gICAgICB0aGlzLmRlc2VyaWFsaXplKHRoaXMuZmlsdGVyU3Rhc2gsIHtzaWxlbnQ6IHRydWV9KTtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdjYW5jZWwnLCB0aGlzLmZpbHRlclN0YXNoKTtcbiAgfVxufSk7XG5cbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8vIHZhciBHZW5lcmljRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvZ2VuZXJpYy1maWx0ZXItbW9kZWwnKTtcbnZhciBUcmVlTm9kZVZpZXcgPSByZXF1aXJlKCcuLi90cmVlL3RyZWUtbm9kZS12aWV3Jyk7XG52YXIgQmFzZUZpbHRlclZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy9iYXNlLWZpbHRlci12aWV3Jyk7XG52YXIgVGVtcGxhdGUgPSBcIjwlIGlmICghZW1wdHkpIHsgJT5cXG5cXHQ8ZGl2IGNsYXNzPVxcXCJzZWFyY2gtZm9ybVxcXCI+XFxuXFx0ICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cCBmb3JtLWdyb3VwXFxcIj5cXG5cXHQgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGRhdGEtaTE4bj1cXFwiW3BsYWNlaG9sZGVyXWFtcC5naXM6cGFuZS1maWx0ZXJzLXNlYXJjaC1wbGFjZWhvbGRlclxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBzZWFyY2gtdGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIlNlYXJjaC4uLlxcXCI+XFxuXFx0ICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcblxcdCAgICAgIDxidXR0b24gZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1zZWFyY2hcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3NcXFwiPkdvPC9idXR0b24+XFxuXFx0ICAgIDwvc3Bhbj5cXG5cXHQgIDwvZGl2PjwhLS0gL2lucHV0LWdyb3VwIC0tPlxcblxcdDwvZGl2PlxcblxcdDxkaXYgY2xhc3M9XFxcInRvZ2dsZS1hbGxcXFwiPlxcblxcdCAgPGVtPlxcblxcdCAgICA8YSBocmVmPVxcXCIjXFxcIiBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLXNlbGVjdFxcXCIgY2xhc3M9XFxcInNlbGVjdC1hbGxcXFwiID5zZWxlY3QgYWxsPC9hPiAvXFxuXFx0ICAgIDxhIGhyZWY9XFxcIiNcXFwiICBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLWRlc2VsZWN0XFxcIiBjbGFzcz1cXFwic2VsZWN0LW5vbmVcXFwiID5kZXNlbGVjdCBhbGw8L2E+XFxuXFx0ICA8L2VtPlxcblxcdDwvZGl2PlxcblxcdFxcblxcdDxkaXYgY2xhc3M9XFxcInRyZWUgdHJlZS1jb250YWluZXJcXFwiIHN0eWxlPVxcXCJcXFwiPjwvZGl2PjwhLS1kaXNwbGF5Om5vbmU7LS0+XFxuPCUgfSBlbHNlIHsgJT5cXG5cXHQ8c3BhbiBkYXRhLWkxOG49J2FtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLWVtcHR5Jz48L3NwYW4+XFxuPCUgfSAlPlxcblwiO1xuXG5cbi8vIFRoaXMgaXMgYSBnZW5lcmljIG1vZGVsIGZvciBmaWx0ZXJzLiBJdCBhc3N1bWVzIGEgdHJlZSBzdHJ1Y3R1cmUuXG4vLyBJZiB5b3UgZG9uJ3Qgd2FudCBhIHRyZWUgc3RydWN0dXJlIGp1c3QgZXh0ZW5kIGJhc2UtZmlsdGVyXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VGaWx0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lICsgJyBmaWx0ZXItZ2VuZXJpYycsXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKFRlbXBsYXRlKSxcbiAgX2xvYWRlZDogbnVsbCxcblxuICBldmVudHM6e1xuICB9LFxuXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuXG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gb3B0aW9ucy50cmFuc2xhdG9yO1xuICAgIHRoaXMudHJhbnNsYXRlID0gb3B0aW9ucy50cmFuc2xhdGU7XG4gICAgdGhpcy50cmVlVmlldyA9IG5ldyBUcmVlTm9kZVZpZXcoe2lzUm9vdDp0cnVlfSk7XG5cbiAgICAvLyBDcmVhdGUgdHJlZSB2aWV3XG4gICAgLy8gVE9ETzogbWFrZSB0cmVlIGxvYWRpbmcgY29udGVudCByZXNwb25zaWJpbGl0eSBvZiBtb2RlbCwgbm90IHZpZXcuLi5cbiAgICB0aGlzLm1vZGVsLmdldFRyZWUoKS50aGVuKGZ1bmN0aW9uKHRyZWVNb2RlbCkge1xuICAgICAgaWYgKHRyZWVNb2RlbCkge1xuICAgICAgICBzZWxmLl91cGRhdGVDb3VudEluTWVudSgpO1xuICAgICAgICB0cmVlTW9kZWwub24oJ2NoYW5nZTpudW1TZWxlY3RlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvdW50SW5NZW51KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdubyB0cmVlIGZvcjogJywgc2VsZi5tb2RlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgc2VhcmNoS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzIHx8IC8vIFByZXNzZWQgJ2VudGVyJ1xuICAgICAgdGhpcy4kKCcuc2VhcmNoLXRleHQnKS52YWwoKSA9PT0gJycgfHxcbiAgICAgIHRoaXMuJCgnLnNlYXJjaC10ZXh0JykudmFsKCkubGVuZ3RoID4gMVxuICAgICAgKSB7XG4gICAgICB0aGlzLm1vZGVsLmdldCgndHJlZScpLmZpbHRlclRleHQodGhpcy4kKCcuc2VhcmNoLXRleHQnKS52YWwoKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH0sXG5cblxuICBfdXBkYXRlQ291bnRJbk1lbnU6ZnVuY3Rpb24oKSB7XHRcbiAgICBpZiAodGhpcy4kdGl0bGVFbCAmJiB0aGlzLm1vZGVsLmdldCgndHJlZScpKSB7XG4gICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5nZXQoJ251bVNlbGVjdGVkJykgPT09IHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuZ2V0KCdudW1Qb3NzaWJsZScpIHx8XG4gICAgICAgICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5nZXQoJ251bVNlbGVjdGVkJykgPT09IDApIHsgICAgXHQgIFxuICAgIFx0ICB0aGlzLiR0aXRsZUVsLmZpbmQoJy5maWx0ZXItY291bnQnKS5hdHRyKCdkYXRhLWkxOG4nLCdhbXAuZ2lzOnBhbmUtZmlsdGVycy1hbGwnKTtcbiAgICBcdCAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpOyAgICAgXHQgIFxuICAgIFx0ICB0aGlzLnRyYW5zbGF0ZSh0aGlzLiR0aXRsZUVsLmZpbmQoJy5maWx0ZXItY291bnQnKS5wYXJlbnQoKSk7XG4gICAgICB9IGVsc2UgeyAgICBcdFxuICAgICAgICB0aGlzLiR0aXRsZUVsLmZpbmQoJy5maWx0ZXItY291bnQnKS50ZXh0KHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuZ2V0KCdudW1TZWxlY3RlZCcpICtcbiAgICAgICAgICAnLycgK1xuICAgICAgICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuZ2V0KCdudW1Qb3NzaWJsZScpKTtcbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLiR0aXRsZUVsLmZpbmQoJy5maWx0ZXItY291bnQnKS5hdHRyKCdkYXRhLWkxOG4nLCcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXHRcbiAgcmVuZGVyVGl0bGUgOiBmdW5jdGlvbigpIHtcdCAgXG5cdCAgQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLnJlbmRlclRpdGxlLmFwcGx5KHRoaXMpO1xuXHQgIHRoaXMuX3VwZGF0ZUNvdW50SW5NZW51KCk7XG5cdCAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyRmlsdGVyczpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLnJlbmRlckZpbHRlcnMuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmdldFRyZWUoKS50aGVuKGZ1bmN0aW9uKHRyZWVNb2RlbCkge1xuICAgICAgc2VsZi4kZWwuaHRtbChzZWxmLnRlbXBsYXRlKHNlbGYubW9kZWwudG9KU09OKCkpKTtcblxuICAgICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgc2VsZi4kKCcuc2VsZWN0LW5vbmUnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtzZWxmLl9zZWxlY3ROb25lKCk7IHJldHVybiBmYWxzZTt9KTsgLy9yZXR1cm4gZmFsc2UgdG8gc3RvcCBwYWdlIHJlZnJlc2guXG4gICAgICBzZWxmLiQoJy5zZWxlY3QtYWxsJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7c2VsZi5fc2VsZWN0QWxsKCk7IHJldHVybiBmYWxzZTt9KTsgLy9yZXR1cm4gZmFsc2UgdG8gc3RvcCBwYWdlIHJlZnJlc2guXG4gICAgICBzZWxmLiQoJ2lucHV0LnNlYXJjaC10ZXh0Jykub24oJ2tleXVwJywgZnVuY3Rpb24oZXZlbnQpIHtzZWxmLnNlYXJjaEtleVVwKGV2ZW50KTt9KTtcblxuICAgICAgaWYgKHRyZWVNb2RlbCkge1xuICAgICAgICBzZWxmLiQoJy50cmVlLWNvbnRhaW5lcicpLmFwcGVuZChzZWxmLnRyZWVWaWV3LnJlbmRlcihzZWxmLm1vZGVsLmdldCgndHJlZScpKS4kZWwpO1xuICAgICAgICB0cmVlTW9kZWwuc2V0KCdleHBhbmRlZCcsIHRydWUpO1xuICAgICAgICB0cmVlTW9kZWwuZmlsdGVyVGV4dCgnJyk7Ly9kZWZhdWx0IG5vIGZpbHRlci5cbiAgICAgIH0gZWxzZXtcbiAgICAgICAgc2VsZi4kKCcudHJlZS1jb250YWluZXInKS5hcHBlbmQoXCJcIik7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZG9uZShmdW5jdGlvbigpIHtcbiAgICBcdHNlbGYudHJhbnNsYXRlKHNlbGYpO1xuICAgIH0pXG4gICAgLmZhaWwoZnVuY3Rpb24oKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlbmRlckZpbHRlcnMgZmFpbGVkIDooJyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAvLyBmb3JjZSB0cmlnZ2VyIGV2ZW4gaWYgYWxyZWFkeSB0aGlzIHN0YXRlIChpbXBvcnRhbnQgZm9yIGhhbGYtZmlsbCB1aVxuICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcbiAgICB0aGlzLm1vZGVsLmdldCgndHJlZScpLnNldCgnc2VsZWN0ZWQnLCB0cnVlKTsgICAgXG4gIH0sXG5cbiAgX3NlbGVjdE5vbmU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIGZvcmNlIHRyaWdnZXIgZXZlbiBpZiBhbHJlYWR5IHRoaXMgc3RhdGUgKGltcG9ydGFudCBmb3IgaGFsZi1maWxsIHVpKVxuICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuc2V0KCdzZWxlY3RlZCcsIHRydWUpO1xuICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTsgICAgXG4gIH1cblxufSk7XG5cbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFRpdGxlVGVtcGxhdGUgPSBcIjwlXFxuLy8gcmVuZGVycyB0aGUgdGl0bGUgb2YgYSB0YWIgXFxuJT5cXG48bGkgY2xhc3M9XFxcIlxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy08JT0gbmFtZS5yZXBsYWNlKC8gL2csJycpICU+XFxcIiBocmVmPVxcXCIjZmlsdGVyLXBhbmUtPCU9IG5hbWUucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj48JT0gbmFtZSAlPjwvYT48L2xpPlxcblwiO1xudmFyIENvbnRlbnRUZW1wbGF0ZSA9IFwiPCVcXG4gLy8gcmVuZGVycyB0aGUgY29udGVudHMgb2YgYSBmaWx0ZXIncyB0YWIgKGUuZy4gZm9yIGV4YW1wbGUgdGhlIFxcXCJDb250cmFjdGluZyAvIEltcGxlbWVudGluZyAvIEV4ZWN1dGluZyAvIFByaW1hcnkgQmVuZWZpY2lhcnkgLyBTZWNvbmRhcnkgQmVuZWZpY2lhcnkgQWdlbmN5XFxcIiBsaXN0IG9mIHRoZSBcXFwiQWxsIEFnZW5jaWVzXFxcIiB0YWIpXFxuIC8vIDxoNj5tZGUgICUtIE1hdGgucmFuZG9tKCkgPC9oNj5cXG4lPlxcbjx1bCBjbGFzcz1cXFwic3ViLWZpbHRlcnMtdGl0bGVzIG5hdiBuYXYtcGlsbHMgbmF2LXN0YWNrZWRcXFwiPlxcbjwvdWw+XFxuPGRpdiBjbGFzcz1cXFwic3ViLWZpbHRlcnMtY29udGVudFxcXCI+XFxuICA8aW1nIHNyYz1cXFwiaW1nXzIvbG9hZGluZy1pY29uLmdpZlxcXCIgLz5cXG48L2Rpdj5cXG5cIjtcblxudmFyIEdlbmVyaWNGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvZ2VuZXJpYy1maWx0ZXItdmlldycpO1xudmFyIFllYXJzRmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3llYXJzLWZpbHRlci12aWV3Jyk7XG52YXIgWWVhcnNPbmx5RmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3llYXJzLW9ubHktZmlsdGVyLXZpZXcnKTtcblxudmFyIFllYXJzRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtZmlsdGVyLW1vZGVsJyk7XG52YXIgWWVhcnNPbmx5RmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtb25seS1maWx0ZXItbW9kZWwnKTtcblxudmFyIGZpbHRlcnNWaWV3TG9nID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3JlYW1wL3Rvb2xzL2xvZ1wiKSgnYW1wOmZpbHRlcnM6dG9wLWxldmVsOnZpZXcnKTtcblxuLy9UT0RPOiByZW5hbWUgdG8gJ2dyb3VwJyB0byBiZSBjb25zaXN0ZW50XG4vLyBQYXJlbnQgYmFzZSB2aWV3IGZvciBmaWx0ZXJzLlxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gIGNsYXNzTmFtZTogICd0YWItcGFuZScsXG4gIHRpdGxlVGVtcGxhdGU6IF8udGVtcGxhdGUoVGl0bGVUZW1wbGF0ZSksXG4gIGNvbnRlbnRUZW1wbGF0ZTogXy50ZW1wbGF0ZShDb250ZW50VGVtcGxhdGUpLFxuICBmaWx0ZXJDb2xsZWN0aW9uOiBudWxsLFxuICB2aWV3TGlzdDpbXSxcbiAgbmFtZTogJ3RiZCcsXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3I7XG4gICAgdGhpcy50cmFuc2xhdGUgPSBvcHRpb25zLnRyYW5zbGF0ZTtcbiAgICB0aGlzLmZpbHRlclZpZXcgPSBvcHRpb25zLmZpbHRlclZpZXc7IFxuICAgIHRoaXMuZmlsdGVyQ29sbGVjdGlvbiA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7ICAgIFxuICAgIHRoaXMuZmlsdGVyQ29sbGVjdGlvbi5vbignY2hhbmdlOm51bVNlbGVjdGVkJywgZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3JlZnJlc2hUaXRsZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNsZWFudXBVbnVzZWRUYWJzOiBmdW5jdGlvbigpIHtcblx0ICBjb25zb2xlLmxvZyh0aGlzKTtcbi8vXHRkZWJ1Z2dlcihzZWxmKTtcbiAgfSxcbiAgXG4gIFxuICAvKipcbiAgICogcmVuZGVycyB0aGUgaXRlbXMgaW4gYSB0YWJcbiAgICogdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHRhYidzIGNvbnRlbnRzIHdpbGwgYmUgcmVuZGVyZWQgSUZGIG9wdGlvbnMucmVuZGVyRmlyc3RFbGVtZW50IGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKi9cbiAgcmVuZGVyRmlsdGVyczogZnVuY3Rpb24ocmVuZGVyRmlyc3RFbGVtZW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gbnVsbDtcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuJGVsLmF0dHIoJ2lkJywgJ2ZpbHRlci1wYW5lLScgKyB0aGlzLm5hbWUucmVwbGFjZSgvIC9nLCcnKSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLmNvbnRlbnRUZW1wbGF0ZSgpKTtcbiAgICAvLyByZW5kZXJzIHRoZSB0YWJzIG9mIHRoZSBmaWx0ZXIgKG9uZSB0YWIgZm9yIGVhY2ggZmlsdGVyQ29sbGVjdGlvbiBlbGVtZW50KVxuICAgIHRoaXMuZmlsdGVyQ29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICBcdGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBZZWFyc0ZpbHRlck1vZGVsKSB7ICAgIFx0XHRcbiAgICBcdFx0dmlldyA9IG5ldyBZZWFyc0ZpbHRlclZpZXcoe1xuICAgIFx0XHRcdG1vZGVsOmZpbHRlcixcbiAgICBcdFx0XHRlbDogc2VsZi4kKCcuc3ViLWZpbHRlcnMtY29udGVudCcpLFxuICAgIFx0XHRcdHRyYW5zbGF0b3I6IHNlbGYudHJhbnNsYXRvcixcbiAgICBcdFx0XHR0cmFuc2xhdGU6IHNlbGYudHJhbnNsYXRlLFxuICAgIFx0XHRcdGZpbHRlclZpZXc6IHNlbGYuZmlsdGVyVmlldyAgICBcdFx0XHRcbiAgICBcdFx0fSk7XG4gICAgXHRcdHNlbGYudmlld0xpc3QucHVzaCh2aWV3KTtcbiAgICBcdH0gZWxzZSBpZiAoZmlsdGVyIGluc3RhbmNlb2YgWWVhcnNPbmx5RmlsdGVyTW9kZWwpIHtcbiAgICBcdFx0dmlldyA9IG5ldyBZZWFyc09ubHlGaWx0ZXJWaWV3KHtcbiAgICBcdFx0XHRtb2RlbDpmaWx0ZXIsXG4gICAgXHRcdFx0ZWw6IHNlbGYuJCgnLnN1Yi1maWx0ZXJzLWNvbnRlbnQnKSxcbiAgICBcdFx0XHR0cmFuc2xhdG9yOiBzZWxmLnRyYW5zbGF0b3IsXG4gICAgXHRcdFx0dHJhbnNsYXRlOiBzZWxmLnRyYW5zbGF0ZSxcbiAgICBcdFx0XHRmaWx0ZXJWaWV3OiBzZWxmLmZpbHRlclZpZXcgICAgXHRcdFx0XG4gICAgXHRcdH0pO1xuICAgIFx0XHRzZWxmLnZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgXHR9IGVsc2Uge1xuICAgIFx0XHR2aWV3ID0gbmV3IEdlbmVyaWNGaWx0ZXJWaWV3KHtcbiAgICBcdFx0XHRtb2RlbDpmaWx0ZXIsXG4gICAgXHRcdFx0ZWw6IHNlbGYuJCgnLnN1Yi1maWx0ZXJzLWNvbnRlbnQnKSxcbiAgICBcdFx0XHR0cmFuc2xhdG9yOiBzZWxmLnRyYW5zbGF0b3IsXG4gICAgXHRcdFx0dHJhbnNsYXRlOiBzZWxmLnRyYW5zbGF0ZVxuICAgIFx0XHR9KTtcbiAgICBcdFx0c2VsZi52aWV3TGlzdC5wdXNoKHZpZXcpO1xuICAgIFx0fVxuXG4gICAgXHR2YXIgdGl0bGVFbGVtID0gdmlldy5yZW5kZXJUaXRsZSgpLiR0aXRsZUVsO1xuICAgIFx0c2VsZi4kKCcuc3ViLWZpbHRlcnMtdGl0bGVzJykuYXBwZW5kKHRpdGxlRWxlbSk7XG5cbiAgICBcdC8vIGhhY2t5IHdheSB0byBvcGVuIGZpcnN0IG9uZSBmb3Igbm93LlxuICAgIFx0aWYgKGZpcnN0ICYmIHJlbmRlckZpcnN0RWxlbWVudCkge1xuICAgIFx0XHRmaXJzdCA9IGZhbHNlO1xuICAgIFx0XHR2aWV3LnJlbmRlckZpbHRlcnMoKTtcbiAgICBcdFx0c2VsZi4kKCcuc3ViLWZpbHRlcnMtdGl0bGVzIGxpOmZpcnN0JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIFx0fVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFdlIG5lZWQgdG8gcmUtdHJhbnNsYXRlIHNvbWUgc3RyaW5ncyBmcm9tIHRoZSByaWdodCBwYW5lbC5cblx0c2VsZi50cmFuc2xhdGUodGhpcyk7XG5cbiAgIFx0cmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3JlZnJlc2hUaXRsZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgdG90YWxTZWxlY3RlZCA9IDA7XG4gICAgdmFyIGNvdW50U3RyID0nJztcblxuICAgIHRoaXMuZmlsdGVyQ29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgaWYoZmlsdGVyLmdldE51bVNlbGVjdGVkKXtcbiAgICAgICAgdG90YWxTZWxlY3RlZCArPSBmaWx0ZXIuZ2V0TnVtU2VsZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKCB0b3RhbFNlbGVjdGVkICE9PSAwKSB7XG4gICAgICBjb3VudFN0ciA9IHRvdGFsU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc2hvdWxkIGJlIGxvY2FsbHkgc2NvcGVkLCBub3QgZ2xvYmFsIGpxdWVyeS5cbiAgICAkKCcjJyt0aGlzLm5hbWUucmVwbGFjZSgvIC9nLCcnKSArICcgLnRpdGxlLWNvdW50JykudGV4dChjb3VudFN0cik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlbmRlcnMgdGhlIHRpdGxlIG9mIGEgdGFiXG4gICAqL1xuICByZW5kZXJUaXRsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aXRsZUVsID0gdGhpcy50aXRsZVRlbXBsYXRlKHtuYW1lOiB0aGlzLm5hbWV9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhc2VGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYmFzZS1maWx0ZXItdmlldycpO1xuXG5yZXF1aXJlKCcuLi9saWIvanF1ZXJ5Lm5vdWlzbGlkZXIubWluLmpzJyk7XG5yZXF1aXJlKCdqcXVlcnktdWkvZGF0ZXBpY2tlcicpO1xuXG52YXIgVGVtcGxhdGUgPSBcIlxcbiAgPGgzIGNsYXNzPVxcXCJ0aXRsZSB0ZXh0LWNlbnRlclxcXCI+PHNwYW4gY2xhc3M9XFxcImRhdGVzXFxcIj48L3NwYW4+PC9oMz5cXG4gICA8ZGl2IGNsYXNzPVxcXCJ5ZWFyLXNsaWRlclxcXCI+PC9kaXY+XFxuXFxuICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1zdGFydGRhdGVcXFwiPlN0YXJ0IERhdGU6PC9zcGFuPiZuYnNwPHA+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJzdGFydC1kYXRlXFxcIiBjbGFzcz1cXFwiZGF0ZS1waWNrZXJcXFwiPjwvcD5cXG4gICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLWVuZGRhdGVcXFwiPkVuZCBEYXRlOjwvc3Bhbj4mbmJzcDxwPjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwiZW5kLWRhdGVcXFwiIGNsYXNzPVxcXCJkYXRlLXBpY2tlclxcXCI+PC9wPlxcblwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VGaWx0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lICsgJyBmaWx0ZXIteWVhcnMnLFxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG4gIF9sb2FkZWQ6IG51bGwsIFxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgdGhpcy5maWx0ZXJWaWV3ID0gb3B0aW9ucy5maWx0ZXJWaWV3OyAgICBcbiAgICBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvcjtcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IG9wdGlvbnMudHJhbnNsYXRlOyAgICBcblxuICAgIHRoaXMuX2xvYWRlZCA9IHRoaXMubW9kZWwuZmV0Y2goKS50aGVuKGZ1bmN0aW9uKCkgeyB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMuX3VwZGF0ZVRpdGxlKTtcbiAgfSxcblxuXG4gIHJlbmRlckZpbHRlcnM6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXJGaWx0ZXJzLmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwudG9KU09OKCkpKTtcblxuICAgIHRoaXMuX2xvYWRlZC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgLy9zZWxmLl9yZW5kZXJTbGlkZXIoKTtcbiAgICAgIHNlbGYuX3JlbmRlckRhdGVQaWNrZXJzKCk7XG4gICAgICBzZWxmLl91cGRhdGVUaXRsZSgpO1xuICAgICAgXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlLXRyYW5zbGF0ZSBzb21lIHN0cmluZ3MgZnJvbSB0aGUgcmlnaHQgcGFuZWwuXG4gICAgICBzZWxmLnRyYW5zbGF0ZShzZWxmKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9yZW5kZXJEYXRlUGlja2VyczogZnVuY3Rpb24oKSB7XHRcdFxuXHRcblx0XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBUT0RPOiBmb3JtYXQgYmFzZWQgb24gYWRtaW4gc2V0dGluZy4uLi5tYXliZSBnZXQgZnJvbSB5ZWFyIGFwaS4uXG4gICAgLy8gVE9ETzogYWJzdHJhY3QgY29tbW9uIHByb3BlcnRpZXMgZnJvbSBvYmplY3QgaW5pdHMgYmVsb3cuLi5cbiAgICAvLyB2YXIgY29tbW9uT2JqID0ge307XG5cbiAgICB0aGlzLiQoJyNzdGFydC1kYXRlJykuZGF0ZXBpY2tlcih7XG4gICAgICBkZWZhdWx0RGF0ZTogdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkU3RhcnQnKSxcbiAgICAgIGRhdGVGb3JtYXQ6IHRoaXMuZmlsdGVyVmlldy5nZXREYXRlRm9ybWF0KCksXG4gICAgICBjaGFuZ2VNb250aDogdHJ1ZSxcbiAgICAgIGNoYW5nZVllYXI6IHRydWUsXG4gICAgICBudW1iZXJPZk1vbnRoczogMSxcbiAgICAgIHllYXJSYW5nZTogJ2MtNjA6Yys2MCcsXG4gICAgICBvbkNsb3NlOiBmdW5jdGlvbihzZWxlY3RlZERhdGUpIHtcbiAgICAgICAgc2VsZi4kKCcjZW5kLWRhdGUnKS5kYXRlcGlja2VyKCdvcHRpb24nLCAnbWluRGF0ZScsIHNlbGVjdGVkRGF0ZSk7ICAgICAgICBcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkU3RhcnQnLCAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZShzZWxmLmZpbHRlclZpZXcuUEFSQU1TX0RBVEVfRk9STUFULCAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKHNlbGYuZmlsdGVyVmlldy5nZXREYXRlRm9ybWF0KCksIHNlbGVjdGVkRGF0ZSkpKTsgICAgICAgIFxuICAgICAgfVxuICAgIH0pOyAgICBcblxuICAgIHRoaXMuJCgnI2VuZC1kYXRlJykuZGF0ZXBpY2tlcih7XG4gICAgICBkZWZhdWx0RGF0ZTogdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJyksXG4gICAgICBkYXRlRm9ybWF0OiB0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLFxuICAgICAgY2hhbmdlTW9udGg6IHRydWUsXG4gICAgICBjaGFuZ2VZZWFyOiB0cnVlLFxuICAgICAgbnVtYmVyT2ZNb250aHM6IDEsXG4gICAgICB5ZWFyUmFuZ2U6ICdjLTYwOmMrNjAnLFxuICAgICAgb25DbG9zZTogZnVuY3Rpb24oc2VsZWN0ZWREYXRlKSB7XG4gICAgICAgIHNlbGYuJCgnI3N0YXJ0LWRhdGUnKS5kYXRlcGlja2VyKCdvcHRpb24nLCAnbWF4RGF0ZScsIHNlbGVjdGVkRGF0ZSk7ICAgICAgICBcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkRW5kJywgJC5kYXRlcGlja2VyLmZvcm1hdERhdGUoc2VsZi5maWx0ZXJWaWV3LlBBUkFNU19EQVRFX0ZPUk1BVCwgJC5kYXRlcGlja2VyLnBhcnNlRGF0ZShzZWxmLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLCBzZWxlY3RlZERhdGUpKSk7ICAgICAgICBcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNldCB0aGUgbGFuZ3VhZ2UgZm9yIGRhdGVwaWNrZXJzIGhlcmUgKGluc3RlYWQgb2YgZG9pbmcgaXQgaW4gZmlsdGVycy12aWV3LmpzKSB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyB0aGF0IHdvdWxkIHNldCB0aGUgd3JvbmcgbGFuZ3VhZ2UuXG4gICAgdmFyIGxhbmcgPSB0aGlzLmZpbHRlclZpZXcuc2V0dGluZ3MuZ2V0KCdsYW5ndWFnZScpO1xuXHRpZiAobGFuZykge1xuXHRcdC8vRW5nbGlzaCBpcyBkZWZhdWx0IHNvIHdlIGRvbnQgc2V0IGl0LlxuICAgICAgICBsYW5nID0gKGxhbmcgPT09ICdlbicpID8gICcnIDogbGFuZzsgXHRcdFxuXHRcdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbbGFuZ10pO1xuXHR9XG4gIH0sXG5cbiAgcmVuZGVyVGl0bGU6ZnVuY3Rpb24oKSB7XG5cdEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXJUaXRsZS5hcHBseSh0aGlzKTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy9UT0RPOiBkbyBtb3JlIGluIHRlbXBsYXRlLlxuICBfdXBkYXRlVGl0bGU6ZnVuY3Rpb24oKSB7XHQgIFxuXHR2YXIgc2VsZWN0ZWRTdGFydCA9IHRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZFN0YXJ0JykgPyAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLCAoJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSh0aGlzLmZpbHRlclZpZXcuUEFSQU1TX0RBVEVfRk9STUFULCB0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWRTdGFydCcpKSkpIDogXCJcIjtcblx0dmFyIHNlbGVjdGVkRW5kID0gdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJykgPyAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLCAoJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSh0aGlzLmZpbHRlclZpZXcuUEFSQU1TX0RBVEVfRk9STUFULCB0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWRFbmQnKSkpKVx0OiBcIlwiO1xuXHQkKCcjZGF0ZVBpY2tlcicpLmRhdGVwaWNrZXIoeyBkYXRlRm9ybWF0OiB0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpIH0pO1xuXHR0aGlzLiQoJyNzdGFydC1kYXRlJykuZGF0ZXBpY2tlcihcInNldERhdGVcIiwgc2VsZWN0ZWRTdGFydCk7XG5cdHRoaXMuJCgnI2VuZC1kYXRlJykuZGF0ZXBpY2tlcihcInNldERhdGVcIiwgc2VsZWN0ZWRFbmQpO1x0XG5cdHZhciBkYXRlcyA9IFwiXCI7XG5cdGlmKHNlbGVjdGVkU3RhcnQubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEVuZC5sZW5ndGggPiAwKXtcblx0XHRkYXRlcyA9IHNlbGVjdGVkU3RhcnQgKyAnIC0gJyArICBzZWxlY3RlZEVuZDtcdFx0XG5cdH1lbHNlIGlmKHNlbGVjdGVkU3RhcnQubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEVuZC5sZW5ndGggPT0gMCl7XG5cdFx0ZGF0ZXMgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmdpczpkYXRlLWZyb20nLCAnRnJvbScpICsgJyAnICsgc2VsZWN0ZWRTdGFydDtcdFx0XHRcdFxuXHR9ZWxzZSBpZihzZWxlY3RlZFN0YXJ0Lmxlbmd0aCA9PSAwICYmIHNlbGVjdGVkRW5kLmxlbmd0aCA+IDApe1xuXHRcdGRhdGVzID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5naXM6ZGF0ZS11bnRpbCcsICdVbnRpbCcpICsgJyAnICsgc2VsZWN0ZWRFbmQ7XHRcdFx0XG5cdH1cblx0dGhpcy4kdGl0bGVFbC5maW5kKCcuZmlsdGVyLWNvdW50JykudGV4dChkYXRlcyk7XG5cdHRoaXMuJCgnLmRhdGVzJykudGV4dChkYXRlcyk7XHRcbiAgfSxcblxuICBfcmVuZGVyU2xpZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyB1c2VzIHdpbmRvdy5qUXVlcnkgYmVjYXVzZSB0aGF0IHdhcyB0aGUgb25seSB3YXkgSSBoYWQgbHVjayB3aXRoIGJyb3dzZXJpZnkgc2hpbS4uLlxuICAgIC8vIHVzZXMgaHR0cHM6Ly9naXRodWIuY29tL2xlb25nZXJzZW4vbm9VaVNsaWRlclxuICAgIHRoaXMuc2xpZGVyID0gd2luZG93LmpRdWVyeSh0aGlzLiQoJy55ZWFyLXNsaWRlcicpKS5ub1VpU2xpZGVyKHtcbiAgICAgIHN0YXJ0OiBbc2VsZi5tb2RlbC5nZXQoJ3NlbGVjdGVkU3RhcnQnKSwgc2VsZi5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJyldLFxuICAgICAgc3RlcDogMSxcbiAgICAgIGNvbm5lY3Q6IHRydWUsXG4gICAgICByYW5nZToge21pbjogc2VsZi5tb2RlbC5nZXQoJ3N0YXJ0WWVhcicpLCBtYXg6c2VsZi5tb2RlbC5nZXQoJ2VuZFllYXInKX0sXG4gICAgICBzZXJpYWxpemF0aW9uOiB7XG4gICAgICAgIGxvd2VyOiBbXG4gICAgICAgICAgd2luZG93LmpRdWVyeS5MaW5rKHtcbiAgICAgICAgICAgIHRhcmdldDogd2luZG93LmpRdWVyeSgnLnN0YXJ0LXllYXInKVxuICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIHVwcGVyOiBbXG4gICAgICAgICAgd2luZG93LmpRdWVyeS5MaW5rKHtcbiAgICAgICAgICAgIHRhcmdldDogd2luZG93LmpRdWVyeSgnLmVuZC15ZWFyJylcbiAgICAgICAgICB9KVxuICAgICAgICBdLFxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICBkZWNpbWFsczogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL3VnbHksIHRvbyBtdWNoIGRhdGEgaW4gdGhlIGRvbS4uLmJ1dCBpdCdzIGhvdyB0aGUgZXhhbXBsZSBnb2VzLlxuICAgIHRoaXMuc2xpZGVyLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYubW9kZWwuc2V0KCdzZWxlY3RlZFN0YXJ0JywgcGFyc2VJbnQoc2VsZi4kKCcuc3RhcnQteWVhcicpLnRleHQoKSwgMTApKTtcbiAgICB9KTtcblxuICAgIC8vdWdseSwgdG9vIG11Y2ggZGF0YSBpbiB0aGUgZG9tLi4uYnV0IGl0J3MgaG93IHRoZSBleGFtcGxlIGdvZXMuXG4gICAgdGhpcy5zbGlkZXIub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkRW5kJywgIHBhcnNlSW50KHNlbGYuJCgnLmVuZC15ZWFyJykudGV4dCgpLCAxMCkpO1xuICAgIH0pO1xuICB9XG5cbn0pO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYXNlRmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL2Jhc2UtZmlsdGVyLXZpZXcnKTtcblxudmFyIFRlbXBsYXRlID0gXCI8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLXllYXJcXFwiPlllYXI6PC9zcGFuPlxcclxcbiZuYnNwXFxyXFxuPHA+XFxyXFxuXFx0PHNlbGVjdCBpZD1cXFwieWVhci1zZWxlY3RcXFwiIGNsYXNzPVxcXCJcXFwiPjwvc2VsZWN0PlxcclxcbjwvcD5cIjtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyVmlldy5leHRlbmQoe1xuXHRjbGFzc05hbWUgOiBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lICsgJyBmaWx0ZXIteWVhcnMnLFxuXHR0ZW1wbGF0ZSA6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxuXHRfbG9hZGVkIDogbnVsbCxcblx0aW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5maWx0ZXJWaWV3ID0gb3B0aW9ucy5maWx0ZXJWaWV3O1xuXHRcdEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIFsgb3B0aW9ucyBdKTtcblx0XHR0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcblx0XHR0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3I7XG5cdFx0dGhpcy50cmFuc2xhdGUgPSBvcHRpb25zLnRyYW5zbGF0ZTtcblx0XHR0aGlzLl9sb2FkZWQgPSB0aGlzLm1vZGVsLmZldGNoKCkudGhlbihmdW5jdGlvbigpIHt9KTtcblx0XHR0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLl91cGRhdGVUaXRsZSk7XG5cdH0sXG5cblx0cmVuZGVyRmlsdGVycyA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUucmVuZGVyRmlsdGVycy5hcHBseSh0aGlzKTtcblx0XHR0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUodGhpcy5tb2RlbC50b0pTT04oKSkpO1xuXHRcdHRoaXMuX2xvYWRlZC50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5fcmVuZGVyU2VsZWN0b3IoKTtcblx0XHRcdC8vIFdlIG5lZWQgdG8gcmUtdHJhbnNsYXRlIHNvbWUgc3RyaW5ncyBmcm9tIHRoZSByaWdodCBwYW5lbC5cblx0XHRcdHNlbGYudHJhbnNsYXRlKHNlbGYpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3JlbmRlclNlbGVjdG9yIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBzZWxlY3RvciA9IHRoaXMuJCgnI3llYXItc2VsZWN0Jyk7XG5cdFx0c2VsZWN0b3IuYXBwZW5kKCQoXCI8b3B0aW9uPlwiKS5hdHRyKCd2YWx1ZScsICcnKS50ZXh0KCcnKSk7XG5cdFx0Xy5lYWNoKHRoaXMubW9kZWwuZ2V0KCd2YWx1ZScpLm9wdGlvbnMsIGZ1bmN0aW9uKGl0ZW0sIGkpIHtcblx0XHRcdHZhciBvcHRpb24gPSAkKFwiPG9wdGlvbj5cIikuYXR0cigndmFsdWUnLCBpdGVtLnZhbHVlKS50ZXh0KGl0ZW0udmFsdWUpO1xuXHRcdFx0aWYgKGl0ZW0udmFsdWUgPT09IHNlbGYubW9kZWwuZ2V0KCdzZWxlY3RlZFllYXInKS50b1N0cmluZygpKSB7XG5cdFx0XHRcdCQob3B0aW9uKS5hdHRyKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0b3IuYXBwZW5kKG9wdGlvbik7XG5cdFx0fSk7XG5cblx0XHQkKHNlbGVjdG9yKS5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLm1vZGVsLnNldCgnc2VsZWN0ZWRZZWFyJywgdGhpcy52YWx1ZSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRpdGxlIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGVjdGVkWWVhciA9IHRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZFllYXInKTtcblx0XHR0aGlzLiQoXCIjeWVhci1zZWxlY3RcIikudmFsKHNlbGVjdGVkWWVhcik7XG5cdH0sXG5cbn0pO1xuIiwidmFyIERlZmVycmVkID0gcmVxdWlyZSgnanF1ZXJ5JykuRGVmZXJyZWQ7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgU2V0dGluZyA9IHJlcXVpcmUoJy4uL21vZGVscy9zZXR0aW5ncy1kZWZpbml0aW9ucycpO1xudmFyIENvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jb25maWcnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb21tb24vY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzICA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblx0bW9kZWwgOiBTZXR0aW5nLFxuXHRjb21wYXJhdG9yOiAnaWQnLFxuXHRmaXJzdFRpbWU6IHRydWUsXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy51cmwgPSBvcHRpb25zLmRlZmluaXRpb25Vcmw7XG5cdFx0dGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcblx0XHR0aGlzLmxvYWRlZCA9IG5ldyBEZWZlcnJlZCgpO1xuXHRcdF8uYmluZEFsbCh0aGlzLCdsb2FkJyk7XG5cdH0sXG5cdHBhcnNlOiBmdW5jdGlvbihzZXR0aW5ncykge1xuXHRcdHJldHVybiBzZXR0aW5ncztcdCAgICBcblx0fSxcblx0bG9hZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuZmlyc3RUaW1lKSB7XG5cdFx0XHR0aGlzLmZpcnN0VGltZSA9IGZhbHNlO1xuXHRcdFx0aWYgKHRoaXMubG9hZGVkLnN0YXRlKCkgIT09ICdwZW5kaW5nJykgeyByZXR1cm4gdGhpcy5sb2FkZWQucHJvbWlzZSgpOyB9XG5cdFx0XHR0aGlzLmZldGNoKHt9KVxuXHRcdFx0LnRoZW4oXyhmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5sb2FkZWQucmVzb2x2ZSgpO1xuXHRcdFx0fSkuYmluZCh0aGlzKSlcblx0XHRcdC5mYWlsKF8oZnVuY3Rpb24oKSB7XHRcdFx0ICAgICAgIFxuXHRcdFx0XHR0aGlzLmxvYWRlZC5yZWplY3QoKTtcblx0XHRcdH0pLmJpbmQodGhpcykpO1xuXHRcdH0gICAgXG5cdFx0cmV0dXJuIHRoaXMubG9hZGVkLnByb21pc2UoKTtcblx0fSxcblx0ZmluZEN1cnJlbmN5QnlJZDogZnVuY3Rpb24oaWQpe1xuXHRcdHJldHVybiBfLmZpbmQodGhpcy5nZXQoQ29uc3RhbnRzLkNVUlJFTkNZX0lEKS5nZXQoJ3ZhbHVlJykub3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKXsgcmV0dXJuIG9wdGlvbi5pZCA9PT0gaWQgfSk7XHRcdCBcblx0fSxcbiAgICBmaW5kQW1vdW50VW5pdHNCeUlkOiBmdW5jdGlvbihpZCl7XG5cdFx0cmV0dXJuIF8uZmluZCh0aGlzLmdldChDb25zdGFudHMuQU1PVU5UX1VOSVRfSUQpLmdldCgndmFsdWUnKS5vcHRpb25zLCBmdW5jdGlvbihvcHRpb24peyByZXR1cm4gb3B0aW9uLmlkID09PSBpZCB9KTtcblx0fSxcbiAgICBmaW5kQW1vdW50VW5pdHNCeVZhbHVlOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0cmV0dXJuIF8uZmluZCh0aGlzLmdldChDb25zdGFudHMuQU1PVU5UX1VOSVRfSUQpLmdldCgndmFsdWUnKS5vcHRpb25zLCBmdW5jdGlvbihvcHRpb24peyByZXR1cm4gb3B0aW9uLnZhbHVlID09PSB2YWx1ZSB9KTtcblx0fSxcblx0ZmluZENhbGVuZGFyQnlJZDogZnVuY3Rpb24oaWQpe1xuXHRcdHJldHVybiBfLmZpbmQodGhpcy5nZXQoQ29uc3RhbnRzLkNBTEVOREFSX0lEKS5nZXQoJ3ZhbHVlJykub3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKXsgcmV0dXJuIG9wdGlvbi5pZCA9PT0gaWQgfSk7XG5cdH0sXG5cdGZpbmRGdW5kaW5nVHlwZUJ5SWQ6IGZ1bmN0aW9uKGlkKXtcblx0XHRyZXR1cm4gXy5maW5kKHRoaXMuZ2V0KENvbnN0YW50cy5GVU5ESU5HX1RZUEVfSUQpLmdldCgndmFsdWUnKS5vcHRpb25zLCBmdW5jdGlvbihvcHRpb24peyByZXR1cm4gb3B0aW9uLmlkID09PSBpZCB9KTtcblx0fSxcblx0Z2V0Q3VycmVuY3lTZXR0aW5nOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLmdldChDb25zdGFudHMuQ1VSUkVOQ1lfSUQpO1xuXHR9LFxuXHRnZXRBbW91bnRVbml0c1NldHRpbmc6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KENvbnN0YW50cy5BTU9VTlRfVU5JVF9JRCk7XG5cdH0sXG5cdGdldENhbGVuZGFyU2V0dGluZzogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5nZXQoQ29uc3RhbnRzLkNBTEVOREFSX0lEKTtcblx0fSxcdFxuXHRnZXRGdW5kaW5nVHlwZVNldHRpbmc6ZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5nZXQoQ29uc3RhbnRzLkZVTkRJTkdfVFlQRV9JRCk7XG5cdH0sXG5cdGdldERlZmF1bHRDdXJyZW5jeUlkOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnJlbmN5U2V0dGluZygpLmdldCgndmFsdWUnKS5kZWZhdWx0SWQ7XG5cdH0sXG5cdGdldERlZmF1bHRBbW91bnRVbml0c0lkOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLmdldEFtb3VudFVuaXRzU2V0dGluZygpLmdldCgndmFsdWUnKS5kZWZhdWx0SWQ7XG5cdH0sXG5cdGdldERlZmF1bHRDYWxlbmRhcklkOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLmdldENhbGVuZGFyU2V0dGluZygpLmdldCgndmFsdWUnKS5kZWZhdWx0SWQ7XG5cdH0sXG5cdGdldERlZmF1bHRGdW5kaW5nVHlwZUJ5SWQ6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RnVuZGluZ1R5cGVTZXR0aW5nKCkuZ2V0KCd2YWx1ZScpLmRlZmF1bHRJZDtcblx0fSxcblx0Z2V0U2VsZWN0ZWRPckRlZmF1bHRDdXJyZW5jeUlkIDogZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5hcHAudG9BUElGb3JtYXQoKVtDb25zdGFudHMuQ1VSUkVOQ1lfSURdIHx8IHRoaXMuZ2V0RGVmYXVsdEN1cnJlbmN5SWQoKTtcblx0fSxcblx0Z2V0U2VsZWN0ZWRPckRlZmF1bHRDYWxlbmRhcklkIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwLnRvQVBJRm9ybWF0KClbQ29uc3RhbnRzLkNBTEVOREFSX0lEXSB8fCB0aGlzLmdldERlZmF1bHRDYWxlbmRhcklkKCk7XG5cdH0sXG5cdGdldFNlbGVjdGVkT3JEZWZhdWx0RnVuZGluZ1R5cGVJZCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmFwcC50b0FQSUZvcm1hdCgpW0NvbnN0YW50cy5GVU5ESU5HX1RZUEVfSURdIHx8IHRoaXMuZ2V0RGVmYXVsdEZ1bmRpbmdUeXBlQnlJZCgpO1xuXHR9XG59KTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0SVNfUE9QVVAgOiB0cnVlXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFlFQVJfUkFOR0VfSUQgOiAneWVhci1yYW5nZScsXHJcblx0Q0FMRU5EQVJfSUQgOiAnY2FsZW5kYXItaWQnLFxyXG5cdENVUlJFTkNZX0lEIDogJ2N1cnJlbmN5LWNvZGUnLFxyXG5cdEZVTkRJTkdfVFlQRV9JRCA6ICdmdW5kaW5nLXR5cGUnLFxyXG5cdENBTEVOREFSX0NVUlJFTkNJRVNfSUQgOiAnY2FsZW5kYXItY3VycmVuY2llcycsXHJcbiAgICBBTU9VTlRfRk9STUFUX0lEIDogJ2Ftb3VudC1mb3JtYXQnLFxyXG4gICAgQU1PVU5UX1VOSVRfSUQgOiAnbnVtYmVyLWRpdmlkZXInLFxyXG4gICAgQU1PVU5UU19PUFRJT05fVEhPVVNBTkRTIDogMTAwMCxcclxuICAgIEFNT1VOVFNfT1BUSU9OX01JTExJT05TIDogMTAwMDAwMCxcclxuXHRZRUFSX0ZST01fSUQ6IFwiZnJvbVwiLFxyXG5cdFlFQVJfVE9fSUQ6IFwidG9cIixcdFxyXG5cdENPTlRFWFQgOiB7XHJcblx0XHRHSVMgOiAnR0lTJyxcclxuXHRcdERBU0hCT0FSRFMgOiAnREFTSEJPQVJEUycsXHJcblx0XHRSRVBPUlRTIDogJ1JFUE9SVFMnLFxyXG5cdFx0VEFCUyA6ICdUQUJTJ1xyXG5cdH1cclxufSIsIlxyXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG4vL2xvYWRpbmcgaGFja3NcclxucmVxdWlyZSgnanF1ZXJ5LXVpL2RyYWdnYWJsZScpO1xyXG52YXIgQ29uZmlnID0gcmVxdWlyZSgnLi9jb21tb24vY29uZmlnJyk7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbW1vbi9jb25zdGFudHMnKTtcclxudmFyIFNldHRpbmdzRGVmaW5pdGlvbnNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9zZXR0aW5ncy1kZWZpbml0aW9ucy1jb2xsZWN0aW9uJyk7XHJcbnZhciBTZXR0aW5nc1ZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL3NldHRpbmdzLXZpZXcnKTtcclxudmFyIEdlbmVyYWxTZXR0aW5ncyA9IHJlcXVpcmUoJy4vbW9kZWxzL2dlbmVyYWwtc2V0dGluZ3MnKTtcclxuLy9qcXVlcnkgaXMgY29sbGlkaW5nIGluIEdJUyBtb2R1bGUsIHNvIHdlIG9ubHkgbG9hZCBpdCBpZiBpdCBpcyBub3QgbG9hZGVkIG9yIGlmIHRoZXJlIGlzIGEganF1ZXJ5IGxvYWRlZCBidXQgdmVyc2lvbiBpcyBvbGRlciB0aGFuIDIueC54XHJcbmlmICh3aW5kb3cuJCA9PSB1bmRlZmluZWQgfHwgJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpWzBdIDwgMikge1x0XHJcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0gQmFja2JvbmUuJCA9IGpRdWVyeTtcdFxyXG5cdCQubm9Db25mbGljdCh0cnVlKTtcclxufVxyXG52YXIgYm9vdHN0cmFwX2VuYWJsZWQgPSAodHlwZW9mICQoKS5tb2RhbCA9PSAnZnVuY3Rpb24nKTtcclxuaWYgKGJvb3RzdHJhcF9lbmFibGVkKSB7XHJcblx0cmVxdWlyZSgnYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwJyk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBXaWRnZXQoKSB7XHJcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbl8uZXh0ZW5kKFdpZGdldC5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1x0XHJcblx0Q29uc3RhbnRzOiBDb25zdGFudHMsIC8vZXhwb3NlIGNvbnN0YW50c1xyXG5cdFxyXG5cdGluaXRpYWxpemUgOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHRpZiAoXy5pc1VuZGVmaW5lZChvcHRpb25zKSB8fCBfLmlzVW5kZWZpbmVkKG9wdGlvbnMuZGVmaW5pdGlvblVybCkgfHwgXy5pc1VuZGVmaW5lZChvcHRpb25zLmNhbGxlcikpIHtcclxuXHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmluaXRpb25VcmwgYW5kIGNhbGxlciBhcmUgcmVxdWlyZWQgZm9yIHRoZSBTZXR0aW5ncyBXaWRnZXQgdG8gZnVuY3Rpb24gY29ycmVjdGx5LicpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XHJcblx0XHRcdGRyYWdnYWJsZSA6IHRydWVcclxuXHRcdH0pO1x0XHRcclxuXHRcdG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcclxuXHRcdFx0aXNQb3B1cCA6IENvbmZpZy5JU19QT1BVUFxyXG5cdFx0fSk7XHRcdFxyXG5cdFx0b3B0aW9ucy5hcHAgPSB0aGlzO1xyXG5cdFx0dGhpcy5kZWZpbml0aW9ucyA9IG5ldyBTZXR0aW5nc0RlZmluaXRpb25zQ29sbGVjdGlvbihbXSwgb3B0aW9ucyk7XHJcblx0XHRvcHRpb25zLmRlZmluaXRpb25zID0gdGhpcy5kZWZpbml0aW9ucztcclxuXHRcdHRoaXMudmlldyA9IG5ldyBTZXR0aW5nc1ZpZXcob3B0aW9ucyk7XHJcblx0XHR0aGlzLmxpc3RlblRvKHRoaXMudmlldywgJ2FsbCcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5kZWZpbml0aW9ucy5sb2FkKCk7XHJcblx0XHRfLmJpbmRBbGwodGhpcywgJ3Nob3cnLCAndG9BUElGb3JtYXQnLCAncmVzdG9yZUZyb21TYXZlZCcsICdzZXRFbGVtZW50Jyk7XHRcdFx0XHRcclxuXHR9LFxyXG5cdHNob3cgOiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMudmlldy5yZW5kZXIoKTtcclxuXHR9LFxyXG5cdHRvQVBJRm9ybWF0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy52aWV3LmdldEN1cnJlbnQoKTtcclxuXHR9LFxyXG5cdHJlc3RvcmVGcm9tU2F2ZWQgOiBmdW5jdGlvbihzdGF0ZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMudmlldy5yZXN0b3JlRnJvbVNhdmVkKHN0YXRlKTtcclxuXHR9LFxyXG5cdHNldEVsZW1lbnQgOiBmdW5jdGlvbihhcmd1bWVudHMpIHtcclxuXHRcdHRoaXMudmlldy5zZXRFbGVtZW50KGFyZ3VtZW50cyk7XHJcblx0fVx0XHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtTZXR0aW5nc1dpZGdldDogV2lkZ2V0LCBHZW5lcmFsU2V0dGluZ3M6IEdlbmVyYWxTZXR0aW5nc31cclxud2luZG93LkFNUFNldHRpbmdzID0ge1NldHRpbmdzV2lkZ2V0OiBXaWRnZXQsIEdlbmVyYWxTZXR0aW5nczogR2VuZXJhbFNldHRpbmdzfTsiLCJ2YXIgRGVmZXJyZWQgPSByZXF1aXJlKCdqcXVlcnknKS5EZWZlcnJlZDtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcclxuXHR1cmw6ICcvcmVzdC9hbXAvc2V0dGluZ3MnLFx0XHJcblx0Zmlyc3RUaW1lOiB0cnVlLFxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5sb2FkZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuXHRcdF8uYmluZEFsbCh0aGlzLCdsb2FkJyk7XHJcblx0fSxcclxuXHRwYXJzZTogZnVuY3Rpb24oc2V0dGluZ3Mpe1xyXG5cdCAgcmV0dXJuIHNldHRpbmdzO1xyXG5cdH0sXHRcclxuXHRsb2FkOiBmdW5jdGlvbigpIHtcclxuXHRcdGlmICh0aGlzLmZpcnN0VGltZSkge1xyXG5cdFx0XHR0aGlzLmZpcnN0VGltZSA9IGZhbHNlO1xyXG5cdFx0XHRpZiAodGhpcy5sb2FkZWQuc3RhdGUoKSAhPT0gJ3BlbmRpbmcnKSB7IHJldHVybiB0aGlzLmxvYWRlZC5wcm9taXNlKCk7IH1cclxuXHRcdFx0dGhpcy5mZXRjaCh7fSlcclxuXHRcdFx0LnRoZW4oXyhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGlzLmxvYWRlZC5yZXNvbHZlKCk7XHJcblx0XHRcdH0pLmJpbmQodGhpcykpXHJcblx0XHRcdC5mYWlsKF8oZnVuY3Rpb24oKSB7XHRcdFx0ICAgICAgIFxyXG5cdFx0XHRcdHRoaXMubG9hZGVkLnJlamVjdCgpO1xyXG5cdFx0XHR9KS5iaW5kKHRoaXMpKTtcclxuXHRcdH0gICAgXHJcblx0XHRyZXR1cm4gdGhpcy5sb2FkZWQucHJvbWlzZSgpO1xyXG5cdH1cclxufSk7IiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcdFxyXG59KTsiLCJcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBUcmFuc2xhdG9yID0gcmVxdWlyZSgnYW1wLXRyYW5zbGF0ZScpO1xyXG52YXIgVGVtcGxhdGUgPSBcIjwlIGlmKG9iai5pc1BvcHVwKSB7JT5cXHJcXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXHJcXG5cXHRcXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlIGNhbmNlbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPng8L2J1dHRvbj5cXHJcXG5cXHRcXHRcXHQ8aDMgY2xhc3M9XFxcInBhbmVsLXRpdGxlXFxcIiBkYXRhLWkxOG49XFxcImFtcC5zZXR0aW5nczp0aXRsZVxcXCI+U2V0dGluZ3M8L2gzPlxcclxcbjwvZGl2PlxcclxcbjwlfSU+XFxyXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFx0XFx0XFxyXFxuPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWZsdWlkXFxcIj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmdzXFxcIj5cXHJcXG4gICAgTG9hZGluZy4uLlxcclxcbiAgPC9kaXY+XFxyXFxuICA8JSBpZighb2JqLmlzUG9wdXApIHslPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICBcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc3VjY2VzcyBhcHBseS1idG5cXFwiIGRhdGEtaTE4bj1cXFwiYW1wLnNldHRpbmdzOmFwcGx5LWJ1dHRvblxcXCI+QXBwbHk8L2J1dHRvbj5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPCV9JT5cXHJcXG48L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG48JSBpZihvYmouaXNQb3B1cCkgeyU+XFxyXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtZm9vdGVyIHNldHRpbmctZGlhbG9nLWZvb3RlclxcXCI+XFxyXFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi13YXJuaW5nIGNhbmNlbC1idG4gY2FuY2VsXFxcIiBkYXRhLWkxOG49XFxcImFtcC5zZXR0aW5nczpjYW5jZWwtYnV0dG9uXFxcIj5DYW5jZWw8L2J1dHRvbj5cXHJcXG4gIFxcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzIGFwcGx5LWJ0blxcXCIgZGF0YS1pMThuPVxcXCJhbXAuc2V0dGluZ3M6YXBwbHktYnV0dG9uXFxcIj5BcHBseTwvYnV0dG9uPlxcclxcbiA8L2Rpdj5cXHJcXG4gPCV9JT5cXHJcXG4gXFxyXFxuIFxcclxcblwiO1xyXG52YXIgU2VsZWN0VGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgPGxhYmVsIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBkYXRhLWkxOG49XFxcImFtcC5zZXR0aW5nczpsYWJlbC08JT0gb2JqLnNldHRpbmcuaWQgJT5cXFwiPjwlPSBvYmouc2V0dGluZy5uYW1lICU+PC9sYWJlbD5cXG4gIDxzZWxlY3QgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcIjwlPSBvYmouc2V0dGluZy5pZCAlPlxcXCI+XFxuICA8JSBfLmVhY2gob2JqLnNldHRpbmcudmFsdWUub3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKXsgJT5cXG4gIDwlIHZhciBzZWxlY3RlZCA9IG9iai5zZXR0aW5nc1NlbGVjdGlvbnNbb2JqLnNldHRpbmcuaWRdIHx8IG9iai5hcHBsaWVkU2V0dGluZ3Nbb2JqLnNldHRpbmcuaWRdOyU+XFxuICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSBvcHRpb24uaWQgJT5cXFwiICA8JSBpZihzZWxlY3RlZCA9PSBvcHRpb24uaWQpeyAlPiBzZWxlY3RlZCA8JSB9ICU+ID5cXG4gICAgICA8JT0gb3B0aW9uLm5hbWUgJT5cXG4gICAgPC9vcHRpb24+XFxuICA8JX0pOyAlPlxcbiAgPC9zZWxlY3Q+XFxuPC9kaXY+XFxuXCI7XHJcbnZhciBTZWxlY3RBbW91bnRVbml0VGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgPGxhYmVsIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBkYXRhLWkxOG49XFxcImFtcC5zZXR0aW5nczpsYWJlbC08JT0gb2JqLnNldHRpbmcuaWQgJT5cXFwiPjwlPSBvYmouc2V0dGluZy5uYW1lICU+PC9sYWJlbD5cXG4gIDxzZWxlY3QgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcIjwlPSBvYmouc2V0dGluZy5pZCAlPlxcXCI+XFxuICA8JSBfLmVhY2gob2JqLnNldHRpbmcudmFsdWUub3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKXsgJT5cXG4gIDwlIHZhciBzZWxlY3RlZCA9IG9iai5zZXR0aW5nc1NlbGVjdGlvbnNbb2JqLnNldHRpbmcuaWRdIHx8IG9iai5hcHBsaWVkU2V0dGluZ3NbJ2Ftb3VudC1mb3JtYXQnXVtvYmouc2V0dGluZy5pZF07JT5cXG4gICAgPG9wdGlvbiB2YWx1ZT1cXFwiPCU9IG9wdGlvbi52YWx1ZSAlPlxcXCIgIDwlIGlmKHNlbGVjdGVkID09IG9wdGlvbi52YWx1ZSl7ICU+IHNlbGVjdGVkIDwlIH0gJT4gPlxcbiAgICAgIDwlPSBvcHRpb24ubmFtZSAlPlxcbiAgICA8L29wdGlvbj5cXG4gIDwlfSk7ICU+XFxuICA8L3NlbGVjdD5cXG48L2Rpdj5cXG5cIjtcclxudmFyIFllYXJSYW5nZVRlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj4gXFxyXFxuPGxhYmVsIGRhdGEtaTE4bj1cXFwiYW1wLnNldHRpbmdzOmxhYmVsLTwlPSBvYmouaWQgJT5cXFwiPjwlPSBvYmoubmFtZSAlPjwvbGFiZWw+IFxcclxcbiA8ZGl2IGNsYXNzPVxcXCJyb3cgeWVhci1yYW5nZSBcXFwiPiBcXHJcXG4gXFxyXFxuIDwvZGl2PiAgXFxyXFxuPC9kaXY+XCI7XHJcbnZhciBZZWFyU2VsZWN0VGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9XFxcImNvbC14cy0yXFxcIj5cXHJcXG4gICA8bGFiZWwgZGF0YS1pMThuPVxcXCJhbXAuc2V0dGluZ3M6bGFiZWwtPCU9IG9iai5zZXR0aW5nLmlkICU+XFxcIiA+PCU9IG9iai5zZXR0aW5nLm5hbWUgJT48L2xhYmVsPlxcclxcbiA8L2Rpdj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImNvbC14cy00XFxcIj5cXHJcXG4gIDxzZWxlY3QgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcIjwlPSBvYmouc2V0dGluZy5pZCAlPlxcXCI+XFxyXFxuICAgIDwlXFxyXFxuICAgICAgdmFyIGFwcGxpZWQgPSBvYmouYXBwbGllZFNldHRpbmdzWyd5ZWFyLXJhbmdlJ10gPyBvYmouYXBwbGllZFNldHRpbmdzWyd5ZWFyLXJhbmdlJ11bb2JqLnNldHRpbmcuaWRdIDogbnVsbDtcXHJcXG4gICAgICB2YXIgc2VsZWN0ZWQgPSBvYmouc2V0dGluZ3NTZWxlY3Rpb25zW29iai5zZXR0aW5nLmlkXTtcXHJcXG4gICAgJT5cXHJcXG4gICAgPG9wdGlvbiBkYXRhLWkxOG49XFxcImFtcC5zZXR0aW5nczphbGxcXFwiIHZhbHVlPVxcXCItMVxcXCI8JSBpZigoc2VsZWN0ZWQgfHwgYXBwbGllZCkgPT0gLTEpeyAlPiBzZWxlY3RlZCA8JSB9ICU+PkFsbDwvb3B0aW9uPlxcclxcbiAgICA8JSBmb3IgKGkgPSBvYmouc2V0dGluZy5yYW5nZUZyb207IGkgPD0gb2JqLnNldHRpbmcucmFuZ2VUbzsgaSsrKSB7ICU+XFxyXFxuICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiPCU9IGkgJT5cXFwiPCUgaWYoKHNlbGVjdGVkIHx8IGFwcGxpZWQpID09IGkpeyAlPiBzZWxlY3RlZCA8JSB9ICU+PlxcclxcbiAgICAgIDwlPSBpICU+XFxyXFxuICAgICAgPC9vcHRpb24+XFxyXFxuICAgIDwlIH0gJT5cXHJcXG4gIDwvc2VsZWN0PlxcclxcbiAgPC9kaXY+XCI7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb21tb24vY29uc3RhbnRzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHR0ZW1wbGF0ZSA6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxyXG5cdHNlbGVjdFRlbXBsYXRlIDogXy50ZW1wbGF0ZShTZWxlY3RUZW1wbGF0ZSksXHJcbiAgICBzZWxlY3RBbW91bnRVbml0VGVtcGxhdGUgOiBfLnRlbXBsYXRlKFNlbGVjdEFtb3VudFVuaXRUZW1wbGF0ZSksXHJcblx0eWVhclJhbmdlVGVtcGxhdGUgOiBfLnRlbXBsYXRlKFllYXJSYW5nZVRlbXBsYXRlKSxcclxuXHR5ZWFyU2VsZWN0VGVtcGxhdGUgOiBfLnRlbXBsYXRlKFllYXJTZWxlY3RUZW1wbGF0ZSksXHJcblx0ZXZlbnRzIDoge1xyXG5cdFx0J2NsaWNrIC5hcHBseS1idG4nIDogJ2FwcGx5U2V0dGluZ3MnLFxyXG5cdFx0J2NoYW5nZSBzZWxlY3QnIDogJ29wdGlvbkNoYW5nZWQnLFxyXG5cdFx0J2NsaWNrIC5jYW5jZWwnIDogJ2Nsb3NlJyxcclxuXHRcdCdjbGljayAuY2xvc2UnIDogJ2Nsb3NlJ1xyXG5cdH0sXHJcblx0YXBwbGllZFNldHRpbmdzIDoge30sXHJcblx0c2V0dGluZ3NTZWxlY3Rpb25zIDoge30sXHJcblx0aW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuZGVmaW5pdGlvbnMgPSBvcHRpb25zLmRlZmluaXRpb25zO1xyXG5cdFx0dGhpcy5pc1BvcHVwID0gb3B0aW9ucy5pc1BvcHVwO1xyXG5cdFx0dGhpcy5jYWxsZXIgPSBvcHRpb25zLmNhbGxlcjtcclxuXHRcdGlmIChvcHRpb25zLnRyYW5zbGF0b3IgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLmNyZWF0ZVRyYW5zbGF0b3IodHJ1ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3I7XHJcblx0XHR9XHJcblx0XHR0aGlzLmFwcGxpZWRTZXR0aW5ncyA9IHt9O1xyXG5cdFx0dGhpcy5zZXR0aW5nc1NlbGVjdGlvbnMgPSB7fTtcclxuXHRcdF8uYmluZEFsbCh0aGlzLCAncmVuZGVyJywgJ2FwcGx5U2V0dGluZ3MnLCAndXBkYXRlVUknLCAnYXBwZW5kU2V0dGluZycsICdhcHBlbmRZZWFyUmFuZ2VTZXR0aW5nJywgJ2NvbmZpZ3VyZVVJJywnc2VsZWN0RGVmYXVsdHMnKTtcclxuXHR9LFxyXG5cdHJlbmRlciA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0c2VsZi4kZWwuaHRtbChzZWxmLnRlbXBsYXRlKHtcclxuXHRcdFx0aXNQb3B1cCA6IHRoaXMuaXNQb3B1cFxyXG5cdFx0fSkpO1x0XHRcclxuXHRcdFxyXG5cdFx0dGhpcy5kZWZpbml0aW9ucy5sb2FkKCkuZG9uZShmdW5jdGlvbigpIHtcclxuXHRcdFx0c2VsZi5zZWxlY3REZWZhdWx0cygpO1xyXG5cdFx0XHRzZWxmLnVwZGF0ZVVJKCk7XHJcblx0XHRcdHNlbGYuJGVsLnNob3coKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHRzZWxlY3REZWZhdWx0czogZnVuY3Rpb24oKXtcdFx0XHJcblx0XHR0aGlzLnNldHRpbmdzU2VsZWN0aW9ucyA9IHt9O1xyXG5cdFx0aWYoXy5pc0VtcHR5KHRoaXMuYXBwbGllZFNldHRpbmdzKSl7XHJcblx0XHRcdHRoaXMuc2V0dGluZ3NTZWxlY3Rpb25zW0NvbnN0YW50cy5DQUxFTkRBUl9JRF0gPSB0aGlzLmRlZmluaXRpb25zLmZpbmRXaGVyZSh7aWQgOiBDb25zdGFudHMuQ0FMRU5EQVJfSUQgfSkuZ2V0KCd2YWx1ZScpLmRlZmF1bHRJZDtcclxuXHRcdFx0dGhpcy5zZXR0aW5nc1NlbGVjdGlvbnNbQ29uc3RhbnRzLkNVUlJFTkNZX0lEXSA9IHRoaXMuZGVmaW5pdGlvbnMuZmluZFdoZXJlKHtpZCA6IENvbnN0YW50cy5DVVJSRU5DWV9JRCB9KS5nZXQoJ3ZhbHVlJykuZGVmYXVsdElkO1xyXG5cdFx0XHRpZiAodGhpcy5jYWxsZXIgPT09IENvbnN0YW50cy5DT05URVhULlJFUE9SVFMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NTZWxlY3Rpb25zW0NvbnN0YW50cy5BTU9VTlRfVU5JVF9JRF0gPSB0aGlzLmRlZmluaXRpb25zLmZpbmRXaGVyZSh7aWQgOiBDb25zdGFudHMuQU1PVU5UX1VOSVRfSUQgfSkuZ2V0KCd2YWx1ZScpLmRlZmF1bHRJZDtcclxuICAgICAgICAgICAgfVxyXG5cdFx0XHRcclxuXHRcdFx0dmFyIGZ1bmRpbmdUeXBlID0gdGhpcy5kZWZpbml0aW9ucy5maW5kV2hlcmUoe2lkIDogQ29uc3RhbnRzLkZVTkRJTkdfVFlQRV9JRCB9KTtcclxuXHRcdFx0aWYgKHRoaXMuY2FsbGVyICE9PSBDb25zdGFudHMuQ09OVEVYVC5EQVNIQk9BUkRTICYmIGZ1bmRpbmdUeXBlKSB7XHJcblx0XHRcdCAgIHRoaXMuc2V0dGluZ3NTZWxlY3Rpb25zW0NvbnN0YW50cy5GVU5ESU5HX1RZUEVfSURdID0gZnVuZGluZ1R5cGUuZ2V0KCd2YWx1ZScpLmRlZmF1bHRJZDtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHllYXJSYW5nZVNldHRpbmcgPSB0aGlzLmRlZmluaXRpb25zLmZpbmRXaGVyZSh7XHJcblx0XHRcdFx0aWQgOiBDb25zdGFudHMuWUVBUl9SQU5HRV9JRFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKHllYXJSYW5nZVNldHRpbmcpIHtcdFx0XHRcdFxyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3NTZWxlY3Rpb25zW0NvbnN0YW50cy5ZRUFSX0ZST01fSURdID0gXy5maW5kV2hlcmUoeWVhclJhbmdlU2V0dGluZy5nZXQoJ3ZhbHVlJyksIHtpZDogQ29uc3RhbnRzLllFQVJfRlJPTV9JRH0pLnZhbHVlLmRlZmF1bHRJZDtcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzU2VsZWN0aW9uc1tDb25zdGFudHMuWUVBUl9UT19JRF0gPSBfLmZpbmRXaGVyZSh5ZWFyUmFuZ2VTZXR0aW5nLmdldCgndmFsdWUnKSwge2lkOiBDb25zdGFudHMuWUVBUl9UT19JRH0pLnZhbHVlLmRlZmF1bHRJZDtcclxuXHRcdFx0fVx0XHRcdFxyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y29uZmlndXJlVUkgOiBmdW5jdGlvbigpIHtcclxuXHRcdGlmICh0aGlzLmlzUG9wdXApIHtcclxuXHRcdFx0dGhpcy4kZWwuYWRkQ2xhc3MoJ3BhbmVsIHBhbmVsLXByaW1hcnkgYW1wLXNldHRpbmdzLWRpYWxvZycpO1xyXG5cdFx0XHR0aGlzLiQoJy5wYW5lbC1oZWFkaW5nJykuc2hvdygpO1xyXG5cdFx0XHR0aGlzLiQoJy5jYW5jZWwtc2V0dGluZ3MnKS5zaG93KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLiQoJy5wYW5lbC1oZWFkaW5nJykuaGlkZSgpO1xyXG5cdFx0XHR0aGlzLiQoJy5jYW5jZWwtc2V0dGluZ3MnKS5oaWRlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR1cGRhdGVVSSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5jb25maWd1cmVVSSgpO1xyXG5cdFx0dGhpcy4kKCcuc2V0dGluZ3MnKS5odG1sKCcnKTtcclxuXHRcdHRoaXMuYXBwZW5kU2V0dGluZyhDb25zdGFudHMuQ0FMRU5EQVJfSUQpO1xyXG5cdFx0dGhpcy5hcHBlbmRTZXR0aW5nKENvbnN0YW50cy5DVVJSRU5DWV9JRCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGVyID09PSBDb25zdGFudHMuQ09OVEVYVC5SRVBPUlRTKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQW1vdW50VW5pdFNldHRpbmcoKTtcclxuICAgICAgICB9XHJcblx0XHRpZiAodGhpcy5jYWxsZXIgIT09IENvbnN0YW50cy5DT05URVhULkRBU0hCT0FSRFMpIHtcclxuXHRcdFx0dGhpcy5hcHBlbmRTZXR0aW5nKENvbnN0YW50cy5GVU5ESU5HX1RZUEVfSUQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5hcHBlbmRZZWFyUmFuZ2VTZXR0aW5nKCk7XHJcblx0XHR0aGlzLnRyYW5zbGF0ZSh0aGlzLiRlbCk7XHJcblx0fSxcclxuXHRhcHBlbmRTZXR0aW5nIDogZnVuY3Rpb24oc2V0dGluZ0lEKSB7XHJcblx0XHR2YXIgc2V0dGluZyA9IHRoaXMuZGVmaW5pdGlvbnMuZmluZFdoZXJlKHtcclxuXHRcdFx0aWQgOiBzZXR0aW5nSURcclxuXHRcdH0pO1xyXG5cdFx0aWYgKHNldHRpbmcpIHtcclxuXHRcdFx0dGhpcy4kKCcuc2V0dGluZ3MnKS5hcHBlbmQodGhpcy5zZWxlY3RUZW1wbGF0ZSh7XHJcblx0XHRcdFx0c2V0dGluZyA6IHNldHRpbmcudG9KU09OKCksXHJcblx0XHRcdFx0YXBwbGllZFNldHRpbmdzIDogdGhpcy5hcHBsaWVkU2V0dGluZ3MsXHJcblx0XHRcdFx0c2V0dGluZ3NTZWxlY3Rpb25zOiB0aGlzLnNldHRpbmdzU2VsZWN0aW9uc1xyXG5cdFx0XHR9KSk7XHJcblx0XHRcdGlmIChzZXR0aW5nSUQgPT09IENvbnN0YW50cy5DVVJSRU5DWV9JRCAmJiBfLmlzVW5kZWZpbmVkKHRoaXMuYWxsQ3VycmVuY2llcykpIHtcclxuXHRcdFx0XHR0aGlzLmFsbEN1cnJlbmNpZXMgPSBzZXR0aW5nLmdldCgndmFsdWUnKS5vcHRpb25zO1xyXG5cdFx0XHR9XHJcblx0XHR9XHRcdFxyXG5cdH0sXHJcblx0YXBwZW5kQW1vdW50VW5pdFNldHRpbmcgOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBzZXR0aW5nID0gdGhpcy5kZWZpbml0aW9ucy5maW5kV2hlcmUoe1xyXG5cdFx0XHRpZCA6IENvbnN0YW50cy5BTU9VTlRfVU5JVF9JRFxyXG5cdFx0fSk7XHJcblx0XHRpZiAoc2V0dGluZykge1xyXG5cdFx0XHR0aGlzLiQoJy5zZXR0aW5ncycpLmFwcGVuZCh0aGlzLnNlbGVjdEFtb3VudFVuaXRUZW1wbGF0ZSh7XHJcblx0XHRcdFx0c2V0dGluZyA6IHNldHRpbmcudG9KU09OKCksXHJcblx0XHRcdFx0YXBwbGllZFNldHRpbmdzIDogdGhpcy5hcHBsaWVkU2V0dGluZ3MsXHJcblx0XHRcdFx0c2V0dGluZ3NTZWxlY3Rpb25zOiB0aGlzLnNldHRpbmdzU2VsZWN0aW9uc1xyXG5cdFx0XHR9KSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhcHBlbmRZZWFyUmFuZ2VTZXR0aW5nIDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgeWVhclJhbmdlU2V0dGluZyA9IHRoaXMuZGVmaW5pdGlvbnMuZmluZFdoZXJlKHtcclxuXHRcdFx0aWQgOiBDb25zdGFudHMuWUVBUl9SQU5HRV9JRFxyXG5cdFx0fSk7XHJcblx0XHRpZiAoeWVhclJhbmdlU2V0dGluZykge1xyXG5cdFx0XHR0aGlzLiQoJy5zZXR0aW5ncycpLmFwcGVuZCh0aGlzLnllYXJSYW5nZVRlbXBsYXRlKHllYXJSYW5nZVNldHRpbmcudG9KU09OKCkpKTtcclxuXHRcdFx0dGhpcy5hcHBlbmRZZWFyU2VsZWN0KHllYXJSYW5nZVNldHRpbmcuZ2V0KCd2YWx1ZScpLCBDb25zdGFudHMuWUVBUl9GUk9NX0lEKTtcclxuXHRcdFx0dGhpcy5hcHBlbmRZZWFyU2VsZWN0KHllYXJSYW5nZVNldHRpbmcuZ2V0KCd2YWx1ZScpLCBDb25zdGFudHMuWUVBUl9UT19JRCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhcHBlbmRZZWFyU2VsZWN0IDogZnVuY3Rpb24oeWVhclJhbmdlU2V0dGluZywgc2V0dGluZ0lEKSB7XHJcblx0XHR2YXIgc2V0dGluZyA9IHtcclxuXHRcdFx0XCJuYW1lXCIgOiBzZXR0aW5nSUQsXHJcblx0XHRcdFwiaWRcIiA6IHNldHRpbmdJRCxcclxuXHRcdFx0XCJyYW5nZUZyb21cIiA6IHllYXJSYW5nZVNldHRpbmdbJ3JhbmdlRnJvbSddLFxyXG5cdFx0XHRcInJhbmdlVG9cIiA6IHllYXJSYW5nZVNldHRpbmdbJ3JhbmdlVG8nXSxcclxuXHRcdFx0XCJmcm9tXCIgOiB5ZWFyUmFuZ2VTZXR0aW5nWydmcm9tJ10sXHJcblx0XHRcdFwidG9cIiA6IHllYXJSYW5nZVNldHRpbmdbJ3RvJ11cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy4kKCcueWVhci1yYW5nZScpLmFwcGVuZCh0aGlzLnllYXJTZWxlY3RUZW1wbGF0ZSh7XHJcblx0XHRcdHNldHRpbmcgOiBzZXR0aW5nLFxyXG5cdFx0XHRhcHBsaWVkU2V0dGluZ3MgOiB0aGlzLmFwcGxpZWRTZXR0aW5ncyxcclxuXHRcdFx0c2V0dGluZ3NTZWxlY3Rpb25zOiB0aGlzLnNldHRpbmdzU2VsZWN0aW9uc1xyXG5cdFx0fSkpO1xyXG5cdH0sXHJcblx0Z2V0Q3VycmVuY2llc0J5Q2FsZW5kYXIgOiBmdW5jdGlvbihjYWxlbmRhcklkKSB7XHJcblx0XHR2YXIgY2FsZW5kYXJDdXJyZW5jaWVzID0gdGhpcy5kZWZpbml0aW9ucy5maW5kV2hlcmUoe1xyXG5cdFx0XHRpZCA6IENvbnN0YW50cy5DQUxFTkRBUl9DVVJSRU5DSUVTX0lEXHJcblx0XHR9KTtcclxuXHRcdHZhciBjdXJyZW5jaWVzID0gW107XHJcblx0XHRpZiAoY2FsZW5kYXJDdXJyZW5jaWVzKSB7XHJcblx0XHRcdGN1cnJlbmNpZXMgPSBfLnVuaXEoXy5maW5kV2hlcmUoY2FsZW5kYXJDdXJyZW5jaWVzLmdldCgndmFsdWUnKS5vcHRpb25zLCB7XHJcblx0XHRcdFx0aWQgOiBjYWxlbmRhcklkXHJcblx0XHRcdH0pLnZhbHVlLnNwbGl0KCcsJykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGN1cnJlbmNpZXM7XHJcblx0fSxcclxuXHRvcHRpb25DaGFuZ2VkIDogZnVuY3Rpb24oZXZ0KSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHR2YXIgc2V0dGluZ0lEID0gJChldnQuY3VycmVudFRhcmdldCkuYXR0cignaWQnKTtcclxuXHRcdHZhciBzZWxlY3RlZElEID0gJChldnQuY3VycmVudFRhcmdldCkudmFsKCk7XHJcblx0XHR0aGlzLnVwZGF0ZVNlbGVjdGVkKHNldHRpbmdJRCwgc2VsZWN0ZWRJRCk7XHJcblx0XHRpZiAoc2V0dGluZ0lEID09PSBDb25zdGFudHMuQ0FMRU5EQVJfSUQpIHtcclxuXHRcdFx0dGhpcy51cGRhdGVDdXJyZW5jeUxpc3Qoc2VsZWN0ZWRJRCk7XHJcblx0XHRcdHRoaXMudXBkYXRlVUkoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHVwZGF0ZUN1cnJlbmN5TGlzdCA6IGZ1bmN0aW9uKHNlbGVjdGVkQ2FsZW5kYXJJZCkge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0Ly8gdXBkYXRlIGN1cnJlbmN5IHNlbGVjdCB3aGVuIGNhbGVuZGFyIGNoYW5nZXNcclxuXHRcdHZhciBhdmFpbGFibGVDdXJyZW5jaWVzRm9yQ2FsZW5kYXIgPSBzZWxmLmdldEN1cnJlbmNpZXNCeUNhbGVuZGFyKHNlbGVjdGVkQ2FsZW5kYXJJZCk7XHJcblx0XHRzZWxmLmRlZmluaXRpb25zLmdldChDb25zdGFudHMuQ1VSUkVOQ1lfSUQpLmdldCgndmFsdWUnKS5vcHRpb25zID0gW107XHJcblx0XHQkLmVhY2goYXZhaWxhYmxlQ3VycmVuY2llc0ZvckNhbGVuZGFyLCBmdW5jdGlvbihpbmRleCwgb2JqZWN0KSB7XHJcblx0XHRcdHNlbGYuZGVmaW5pdGlvbnMuZ2V0KENvbnN0YW50cy5DVVJSRU5DWV9JRCkuZ2V0KCd2YWx1ZScpLm9wdGlvbnMucHVzaChfLmZpbmQoc2VsZi5hbGxDdXJyZW5jaWVzLCBmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0cmV0dXJuIGl0ZW0uaWQgPT09IG9iamVjdFxyXG5cdFx0XHR9KSk7XHJcblx0XHR9KTtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHR2YXIgc2VsZWN0ZWRDdXJyZW5jeSA9IF8uZmlsdGVyKGF2YWlsYWJsZUN1cnJlbmNpZXNGb3JDYWxlbmRhciwgZnVuY3Rpb24oY3Vycil7IHJldHVybiBjdXJyID09PSBzZWxmLnNldHRpbmdzU2VsZWN0aW9uc1tDb25zdGFudHMuQ1VSUkVOQ1lfSURdIDsgfSlbMF07XHJcblx0XHR2YXIgYXBwbGllZEN1cnJlbmN5ID0gXy5maWx0ZXIoYXZhaWxhYmxlQ3VycmVuY2llc0ZvckNhbGVuZGFyLCBmdW5jdGlvbihjdXJyKXsgcmV0dXJuIGN1cnIgPT09IHNlbGYuYXBwbGllZFNldHRpbmdzW0NvbnN0YW50cy5DVVJSRU5DWV9JRF0gOyB9KVswXTtcclxuXHRcdHZhciBmaXJzdEN1cnJlbmN5ID0gYXZhaWxhYmxlQ3VycmVuY2llc0ZvckNhbGVuZGFyWzBdO1xyXG5cdFx0dGhpcy51cGRhdGVTZWxlY3RlZChDb25zdGFudHMuQ1VSUkVOQ1lfSUQsIHNlbGVjdGVkQ3VycmVuY3kgfHwgYXBwbGllZEN1cnJlbmN5IHx8IGZpcnN0Q3VycmVuY3kpO1x0XHJcblx0fSxcclxuXHR1cGRhdGVTZWxlY3RlZCA6IGZ1bmN0aW9uKHNldHRpbmdJRCwgc2VsZWN0ZWRJRCkge1xyXG5cdFx0Ly8gc3RvcmUgdXNlciBzZWxlY3Rpb25zIGluIGEgdGVtcCBvYmplY3QgLSBvbmx5IHRyYW5zZmVyZWQgdG8gdGhlIGFwcGxpZWQgc2V0dGluZ3MgaWYgdGhlIGFwcGx5IGJ1dHRvbiBpcyBjbGlja2VkXHJcblx0XHR0aGlzLnNldHRpbmdzU2VsZWN0aW9uc1tzZXR0aW5nSURdID0gc2VsZWN0ZWRJRDtcclxuXHR9LFxyXG4gICAgdXBkYXRlQXBwbGllZFNldHRpbmdzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdHJhbnNmZXIgdXNlciBzZWxlY3Rpb25zIHRvIGFwcGxpZWQgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLnNldHRpbmdzU2VsZWN0aW9ucywgZnVuY3Rpb24gKHNlbGVjdGVkSUQsIHNldHRpbmdJRCkge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ0lEID09PSBDb25zdGFudHMuWUVBUl9GUk9NX0lEIHx8IHNldHRpbmdJRCA9PT0gQ29uc3RhbnRzLllFQVJfVE9fSUQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHNlbGYuYXBwbGllZFNldHRpbmdzW0NvbnN0YW50cy5ZRUFSX1JBTkdFX0lEXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGxpZWRTZXR0aW5nc1tDb25zdGFudHMuWUVBUl9SQU5HRV9JRF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYuYXBwbGllZFNldHRpbmdzW0NvbnN0YW50cy5ZRUFSX1JBTkdFX0lEXVtzZXR0aW5nSURdID0gc2VsZWN0ZWRJRDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuYXBwbGllZFNldHRpbmdzW3NldHRpbmdJRF0gPSBzZWxlY3RlZElEO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdJRCA9PT0gQ29uc3RhbnRzLkFNT1VOVF9VTklUX0lEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBsaWVkU2V0dGluZ3NbQ29uc3RhbnRzLkFNT1VOVF9GT1JNQVRfSURdW0NvbnN0YW50cy5BTU9VTlRfVU5JVF9JRF0gPSBOdW1iZXIoc2VsZWN0ZWRJRCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNldHRpbmdzU2VsZWN0aW9ucyA9IHt9O1xyXG4gICAgfSxcclxuXHRnZXRDdXJyZW50IDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5hcHBsaWVkU2V0dGluZ3M7XHJcblx0fSxcclxuXHRyZXN0b3JlRnJvbVNhdmVkIDogZnVuY3Rpb24oc3RhdGUpIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdF8uZWFjaChzdGF0ZSwgZnVuY3Rpb24odiwgaykge1xyXG5cdFx0XHRzZWxmLmFwcGxpZWRTZXR0aW5nc1trXSA9IHY7XHJcblx0XHR9KTtcclxuXHRcdHRoaXMudXBkYXRlVUkoKTtcclxuXHR9LFxyXG5cdGFwcGx5U2V0dGluZ3MgOiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMudXBkYXRlQXBwbGllZFNldHRpbmdzKCk7XHJcblx0XHR0aGlzLnRyaWdnZXIoJ2FwcGx5U2V0dGluZ3MnLCB0aGlzLmFwcGxpZWRTZXR0aW5ncyk7XHJcblx0fSxcclxuXHRjbG9zZSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5nc1NlbGVjdGlvbnMgPSB7fTtcclxuXHRcdHRoaXMudHJpZ2dlcignY2xvc2UnKTtcclxuXHR9LFxyXG5cdGNyZWF0ZVRyYW5zbGF0b3IgOiBmdW5jdGlvbihmb3JjZSkge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0dmFyIHRyYW5zbGF0ZUtleXMgPSBKU09OLnBhcnNlKFwie1xcclxcbiAgXFxcImFtcC5zZXR0aW5nczp0aXRsZVxcXCI6IFxcXCJTZXR0aW5nc1xcXCIsXFxyXFxuICBcXFwiYW1wLnNldHRpbmdzOmxhYmVsLWNhbGVuZGFyLWlkXFxcIjogXFxcIkNhbGVuZGFyXFxcIixcXHJcXG4gIFxcXCJhbXAuc2V0dGluZ3M6bGFiZWwtY3VycmVuY3ktY29kZVxcXCI6IFxcXCJDdXJyZW5jeVxcXCIsXFxyXFxuICBcXFwiYW1wLnNldHRpbmdzOmxhYmVsLWZ1bmRpbmctdHlwZVxcXCI6IFxcXCJGdW5kaW5nIFR5cGVcXFwiLFxcclxcbiAgXFxcImFtcC5zZXR0aW5nczpsYWJlbC15ZWFyLXJhbmdlXFxcIjogXFxcIlllYXIgUmFuZ2VcXFwiLFxcclxcbiAgXFxcImFtcC5zZXR0aW5nczpsYWJlbC1mcm9tXFxcIjogXFxcIkZyb206XFxcIixcXHJcXG4gIFxcXCJhbXAuc2V0dGluZ3M6bGFiZWwtdG9cXFwiOiBcXFwiVG86XFxcIixcXHJcXG4gIFxcXCJhbXAuc2V0dGluZ3M6YXBwbHktYnV0dG9uXFxcIiA6IFxcXCJBcHBseVxcXCIsXFxyXFxuICBcXFwiYW1wLnNldHRpbmdzOmNhbmNlbC1idXR0b25cXFwiOiBcXFwiQ2FuY2VsXFxcIixcXHJcXG4gIFxcXCJhbXAuc2V0dGluZ3M6YWxsXFxcIjogXFxcIkFsbFxcXCJcXHJcXG59XCIpO1xyXG5cdFx0aWYgKGZvcmNlID09PSB0cnVlIHx8IHNlbGYudHJhbnNsYXRvciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHNlbGYudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHtcclxuXHRcdFx0XHRkZWZhdWx0S2V5cyA6IHRyYW5zbGF0ZUtleXNcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR0cmFuc2xhdGUgOiBmdW5jdGlvbih0YXJnZXQpIHtcclxuXHRcdHZhciBlbGVtZW50ID0gdGhpcztcclxuXHRcdGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRlbGVtZW50ID0gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGVsZW1lbnQuZWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKGVsZW1lbnQuZWwpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTShlbGVtZW50KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG59KTsiLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuZnVuY3Rpb24gU3RhdGVMb2FkRXJyb3IobWVzc2FnZSwgb3JpZ2luYWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0YXRlTG9hZEVycm9yKSkgeyByZXR1cm4gbmV3IFNhdGVMb2FkRXJyb3IobWVzc2FnZSwgb3JpZ2luYWwpOyB9XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbDtcblxuICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZSgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgfVxuXG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKFN0YXRlLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuc2F2ZWQgPSBvcHRpb25zLnNhdmVkO1xuICAgIC8vIEFueXRoaW5nIHRoYXQgc3RhdGUgbXVzdCByZWdpc3RlciBpdHNlbGYuIFNlZSBgU3RhdGUucmVnaXN0ZXJgLlxuICAgIHRoaXMuX3N0YXRlUmVnaXN0cnkgPSB7fTtcbiAgICAvLyBXaGVuIGxvYWRpbmcgc3RhdGUsIHNvbWUgdGhpbmdzIG1pZ2h0IG5vdCBoYXZlIHJlZ2lzdGVyZWQgeWV0LlxuICAgIC8vIEl0IGdldHMgbWFya2VkIGFzIHVuY2xhaW1lZCwgYW5kIHN0b3JlZCBoZXJlLlxuICAgIHRoaXMuX3VuY2xhaW1lZCA9IHt9O1xuICAgIC8vIHVzZSB0aGUgdXJsLCBpZiB3ZSBoYXZlIGl0XG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICB0aGlzLmxpc3RlblRvVVJMKF8ob3B0aW9ucykucGljaygndXJsJywgJ3ByZWZpeCcsICdhdXRvaW5pdCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuVG9VUkw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLl91cmxQcmVmaXhlcyA9IG9wdGlvbnMucHJlZml4IHx8IFsnc2F2ZWQvJ107XG5cbiAgICAvLyB3cmFwIHByZWZpeGVzIGluIGFycmF5IHRvIG1ha2UgYmFja3dhcmQgY29tcGF0OlxuICAgIGlmICh0aGlzLl91cmxQcmVmaXhlcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpe1xuICAgICAgdGhpcy5fdXJsUHJlZml4ZXMgPSBbdGhpcy5fdXJsUHJlZml4ZXNdO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5fdXJsLCAnY2hhbmdlJywgdGhpcy51cmxNYXliZUxvYWQpO1xuICAgIGlmIChvcHRpb25zLmF1dG9pbml0ICYmIHRoaXMuX3VybC5oYXNoKCkpIHtcbiAgICAgIHRoaXMudXJsTWF5YmVMb2FkKHRoaXMuX3VybC5oYXNoKCkpO1xuICAgIH0gIC8vIGluaXRpYWwgc3RhdGVcbiAgfSxcblxuICB1cmxNYXliZUxvYWQ6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICBoYXNoID0gaGFzaCB8fCB0aGlzLl91cmwuaGFzaCgpO1xuXG4gICAgLy8gc2VlIGlmIGFueSBwcmVmaXhlcyBtYXRjaCB0aGUgaGFzaC5cbiAgICBfLmVhY2godGhpcy5fdXJsUHJlZml4ZXMsIGZ1bmN0aW9uKHByZWZpeCl7XG4gICAgICAvLyBsb2FkIGEgc3RhdGUgaWYgd2UgZ2V0IHRoZSBVUkwgaGFzaCBmb3Igb25lXG4gICAgICBpZiAoaGFzaC5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgdmFyIHN0YXRlX29yX2lkID0gaGFzaC5zcGxpdChwcmVmaXgpWzFdO1xuICAgICAgICBpZiAoc3RhdGVfb3JfaWQpIHtcbiAgICAgICAgICBtYXRjaEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmW3NlbGYuc2F2ZWQgPyAnbG9hZEJ5SWQnIDogJ2xvYWQnXShzdGF0ZV9vcl9pZCwgcHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbWF0Y2hGb3VuZCAmJiBoYXNoID09PSAnJykge1xuICAgICAgc2VsZi5yZXNldCgpO1xuICAgIH1cbiAgfSxcblxuICB0b0hhc2g6IGZ1bmN0aW9uKHN0YXRlX29yX2lkKSB7XG4gICAgaWYgKCFfKHRoaXMpLmhhcygnX3VybCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgZ2VuZXJhdGUgVVJMIGhhc2ggd2l0aG91dCBiZWluZyBpbml0aWFsaXplZCB3aXRoIFVSTCBpbnN0YW5jZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsUHJlZml4ZXNbMF0gKyBzdGF0ZV9vcl9pZDtcbiAgICB9XG4gIH0sXG5cbiAgbG9hZEJ5SWQ6IGZ1bmN0aW9uKGlkLCBtYXRjaGVkUHJlZml4KSB7XG4gICAgdGhpcy5sb2FkUHJvbWlzZSA9IHRoaXMuc2F2ZWQubG9hZChpZCwgbWF0Y2hlZFByZWZpeCAgKTsvLyBUT0RPOiBkcnM6IGFuZCBwYXNzIG1hdGNoaW5nIHByZWZpeC4uXG4gICAgdGhpcy5sb2FkUHJvbWlzZVxuICAgICAgLmRvbmUoXyhmdW5jdGlvbihzdGF0ZU1vZGVsKSB7XG4gICAgICAgIHRoaXMubG9hZChzdGF0ZU1vZGVsLmdldCgnc3RhdGVCbG9iJykpO1xuICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RhdGVMb2FkRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIHN0YXRlIGJ5IGlkOiAnICsgaWQpO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgbG9hZDogZnVuY3Rpb24oc3RhdGVzQmxvYikge1xuICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlKHN0YXRlc0Jsb2IpO1xuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBfLmVhY2gocGFyc2VkLCBmdW5jdGlvbihzdGF0ZVRvU2V0LCBpZCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9zdGF0ZVJlZ2lzdHJ5W2lkXTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGN1cnJlbnQpKSB7XG4gICAgICAgIHRoaXMuX3VuY2xhaW1lZFtpZF0gPSBzdGF0ZVRvU2V0O1xuICAgICAgfSBlbHNlIGlmICghXy5pc0VxdWFsKGN1cnJlbnQuZ2V0KCksIHN0YXRlVG9TZXQpKSB7XG4gICAgICAgIGN1cnJlbnQuc2V0KHN0YXRlVG9TZXQpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMudHJpZ2dlcignbG9hZCcpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oc3RhdGVzQmxvYikge1xuICAgIC8vIGJyZWFrIG91dCB0aGUgY2FsbCB0byBKU09OLnBhcnNlIHNvIHRoYXQgbG9hZCBjYW4gc3RpbGwgYmUgb3B0aW1pemVkXG4gICAgdmFyIHBhcnNlZDtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShzdGF0ZXNCbG9iKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTdGF0ZUxvYWRFcnJvcignQ291bGQgbm90IHBhcnNlIHN0YXRlJywgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBSZXN0b3JlIGFsbCBzdGF0ZXMgdG8gdGhlaXIgZGVmYXVsdHMgKHNwZWNpZmllZCBhdCByZWdpc3RyYXRpb24pXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5fc3RhdGVSZWdpc3RyeSwgZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZS5nZXQoKTtcbiAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRTdGF0ZSwgc3RhdGUuZW1wdHkpKSB7XG4gICAgICAgIC8vIG9ubHkgY2FsbCAuc2V0IGlmIHJlc2V0dGluZyB3aWxsIGFjdHVhbGx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIHN0YXRlLnNldChzdGF0ZS5lbXB0eSk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdyZXNldCcpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBcbiAgZmlsdGVyc0xvYWRlZDogZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGRmZCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblx0XHQgIGlmIChzZWxmLl9zdGF0ZVJlZ2lzdHJ5LmZpbHRlcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ICBjbGVhckludGVydmFsKHRpbWVyKTtcblx0XHRcdCAgZGZkLnJlc29sdmUoKTtcblx0XHQgIH1cblx0ICB9LCAxMDAwKTtcblx0ICByZXR1cm4gZGZkLnByb21pc2UoKTsgXG4gIH0sXG4gIFxuICBcbiAgZnJlZXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHN0YXRlU25hcHNob3QgPSB7fTtcbiAgICBfLmVhY2godGhpcy5fc3RhdGVSZWdpc3RyeSwgZnVuY3Rpb24oc3RhdGUsIGlkKSB7XG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gc3RhdGUuZ2V0KCk7XG4gICAgICBzdGF0ZVNuYXBzaG90W2lkXSA9IF8uY2xvbmUoY3VycmVudFN0YXRlKTsgIC8vIFRPRE86IGRlZXAgY2xvbmUoISEpXG4gICAgfSk7XG4gICAgdmFyIHN0YXRlc0Jsb2IgPSBKU09OLnN0cmluZ2lmeShzdGF0ZVNuYXBzaG90KTtcbiAgICBpZiAob3B0aW9ucy50b1VSTCkge1xuICAgICAgaWYgKCF0aGlzLl91cmwpIHsgY29uc29sZS5lcnJvcignU3RhdGUgY2Fubm90IGNoYW5nZSBVUkwgaWYgaXQgZG9lcyBoYXZlIGEgcmVmIHRvIGl0Jyk7IH1cbiAgICAgIHRoaXMuX3VybC5oYXNoKHRoaXMuX3VybFByZWZpeGVzWzBdICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0YXRlc0Jsb2IpKTtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdmcmVlemUnLCBzdGF0ZXNCbG9iKTtcbiAgICByZXR1cm4gc3RhdGVzQmxvYjtcbiAgfSxcblxuICByZWdpc3RlcjogZnVuY3Rpb24ocmVnaXN0cmFibGUsIGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKGlkIGluIHRoaXMuX3N0YXRlUmVnaXN0cnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHJlZ2lzdHJhdGlvbiBvZiBkdXBsaWNhdGUgc3RhdGUgaWQgJyArIGlkKTtcbiAgICB9XG5cbiAgICAvLyByZWdpc3RlciB0aGUgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZVJlZ2lzdHJ5W2lkXSA9IHtcbiAgICAgIGdldDogXy5iaW5kKG9wdGlvbnMuZ2V0LCByZWdpc3RyYWJsZSksXG4gICAgICBzZXQ6IF8uYmluZChvcHRpb25zLnNldCwgcmVnaXN0cmFibGUpLFxuICAgICAgZW1wdHk6IG9wdGlvbnMuZW1wdHlcbiAgICB9O1xuXG4gICAgLy8gc2V0IHRvIHRoZSBjdXJyZW50bHkgbG9hZGVkIHN0YXRlLCBvciBpdHMgZGVmYXVsdCBlbXB0eSBzdGF0ZVxuICAgIGlmIChpZCBpbiB0aGlzLl91bmNsYWltZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlUmVnaXN0cnlbaWRdLnNldCh0aGlzLl91bmNsYWltZWRbaWRdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91bmNsYWltZWRbaWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZVJlZ2lzdHJ5W2lkXS5zZXQob3B0aW9ucy5lbXB0eSk7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdyZWdpc3RlcicpO1xuICB9XG59KTtcblxuXG5TdGF0ZS5TdGF0ZUxvYWRFcnJvciA9IFN0YXRlTG9hZEVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcbiIsIi8vIFRPRE86IG1vdmUgdGhpcyB1cCBhIGRpciwgYW5kIGluc3RhbnRpYXRlIGFuZCBhdHRhY2ggdG8gdGhlIGFwcFxuXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbmZ1bmN0aW9uIFRyYW5zbGF0b3Iob3B0aW9ucykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zbGF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2xhdG9yIG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgfVxuXG4gIC8vIHRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IGhhcyBhbGwgIHRoZSBrZXkgdmFsdWUgcGFpcnMgZm9yIHRoZSB3aWRnZXQuXG4gIHZhciB0cmFuc2xhdG9yRGVmYXVsdHMgPSB7XG4gICAgZGVmYXVsdEtleXM6IHt9LFxuICAgIGF2YWlsYWJsZUxhbmd1YWdlczogbnVsbCwvLyBiYWNrYm9uZSBjb2xsZWN0aW9uXG4gICAgdHJhbnNsYXRpb25zOiB7XG4gICAgICBsb2NhbGVzOiB7XG4gICAgICAgIGVuOm51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIGFqYXg6ICQuYWpheFxuICB9O1xuXG4gIC8qIEdhdGhlciBvcHRpb25zICovXG4gIGlmIChvcHRpb25zKSB7XG4gICAgLyogRXNwZWNpYWxseSB1c2VmdWwgZm9yIG92ZXJ3cml0aW5nIGRlZmF1bHRLZXlzLCBhdmFpbGFibGVMYW5ndWFnZXMgYW5kIHRyYW5zbGF0aW9ucyAqL1xuICAgIF8uZGVmYXVsdHModGhpcywgb3B0aW9ucywgdHJhbnNsYXRvckRlZmF1bHRzKTtcbiAgfVxuXG4gIHRoaXMuX3Byb21pc2UgPSBudWxsO1xuICB0aGlzLl9jdXJyZW50TG5nID0gJ3RtcCc7XG4gIHRoaXMuX2ZpcnN0R2V0ID0gbnVsbDtcblxuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgbG9jYWwgc3RvcmFnZSB3aXRoIHRpbWVzdGFtcFxuICB0aGlzLmluaXRUcmFuc2xhdGlvbnMgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cbiAgICAvLyB0cnkgd2ViXG4gICAgdGhpcy5fcHJvbWlzZSA9IHRoaXMuZ2V0VHJhbnNsYXRpb25zKHNlbGYuZGVmYXVsdEtleXMpXG4gICAgICAuZmFpbChmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkICcsIGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICB9KTtcbiAgICB0aGlzLnByb21pc2UgPSB0aGlzLl9wcm9taXNlLnByb21pc2UoKTtcbiAgfTtcblxuICAvKiBVc2UgdGhpcyBmb3IgYWRkaW5nIG1vcmUgZGVmYXVsdEtleXMgb3IgdHJhbnNsYXRpb25zIGJ5IG1vZHVsZVxuICAgKiBpZiB0cmFuc2xhdG9yIGhhcyBhbHJlYWR5IGJlZW4gaW5zdGFudGlhdGVkXG4gICAqL1xuICB0aGlzLmFkZFRyYW5zbGF0b3JPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8qIGZvcmNlIGEgcmVxdWVzdCBmcm9tIEFQSSBuZXh0IHRpbWUgKi9cbiAgICBfLmRlZmF1bHRzKHRoaXMuZGVmYXVsdEtleXMsIG9wdGlvbnMuZGVmYXVsdEtleXMpO1xuICAgIHRoaXMuX2ZpcnN0R2V0ID0gbnVsbDtcbiAgfTtcblxuXG4gIHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuXG4gICAgaWYgKHRoaXMuYXZhaWxhYmxlTGFuZ3VhZ2VzKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMuYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5pdEF2YWlsYWJsZUxhbmd1YWdlcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcy5hdmFpbGFibGVMYW5ndWFnZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9O1xuXG4gIHRoaXMuX2luaXRBdmFpbGFibGVMYW5ndWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmF2YWlsYWJsZUxhbmd1YWdlcyA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKFtdKTtcbiAgICB0aGlzLmF2YWlsYWJsZUxhbmd1YWdlcy51cmwgPSAnL3Jlc3QvdHJhbnNsYXRpb25zL2xhbmd1YWdlcyc7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlTGFuZ3VhZ2VzLmZldGNoKCk7XG4gIH07XG5cblxuICAvLyBpbXBvcnRhbnQgdG8gbGV0IHRoZSBhcGkga25vdywgc28gYWxsIHJlc3BvbnNlcyBhcmUgdHJhbnNsYXRlZC5cbiAgdGhpcy5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uKGxuZykge1xuICAgIHRoaXMuX2N1cnJlbnRMbmcgPSBsbmc7XG4gICAgcmV0dXJuIHRoaXMuX2FwaUNhbGwoJy9yZXN0L3RyYW5zbGF0aW9ucy9sYW5ndWFnZXMvJyArIGxuZywgbnVsbCwgJ0dFVCcpO1xuICB9O1xuXG5cbiAgdGhpcy50cmFuc2xhdGVET00gPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciAkbmV3RWwgPSAkKGVsKTtcbiAgICAvKiBUT0RPKHRkayk6IFdlIGlkZW50aWZpZWQgYSBtYWpvciBidWcgaGVyZSB3aGVyZSByb290IGltbWVkaWF0ZSBjaGlsZFxuICAgICAqICB0ZW1wbGF0ZSBlbGVtZW50cyB3aXRoIHRyYW5zbGF0aW9ucyBhcmUgbm90IGJlaW5nIGNhdWdodCBieSB0aGlzXG4gICAgICogIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogIFRvIHdvcmthcm91bmQsIHdlIHNob3VsZCBjbG9uZSwgd3JhcCwgcnVuIHRoZSBzZWxlY3RvciBhbmQgdW53cmFwIHRoZSBET00uXG4gICAgICpcbiAgICAgKiAgUmVtZW1iZXIgdGhpcyBoYXMgdG8gd29yayBmb3IgZWwncyBhcm91bmQgdGhlIGFwcCB0aGF0IGFyZSBib3VuZFxuICAgICAqICBhbmQgbm90IGJvdW5kLlxuICAgICAqL1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNsYXRpb25zKCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAkLmVhY2goZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAvKmlmICgkKCdbZGF0YS1pMThuPVwiJyArIGtleSArICdcIl0nLCAkbmV3RWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgIGNvbnNvbGUubG9nKGtleSwgJy0+JywgdmFsdWUsJyAkIGZvdW5kLT4nLCAkbmV3RWwuZmluZCgnW2RhdGEtaTE4bj1cIicgKyBrZXkgKyAnXCJdJykudGV4dCgpKTtcbiAgICAgICAgIH0qL1xuXG4gICAgICAgIC8vIFdlIG5lZWQgYSB3YXkgdG8gaWRlbnRpZnkgY29udHJvbHMgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIG5lZWRzIHRvIGJlIHRyYW5zbGF0ZWQgaW5zdGVhZCBvZiB0aGUgdGV4dC5cbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdbcGxhY2Vob2xkZXJdJykgPiAtMSkge1xuICAgICAgICAgICQoJ1tkYXRhLWkxOG49XCInICsga2V5ICsgJ1wiXScsICRuZXdFbCkuYXR0cigncGxhY2Vob2xkZXInLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5LmluZGV4T2YoJ1t0aXRsZV0nKSA+IC0xKSB7XG4gICAgICAgICAgJCgnW2RhdGEtaTE4bj1cIicgKyBrZXkgKyAnXCJdJywgJG5ld0VsKS5hdHRyKCd0aXRsZScsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkKCdbZGF0YS1pMThuPVwiJyArIGtleSArICdcIl0nLCAkbmV3RWwpLnRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAkbmV3RWw7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKlxuICAgKiBQYXNzIGluIGEge1wiYW1wLmdpczpkYXRhLWkxOG4tY29kZVwiOiBcImJhc2UgbGFuZyB3b3Jkc1wiLCAuLi59IG9iamVjdCBmb3JcbiAgICogdHJhbnNsYXRpb24gZS5nLiBwYWdlIHRpdGxlXG4gICAqICovXG4gIC8vIFRPRE86IGRvbid0IGNhbGwgaXQgYSBsaXN0IGlmIGl0J3MgYW4gb2JqZWN0ID8hXG4gIHRoaXMudHJhbnNsYXRlTGlzdCA9IGZ1bmN0aW9uKGxpc3QpIHtcblxuICAgIC8vIHVwZGF0ZSB0cmFuc2xhdGVhYmxlIGVsZW1lbnRzIGluIHRoaXMga2V5LXZhbHVlIHNldFxuICAgIHZhciBfdXBkYXRlTGlzdCA9IGZ1bmN0aW9uKGxpc3QsIGkxOG5EYXRhKSB7XG4gICAgICBfLmVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCkge1xuICAgICAgICBpZiAoaTE4bkRhdGFba2V5XSkge1xuICAgICAgICAgIGxpc3Rba2V5XSA9IGkxOG5EYXRhW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdFtrZXldID0ga2V5W3ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNsYXRpb25zKCkudGhlbihmdW5jdGlvbihpMThuRGF0YSkge1xuICAgICAgdmFyIG91dExpc3QgPSBfdXBkYXRlTGlzdChsaXN0LCBpMThuRGF0YSk7XG4gICAgICByZXR1cm4gb3V0TGlzdDtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qXG4gICAqIFN5bmNocm9ub3VzbHkgZ2V0IGEgKGFscmVhZHktbG9hZGVkKSB0cmFuc2xhdGlvblxuICAgKi9cbiAgdGhpcy50cmFuc2xhdGVTeW5jID0gZnVuY3Rpb24oa2V5LCBhbHQpIHtcbiAgICBpZiAodGhpcy5nZXRUcmFuc2xhdGlvbnMoKS5zdGF0ZSgpICE9PSAncmVzb2x2ZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGVTeW5jIHdhcyBjYWxsZWQgd2hlbiBnZXRUcmFuc2xhdGlvbnMgaXMgbm90IHN1Y2Nlc3NmdWxseSByZXNvbHZlZCcpO1xuICAgIH1cbiAgICB2YXIgdHJhbnNsYXRlZCA9IHRoaXMudHJhbnNsYXRpb25zLmxvY2FsZXNbdGhpcy5fY3VycmVudExuZ11ba2V5XTtcbiAgICBpZiAodHJhbnNsYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHRyYW5zbGF0aW9uIGhhcyBiZWVuIGxvYWRlZCBmb3InLCBrZXkpO1xuICAgICAgdHJhbnNsYXRlZCA9IGFsdCB8fCBrZXk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2xhdGVkO1xuICB9O1xuXG5cbiAgLy8gT25seSBkbyBzaW5nbGUgcmVxdWVzdCBvbiBsYXVuY2guXG4gIHRoaXMuZ2V0VHJhbnNsYXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdGhpcyB3YXkgd29uJ3Qgd29yayB3aXRoIGNoYW5nZSBsYW5ndWFnZXMgbWlkIHdheSB0aG91Z2guXG4gICAgaWYgKCF0aGlzLl9maXJzdEdldCkge1xuICAgICAgdGhpcy5fZmlyc3RHZXQgPSB0aGlzLl9nZXRUcmFuc2xhdGlvbnNGcm9tQVBJKHRoaXMuZGVmYXVsdEtleXMsIHRoaXMuX2N1cnJlbnRMbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmlyc3RHZXQ7XG4gIH07XG5cblxuICB0aGlzLl9nZXRUcmFuc2xhdGlvbnNGcm9tQVBJID0gZnVuY3Rpb24odHJhbnNsYXRlYWJsZXMsIGxuZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdXJsID0gJy9yZXN0L3RyYW5zbGF0aW9ucy9sYWJlbC10cmFuc2xhdGlvbnMnO1xuXG4gICAgcmV0dXJuIHRoaXMuX2FwaUNhbGwodXJsLCB0cmFuc2xhdGVhYmxlcywgJ1BPU1QnKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIC8vY2FjaGUgaWYgd2Uga25vdyB0aGUgbG5nLiBUT0RPOiBnZXQgYXBpIHRvIGFsd2F5cyByZXR1cm4gdGhlIGxuZy5cbiAgICAgIGlmIChsbmcpIHtcbiAgICAgICAgc2VsZi50cmFuc2xhdGlvbnMubG9jYWxlc1tsbmddID0gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRlbXAgaGFjayB0byBkbyBjYWNoaW5nIGlmIEFQSSBkb2Vzbid0IHJldHVybiBjdXJyZW50IGxuZ1xuICAgICAgICBsbmcgPSB0aGlzLl9jdXJyZW50TG5nO1xuICAgICAgICBzZWxmLnRyYW5zbGF0aW9ucy5sb2NhbGVzW2xuZ10gPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8vIGhlbHBlciB0byB3cmFwIGFwaSBjYWxsXG4gIHRoaXMuX2FwaUNhbGwgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHR5cGUpIHtcbiAgICB2YXIgYWpheE9wdGlvbnMgPSB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIGpzY3M6ZGlzYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAvLyBqc2NzOmVuYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICAgIH0sXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgfTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgYWpheE9wdGlvbnMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFqYXgoYWpheE9wdGlvbnMpO1xuICB9O1xuXG4gIHRoaXMuaW5pdFRyYW5zbGF0aW9ucygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zbGF0b3I7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuZnVuY3Rpb24gVVJMKCkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgbmVlZHMgdG8gYmUgY3JlYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICB9XG4gIGlmICh3aW5kb3cuX2FtcFVybGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbm90aGVyIGluc3RhbmNlIG9mIFVSTCBpcyBhbHJlYWR5IG1hbmFnaW5nIHdpbmRvdy5sb2NhdGlvbicpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5fYW1wVXJsZXIgPSB0cnVlO1xuICB9XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKFVSTC5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGFuZ2UnKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hhbmdlKTsgIC8vIElFIDgrXG4gIH0sXG5cbiAgaGFzaDogZnVuY3Rpb24obmV3SGFzaCwgb3B0aW9ucykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpOyAgLy8gcmVtb3ZlICcjJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoYW5nZSk7IH0gIC8vIElFIDkrXG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IG5ld0hhc2g7XG4gICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoYW5nZSk7IH1cbiAgICB9XG4gIH0sXG5cbiAgZnVsbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgd2luZG93LmxvY2F0aW9uO1xuICB9LFxuXG4gIGNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLmhhc2goKSk7XG4gIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBVUkw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0dmFyIF9kZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblx0dmFyIF9kZWJ1ZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWJ1Zyk7XG5cblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc2x1Zykge1xuXHQgIHZhciByZXMgPSB7XG5cdCAgICBsb2c6ICgwLCBfZGVidWcyW1wiZGVmYXVsdFwiXSkoc2x1ZyksXG5cdCAgICBlcnI6ICgwLCBfZGVidWcyW1wiZGVmYXVsdFwiXSkoc2x1ZyksXG5cdCAgICB3YXJuOiAoMCwgX2RlYnVnMltcImRlZmF1bHRcIl0pKHNsdWcpLFxuXHQgICAgb25EZWJ1ZzogKDAsIF9kZWJ1ZzJbXCJkZWZhdWx0XCJdKShzbHVnKVxuXHQgIH07XG5cdCAgcmVzLmVyci5sb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUuZXJyb3IsIGNvbnNvbGUpO1xuXHQgIHJlcy53YXJuLmxvZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS53YXJuLCBjb25zb2xlKTtcblx0ICByZXMub25EZWJ1Zy5sb2cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpbmRleCBpbiBhcmdzKSB7XG5cdCAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFyZ3NbaW5kZXhdKSB7XG5cdCAgICAgICAgYXJnc1tpbmRleF0oKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG5cdCAqXG5cdCAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cblx0ICovXG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0ZXhwb3J0cy5sb2cgPSBsb2c7XG5cdGV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5cdGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5cdGV4cG9ydHMubG9hZCA9IGxvYWQ7XG5cdGV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXHRleHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG5cdCAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuXHQgICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG5cdCAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cblx0LyoqXG5cdCAqIENvbG9ycy5cblx0ICovXG5cblx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCAgJ2xpZ2h0c2VhZ3JlZW4nLFxuXHQgICdmb3Jlc3RncmVlbicsXG5cdCAgJ2dvbGRlbnJvZCcsXG5cdCAgJ2RvZGdlcmJsdWUnLFxuXHQgICdkYXJrb3JjaGlkJyxcblx0ICAnY3JpbXNvbidcblx0XTtcblxuXHQvKipcblx0ICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcblx0ICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG5cdCAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cblx0ICpcblx0ICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcblx0ICovXG5cblx0ZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQgIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdCAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuXHQgICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHQgICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcblx0ICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuXHQgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdCAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cblx0ICovXG5cblx0ZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG5cdCAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcblx0ICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0ICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cblx0ICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcblx0ICAgICsgdGhpcy5uYW1lc3BhY2Vcblx0ICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuXHQgICAgKyBhcmdzWzBdXG5cdCAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcblx0ICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdCAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG5cdCAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHQgIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuXHQgIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdCAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQgIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGxhc3RDID0gMDtcblx0ICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0ICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuXHQgICAgaW5kZXgrKztcblx0ICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuXHQgICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0ICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0ICAgICAgbGFzdEMgPSBpbmRleDtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcblx0ICByZXR1cm4gYXJncztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cblx0ICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9nKCkge1xuXHQgIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdCAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0ICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG5cdCAgICAmJiBjb25zb2xlLmxvZ1xuXHQgICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZSBgbmFtZXNwYWNlc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0ICB0cnkge1xuXHQgICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuXHQgICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG5cdCAgICB9XG5cdCAgfSBjYXRjaChlKSB7fVxuXHR9XG5cblx0LyoqXG5cdCAqIExvYWQgYG5hbWVzcGFjZXNgLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb2FkKCkge1xuXHQgIHZhciByO1xuXHQgIHRyeSB7XG5cdCAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuXHQgIH0gY2F0Y2goZSkge31cblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuXHQgKi9cblxuXHRleHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG5cdC8qKlxuXHQgKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG5cdCAqXG5cdCAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuXHQgKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuXHQgKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG5cdCAgfSBjYXRjaCAoZSkge31cblx0fVxuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyoqXG5cdCAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcblx0ICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cblx0ICpcblx0ICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuXHQgKi9cblxuXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1Zztcblx0ZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5cdGV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuXHRleHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRleHBvcnRzLmh1bWFuaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCAqL1xuXG5cdGV4cG9ydHMubmFtZXMgPSBbXTtcblx0ZXhwb3J0cy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCAqXG5cdCAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuXHQgKi9cblxuXHRleHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0ICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cblx0ICovXG5cblx0dmFyIHByZXZDb2xvciA9IDA7XG5cblx0LyoqXG5cdCAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG5cdCAqL1xuXG5cdHZhciBwcmV2VGltZTtcblxuXHQvKipcblx0ICogU2VsZWN0IGEgY29sb3IuXG5cdCAqXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuXHQgIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG5cdCAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cblx0ICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcblx0ICB9XG5cdCAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdCAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuXHQgIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cblx0ICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuXHQgICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0ICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG5cdCAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHQgICAgc2VsZi5kaWZmID0gbXM7XG5cdCAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0ICAgIHNlbGYuY3VyciA9IGN1cnI7XG5cdCAgICBwcmV2VGltZSA9IGN1cnI7XG5cblx0ICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG5cdCAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuXHQgICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cblx0ICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHQgICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdCAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG5cdCAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG5cdCAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG5cdCAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0ICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG5cdCAgICAgIGluZGV4Kys7XG5cdCAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0ICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcblx0ICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG5cdCAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdCAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHQgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICBpbmRleC0tO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuXHQgICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHQgICAgfVxuXHQgICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcblx0ICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHQgIH1cblx0ICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG5cdCAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cblx0ICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cblx0ICByZXR1cm4gZm47XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHQgIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHQgIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHQgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0ICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXHQgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHQgICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0ICBleHBvcnRzLmVuYWJsZSgnJyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0ICB2YXIgaSwgbGVuO1xuXHQgIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0ICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29lcmNlIGB2YWxgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01peGVkfSB2YWxcblx0ICogQHJldHVybiB7TWl4ZWR9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdCAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHQgIHJldHVybiB2YWw7XG5cdH1cblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdCAqIEhlbHBlcnMuXG5cdCAqL1xuXG5cdHZhciBzID0gMTAwMDtcblx0dmFyIG0gPSBzICogNjA7XG5cdHZhciBoID0gbSAqIDYwO1xuXHR2YXIgZCA9IGggKiAyNDtcblx0dmFyIHkgPSBkICogMzY1LjI1O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuXHQgKlxuXHQgKiBPcHRpb25zOlxuXHQgKlxuXHQgKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcblx0ICByZXR1cm4gb3B0aW9ucy5sb25nXG5cdCAgICA/IGxvbmcodmFsKVxuXHQgICAgOiBzaG9ydCh2YWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG5cdCAgc3RyID0gJycgKyBzdHI7XG5cdCAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuXHQgIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcblx0ICBpZiAoIW1hdGNoKSByZXR1cm47XG5cdCAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcblx0ICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSAneWVhcnMnOlxuXHQgICAgY2FzZSAneWVhcic6XG5cdCAgICBjYXNlICd5cnMnOlxuXHQgICAgY2FzZSAneXInOlxuXHQgICAgY2FzZSAneSc6XG5cdCAgICAgIHJldHVybiBuICogeTtcblx0ICAgIGNhc2UgJ2RheXMnOlxuXHQgICAgY2FzZSAnZGF5Jzpcblx0ICAgIGNhc2UgJ2QnOlxuXHQgICAgICByZXR1cm4gbiAqIGQ7XG5cdCAgICBjYXNlICdob3Vycyc6XG5cdCAgICBjYXNlICdob3VyJzpcblx0ICAgIGNhc2UgJ2hycyc6XG5cdCAgICBjYXNlICdocic6XG5cdCAgICBjYXNlICdoJzpcblx0ICAgICAgcmV0dXJuIG4gKiBoO1xuXHQgICAgY2FzZSAnbWludXRlcyc6XG5cdCAgICBjYXNlICdtaW51dGUnOlxuXHQgICAgY2FzZSAnbWlucyc6XG5cdCAgICBjYXNlICdtaW4nOlxuXHQgICAgY2FzZSAnbSc6XG5cdCAgICAgIHJldHVybiBuICogbTtcblx0ICAgIGNhc2UgJ3NlY29uZHMnOlxuXHQgICAgY2FzZSAnc2Vjb25kJzpcblx0ICAgIGNhc2UgJ3NlY3MnOlxuXHQgICAgY2FzZSAnc2VjJzpcblx0ICAgIGNhc2UgJ3MnOlxuXHQgICAgICByZXR1cm4gbiAqIHM7XG5cdCAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuXHQgICAgY2FzZSAnbXNlY3MnOlxuXHQgICAgY2FzZSAnbXNlYyc6XG5cdCAgICBjYXNlICdtcyc6XG5cdCAgICAgIHJldHVybiBuO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzaG9ydChtcykge1xuXHQgIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuXHQgIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuXHQgIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuXHQgIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuXHQgIHJldHVybiBtcyArICdtcyc7XG5cdH1cblxuXHQvKipcblx0ICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb25nKG1zKSB7XG5cdCAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG5cdCAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcblx0ICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG5cdCAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuXHQgICAgfHwgbXMgKyAnIG1zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cblx0ICovXG5cblx0ZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG5cdCAgaWYgKG1zIDwgbikgcmV0dXJuO1xuXHQgIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuXHQgIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG5cdH1cblxuXG4vKioqLyB9XG4vKioqKioqLyBdKTsiXX0=
