package org.digijava.kernel.ampapi.endpoints.activity;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;

import com.google.common.collect.ImmutableList;
import org.digijava.kernel.ampapi.endpoints.activity.field.APIField;
import org.digijava.kernel.ampapi.endpoints.activity.validators.ErrorDecorator;
import org.digijava.kernel.ampapi.endpoints.errors.ApiErrorMessage;
import org.digijava.kernel.validation.ConstraintDescriptor;
import org.digijava.kernel.validation.ConstraintValidator;
import org.digijava.kernel.validation.ConstraintViolation;
import org.digijava.kernel.validation.Path;
import org.digijava.kernel.validation.Validator;
import org.digijava.kernel.validators.activity.ComponentFundingOrgRoleValidator;
import org.digijava.module.aim.validator.groups.API;

/**
 * Acts as a bridge between importer and interchangeable validation.
 *
 * Note: current implementation ignores completely constraint violations coming from field validators.
 *
 * @author Octavian Ciubotaru
 */
public class ImporterInterchangeValidator {

    private Validator validator;

    private Map<Integer, ApiErrorMessage> errors;

    public ImporterInterchangeValidator(Map<Integer, ApiErrorMessage> errors) {
        this.errors = errors;

        validator = new Validator();
    }

    /**
     * Invoke interchangeable validation on the root object. If there are constraint violations generated by
     * constraints defined at class level, those violations will be injected into the json object and added to the
     * errors map.
     *
     * Validation is recursive and will reveal constraint violations for root object and also for objects deep into
     * the object tree.
     *
     * @param json json representation of the object
     * @param type type information for the object
     * @param root internal representation of the object
     */
    public void validate(Map<String, Object> json, APIField type, Object root) {
        Set<ConstraintViolation> violations = validator.validate(type, root, API.class);

        for (ConstraintViolation violation : violations) {
            if (isViolationForType(violation)) {
                List<Path.Node> nodes = ImmutableList.copyOf(violation.getPath().iterator());

                Predicate<Object> leafFilter = getLeafFilter(violation);

                String fieldPath = violation.getPath().toString();

                boolean errorsAdded = walk(json, nodes, fieldPath, violation.getMessage(), leafFilter);

                if (!errorsAdded) {
                    throw new IllegalStateException("Constraint violation not added to json: " + violation);
                }
            }
        }
    }

    /**
     * Returns value filter for leaf nodes. Some field paths will match multiple fields in the final json object. This
     * filter can be used to select for which fields exactly the error applies to.
     *
     * @param violation constraint violation for which a filter is needed
     * @return filter that accepts the value from json
     */
    private Predicate<Object> getLeafFilter(ConstraintViolation violation) {
        Predicate<Object> leafFilter;

        Class<? extends ConstraintValidator> validatorClass =
                violation.getConstraintDescriptor().getConstraintValidatorClass();

        if (validatorClass.equals(ComponentFundingOrgRoleValidator.class)) {
            Long orgId = (Long) violation.getAttributes().get(ComponentFundingOrgRoleValidator.ATTR_ORG_ID);
            leafFilter = orgId::equals;
        } else {
            leafFilter = o -> true;
        }

        return leafFilter;
    }

    /**
     * Walk the original json and inject errors at the appropriate locations as specified by nodes. If there are
     * multiple leaf nodes where error can be injected, then it will be injected in all places for which leafFilter
     * returns true.
     *
     * @param json original json
     * @param nodes location where to inject the errors
     * @param fieldPath full fields path of the error
     * @param message error message to inject
     * @param leafFilter errors will be applied only to fields filtered by this predicate, input is the leaf json value
     * @return true if the error message was injected at least once
     */
    private boolean walk(Map<String, Object> json, List<Path.Node> nodes, String fieldPath, ApiErrorMessage message,
            Predicate<Object> leafFilter) {
        boolean errorsAdded = false;
        String fieldName = nodes.get(0).getName();
        Object value = json.get(fieldName);
        if (value != null) {
            if (nodes.size() == 1) { // leaf case
                if (leafFilter.test(value)) {
                    errorsAdded = true;
                    ErrorDecorator.addError(json, fieldName, fieldPath, message, errors);
                }
            } else {
                List<Path.Node> subNodes = nodes.subList(1, nodes.size());
                if (value instanceof Collection) {
                    Collection collection = (Collection) value;
                    for (Object element : collection) {
                        errorsAdded |= walk((Map) element, subNodes, fieldPath, message, leafFilter);
                    }
                } else {
                    errorsAdded = walk((Map) value, subNodes, fieldPath, message, leafFilter);
                }
            }
        }
        return errorsAdded;
    }

    /**
     * Is this violation coming from a validator defined at class level?
     *
     * @param violation violation to check
     * @return true if the validator was defined on the class
     */
    private boolean isViolationForType(ConstraintViolation violation) {
        return violation.getConstraintDescriptor().getTarget() == ConstraintDescriptor.ConstraintTarget.TYPE;
    }
}
